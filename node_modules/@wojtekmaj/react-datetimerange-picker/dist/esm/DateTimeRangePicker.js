var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import { createPortal } from 'react-dom';
import PropTypes from 'prop-types';
import makeEventProps from 'make-event-props';
import clsx from 'clsx';
import Calendar from 'react-calendar';
import Clock from 'react-clock';
import Fit from 'react-fit';
import DateTimeInput from 'react-datetime-picker/dist/cjs/DateTimeInput';
import { isMaxDate, isMinDate } from './shared/propTypes';
var baseClassName = 'react-datetimerange-picker';
var outsideActionEvents = ['mousedown', 'focusin', 'touchstart'];
var allViews = ['hour', 'minute', 'second'];
var iconProps = {
    xmlns: 'http://www.w3.org/2000/svg',
    width: 19,
    height: 19,
    viewBox: '0 0 19 19',
    stroke: 'black',
    strokeWidth: 2,
};
var CalendarIcon = (React.createElement("svg", __assign({}, iconProps, { className: "".concat(baseClassName, "__calendar-button__icon ").concat(baseClassName, "__button__icon") }),
    React.createElement("rect", { fill: "none", height: "15", width: "15", x: "2", y: "2" }),
    React.createElement("line", { x1: "6", x2: "6", y1: "0", y2: "4" }),
    React.createElement("line", { x1: "13", x2: "13", y1: "0", y2: "4" })));
var ClearIcon = (React.createElement("svg", __assign({}, iconProps, { className: "".concat(baseClassName, "__clear-button__icon ").concat(baseClassName, "__button__icon") }),
    React.createElement("line", { x1: "4", x2: "15", y1: "4", y2: "15" }),
    React.createElement("line", { x1: "15", x2: "4", y1: "4", y2: "15" })));
export default function DateTimeRangePicker(props) {
    var amPmAriaLabel = props.amPmAriaLabel, autoFocus = props.autoFocus, calendarAriaLabel = props.calendarAriaLabel, _a = props.calendarIcon, calendarIcon = _a === void 0 ? CalendarIcon : _a, className = props.className, clearAriaLabel = props.clearAriaLabel, _b = props.clearIcon, clearIcon = _b === void 0 ? ClearIcon : _b, _c = props.closeWidgets, shouldCloseWidgetsProps = _c === void 0 ? true : _c, dataTestid = props["data-testid"], dayAriaLabel = props.dayAriaLabel, dayPlaceholder = props.dayPlaceholder, disableCalendar = props.disableCalendar, disableClock = props.disableClock, disabled = props.disabled, format = props.format, hourAriaLabel = props.hourAriaLabel, hourPlaceholder = props.hourPlaceholder, id = props.id, _d = props.isCalendarOpen, isCalendarOpenProps = _d === void 0 ? null : _d, _e = props.isClockOpen, isClockOpenProps = _e === void 0 ? null : _e, locale = props.locale, maxDate = props.maxDate, _f = props.maxDetail, maxDetail = _f === void 0 ? 'minute' : _f, minDate = props.minDate, minuteAriaLabel = props.minuteAriaLabel, minutePlaceholder = props.minutePlaceholder, monthAriaLabel = props.monthAriaLabel, monthPlaceholder = props.monthPlaceholder, _g = props.name, name = _g === void 0 ? 'datetimerange' : _g, nativeInputAriaLabel = props.nativeInputAriaLabel, onCalendarClose = props.onCalendarClose, onCalendarOpen = props.onCalendarOpen, onChangeProps = props.onChange, onClockClose = props.onClockClose, onClockOpen = props.onClockOpen, onFocusProps = props.onFocus, _h = props.openWidgetsOnFocus, openWidgetsOnFocus = _h === void 0 ? true : _h, _j = props.rangeDivider, rangeDivider = _j === void 0 ? 'â€“' : _j, required = props.required, secondAriaLabel = props.secondAriaLabel, secondPlaceholder = props.secondPlaceholder, showLeadingZeros = props.showLeadingZeros, value = props.value, yearAriaLabel = props.yearAriaLabel, yearPlaceholder = props.yearPlaceholder, otherProps = __rest(props, ["amPmAriaLabel", "autoFocus", "calendarAriaLabel", "calendarIcon", "className", "clearAriaLabel", "clearIcon", "closeWidgets", 'data-testid', "dayAriaLabel", "dayPlaceholder", "disableCalendar", "disableClock", "disabled", "format", "hourAriaLabel", "hourPlaceholder", "id", "isCalendarOpen", "isClockOpen", "locale", "maxDate", "maxDetail", "minDate", "minuteAriaLabel", "minutePlaceholder", "monthAriaLabel", "monthPlaceholder", "name", "nativeInputAriaLabel", "onCalendarClose", "onCalendarOpen", "onChange", "onClockClose", "onClockOpen", "onFocus", "openWidgetsOnFocus", "rangeDivider", "required", "secondAriaLabel", "secondPlaceholder", "showLeadingZeros", "value", "yearAriaLabel", "yearPlaceholder"]);
    var _k = useState(isCalendarOpenProps), isCalendarOpen = _k[0], setIsCalendarOpen = _k[1];
    var _l = useState(isClockOpenProps), isClockOpen = _l[0], setIsClockOpen = _l[1];
    var wrapper = useRef(null);
    var calendarWrapper = useRef(null);
    var clockWrapper = useRef(null);
    useEffect(function () {
        setIsCalendarOpen(isCalendarOpenProps);
    }, [isCalendarOpenProps]);
    useEffect(function () {
        setIsClockOpen(isClockOpenProps);
    }, [isClockOpenProps]);
    function openCalendar() {
        setIsClockOpen(false);
        setIsCalendarOpen(true);
        if (onCalendarOpen) {
            onCalendarOpen();
        }
    }
    var closeCalendar = useCallback(function () {
        setIsCalendarOpen(false);
        if (onCalendarClose) {
            onCalendarClose();
        }
    }, [onCalendarClose]);
    function toggleCalendar() {
        if (isCalendarOpen) {
            closeCalendar();
        }
        else {
            openCalendar();
        }
    }
    function openClock() {
        setIsCalendarOpen(false);
        setIsClockOpen(true);
        if (onClockOpen) {
            onClockOpen();
        }
    }
    var closeClock = useCallback(function () {
        setIsClockOpen(false);
        if (onClockClose) {
            onClockClose();
        }
    }, [onClockClose]);
    var closeWidgets = useCallback(function () {
        closeCalendar();
        closeClock();
    }, [closeCalendar, closeClock]);
    function onChange(value, shouldCloseWidgets) {
        if (shouldCloseWidgets === void 0) { shouldCloseWidgets = shouldCloseWidgetsProps; }
        if (shouldCloseWidgets) {
            closeWidgets();
        }
        if (onChangeProps) {
            onChangeProps(value);
        }
    }
    function onChangeFrom(valueFrom, closeCalendar) {
        var _a = Array.isArray(value) ? value : [value], valueTo = _a[1];
        var valueToDate = valueTo ? new Date(valueTo) : null;
        onChange([valueFrom, valueToDate], closeCalendar);
    }
    function onChangeTo(valueTo, closeCalendar) {
        var valueFrom = (Array.isArray(value) ? value : [value])[0];
        var valueFromDate = valueFrom ? new Date(valueFrom) : null;
        onChange([valueFromDate, valueTo], closeCalendar);
    }
    function onDateChange(nextValue, shouldCloseWidgets) {
        // React-Calendar passes an array of values when selectRange is enabled
        var _a = Array.isArray(nextValue) ? nextValue : [nextValue], rawNextValueFrom = _a[0], rawNextValueTo = _a[1];
        var _b = Array.isArray(value) ? value : [value], valueFrom = _b[0], valueTo = _b[1];
        var nextValueFrom = (function () {
            if (!valueFrom || !rawNextValueFrom) {
                return rawNextValueFrom;
            }
            var valueFromDate = new Date(valueFrom);
            var nextValueFromWithHour = new Date(rawNextValueFrom);
            nextValueFromWithHour.setHours(valueFromDate.getHours(), valueFromDate.getMinutes(), valueFromDate.getSeconds(), valueFromDate.getMilliseconds());
            return nextValueFromWithHour;
        })();
        var nextValueTo = (function () {
            if (!valueTo || !rawNextValueTo) {
                return rawNextValueTo;
            }
            var valueToDate = new Date(valueTo);
            var nextValueToWithHour = new Date(rawNextValueTo);
            nextValueToWithHour.setHours(valueToDate.getHours(), valueToDate.getMinutes(), valueToDate.getSeconds(), valueToDate.getMilliseconds());
            return nextValueToWithHour;
        })();
        onChange([nextValueFrom || null, nextValueTo || null], shouldCloseWidgets);
    }
    function onFocus(event) {
        if (onFocusProps) {
            onFocusProps(event);
        }
        if (
        // Internet Explorer still fires onFocus on disabled elements
        disabled ||
            isCalendarOpen ||
            isClockOpen ||
            !openWidgetsOnFocus ||
            event.target.dataset.select === 'true') {
            return;
        }
        switch (event.target.name) {
            case 'day':
            case 'month':
            case 'year':
                openCalendar();
                break;
            case 'hour12':
            case 'hour24':
            case 'minute':
            case 'second':
                openClock();
                break;
            default:
        }
    }
    var onKeyDown = useCallback(function (event) {
        if (event.key === 'Escape') {
            closeWidgets();
        }
    }, [closeWidgets]);
    function clear() {
        onChange(null);
    }
    function stopPropagation(event) {
        event.stopPropagation();
    }
    var onOutsideAction = useCallback(function (event) {
        var wrapperEl = wrapper.current;
        var calendarWrapperEl = calendarWrapper.current;
        var clockWrapperEl = clockWrapper.current;
        // Try event.composedPath first to handle clicks inside a Shadow DOM.
        var target = ('composedPath' in event ? event.composedPath()[0] : event.target);
        if (target &&
            wrapperEl &&
            !wrapperEl.contains(target) &&
            (!calendarWrapperEl || !calendarWrapperEl.contains(target)) &&
            (!clockWrapperEl || !clockWrapperEl.contains(target))) {
            closeWidgets();
        }
    }, [calendarWrapper, clockWrapper, closeWidgets, wrapper]);
    var handleOutsideActionListeners = useCallback(function (shouldListen) {
        if (shouldListen === void 0) { shouldListen = isCalendarOpen || isClockOpen; }
        outsideActionEvents.forEach(function (event) {
            if (shouldListen) {
                document.addEventListener(event, onOutsideAction);
            }
            else {
                document.removeEventListener(event, onOutsideAction);
            }
        });
        if (shouldListen) {
            document.addEventListener('keydown', onKeyDown);
        }
        else {
            document.removeEventListener('keydown', onKeyDown);
        }
    }, [isCalendarOpen, isClockOpen, onOutsideAction, onKeyDown]);
    useEffect(function () {
        handleOutsideActionListeners();
        return function () {
            handleOutsideActionListeners(false);
        };
    }, [handleOutsideActionListeners]);
    function renderInputs() {
        var _a = Array.isArray(value) ? value : [value], valueFrom = _a[0], valueTo = _a[1];
        var ariaLabelProps = {
            amPmAriaLabel: amPmAriaLabel,
            dayAriaLabel: dayAriaLabel,
            hourAriaLabel: hourAriaLabel,
            minuteAriaLabel: minuteAriaLabel,
            monthAriaLabel: monthAriaLabel,
            nativeInputAriaLabel: nativeInputAriaLabel,
            secondAriaLabel: secondAriaLabel,
            yearAriaLabel: yearAriaLabel,
        };
        var placeholderProps = {
            dayPlaceholder: dayPlaceholder,
            hourPlaceholder: hourPlaceholder,
            minutePlaceholder: minutePlaceholder,
            monthPlaceholder: monthPlaceholder,
            secondPlaceholder: secondPlaceholder,
            yearPlaceholder: yearPlaceholder,
        };
        var commonProps = __assign(__assign(__assign({}, ariaLabelProps), placeholderProps), { className: "".concat(baseClassName, "__inputGroup"), disabled: disabled, format: format, isWidgetOpen: isCalendarOpen || isClockOpen, locale: locale, maxDate: maxDate, maxDetail: maxDetail, minDate: minDate, required: required, showLeadingZeros: showLeadingZeros });
        return (React.createElement("div", { className: "".concat(baseClassName, "__wrapper") },
            React.createElement(DateTimeInput, __assign({}, commonProps, { 
                // eslint-disable-next-line jsx-a11y/no-autofocus
                autoFocus: autoFocus, name: "".concat(name, "_from"), onChange: onChangeFrom, value: valueFrom })),
            React.createElement("span", { className: "".concat(baseClassName, "__range-divider") }, rangeDivider),
            React.createElement(DateTimeInput, __assign({}, commonProps, { name: "".concat(name, "_to"), onChange: onChangeTo, value: valueTo })),
            clearIcon !== null && (React.createElement("button", { "aria-label": clearAriaLabel, className: "".concat(baseClassName, "__clear-button ").concat(baseClassName, "__button"), disabled: disabled, onClick: clear, onFocus: stopPropagation, type: "button" }, typeof clearIcon === 'function' ? React.createElement(clearIcon) : clearIcon)),
            calendarIcon !== null && !disableCalendar && (React.createElement("button", { "aria-label": calendarAriaLabel, className: "".concat(baseClassName, "__calendar-button ").concat(baseClassName, "__button"), disabled: disabled, onClick: toggleCalendar, onFocus: stopPropagation, type: "button" }, typeof calendarIcon === 'function' ? React.createElement(calendarIcon) : calendarIcon))));
    }
    function renderCalendar() {
        if (isCalendarOpen === null || disableCalendar) {
            return null;
        }
        var calendarClassName = props.calendarClassName, dateTimeRangePickerClassName = props.className, // Unused, here to exclude it from calendarProps
        dateTimeRangePickerMaxDetail = props.maxDetail, // Unused, here to exclude it from calendarProps
        onChangeProps = props.onChange, // Unused, here to exclude it from calendarProps
        portalContainer = props.portalContainer, value = props.value, calendarProps = __rest(props, ["calendarClassName", "className", "maxDetail", "onChange", "portalContainer", "value"]);
        var className = "".concat(baseClassName, "__calendar");
        var classNames = clsx(className, "".concat(className, "--").concat(isCalendarOpen ? 'open' : 'closed'));
        var calendar = (React.createElement(Calendar, __assign({ className: calendarClassName, onChange: function (value) { return onDateChange(value); }, selectRange: true, value: value }, calendarProps)));
        return portalContainer ? (createPortal(React.createElement("div", { ref: calendarWrapper, className: classNames }, calendar), portalContainer)) : (React.createElement(Fit, null,
            React.createElement("div", { ref: function (ref) {
                    if (ref && !isCalendarOpen) {
                        ref.removeAttribute('style');
                    }
                }, className: classNames }, calendar)));
    }
    function renderClock() {
        if (isClockOpen === null || disableClock) {
            return null;
        }
        var clockClassName = props.clockClassName, dateTimePickerClassName = props.className, // Unused, here to exclude it from clockProps
        _a = props.maxDetail, // Unused, here to exclude it from clockProps
        maxDetail = _a === void 0 ? 'minute' : _a, onChange = props.onChange, portalContainer = props.portalContainer, value = props.value, clockProps = __rest(props, ["clockClassName", "className", "maxDetail", "onChange", "portalContainer", "value"]);
        var className = "".concat(baseClassName, "__clock");
        var classNames = clsx(className, "".concat(className, "--").concat(isClockOpen ? 'open' : 'closed'));
        var valueFrom = (Array.isArray(value) ? value : [value])[0];
        var maxDetailIndex = allViews.indexOf(maxDetail);
        var clock = (React.createElement(Clock, __assign({ className: clockClassName, renderMinuteHand: maxDetailIndex > 0, renderSecondHand: maxDetailIndex > 1, value: valueFrom }, clockProps)));
        return portalContainer ? (createPortal(React.createElement("div", { ref: clockWrapper, className: classNames }, clock), portalContainer)) : (React.createElement(Fit, null,
            React.createElement("div", { ref: function (ref) {
                    if (ref && !isClockOpen) {
                        ref.removeAttribute('style');
                    }
                }, className: classNames }, clock)));
    }
    var eventProps = useMemo(function () { return makeEventProps(otherProps); }, [otherProps]);
    return (React.createElement("div", __assign({ className: clsx(baseClassName, "".concat(baseClassName, "--").concat(isCalendarOpen || isClockOpen ? 'open' : 'closed'), "".concat(baseClassName, "--").concat(disabled ? 'disabled' : 'enabled'), className), "data-testid": dataTestid, id: id }, eventProps, { onFocus: onFocus, ref: wrapper }),
        renderInputs(),
        renderCalendar(),
        renderClock()));
}
var isValue = PropTypes.oneOfType([PropTypes.string, PropTypes.instanceOf(Date)]);
var isValueOrValueArray = PropTypes.oneOfType([isValue, PropTypes.arrayOf(isValue)]);
DateTimeRangePicker.propTypes = {
    amPmAriaLabel: PropTypes.string,
    autoFocus: PropTypes.bool,
    calendarAriaLabel: PropTypes.string,
    calendarClassName: PropTypes.oneOfType([PropTypes.string, PropTypes.arrayOf(PropTypes.string)]),
    calendarIcon: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),
    className: PropTypes.oneOfType([PropTypes.string, PropTypes.arrayOf(PropTypes.string)]),
    clearAriaLabel: PropTypes.string,
    clearIcon: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),
    clockClassName: PropTypes.oneOfType([PropTypes.string, PropTypes.arrayOf(PropTypes.string)]),
    closeWidgets: PropTypes.bool,
    'data-testid': PropTypes.string,
    dayAriaLabel: PropTypes.string,
    dayPlaceholder: PropTypes.string,
    disableCalendar: PropTypes.bool,
    disableClock: PropTypes.bool,
    disabled: PropTypes.bool,
    format: PropTypes.string,
    hourAriaLabel: PropTypes.string,
    hourPlaceholder: PropTypes.string,
    id: PropTypes.string,
    isCalendarOpen: PropTypes.bool,
    isClockOpen: PropTypes.bool,
    locale: PropTypes.string,
    maxDate: isMaxDate,
    maxDetail: PropTypes.oneOf(allViews),
    minDate: isMinDate,
    minuteAriaLabel: PropTypes.string,
    minutePlaceholder: PropTypes.string,
    monthAriaLabel: PropTypes.string,
    monthPlaceholder: PropTypes.string,
    name: PropTypes.string,
    nativeInputAriaLabel: PropTypes.string,
    onCalendarClose: PropTypes.func,
    onCalendarOpen: PropTypes.func,
    onChange: PropTypes.func,
    onClockClose: PropTypes.func,
    onClockOpen: PropTypes.func,
    onFocus: PropTypes.func,
    openWidgetsOnFocus: PropTypes.bool,
    portalContainer: PropTypes.object,
    rangeDivider: PropTypes.node,
    required: PropTypes.bool,
    secondAriaLabel: PropTypes.string,
    secondPlaceholder: PropTypes.string,
    showLeadingZeros: PropTypes.bool,
    value: isValueOrValueArray,
    yearAriaLabel: PropTypes.string,
    yearPlaceholder: PropTypes.string,
};
