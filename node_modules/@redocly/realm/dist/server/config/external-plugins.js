import{existsSync as a}from"node:fs";import s from"node:path";import{pathToFileURL as h}from"node:url";import{isDefined as y}from"../../shared/jsUtils.js";import{sha as P}from"../utils/crypto.js";import{reporter as v,logger as m}from"../utils/index.js";import{DEFAULT_PROJECT_PLUGIN_PATHS as p,DEFAULT_THEME_NAME as D,STYLES_FILE as A,USER_THEME_ALIAS as _}from"./constants.js";import{resolveModule as g}from"./resolve-module.js";import{EntitlementsProvider as j}from"../entitlements/entitlements-provider.js";import{Feature as w}from"../entitlements/entitlements.types.js";import{GATED_PLUGINS as E}from"../entitlements/constants.js";const f={sha:"",value:Promise.resolve({resolvedPlugins:[],errors:[]})};async function J(e,n=[]){const r=P(JSON.stringify(n));if(f.sha!==r){f.sha=r;const t=F(e,n);f.value=Promise.all(t.map(l=>O(l,e))).then(l=>{const u=l.filter(y),i=u.filter(c=>c?.type&&["error","warning"].includes(c.type)),d=u.filter(c=>c.type==="resolvedPlugin");return{errors:i,resolvedPlugins:d}})}const o=await f.value;if(o.errors.length)for(let t=0;t<o.errors.length;t++)v.panicOnBuildContentError(o.errors[t].error);return o.resolvedPlugins}function F(e,n=[]){const r=[...n];for(const t of p)!r.includes(t)&&a(s.join(e,t))&&r.push(t);return r.includes("@redocly/theme/plugin.js")||r.unshift("@redocly/theme/plugin.js"),r.some(t=>p.includes(t))||r.push(p[0]),r}async function O(e,n){const r=C(e,n);if(!r)return{type:"error",error:`Plugin with path "${e}" not found`};const o=s.dirname(r),l=s.dirname(e)===D?void 0:await S(e,r,n);return{name:s.dirname(e),type:"resolvedPlugin",isNpmPackage:T(e),pluginDirAbsolutePath:o,pluginPath:e,lifecyclePlugin:l?.lifecyclePlugin,config:l?.config||{},stylesFile:s.resolve(o,A),markdoc:M(o)}}function T(e){const n=s.dirname(e);return g(s.join(n,"package.json"))!=null}async function S(e,n,r){const o=j.instance();if(!(!o.canAccessFeature(w.CustomPlugins)&&!E.includes(e)))try{const l=await import(h(n).toString());if(b(l)){m.warn("Plugin format is deprecated, please use the new plugin format: %rp",e);return}const u=typeof l.default=="function"?l.default:l.default?.default;if(!u)throw new Error("does not have a default export");if(typeof u!="function")throw new Error(`default export should be a function, got ${typeof u}`);const i=await u({contentDir:r});if(typeof i!="object"||i===null)throw new Error(`default export should return an object, got ${typeof i}`);return i.requiredEntitlements&&E.includes(e)&&!i.requiredEntitlements.every(d=>o.canAccessFeature(d))?void 0:{lifecyclePlugin:{id:i.id||e,processContent:i.processContent,afterRoutesCreated:i.afterRoutesCreated,loaders:i.loaders,requiredEntitlements:i.requiredEntitlements},config:{ssoSchema:i.ssoConfigSchema,schema:i.redoclyConfigSchema,ejectIgnore:i.ejectIgnore}}}catch(t){t.code==="ERR_MODULE_NOT_FOUND"||t.code==="ERR_PACKAGE_PATH_NOT_EXPORTED"?m.verbose("%s not found: %s",e,t.message):m.error("%s errored: %s",e,t.message)}}function C(e,n){if(s.dirname(e)===_)return s.join(n,e);const o=s.join(n,e);return a(o)?o:g(e)}function M(e){const n=s.resolve(e,"markdoc"),r=s.join(n,"schema.ts");if(!a(r))return null;const o=s.join(n,"components.tsx");return{schemaFile:r,componentsFile:a(o)?o:void 0}}function b(e){return typeof e.default=="object"&&"id"in e.default}export{J as resolvePlugins};
