import f from"node:path";import{Fs as F}from"./fs.js";import{I18N_DIR_NAME as u,L10N_DIR_NAME as h}from"../constants.js";import{isL10nPath as n}from"./utils/is-l10n-path.js";import{getLocaleFromRelativePath as d}from"./utils/get-locale-from-relative-path.js";import{removeL10nPrefix as c}from"./utils/remove-l10n-prefix.js";import{LastModifiedTracker as m}from"./last-modified-tracker.js";import{logger as p}from"../utils/index.js";class z extends F{cwd;ignored;l10nFolders=new Map;lastModifiedTracker;activeLocalizationFolder;constructor(e,t=[]){super(e,t),this.cwd=e,this.ignored=t,this.lastModifiedTracker=new m(this),this.init()}get localeFolders(){return Array.from(this.l10nFolders.keys())}get localizationFolder(){if(this.activeLocalizationFolder)return this.activeLocalizationFolder;let e=!1,t=!1;const r=this.localeFolders;if(!r.length)return;for(const l of r)for(const s of this.l10nFolders.get(l)?.values()||[]){const i=s.startsWith(h),o=s.startsWith(u);i&&!e&&(e=!0),o&&!t&&(t=!0)}e&&t&&p.panic("Only one folder `@l10n` should be used for localization"),t&&p.warn("`@i18n` folder is deprecated. Please use `@l10n` folder instead.");const a=e?h:u;return this.activeLocalizationFolder=a,a}async getFileInfo(e){if(e=e.replace(/^\.\//g,""),n(e)){if(await super.exists(e))return super.getFileInfo(e);const t=c(e),r=await super.getFileInfo(t);return r&&{...r,relativePath:e,realRelativePath:t,dirname:f.posix.dirname(e),isVirtual:!0}}return super.getFileInfo(e)}async readdir(e){if(n(e))throw new Error("readdir is not supported in l10n or i18n directories");return super.readdir(e)}async exists(e){return e=e.replace(/^\.\//g,""),n(e)?await super.exists(e)||await super.exists(c(e)):super.exists(e)}async read(e,t="utf-8"){return n(e)?await super.exists(e)?super.read(e,t):super.read(c(e),t):super.read(e,t)}async scan(e){const t=await super.scan(e),r={},a=new Set,l=t.map(s=>{if(n(s.relativePath)){const i=d(s.relativePath),o=r[i]||new Set;o.add(c(s.relativePath)),r[i]=o}else a.add(s.relativePath);return s});for(const s of a.values())for(const i of this.l10nFolders.keys())if(!r[i]?.has(s)){const o=`${this.localizationFolder}/${i}/${s}`;l.push({realRelativePath:s,relativePath:o,dirname:f.posix.dirname(o),isVirtual:!0})}return l}async getLastModified(e){await this.watcher;const t=await this.getFileInfo(e);return this.lastModifiedTracker.getLastModified(t?.realRelativePath||e)}async init(){await this.watcher,this.l10nFolders=new Map;for(const e of this.filesList.values())if(n(e.relativePath)){const t=d(e.relativePath),r=this.l10nFolders.get(t)||new Set;r.add(e.relativePath),this.l10nFolders.set(t,r)}super.watch(async e=>{for(const t of e){if(t.event==="code-updated"||!n(t.path))continue;const r=d(t.path),a=this.l10nFolders.get(r)||new Set;switch(t.event){case"add":a.add(t.path),this.l10nFolders.set(r,a);break;case"unlink":a&&(a.delete(t.path),a.size===0&&this.l10nFolders.delete(r));break}}})}}export{z as ContentFs};
