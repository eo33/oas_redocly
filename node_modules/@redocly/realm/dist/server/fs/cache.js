import k from"node:path";import{NestedMap as A}from"./utils/nested-map.js";import{touchedCacheRecordsStore as p,trackAccessStore as m,fsChangesStore as L}from"./utils/async-storage.js";import{sha1 as D}from"../utils/crypto.js";import{LoadError as C}from"./load-error.js";import{createLifecycleContext as U}from"../plugins/lifecycle.js";function f(d,t){return d+":"+t}class z{fs;errors=new Map;cache=new A;accessRecords=new A;lifecycleContext;loaders={};constructor(t){this.fs=t,this.lifecycleContext=U(t,this),this.fs.setEmitWrapper(async r=>p.run(new Set,async()=>{await r(),this.cleanUpCache()}))}async load(t,r,a){let s,h;typeof r=="string"?(s=r,h=this.loaders[r]):(s=r.name,h=r.loader);const i=a?.join("")??"",o=a?i.length>20?D(i):i:void 0,n=!this.wasChanged(t,s,o),e=f(s,t),l=p.getStore();l?.add(e);const u=this.cache.get(s,t),y=m.getStore()??[];if(n&&u)return y.push({type:"load",loaderKey:s,cacheKey:t,hash:u.compoundHash}),o!==void 0&&y.push({type:"dependencies",hash:o}),l&&E(this.accessRecords.get(s,t)??[],this.accessRecords,l),u;const K=await this.trackAccess(t,s,async()=>{let w;const R=m.getStore()||[];o!==void 0&&R.push({type:"dependencies",hash:o});const g=[],M=c=>g.push(c);try{w=await h(t,this.lifecycleContext,M),g.length>0?this.errors.set(e,g):this.errors.delete(e)}catch(c){const x=this.cache.get(s,t)?.data,v=s==="redocly-config"||s==="nearest-redocly-config"?!1:(await this.load(t,"is-ignored")).data;if(!(c instanceof C)&&!v&&this.errors.set(e,[c]),!x)throw c instanceof C?c:new C(c.message,{loaderKey:s,cause:c});w=x}const S=D(t+R.map(c=>c.hash).join(""));return y.push({type:"load",loaderKey:s,cacheKey:t,hash:S}),{data:w,compoundHash:S}});return this.cache.set(s,t,K),K}cleanUpCache(){const t=p.getStore()??new Set;for(const r of this.cache.keys())for(const a of this.cache.get(r)?.keys()??[]){const s=f(r,a);t.has(s)||(this.cache.delete(r,a),this.errors.delete(s))}}setLoaders(t){this.loaders={...this.loaders,...t}}wasChanged(t,r,a,s){const h=p.getStore();if(!s&&h?.has(f(r,t)))return!1;const i=L.getStore()??[],o=this.accessRecords.get(r,t)??[];return a!==void 0&&!o.find(e=>e.type!=="dependencies"?!1:e.hash===a)?!0:i.some(n=>{switch(n.event){case"add":return o.some(e=>{switch(e.type){case"read":return e.path===n.path;case"readdir":return e.path===k.posix.dirname(n.path);case"exists":return e.path===n.path;case"load":return this.wasChanged(e.cacheKey,e.loaderKey,void 0,!0);case"scan":return!e.pattern||e.pattern.test(n.path)}});case"change":return o.some(e=>{switch(e.type){case"read":return e.path===n.path;case"readdir":return!1;case"exists":return!1;case"load":return this.wasChanged(e.cacheKey,e.loaderKey,void 0,!0);case"scan":return!1}});case"unlink":return o.some(e=>{switch(e.type){case"read":return e.path===n.path;case"readdir":return e.path===k.posix.dirname(n.path);case"exists":return e.path===n.path;case"load":return this.wasChanged(e.cacheKey,e.loaderKey,void 0,!0);case"scan":return!e.pattern||e.pattern.test(n.path)}})}})}trackAccess(t,r,a){const s=[];return this.accessRecords.set(r,t,s),m.run(s,a)}}const E=(d,t,r)=>{for(const a of d)if(a.type==="load"){const s=f(a.loaderKey,a.cacheKey);if(r.has(s))continue;r.add(s);const h=t.get(a.loaderKey,a.cacheKey);h&&E(h,t,r)}};export{z as Cache};
