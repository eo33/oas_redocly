import { createRequire as topLevelCreateRequire } from 'module';
 const require = topLevelCreateRequire(import.meta.url);
import {
  c,
  s
} from "./chunk-P5LFNF57.js";
import {
  f,
  g,
  h,
  i,
  l,
  y
} from "./chunk-7WVTT2DN.js";
import {
  Markdoc,
  init_dist
} from "./chunk-EAFIJ2VV.js";
import {
  __export,
  __publicField
} from "./chunk-35AYGKFE.js";

// node_modules/@redocly/realm/dist/server/plugins/markdown/markdoc/nodes/index.js
var nodes_exports = {};
__export(nodes_exports, {
  document: () => d3,
  em: () => r,
  fence: () => h3,
  heading: () => d2,
  item: () => h2,
  link: () => s2,
  s: () => t,
  strong: () => n2,
  table: () => o2
});
init_dist();

// node_modules/@redocly/realm/dist/server/plugins/markdown/markdoc/nodes/gfm-list-item.js
init_dist();

// node_modules/@redocly/realm/dist/server/plugins/markdown/markdoc/utils/is-sting-node.js
function n(t3) {
  return typeof t3 == "string";
}

// node_modules/@redocly/realm/dist/server/plugins/markdown/markdoc/nodes/gfm-list-item.js
var o = Markdoc.nodes.item;
var a = (e) => e.match(/^\[[x ]\]/i);
var c2 = (e) => !e.startsWith("[ ]");
var h2 = { ...o, transform(e, s4) {
  const i4 = e.transformAttributes(s4);
  let t3 = e.transformChildren(s4);
  return n(t3[0]) && a(t3[0]) && (t3 = [new Markdoc.Tag("input", { checked: c2(t3[0]), type: "checkbox", readOnly: true }, []), t3[0].substring(3), ...t3.slice(1)]), new Markdoc.Tag("li", i4, t3);
} };

// node_modules/@redocly/realm/dist/server/plugins/markdown/markdoc/nodes/heading.js
init_dist();

// node_modules/@redocly/realm/dist/shared/markdoc.js
function i2(r2, { isTrim: e = true } = {}) {
  const n3 = [];
  for (const t3 of r2)
    y(t3) ? n3.push(String(t3)) : i(t3) ? g(t3) || l(t3) ? n3.push(i2([c3(t3, "content")], { isTrim: e })) : n3.push(i2(t3.children, { isTrim: e })) : f(t3) && t3.name === "code" && n3.push(i2(t3.children, { isTrim: e })), h(t3) && n3.push(i2([d(t3)], { isTrim: e }));
  return e ? n3.map((t3) => t3.trim()).join(" ").trim() : n3.join(" ");
}
function c3(r2, e) {
  return r2.attributes[e] || null;
}
function d(r2) {
  const e = r2?.path?.[0] === "env" ? r2.path[1] : null;
  return e ? s(e) : "";
}

// node_modules/@redocly/realm/dist/server/plugins/markdown/markdoc/nodes/heading.js
var d2 = { children: ["inline"], attributes: { id: { type: String }, level: { type: Number, required: true, default: 1 } }, transform(t3, e) {
  const r2 = t3.transformAttributes(e), i4 = t3.transformChildren(e), n3 = typeof r2.id == "string" ? r2.id : c.slug(i2(i4));
  return new Markdoc.Tag("Heading", { ...r2, id: n3, level: t3.attributes.level }, i4);
} };

// node_modules/@redocly/realm/dist/server/plugins/markdown/markdoc/nodes/fence/index.js
init_dist();
var g2 = Markdoc.nodes.fence;
var h3 = { ...g2, attributes: { ...g2.attributes, label: { type: String, render: "data-label" }, title: { type: String, render: "data-title" }, highlight: { type: String, render: "data-highlight" } }, transform(e, i4) {
  const r2 = e.transformAttributes(i4);
  let t3 = e.transformChildren(i4);
  const s4 = r2["data-language"], l2 = r2["data-title"];
  switch (e.attributes.process === false && (t3 = [e.attributes.content]), s4) {
    case "mermaid":
      return n(t3[0]) ? new Markdoc.Tag("Mermaid", { ...r2, diagramSource: t3[0] }, t3) : new Markdoc.Tag(e.tag, r2, t3);
    default:
      const c5 = t3.map((n3) => y(n3) ? n3.toString() : f(n3) ? n3?.attributes?.rawtag : "").join("");
      return n(t3[0]) ? new Markdoc.Tag("CodeBlock", { ...r2, header: { title: l2, controls: { copy: {} } }, source: c5, lang: s4 }, []) : new Markdoc.Tag(e.tag, r2, t3);
  }
} };

// node_modules/@redocly/realm/dist/server/plugins/markdown/markdoc/nodes/table.js
init_dist();
var o2 = { transform(t3, r2) {
  const s4 = t3.transformAttributes(r2), e = t3.transformChildren(r2);
  return new Markdoc.Tag("div", { className: "md-table-wrapper" }, [new Markdoc.Tag("table", { ...s4, className: "md" }, u(e))]);
} };
function u(t3) {
  if (!t3.length)
    return t3;
  const [r2, ...s4] = t3;
  return !f(r2) || r2.name !== "thead" ? t3 : [new Markdoc.Tag("thead", r2.attributes, r2.children.map((e) => !f(e) || e.name !== "tr" ? e : new Markdoc.Tag("tr", e.attributes, e.children.map((a4) => !f(a4) || a4.name !== "th" ? a4 : new Markdoc.Tag("th", { ...a4.attributes, "data-label": i2(a4.children) }, a4.children))))), ...s4];
}

// node_modules/@redocly/realm/dist/server/plugins/markdown/markdoc/nodes/index.js
var n2 = { ...Markdoc.nodes.strong, children: [...Markdoc.nodes.strong.children, "softbreak", "em", "strong"] };
var r = { ...Markdoc.nodes.em, children: [...Markdoc.nodes.em.children, "softbreak", "em", "strong"] };
var t = { ...Markdoc.nodes.s, children: [...Markdoc.nodes.s.children, "softbreak"] };
var s2 = { ...Markdoc.nodes.link, children: [...Markdoc.nodes.link.children, "softbreak", "image"] };
var d3 = { ...Markdoc.nodes.document, children: [...Markdoc.nodes.document.children, "text"] };

// node_modules/@redocly/realm/dist/server/plugins/markdown/markdoc/attributes/definition-path.js
var t2 = class {
  validate(a4) {
    return [];
  }
};
__publicField(t2, "resolver", "openapiRef");

// node_modules/@redocly/realm/dist/server/plugins/markdown/markdoc/attributes/json-schema-ref.js
var s3 = class {
  validate(a4) {
    return [];
  }
};
__publicField(s3, "resolver", "jsonSchemaRef");

// node_modules/@redocly/realm/dist/server/plugins/markdown/markdoc/tags/json-schema.js
var o3 = { schema: { attributes: { schema: { type: s3 }, options: { type: Object, default: {} }, schemaResolved: { type: Object }, schemaResolvedErrors: { type: Array, default: [] } }, render: "JsonSchema", selfClosing: true, dynamicComponentLib: "openapi" }, tagName: "json-schema" };

// node_modules/@redocly/realm/dist/server/plugins/markdown/markdoc/tags/openapi-code-sample.js
var a2 = { schema: { attributes: { descriptionFile: { type: t2, required: true }, pointer: { type: String, required: false }, operationId: { type: String, required: false }, exampleKey: { type: String, required: false }, mimeType: { type: String, required: false }, language: { type: String, required: false }, parameters: { type: Object, default: {}, required: false }, requestBody: { type: Object, required: false }, options: { type: Object, default: {}, required: false }, environments: { type: Object, default: {}, required: false }, environment: { type: String, required: false } }, validate(e) {
  const t3 = [];
  return e.attributes.pointer && e.attributes.operationId && t3.push({ id: "pointer-and-operationId-attributes-are-mutually-exclusive", level: "error", message: 'The "pointer" and "operationId" attributes are mutually exclusive, you can only use one.' }), !e.attributes.pointer && !e.attributes.operationId && t3.push({ id: "pointer-or-operationId-attribute-required", level: "error", message: 'This tag requires the "pointer" or "operationId" attribute to render correctly.' }), t3;
}, render: "OpenApiCodeSample", selfClosing: true, dynamicComponentLib: "openapi" }, tagName: "openapi-code-sample" };

// node_modules/@redocly/realm/dist/server/plugins/markdown/markdoc/tags/openapi-example.js
var i3 = { schema: { attributes: { descriptionFile: { type: t2, required: true }, pointer: { type: String, required: true }, options: { type: Object, default: {} }, mimeType: { type: String, required: false } }, render: "OpenApiExample", selfClosing: true, dynamicComponentLib: "openapi" }, tagName: "openapi-example" };

// node_modules/@redocly/realm/dist/server/plugins/markdown/markdoc/tags/replay-openapi.js
var a3 = { schema: { attributes: { descriptionFile: { type: t2, required: true }, pointer: { type: String, required: false }, operationId: { type: String, required: false }, exampleKey: { type: String, required: false }, mimeType: { type: String, required: false }, parameters: { type: Object, default: {}, required: false }, requestBody: { type: Object, required: false }, options: { type: Object, default: {}, required: false }, environments: { type: Object, default: {}, required: false }, environment: { type: String, required: false } }, validate(e) {
  const t3 = [];
  return e.attributes.pointer && e.attributes.operationId && t3.push({ id: "pointer-and-operationId-attributes-are-mutually-exclusive", level: "error", message: 'The "pointer" and "operationId" attributes are mutually exclusive, you can only use one.' }), !e.attributes.pointer && !e.attributes.operationId && t3.push({ id: "pointer-or-operationId-attribute-required", level: "error", message: 'This tag requires the "pointer" or "operationId" attribute to render correctly.' }), t3;
}, render: "ReplayOpenApi", selfClosing: true, dynamicComponentLib: "openapi" }, tagName: "replay-openapi" };

// node_modules/@redocly/realm/dist/server/plugins/markdown/markdoc/tags/index.js
var c4 = { [o3.tagName]: o3.schema, [a2.tagName]: a2.schema, [i3.tagName]: i3.schema, [a3.tagName]: a3.schema };

export {
  n,
  i2 as i,
  c3 as c,
  nodes_exports,
  c4 as c2
};
