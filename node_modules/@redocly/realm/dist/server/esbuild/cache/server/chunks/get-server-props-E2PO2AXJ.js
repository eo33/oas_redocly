import { createRequire as topLevelCreateRequire } from 'module';
 const require = topLevelCreateRequire(import.meta.url);
import "./chunk-2BYWYT7Z.js";
import {
  d as d2,
  r,
  x
} from "./chunk-E25PHAH2.js";
import {
  c,
  c2 as c3,
  i,
  n,
  nodes_exports
} from "./chunk-RAP5XDZA.js";
import {
  c as c2,
  d
} from "./chunk-P5LFNF57.js";
import {
  f
} from "./chunk-7WVTT2DN.js";
import {
  Markdoc,
  default_exports2 as default_exports,
  init_dist,
  init_src
} from "./chunk-EAFIJ2VV.js";
import "./chunk-AB7LF64Z.js";
import "./chunk-Q6LZZN6W.js";
import "./chunk-WLDWULA7.js";
import "./chunk-GHSOG4VG.js";
import "./chunk-D237NEF2.js";
import "./chunk-2J7OHCSZ.js";
import "./chunk-XQXU7C5Q.js";
import "./chunk-SX3NFZJN.js";
import "./chunk-WNBJGIID.js";
import "./chunk-R4PATEVC.js";
import "./chunk-35AYGKFE.js";

// node_modules/@redocly/realm/dist/server/plugins/markdown/get-server-props.js
init_dist();

// node_modules/@redocly/realm/dist/server/plugins/markdown/runtime-transform.js
init_dist();

// node_modules/@redocly/realm/dist/server/plugins/markdown/markdoc/markdoc-options.js
init_dist();
init_src();

// node_modules/@redocly/realm/dist/server/plugins/markdown/markdoc/functions/includes.js
var s = { transform(a2) {
  const [r3, e] = Object.values(a2);
  return Array.isArray(r3) ? r3.includes(e) : false;
} };

// node_modules/@redocly/realm/dist/server/plugins/markdown/markdoc/import-user-tags.js
import { pathToFileURL as r2 } from "url";
async function a(e) {
  if (process.env.REDOCLY_STATIC_BUNDLE)
    return await import("./schema-GEAWW3H6.js");
  {
    const t = r() ? "js" : "mjs";
    return await import(r2(`${e}/user-tags-entry.${t}`) + "?" + /* @__PURE__ */ new Date());
  }
}

// node_modules/@redocly/realm/dist/server/plugins/markdown/markdoc/markdoc-options.js
var h = default_exports.tags;
function O(s2) {
  return Object.fromEntries(Object.entries(s2).map(([o, e]) => [e.tagName || o, e]));
}
function y(s2) {
  const { tags: o, functions: e = {}, ...n3 } = s2, a2 = { ...o, ...n3 };
  let i4 = Object.entries(a2);
  const r3 = [], t = [];
  for (const [c5, m] of i4)
    Markdoc.nodes[c5] ? r3.push([c5, m]) : t.push([c5, m]);
  return { nodes: Object.fromEntries(r3), tags: Object.fromEntries(t), functions: e };
}
async function j(s2 = "../../../esbuild/cache/server/", o = "") {
  let e;
  try {
    e = (await a(s2)).schema;
  } catch (t) {
    throw t.code === "ERR_MODULE_NOT_FOUND" ? new Error("Please fix the errors above and try again.") : t;
  }
  const { tags: n3 = {}, nodes: a2 = {}, functions: i4 = {} } = y(e), r3 = { tags: { schemaDefinition: { render: "SchemaDefinition", attributes: { schemaRef: { type: String }, exampleRef: { type: String }, showReadOnly: { type: Boolean }, showWriteOnly: { type: Boolean } } } } };
  return { nodes: { ...nodes_exports, ...a2 }, tags: { ...c3, ...h, ...O(n3), ...r3.tags }, functions: { ...Markdoc.functions, ...i4, includes: s } };
}

// node_modules/@redocly/realm/dist/server/plugins/markdown/markdoc/plugins/utils.js
function l(t) {
  const r3 = c(t, "level");
  if (r3)
    return { value: i(t.children), id: c(t, "id"), depth: r3 };
}
var n2 = Symbol("Exit visitor");
function u(t, r3) {
  if (!t)
    return;
  const e = r3(t);
  if (e === n2)
    return e;
  for (const i4 of t.children) {
    if (!i4 || n(i4))
      continue;
    const o = u(i4, r3);
    if (o === n2)
      return o;
  }
}

// node_modules/nanoid/index.js
import crypto from "crypto";

// node_modules/nanoid/url-alphabet/index.js
var urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";

// node_modules/nanoid/index.js
var POOL_SIZE_MULTIPLIER = 128;
var pool;
var poolOffset;
var fillPool = (bytes) => {
  if (!pool || pool.length < bytes) {
    pool = Buffer.allocUnsafe(bytes * POOL_SIZE_MULTIPLIER);
    crypto.randomFillSync(pool);
    poolOffset = 0;
  } else if (poolOffset + bytes > pool.length) {
    crypto.randomFillSync(pool);
    poolOffset = 0;
  }
  poolOffset += bytes;
};
var nanoid = (size = 21) => {
  fillPool(size -= 0);
  let id = "";
  for (let i4 = poolOffset - size; i4 < poolOffset; i4++) {
    id += urlAlphabet[pool[i4] & 63];
  }
  return id;
};

// node_modules/@redocly/realm/dist/server/plugins/markdown/markdoc/plugins/render-mermaid.js
var i3 = {};
async function E(t, h2 = "default") {
  if (t.length === 0)
    return [];
  const r3 = [];
  for (let e = 0; e < t.length; e++) {
    const n3 = d2(t[e]);
    i3[n3] || r3.push(t[e]);
  }
  if (r3.length) {
    const e = process.env.REDOCLY_MERMAID_MICROSERVICE_URL || "https://api.redocly.com/mermaid", n3 = x.startTiming(), c5 = nanoid(), d3 = await fetch(e, { method: "POST", headers: { "Content-Type": "application/json", "x-request-id": process.env.REQUEST_ID || "" }, body: JSON.stringify({ definitions: r3, rayId: c5, theme: h2, organizationId: process.env.ORGANIZATION_ID }) });
    if (d3.status !== 200)
      throw new Error(`Something went wrong during remote rendering. Please, save this Ray ID: ${c5} and contact Redocly team.`);
    x.verboseTime(n3, "Rendered mermaid diagrams (%s)", r3.length);
    const g = await d3.json();
    for (let o = 0; o < r3.length; o++) {
      const p = d2(r3[o]);
      i3[p] = g[o];
    }
  }
  const a2 = [];
  for (let e = 0; e < t.length; e++) {
    const n3 = d2(t[e]);
    a2.push(i3[n3]);
  }
  return a2;
}

// node_modules/@redocly/realm/dist/server/plugins/markdown/runtime-transform.js
async function D(s2, m, n3) {
  const d3 = await j(n3), e = [], t = [];
  c2.reset();
  const a2 = Markdoc.transform(s2, { ...d3, ...m });
  u(a2, (r3) => {
    if (f(r3))
      switch (r3.name) {
        case "Heading":
          const i4 = l(r3);
          i4 && e.push(i4);
          break;
        case "Mermaid":
          t.push({ tag: r3, source: r3.attributes.diagramSource });
          break;
      }
  });
  const o = await E(t.map((r3) => r3.source));
  for (let r3 = 0; r3 < o.length; r3++)
    t[r3].tag.attributes.diagramHtml = o[r3];
  return { headings: e, renderableAst: a2 };
}

// node_modules/@redocly/realm/dist/server/plugins/markdown/get-server-props.js
async function c4(b, a2, r3, e) {
  const { ast: o, frontmatter: t, props: s2, editPage: i4, lastModified: n3 } = a2, { headings: f2, renderableAst: l2 } = await D(Markdoc.Ast.fromJSON(o), { partials: r3.partials, variables: { frontmatter: t, ...r3.variables, env: d() } }, e);
  return { ...s2, ast: l2, headings: f2, frontmatter: t, editPage: i4, lastModified: n3 };
}
export {
  c4 as default
};
