import { createRequire as topLevelCreateRequire } from 'module';
 const require = topLevelCreateRequire(import.meta.url);
import {
  AddIcon,
  ArrowUpRightIcon,
  BookmarkAddIcon,
  CharacterIcon,
  ChevronRightIcon,
  ChevronSortIcon,
  CircleDashIcon,
  CleanIcon,
  CloseFilledIcon,
  CloseOutlineIcon,
  CloudUploadIcon,
  CodeIcon,
  CookieIcon,
  CopyButton,
  DataFormatIcon,
  DocumentAddIcon,
  DocumentBlankIcon,
  DownloadIcon,
  ExportIcon,
  FileIcon,
  FileStorageIcon,
  FolderAddIcon,
  FolderIcon,
  GlobalStyle,
  H4,
  IBMCloudHyperProtectCryptoServicesIcon,
  InformationIcon,
  OverflowMenuVerticalIcon,
  Portal,
  RestartIcon,
  SaveIcon,
  SecurityIcon,
  Segmented,
  SidePanelCloseIcon,
  SidePanelOpenIcon,
  Spinner,
  SpinnerIcon,
  StatusCode,
  Switch,
  TableBuiltIcon,
  TimeIcon,
  TrashCanIcon,
  Typography,
  ValueVariableIcon,
  ViewIcon,
  ViewOffIcon,
  WarningFilledIcon,
  default_exports2 as default_exports,
  init_src
} from "./chunk-EAFIJ2VV.js";
import {
  EditIcon,
  Markdown
} from "./chunk-AB7LF64Z.js";
import "./chunk-Q6LZZN6W.js";
import "./chunk-WLDWULA7.js";
import "./chunk-GHSOG4VG.js";
import "./chunk-D237NEF2.js";
import {
  CheckboxIcon,
  CheckmarkIcon,
  ChevronDownIcon,
  ChevronUpIcon,
  CloseIcon,
  Dropdown,
  DropdownMenu,
  SearchIcon,
  Select,
  Tag,
  require_react_dom
} from "./chunk-2J7OHCSZ.js";
import {
  ArrowRightIcon
} from "./chunk-XQXU7C5Q.js";
import {
  Button
} from "./chunk-SX3NFZJN.js";
import {
  isString,
  useFocusTrap,
  useModalScrollLock,
  useMount,
  useOutsideClick,
  useThemeHooks
} from "./chunk-WNBJGIID.js";
import "./chunk-R4PATEVC.js";
import {
  __toESM
} from "./chunk-35AYGKFE.js";

// node_modules/@redocly/replay/dist/replay.js
init_src();
var import_react_dom = __toESM(require_react_dom(), 1);
import * as q from "react";
import it, { useRef as Ke, useContext as Ii, createElement as Xi, useState as fe, useCallback as Ue, createContext as Ac, forwardRef as xs, Fragment as _r, useLayoutEffect as qk, useMemo as We, Component as i4, useEffect as _e, useImperativeHandle as $O, memo as no, useTransition as o4, StrictMode as jO } from "react";
var n4 = Object.defineProperty;
var r4 = (t4, e, n) => e in t4 ? n4(t4, e, { enumerable: true, configurable: true, writable: true, value: n }) : t4[e] = n;
var Mv = (t4, e, n) => r4(t4, typeof e != "symbol" ? e + "" : e, n);
var Ze = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Za(t4) {
  return t4 && t4.__esModule && Object.prototype.hasOwnProperty.call(t4, "default") ? t4.default : t4;
}
function W4(t4) {
  if (t4.__esModule)
    return t4;
  var e = t4.default;
  if (typeof e == "function") {
    var n = function r() {
      return this instanceof r ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
    };
    n.prototype = e.prototype;
  } else
    n = {};
  return Object.defineProperty(n, "__esModule", { value: true }), Object.keys(t4).forEach(function(r) {
    var i = Object.getOwnPropertyDescriptor(t4, r);
    Object.defineProperty(n, r, i.get ? i : {
      enumerable: true,
      get: function() {
        return t4[r];
      }
    });
  }), n;
}
var tg = { exports: {} };
var cl = {};
var Vv;
function z4() {
  return Vv || (Vv = 1, function() {
    var t4 = it, e = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), i = Symbol.for("react.strict_mode"), o = Symbol.for("react.profiler"), s = Symbol.for("react.provider"), a = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), c = Symbol.for("react.suspense"), u = Symbol.for("react.suspense_list"), f = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), h = Symbol.for("react.offscreen"), p = Symbol.iterator, O = "@@iterator";
    function m(F) {
      if (F === null || typeof F != "object")
        return null;
      var re = p && F[p] || F[O];
      return typeof re == "function" ? re : null;
    }
    var x = t4.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function v(F) {
      {
        for (var re = arguments.length, le = new Array(re > 1 ? re - 1 : 0), Ce = 1; Ce < re; Ce++)
          le[Ce - 1] = arguments[Ce];
        y("error", F, le);
      }
    }
    function y(F, re, le) {
      {
        var Ce = x.ReactDebugCurrentFrame, Ye = Ce.getStackAddendum();
        Ye !== "" && (re += "%s", le = le.concat([Ye]));
        var ct = le.map(function(Ve) {
          return String(Ve);
        });
        ct.unshift("Warning: " + re), Function.prototype.apply.call(console[F], console, ct);
      }
    }
    var S = false, b = false, w = false, C = false, k = false, T;
    T = Symbol.for("react.module.reference");
    function A(F) {
      return !!(typeof F == "string" || typeof F == "function" || F === r || F === o || k || F === i || F === c || F === u || C || F === h || S || b || w || typeof F == "object" && F !== null && (F.$$typeof === d || F.$$typeof === f || F.$$typeof === s || F.$$typeof === a || F.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      F.$$typeof === T || F.getModuleId !== void 0));
    }
    function E(F, re, le) {
      var Ce = F.displayName;
      if (Ce)
        return Ce;
      var Ye = re.displayName || re.name || "";
      return Ye !== "" ? le + "(" + Ye + ")" : le;
    }
    function $(F) {
      return F.displayName || "Context";
    }
    function j(F) {
      if (F == null)
        return null;
      if (typeof F.tag == "number" && v("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof F == "function")
        return F.displayName || F.name || null;
      if (typeof F == "string")
        return F;
      switch (F) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case o:
          return "Profiler";
        case i:
          return "StrictMode";
        case c:
          return "Suspense";
        case u:
          return "SuspenseList";
      }
      if (typeof F == "object")
        switch (F.$$typeof) {
          case a:
            var re = F;
            return $(re) + ".Consumer";
          case s:
            var le = F;
            return $(le._context) + ".Provider";
          case l:
            return E(F, F.render, "ForwardRef");
          case f:
            var Ce = F.displayName || null;
            return Ce !== null ? Ce : j(F.type) || "Memo";
          case d: {
            var Ye = F, ct = Ye._payload, Ve = Ye._init;
            try {
              return j(Ve(ct));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var B = Object.assign, D = 0, N, z, Z, J, L, W, R;
    function Q() {
    }
    Q.__reactDisabledLog = true;
    function _() {
      {
        if (D === 0) {
          N = console.log, z = console.info, Z = console.warn, J = console.error, L = console.group, W = console.groupCollapsed, R = console.groupEnd;
          var F = {
            configurable: true,
            enumerable: true,
            value: Q,
            writable: true
          };
          Object.defineProperties(console, {
            info: F,
            log: F,
            warn: F,
            error: F,
            group: F,
            groupCollapsed: F,
            groupEnd: F
          });
        }
        D++;
      }
    }
    function G() {
      {
        if (D--, D === 0) {
          var F = {
            configurable: true,
            enumerable: true,
            writable: true
          };
          Object.defineProperties(console, {
            log: B({}, F, {
              value: N
            }),
            info: B({}, F, {
              value: z
            }),
            warn: B({}, F, {
              value: Z
            }),
            error: B({}, F, {
              value: J
            }),
            group: B({}, F, {
              value: L
            }),
            groupCollapsed: B({}, F, {
              value: W
            }),
            groupEnd: B({}, F, {
              value: R
            })
          });
        }
        D < 0 && v("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var M = x.ReactCurrentDispatcher, K;
    function V(F, re, le) {
      {
        if (K === void 0)
          try {
            throw Error();
          } catch (Ye) {
            var Ce = Ye.stack.trim().match(/\n( *(at )?)/);
            K = Ce && Ce[1] || "";
          }
        return `
` + K + F;
      }
    }
    var ae = false, te;
    {
      var oe = typeof WeakMap == "function" ? WeakMap : Map;
      te = new oe();
    }
    function Y(F, re) {
      if (!F || ae)
        return "";
      {
        var le = te.get(F);
        if (le !== void 0)
          return le;
      }
      var Ce;
      ae = true;
      var Ye = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ct;
      ct = M.current, M.current = null, _();
      try {
        if (re) {
          var Ve = function() {
            throw Error();
          };
          if (Object.defineProperty(Ve.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(Ve, []);
            } catch (Jn) {
              Ce = Jn;
            }
            Reflect.construct(F, [], Ve);
          } else {
            try {
              Ve.call();
            } catch (Jn) {
              Ce = Jn;
            }
            F.call(Ve.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Jn) {
            Ce = Jn;
          }
          F();
        }
      } catch (Jn) {
        if (Jn && Ce && typeof Jn.stack == "string") {
          for (var Be = Jn.stack.split(`
`), Ht = Ce.stack.split(`
`), Ct = Be.length - 1, kt = Ht.length - 1; Ct >= 1 && kt >= 0 && Be[Ct] !== Ht[kt]; )
            kt--;
          for (; Ct >= 1 && kt >= 0; Ct--, kt--)
            if (Be[Ct] !== Ht[kt]) {
              if (Ct !== 1 || kt !== 1)
                do
                  if (Ct--, kt--, kt < 0 || Be[Ct] !== Ht[kt]) {
                    var Pt = `
` + Be[Ct].replace(" at new ", " at ");
                    return F.displayName && Pt.includes("<anonymous>") && (Pt = Pt.replace("<anonymous>", F.displayName)), typeof F == "function" && te.set(F, Pt), Pt;
                  }
                while (Ct >= 1 && kt >= 0);
              break;
            }
        }
      } finally {
        ae = false, M.current = ct, G(), Error.prepareStackTrace = Ye;
      }
      var oi = F ? F.displayName || F.name : "", Lo = oi ? V(oi) : "";
      return typeof F == "function" && te.set(F, Lo), Lo;
    }
    function he(F, re, le) {
      return Y(F, false);
    }
    function X(F) {
      var re = F.prototype;
      return !!(re && re.isReactComponent);
    }
    function ee(F, re, le) {
      if (F == null)
        return "";
      if (typeof F == "function")
        return Y(F, X(F));
      if (typeof F == "string")
        return V(F);
      switch (F) {
        case c:
          return V("Suspense");
        case u:
          return V("SuspenseList");
      }
      if (typeof F == "object")
        switch (F.$$typeof) {
          case l:
            return he(F.render);
          case f:
            return ee(F.type, re, le);
          case d: {
            var Ce = F, Ye = Ce._payload, ct = Ce._init;
            try {
              return ee(ct(Ye), re, le);
            } catch {
            }
          }
        }
      return "";
    }
    var de = Object.prototype.hasOwnProperty, ve = {}, Re = x.ReactDebugCurrentFrame;
    function ye(F) {
      if (F) {
        var re = F._owner, le = ee(F.type, F._source, re ? re.type : null);
        Re.setExtraStackFrame(le);
      } else
        Re.setExtraStackFrame(null);
    }
    function Ee(F, re, le, Ce, Ye) {
      {
        var ct = Function.call.bind(de);
        for (var Ve in F)
          if (ct(F, Ve)) {
            var Be = void 0;
            try {
              if (typeof F[Ve] != "function") {
                var Ht = Error((Ce || "React class") + ": " + le + " type `" + Ve + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof F[Ve] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Ht.name = "Invariant Violation", Ht;
              }
              Be = F[Ve](re, Ve, Ce, le, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Ct) {
              Be = Ct;
            }
            Be && !(Be instanceof Error) && (ye(Ye), v("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", Ce || "React class", le, Ve, typeof Be), ye(null)), Be instanceof Error && !(Be.message in ve) && (ve[Be.message] = true, ye(Ye), v("Failed %s type: %s", le, Be.message), ye(null));
          }
      }
    }
    var $e = Array.isArray;
    function Ge(F) {
      return $e(F);
    }
    function Je(F) {
      {
        var re = typeof Symbol == "function" && Symbol.toStringTag, le = re && F[Symbol.toStringTag] || F.constructor.name || "Object";
        return le;
      }
    }
    function be(F) {
      try {
        return lt(F), false;
      } catch {
        return true;
      }
    }
    function lt(F) {
      return "" + F;
    }
    function wt(F) {
      if (be(F))
        return v("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Je(F)), lt(F);
    }
    var nn = x.ReactCurrentOwner, gn = {
      key: true,
      ref: true,
      __self: true,
      __source: true
    }, xn, vn, Wn;
    Wn = {};
    function rn(F) {
      if (de.call(F, "ref")) {
        var re = Object.getOwnPropertyDescriptor(F, "ref").get;
        if (re && re.isReactWarning)
          return false;
      }
      return F.ref !== void 0;
    }
    function zo(F) {
      if (de.call(F, "key")) {
        var re = Object.getOwnPropertyDescriptor(F, "key").get;
        if (re && re.isReactWarning)
          return false;
      }
      return F.key !== void 0;
    }
    function _i(F, re) {
      if (typeof F.ref == "string" && nn.current && re && nn.current.stateNode !== re) {
        var le = j(nn.current.type);
        Wn[le] || (v('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', j(nn.current.type), F.ref), Wn[le] = true);
      }
    }
    function ro(F, re) {
      {
        var le = function() {
          xn || (xn = true, v("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", re));
        };
        le.isReactWarning = true, Object.defineProperty(F, "key", {
          get: le,
          configurable: true
        });
      }
    }
    function Wr(F, re) {
      {
        var le = function() {
          vn || (vn = true, v("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", re));
        };
        le.isReactWarning = true, Object.defineProperty(F, "ref", {
          get: le,
          configurable: true
        });
      }
    }
    var Rn = function(F, re, le, Ce, Ye, ct, Ve) {
      var Be = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: e,
        // Built-in properties that belong on the element
        type: F,
        key: re,
        ref: le,
        props: Ve,
        // Record the component responsible for creating this element.
        _owner: ct
      };
      return Be._store = {}, Object.defineProperty(Be._store, "validated", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: false
      }), Object.defineProperty(Be, "_self", {
        configurable: false,
        enumerable: false,
        writable: false,
        value: Ce
      }), Object.defineProperty(Be, "_source", {
        configurable: false,
        enumerable: false,
        writable: false,
        value: Ye
      }), Object.freeze && (Object.freeze(Be.props), Object.freeze(Be)), Be;
    };
    function lr(F, re, le, Ce, Ye) {
      {
        var ct, Ve = {}, Be = null, Ht = null;
        le !== void 0 && (wt(le), Be = "" + le), zo(re) && (wt(re.key), Be = "" + re.key), rn(re) && (Ht = re.ref, _i(re, Ye));
        for (ct in re)
          de.call(re, ct) && !gn.hasOwnProperty(ct) && (Ve[ct] = re[ct]);
        if (F && F.defaultProps) {
          var Ct = F.defaultProps;
          for (ct in Ct)
            Ve[ct] === void 0 && (Ve[ct] = Ct[ct]);
        }
        if (Be || Ht) {
          var kt = typeof F == "function" ? F.displayName || F.name || "Unknown" : F;
          Be && ro(Ve, kt), Ht && Wr(Ve, kt);
        }
        return Rn(F, Be, Ht, Ye, Ce, nn.current, Ve);
      }
    }
    var Vn = x.ReactCurrentOwner, on = x.ReactDebugCurrentFrame;
    function cr(F) {
      if (F) {
        var re = F._owner, le = ee(F.type, F._source, re ? re.type : null);
        on.setExtraStackFrame(le);
      } else
        on.setExtraStackFrame(null);
    }
    var Vr;
    Vr = false;
    function zn(F) {
      return typeof F == "object" && F !== null && F.$$typeof === e;
    }
    function Dt() {
      {
        if (Vn.current) {
          var F = j(Vn.current.type);
          if (F)
            return `

Check the render method of \`` + F + "`.";
        }
        return "";
      }
    }
    function Qt(F) {
      return "";
    }
    var At = {};
    function ri(F) {
      {
        var re = Dt();
        if (!re) {
          var le = typeof F == "string" ? F : F.displayName || F.name;
          le && (re = `

Check the top-level render call using <` + le + ">.");
        }
        return re;
      }
    }
    function ur(F, re) {
      {
        if (!F._store || F._store.validated || F.key != null)
          return;
        F._store.validated = true;
        var le = ri(re);
        if (At[le])
          return;
        At[le] = true;
        var Ce = "";
        F && F._owner && F._owner !== Vn.current && (Ce = " It was passed a child from " + j(F._owner.type) + "."), cr(F), v('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', le, Ce), cr(null);
      }
    }
    function fr(F, re) {
      {
        if (typeof F != "object")
          return;
        if (Ge(F))
          for (var le = 0; le < F.length; le++) {
            var Ce = F[le];
            zn(Ce) && ur(Ce, re);
          }
        else if (zn(F))
          F._store && (F._store.validated = true);
        else if (F) {
          var Ye = m(F);
          if (typeof Ye == "function" && Ye !== F.entries)
            for (var ct = Ye.call(F), Ve; !(Ve = ct.next()).done; )
              zn(Ve.value) && ur(Ve.value, re);
        }
      }
    }
    function Mi(F) {
      {
        var re = F.type;
        if (re == null || typeof re == "string")
          return;
        var le;
        if (typeof re == "function")
          le = re.propTypes;
        else if (typeof re == "object" && (re.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        re.$$typeof === f))
          le = re.propTypes;
        else
          return;
        if (le) {
          var Ce = j(re);
          Ee(le, F.props, "prop", Ce, F);
        } else if (re.PropTypes !== void 0 && !Vr) {
          Vr = true;
          var Ye = j(re);
          v("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", Ye || "Unknown");
        }
        typeof re.getDefaultProps == "function" && !re.getDefaultProps.isReactClassApproved && v("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function ii(F) {
      {
        for (var re = Object.keys(F.props), le = 0; le < re.length; le++) {
          var Ce = re[le];
          if (Ce !== "children" && Ce !== "key") {
            cr(F), v("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", Ce), cr(null);
            break;
          }
        }
        F.ref !== null && (cr(F), v("Invalid attribute `ref` supplied to `React.Fragment`."), cr(null));
      }
    }
    function Mt(F, re, le, Ce, Ye, ct) {
      {
        var Ve = A(F);
        if (!Ve) {
          var Be = "";
          (F === void 0 || typeof F == "object" && F !== null && Object.keys(F).length === 0) && (Be += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Ht = Qt();
          Ht ? Be += Ht : Be += Dt();
          var Ct;
          F === null ? Ct = "null" : Ge(F) ? Ct = "array" : F !== void 0 && F.$$typeof === e ? (Ct = "<" + (j(F.type) || "Unknown") + " />", Be = " Did you accidentally export a JSX literal instead of a component?") : Ct = typeof F, v("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Ct, Be);
        }
        var kt = lr(F, re, le, Ye, ct);
        if (kt == null)
          return kt;
        if (Ve) {
          var Pt = re.children;
          if (Pt !== void 0)
            if (Ce)
              if (Ge(Pt)) {
                for (var oi = 0; oi < Pt.length; oi++)
                  fr(Pt[oi], F);
                Object.freeze && Object.freeze(Pt);
              } else
                v("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              fr(Pt, F);
        }
        return F === r ? ii(kt) : Mi(kt), kt;
      }
    }
    function Vt(F, re, le) {
      return Mt(F, re, le, true);
    }
    function io(F, re, le) {
      return Mt(F, re, le, false);
    }
    var Ni = io, oo = Vt;
    cl.Fragment = r, cl.jsx = Ni, cl.jsxs = oo;
  }()), cl;
}
false ? tg.exports = V4() : tg.exports = z4();
var g = tg.exports;
var ng = { exports: {} };
var Ot = {};
var Lv;
function X4() {
  return Lv || (Lv = 1, function() {
    var t4 = Symbol.for("react.element"), e = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), r = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), o = Symbol.for("react.provider"), s = Symbol.for("react.context"), a = Symbol.for("react.server_context"), l = Symbol.for("react.forward_ref"), c = Symbol.for("react.suspense"), u = Symbol.for("react.suspense_list"), f = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), h = Symbol.for("react.offscreen"), p = false, O = false, m = false, x = false, v = false, y;
    y = Symbol.for("react.module.reference");
    function S(X) {
      return !!(typeof X == "string" || typeof X == "function" || X === n || X === i || v || X === r || X === c || X === u || x || X === h || p || O || m || typeof X == "object" && X !== null && (X.$$typeof === d || X.$$typeof === f || X.$$typeof === o || X.$$typeof === s || X.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      X.$$typeof === y || X.getModuleId !== void 0));
    }
    function b(X) {
      if (typeof X == "object" && X !== null) {
        var ee = X.$$typeof;
        switch (ee) {
          case t4:
            var de = X.type;
            switch (de) {
              case n:
              case i:
              case r:
              case c:
              case u:
                return de;
              default:
                var ve = de && de.$$typeof;
                switch (ve) {
                  case a:
                  case s:
                  case l:
                  case d:
                  case f:
                  case o:
                    return ve;
                  default:
                    return ee;
                }
            }
          case e:
            return ee;
        }
      }
    }
    var w = s, C = o, k = t4, T = l, A = n, E = d, $ = f, j = e, B = i, D = r, N = c, z = u, Z = false, J = false;
    function L(X) {
      return Z || (Z = true, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.")), false;
    }
    function W(X) {
      return J || (J = true, console.warn("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.")), false;
    }
    function R(X) {
      return b(X) === s;
    }
    function Q(X) {
      return b(X) === o;
    }
    function _(X) {
      return typeof X == "object" && X !== null && X.$$typeof === t4;
    }
    function G(X) {
      return b(X) === l;
    }
    function M(X) {
      return b(X) === n;
    }
    function K(X) {
      return b(X) === d;
    }
    function V(X) {
      return b(X) === f;
    }
    function ae(X) {
      return b(X) === e;
    }
    function te(X) {
      return b(X) === i;
    }
    function oe(X) {
      return b(X) === r;
    }
    function Y(X) {
      return b(X) === c;
    }
    function he(X) {
      return b(X) === u;
    }
    Ot.ContextConsumer = w, Ot.ContextProvider = C, Ot.Element = k, Ot.ForwardRef = T, Ot.Fragment = A, Ot.Lazy = E, Ot.Memo = $, Ot.Portal = j, Ot.Profiler = B, Ot.StrictMode = D, Ot.Suspense = N, Ot.SuspenseList = z, Ot.isAsyncMode = L, Ot.isConcurrentMode = W, Ot.isContextConsumer = R, Ot.isContextProvider = Q, Ot.isElement = _, Ot.isForwardRef = G, Ot.isFragment = M, Ot.isLazy = K, Ot.isMemo = V, Ot.isPortal = ae, Ot.isProfiler = te, Ot.isStrictMode = oe, Ot.isSuspense = Y, Ot.isSuspenseList = he, Ot.isValidElementType = S, Ot.typeOf = b;
  }()), Ot;
}
false ? ng.exports = L4() : ng.exports = X4();
var ss = ng.exports;
function G4(t4) {
  function e(R, Q, _, G, M) {
    for (var K = 0, V = 0, ae = 0, te = 0, oe, Y, he = 0, X = 0, ee, de = ee = oe = 0, ve = 0, Re = 0, ye = 0, Ee = 0, $e = _.length, Ge = $e - 1, Je, be = "", lt = "", wt = "", nn = "", gn; ve < $e; ) {
      if (Y = _.charCodeAt(ve), ve === Ge && V + te + ae + K !== 0 && (V !== 0 && (Y = V === 47 ? 10 : 47), te = ae = K = 0, $e++, Ge++), V + te + ae + K === 0) {
        if (ve === Ge && (0 < Re && (be = be.replace(d, "")), 0 < be.trim().length)) {
          switch (Y) {
            case 32:
            case 9:
            case 59:
            case 13:
            case 10:
              break;
            default:
              be += _.charAt(ve);
          }
          Y = 59;
        }
        switch (Y) {
          case 123:
            for (be = be.trim(), oe = be.charCodeAt(0), ee = 1, Ee = ++ve; ve < $e; ) {
              switch (Y = _.charCodeAt(ve)) {
                case 123:
                  ee++;
                  break;
                case 125:
                  ee--;
                  break;
                case 47:
                  switch (Y = _.charCodeAt(ve + 1)) {
                    case 42:
                    case 47:
                      e: {
                        for (de = ve + 1; de < Ge; ++de)
                          switch (_.charCodeAt(de)) {
                            case 47:
                              if (Y === 42 && _.charCodeAt(de - 1) === 42 && ve + 2 !== de) {
                                ve = de + 1;
                                break e;
                              }
                              break;
                            case 10:
                              if (Y === 47) {
                                ve = de + 1;
                                break e;
                              }
                          }
                        ve = de;
                      }
                  }
                  break;
                case 91:
                  Y++;
                case 40:
                  Y++;
                case 34:
                case 39:
                  for (; ve++ < Ge && _.charCodeAt(ve) !== Y; )
                    ;
              }
              if (ee === 0)
                break;
              ve++;
            }
            switch (ee = _.substring(Ee, ve), oe === 0 && (oe = (be = be.replace(f, "").trim()).charCodeAt(0)), oe) {
              case 64:
                switch (0 < Re && (be = be.replace(d, "")), Y = be.charCodeAt(1), Y) {
                  case 100:
                  case 109:
                  case 115:
                  case 45:
                    Re = Q;
                    break;
                  default:
                    Re = N;
                }
                if (ee = e(Q, Re, ee, Y, M + 1), Ee = ee.length, 0 < Z && (Re = n(N, be, ye), gn = a(3, ee, Re, Q, j, $, Ee, Y, M, G), be = Re.join(""), gn !== void 0 && (Ee = (ee = gn.trim()).length) === 0 && (Y = 0, ee = "")), 0 < Ee)
                  switch (Y) {
                    case 115:
                      be = be.replace(w, s);
                    case 100:
                    case 109:
                    case 45:
                      ee = be + "{" + ee + "}";
                      break;
                    case 107:
                      be = be.replace(v, "$1 $2"), ee = be + "{" + ee + "}", ee = D === 1 || D === 2 && o("@" + ee, 3) ? "@-webkit-" + ee + "@" + ee : "@" + ee;
                      break;
                    default:
                      ee = be + ee, G === 112 && (ee = (lt += ee, ""));
                  }
                else
                  ee = "";
                break;
              default:
                ee = e(Q, n(Q, be, ye), ee, G, M + 1);
            }
            wt += ee, ee = ye = Re = de = oe = 0, be = "", Y = _.charCodeAt(++ve);
            break;
          case 125:
          case 59:
            if (be = (0 < Re ? be.replace(d, "") : be).trim(), 1 < (Ee = be.length))
              switch (de === 0 && (oe = be.charCodeAt(0), oe === 45 || 96 < oe && 123 > oe) && (Ee = (be = be.replace(" ", ":")).length), 0 < Z && (gn = a(1, be, Q, R, j, $, lt.length, G, M, G)) !== void 0 && (Ee = (be = gn.trim()).length) === 0 && (be = "\0\0"), oe = be.charCodeAt(0), Y = be.charCodeAt(1), oe) {
                case 0:
                  break;
                case 64:
                  if (Y === 105 || Y === 99) {
                    nn += be + _.charAt(ve);
                    break;
                  }
                default:
                  be.charCodeAt(Ee - 1) !== 58 && (lt += i(be, oe, Y, be.charCodeAt(2)));
              }
            ye = Re = de = oe = 0, be = "", Y = _.charCodeAt(++ve);
        }
      }
      switch (Y) {
        case 13:
        case 10:
          V === 47 ? V = 0 : 1 + oe === 0 && G !== 107 && 0 < be.length && (Re = 1, be += "\0"), 0 < Z * L && a(0, be, Q, R, j, $, lt.length, G, M, G), $ = 1, j++;
          break;
        case 59:
        case 125:
          if (V + te + ae + K === 0) {
            $++;
            break;
          }
        default:
          switch ($++, Je = _.charAt(ve), Y) {
            case 9:
            case 32:
              if (te + K + V === 0)
                switch (he) {
                  case 44:
                  case 58:
                  case 9:
                  case 32:
                    Je = "";
                    break;
                  default:
                    Y !== 32 && (Je = " ");
                }
              break;
            case 0:
              Je = "\\0";
              break;
            case 12:
              Je = "\\f";
              break;
            case 11:
              Je = "\\v";
              break;
            case 38:
              te + V + K === 0 && (Re = ye = 1, Je = "\f" + Je);
              break;
            case 108:
              if (te + V + K + B === 0 && 0 < de)
                switch (ve - de) {
                  case 2:
                    he === 112 && _.charCodeAt(ve - 3) === 58 && (B = he);
                  case 8:
                    X === 111 && (B = X);
                }
              break;
            case 58:
              te + V + K === 0 && (de = ve);
              break;
            case 44:
              V + ae + te + K === 0 && (Re = 1, Je += "\r");
              break;
            case 34:
            case 39:
              V === 0 && (te = te === Y ? 0 : te === 0 ? Y : te);
              break;
            case 91:
              te + V + ae === 0 && K++;
              break;
            case 93:
              te + V + ae === 0 && K--;
              break;
            case 41:
              te + V + K === 0 && ae--;
              break;
            case 40:
              if (te + V + K === 0) {
                if (oe === 0)
                  switch (2 * he + 3 * X) {
                    case 533:
                      break;
                    default:
                      oe = 1;
                  }
                ae++;
              }
              break;
            case 64:
              V + ae + te + K + de + ee === 0 && (ee = 1);
              break;
            case 42:
            case 47:
              if (!(0 < te + K + ae))
                switch (V) {
                  case 0:
                    switch (2 * Y + 3 * _.charCodeAt(ve + 1)) {
                      case 235:
                        V = 47;
                        break;
                      case 220:
                        Ee = ve, V = 42;
                    }
                    break;
                  case 42:
                    Y === 47 && he === 42 && Ee + 2 !== ve && (_.charCodeAt(Ee + 2) === 33 && (lt += _.substring(Ee, ve + 1)), Je = "", V = 0);
                }
          }
          V === 0 && (be += Je);
      }
      X = he, he = Y, ve++;
    }
    if (Ee = lt.length, 0 < Ee) {
      if (Re = Q, 0 < Z && (gn = a(2, lt, Re, R, j, $, Ee, G, M, G), gn !== void 0 && (lt = gn).length === 0))
        return nn + lt + wt;
      if (lt = Re.join(",") + "{" + lt + "}", D * B !== 0) {
        switch (D !== 2 || o(lt, 2) || (B = 0), B) {
          case 111:
            lt = lt.replace(S, ":-moz-$1") + lt;
            break;
          case 112:
            lt = lt.replace(y, "::-webkit-input-$1") + lt.replace(y, "::-moz-$1") + lt.replace(y, ":-ms-input-$1") + lt;
        }
        B = 0;
      }
    }
    return nn + lt + wt;
  }
  function n(R, Q, _) {
    var G = Q.trim().split(m);
    Q = G;
    var M = G.length, K = R.length;
    switch (K) {
      case 0:
      case 1:
        var V = 0;
        for (R = K === 0 ? "" : R[0] + " "; V < M; ++V)
          Q[V] = r(R, Q[V], _).trim();
        break;
      default:
        var ae = V = 0;
        for (Q = []; V < M; ++V)
          for (var te = 0; te < K; ++te)
            Q[ae++] = r(R[te] + " ", G[V], _).trim();
    }
    return Q;
  }
  function r(R, Q, _) {
    var G = Q.charCodeAt(0);
    switch (33 > G && (G = (Q = Q.trim()).charCodeAt(0)), G) {
      case 38:
        return Q.replace(x, "$1" + R.trim());
      case 58:
        return R.trim() + Q.replace(x, "$1" + R.trim());
      default:
        if (0 < 1 * _ && 0 < Q.indexOf("\f"))
          return Q.replace(x, (R.charCodeAt(0) === 58 ? "" : "$1") + R.trim());
    }
    return R + Q;
  }
  function i(R, Q, _, G) {
    var M = R + ";", K = 2 * Q + 3 * _ + 4 * G;
    if (K === 944) {
      R = M.indexOf(":", 9) + 1;
      var V = M.substring(R, M.length - 1).trim();
      return V = M.substring(0, R).trim() + V + ";", D === 1 || D === 2 && o(V, 1) ? "-webkit-" + V + V : V;
    }
    if (D === 0 || D === 2 && !o(M, 1))
      return M;
    switch (K) {
      case 1015:
        return M.charCodeAt(10) === 97 ? "-webkit-" + M + M : M;
      case 951:
        return M.charCodeAt(3) === 116 ? "-webkit-" + M + M : M;
      case 963:
        return M.charCodeAt(5) === 110 ? "-webkit-" + M + M : M;
      case 1009:
        if (M.charCodeAt(4) !== 100)
          break;
      case 969:
      case 942:
        return "-webkit-" + M + M;
      case 978:
        return "-webkit-" + M + "-moz-" + M + M;
      case 1019:
      case 983:
        return "-webkit-" + M + "-moz-" + M + "-ms-" + M + M;
      case 883:
        if (M.charCodeAt(8) === 45)
          return "-webkit-" + M + M;
        if (0 < M.indexOf("image-set(", 11))
          return M.replace(E, "$1-webkit-$2") + M;
        break;
      case 932:
        if (M.charCodeAt(4) === 45)
          switch (M.charCodeAt(5)) {
            case 103:
              return "-webkit-box-" + M.replace("-grow", "") + "-webkit-" + M + "-ms-" + M.replace("grow", "positive") + M;
            case 115:
              return "-webkit-" + M + "-ms-" + M.replace("shrink", "negative") + M;
            case 98:
              return "-webkit-" + M + "-ms-" + M.replace("basis", "preferred-size") + M;
          }
        return "-webkit-" + M + "-ms-" + M + M;
      case 964:
        return "-webkit-" + M + "-ms-flex-" + M + M;
      case 1023:
        if (M.charCodeAt(8) !== 99)
          break;
        return V = M.substring(M.indexOf(":", 15)).replace("flex-", "").replace("space-between", "justify"), "-webkit-box-pack" + V + "-webkit-" + M + "-ms-flex-pack" + V + M;
      case 1005:
        return p.test(M) ? M.replace(h, ":-webkit-") + M.replace(h, ":-moz-") + M : M;
      case 1e3:
        switch (V = M.substring(13).trim(), Q = V.indexOf("-") + 1, V.charCodeAt(0) + V.charCodeAt(Q)) {
          case 226:
            V = M.replace(b, "tb");
            break;
          case 232:
            V = M.replace(b, "tb-rl");
            break;
          case 220:
            V = M.replace(b, "lr");
            break;
          default:
            return M;
        }
        return "-webkit-" + M + "-ms-" + V + M;
      case 1017:
        if (M.indexOf("sticky", 9) === -1)
          break;
      case 975:
        switch (Q = (M = R).length - 10, V = (M.charCodeAt(Q) === 33 ? M.substring(0, Q) : M).substring(R.indexOf(":", 7) + 1).trim(), K = V.charCodeAt(0) + (V.charCodeAt(7) | 0)) {
          case 203:
            if (111 > V.charCodeAt(8))
              break;
          case 115:
            M = M.replace(V, "-webkit-" + V) + ";" + M;
            break;
          case 207:
          case 102:
            M = M.replace(V, "-webkit-" + (102 < K ? "inline-" : "") + "box") + ";" + M.replace(V, "-webkit-" + V) + ";" + M.replace(V, "-ms-" + V + "box") + ";" + M;
        }
        return M + ";";
      case 938:
        if (M.charCodeAt(5) === 45)
          switch (M.charCodeAt(6)) {
            case 105:
              return V = M.replace("-items", ""), "-webkit-" + M + "-webkit-box-" + V + "-ms-flex-" + V + M;
            case 115:
              return "-webkit-" + M + "-ms-flex-item-" + M.replace(k, "") + M;
            default:
              return "-webkit-" + M + "-ms-flex-line-pack" + M.replace("align-content", "").replace(k, "") + M;
          }
        break;
      case 973:
      case 989:
        if (M.charCodeAt(3) !== 45 || M.charCodeAt(4) === 122)
          break;
      case 931:
      case 953:
        if (A.test(R) === true)
          return (V = R.substring(R.indexOf(":") + 1)).charCodeAt(0) === 115 ? i(R.replace("stretch", "fill-available"), Q, _, G).replace(":fill-available", ":stretch") : M.replace(V, "-webkit-" + V) + M.replace(V, "-moz-" + V.replace("fill-", "")) + M;
        break;
      case 962:
        if (M = "-webkit-" + M + (M.charCodeAt(5) === 102 ? "-ms-" + M : "") + M, _ + G === 211 && M.charCodeAt(13) === 105 && 0 < M.indexOf("transform", 10))
          return M.substring(0, M.indexOf(";", 27) + 1).replace(O, "$1-webkit-$2") + M;
    }
    return M;
  }
  function o(R, Q) {
    var _ = R.indexOf(Q === 1 ? ":" : "{"), G = R.substring(0, Q !== 3 ? _ : 10);
    return _ = R.substring(_ + 1, R.length - 1), J(Q !== 2 ? G : G.replace(T, "$1"), _, Q);
  }
  function s(R, Q) {
    var _ = i(Q, Q.charCodeAt(0), Q.charCodeAt(1), Q.charCodeAt(2));
    return _ !== Q + ";" ? _.replace(C, " or ($1)").substring(4) : "(" + Q + ")";
  }
  function a(R, Q, _, G, M, K, V, ae, te, oe) {
    for (var Y = 0, he = Q, X; Y < Z; ++Y)
      switch (X = z[Y].call(u, R, he, _, G, M, K, V, ae, te, oe)) {
        case void 0:
        case false:
        case true:
        case null:
          break;
        default:
          he = X;
      }
    if (he !== Q)
      return he;
  }
  function l(R) {
    switch (R) {
      case void 0:
      case null:
        Z = z.length = 0;
        break;
      default:
        if (typeof R == "function")
          z[Z++] = R;
        else if (typeof R == "object")
          for (var Q = 0, _ = R.length; Q < _; ++Q)
            l(R[Q]);
        else
          L = !!R | 0;
    }
    return l;
  }
  function c(R) {
    return R = R.prefix, R !== void 0 && (J = null, R ? typeof R != "function" ? D = 1 : (D = 2, J = R) : D = 0), c;
  }
  function u(R, Q) {
    var _ = R;
    if (33 > _.charCodeAt(0) && (_ = _.trim()), W = _, _ = [W], 0 < Z) {
      var G = a(-1, Q, _, _, j, $, 0, 0, 0, 0);
      G !== void 0 && typeof G == "string" && (Q = G);
    }
    var M = e(N, _, Q, 0, 0);
    return 0 < Z && (G = a(-2, M, _, _, j, $, M.length, 0, 0, 0), G !== void 0 && (M = G)), W = "", B = 0, $ = j = 1, M;
  }
  var f = /^\0+/g, d = /[\0\r\f]/g, h = /: */g, p = /zoo|gra/, O = /([,: ])(transform)/g, m = /,\r+?/g, x = /([\t\r\n ])*\f?&/g, v = /@(k\w+)\s*(\S*)\s*/, y = /::(place)/g, S = /:(read-only)/g, b = /[svh]\w+-[tblr]{2}/, w = /\(\s*(.*)\s*\)/g, C = /([\s\S]*?);/g, k = /-self|flex-/g, T = /[^]*?(:[rp][el]a[\w-]+)[^]*/, A = /stretch|:\s*\w+\-(?:conte|avail)/, E = /([^-])(image-set\()/, $ = 1, j = 1, B = 0, D = 1, N = [], z = [], Z = 0, J = null, L = 0, W = "";
  return u.use = l, u.set = c, t4 !== void 0 && c(t4), u;
}
var Y4 = {
  animationIterationCount: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};
function sA(t4) {
  var e = /* @__PURE__ */ Object.create(null);
  return function(n) {
    return e[n] === void 0 && (e[n] = t4(n)), e[n];
  };
}
var q4 = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
var Xv = /* @__PURE__ */ sA(
  function(t4) {
    return q4.test(t4) || t4.charCodeAt(0) === 111 && t4.charCodeAt(1) === 110 && t4.charCodeAt(2) < 91;
  }
  /* Z+1 */
);
var rg = { exports: {} };
var vt = {};
var Yv;
function H42() {
  return Yv || (Yv = 1, function() {
    var t4 = typeof Symbol == "function" && Symbol.for, e = t4 ? Symbol.for("react.element") : 60103, n = t4 ? Symbol.for("react.portal") : 60106, r = t4 ? Symbol.for("react.fragment") : 60107, i = t4 ? Symbol.for("react.strict_mode") : 60108, o = t4 ? Symbol.for("react.profiler") : 60114, s = t4 ? Symbol.for("react.provider") : 60109, a = t4 ? Symbol.for("react.context") : 60110, l = t4 ? Symbol.for("react.async_mode") : 60111, c = t4 ? Symbol.for("react.concurrent_mode") : 60111, u = t4 ? Symbol.for("react.forward_ref") : 60112, f = t4 ? Symbol.for("react.suspense") : 60113, d = t4 ? Symbol.for("react.suspense_list") : 60120, h = t4 ? Symbol.for("react.memo") : 60115, p = t4 ? Symbol.for("react.lazy") : 60116, O = t4 ? Symbol.for("react.block") : 60121, m = t4 ? Symbol.for("react.fundamental") : 60117, x = t4 ? Symbol.for("react.responder") : 60118, v = t4 ? Symbol.for("react.scope") : 60119;
    function y(Y) {
      return typeof Y == "string" || typeof Y == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      Y === r || Y === c || Y === o || Y === i || Y === f || Y === d || typeof Y == "object" && Y !== null && (Y.$$typeof === p || Y.$$typeof === h || Y.$$typeof === s || Y.$$typeof === a || Y.$$typeof === u || Y.$$typeof === m || Y.$$typeof === x || Y.$$typeof === v || Y.$$typeof === O);
    }
    function S(Y) {
      if (typeof Y == "object" && Y !== null) {
        var he = Y.$$typeof;
        switch (he) {
          case e:
            var X = Y.type;
            switch (X) {
              case l:
              case c:
              case r:
              case o:
              case i:
              case f:
                return X;
              default:
                var ee = X && X.$$typeof;
                switch (ee) {
                  case a:
                  case u:
                  case p:
                  case h:
                  case s:
                    return ee;
                  default:
                    return he;
                }
            }
          case n:
            return he;
        }
      }
    }
    var b = l, w = c, C = a, k = s, T = e, A = u, E = r, $ = p, j = h, B = n, D = o, N = i, z = f, Z = false;
    function J(Y) {
      return Z || (Z = true, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), L(Y) || S(Y) === l;
    }
    function L(Y) {
      return S(Y) === c;
    }
    function W(Y) {
      return S(Y) === a;
    }
    function R(Y) {
      return S(Y) === s;
    }
    function Q(Y) {
      return typeof Y == "object" && Y !== null && Y.$$typeof === e;
    }
    function _(Y) {
      return S(Y) === u;
    }
    function G(Y) {
      return S(Y) === r;
    }
    function M(Y) {
      return S(Y) === p;
    }
    function K(Y) {
      return S(Y) === h;
    }
    function V(Y) {
      return S(Y) === n;
    }
    function ae(Y) {
      return S(Y) === o;
    }
    function te(Y) {
      return S(Y) === i;
    }
    function oe(Y) {
      return S(Y) === f;
    }
    vt.AsyncMode = b, vt.ConcurrentMode = w, vt.ContextConsumer = C, vt.ContextProvider = k, vt.Element = T, vt.ForwardRef = A, vt.Fragment = E, vt.Lazy = $, vt.Memo = j, vt.Portal = B, vt.Profiler = D, vt.StrictMode = N, vt.Suspense = z, vt.isAsyncMode = J, vt.isConcurrentMode = L, vt.isContextConsumer = W, vt.isContextProvider = R, vt.isElement = Q, vt.isForwardRef = _, vt.isFragment = G, vt.isLazy = M, vt.isMemo = K, vt.isPortal = V, vt.isProfiler = ae, vt.isStrictMode = te, vt.isSuspense = oe, vt.isValidElementType = y, vt.typeOf = S;
  }()), vt;
}
false ? rg.exports = U4() : rg.exports = H42();
var J4 = rg.exports;
var _O = J4;
var K4 = {
  childContextTypes: true,
  contextType: true,
  contextTypes: true,
  defaultProps: true,
  displayName: true,
  getDefaultProps: true,
  getDerivedStateFromError: true,
  getDerivedStateFromProps: true,
  mixins: true,
  propTypes: true,
  type: true
};
var eR = {
  name: true,
  length: true,
  prototype: true,
  caller: true,
  callee: true,
  arguments: true,
  arity: true
};
var tR = {
  $$typeof: true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var aA = {
  $$typeof: true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var MO = {};
MO[_O.ForwardRef] = tR;
MO[_O.Memo] = aA;
function qv(t4) {
  return _O.isMemo(t4) ? aA : MO[t4.$$typeof] || K4;
}
var nR = Object.defineProperty;
var rR = Object.getOwnPropertyNames;
var Uv = Object.getOwnPropertySymbols;
var iR = Object.getOwnPropertyDescriptor;
var oR = Object.getPrototypeOf;
var Hv = Object.prototype;
function lA(t4, e, n) {
  if (typeof e != "string") {
    if (Hv) {
      var r = oR(e);
      r && r !== Hv && lA(t4, r, n);
    }
    var i = rR(e);
    Uv && (i = i.concat(Uv(e)));
    for (var o = qv(t4), s = qv(e), a = 0; a < i.length; ++a) {
      var l = i[a];
      if (!eR[l] && !(n && n[l]) && !(s && s[l]) && !(o && o[l])) {
        var c = iR(e, l);
        try {
          nR(t4, l, c);
        } catch {
        }
      }
    }
  }
  return t4;
}
var sR = lA;
var aR = /* @__PURE__ */ Za(sR);
function zi() {
  return (zi = Object.assign || function(t4) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (t4[r] = n[r]);
    }
    return t4;
  }).apply(this, arguments);
}
var Jv = function(t4, e) {
  for (var n = [t4[0]], r = 0, i = e.length; r < i; r += 1)
    n.push(e[r], t4[r + 1]);
  return n;
};
var ig = function(t4) {
  return t4 !== null && typeof t4 == "object" && (t4.toString ? t4.toString() : Object.prototype.toString.call(t4)) === "[object Object]" && !ss.typeOf(t4);
};
var wf = Object.freeze([]);
var bo = Object.freeze({});
function Yl(t4) {
  return typeof t4 == "function";
}
function og(t4) {
  return typeof t4 == "string" && t4 || t4.displayName || t4.name || "Component";
}
function NO(t4) {
  return t4 && typeof t4.styledComponentId == "string";
}
var ma = typeof process < "u" && process.env !== void 0 && (process.env.REACT_APP_SC_ATTR || process.env.SC_ATTR) || "data-styled";
var FO = typeof window < "u" && "HTMLElement" in window;
var lR = !!(typeof SC_DISABLE_SPEEDY == "boolean" ? SC_DISABLE_SPEEDY : typeof process < "u" && process.env !== void 0 && (process.env.REACT_APP_SC_DISABLE_SPEEDY !== void 0 && process.env.REACT_APP_SC_DISABLE_SPEEDY !== "" ? process.env.REACT_APP_SC_DISABLE_SPEEDY !== "false" && process.env.REACT_APP_SC_DISABLE_SPEEDY : process.env.SC_DISABLE_SPEEDY !== void 0 && process.env.SC_DISABLE_SPEEDY !== "" ? process.env.SC_DISABLE_SPEEDY !== "false" && process.env.SC_DISABLE_SPEEDY : true));
var cR = true ? { 1: `Cannot create styled-component for component: %s.

`, 2: `Can't collect styles once you've consumed a \`ServerStyleSheet\`'s styles! \`ServerStyleSheet\` is a one off instance for each server-side render cycle.

- Are you trying to reuse it across renders?
- Are you accidentally calling collectStyles twice?

`, 3: `Streaming SSR is only supported in a Node.js environment; Please do not try to call this method in the browser.

`, 4: `The \`StyleSheetManager\` expects a valid target or sheet prop!

- Does this error occur on the client and is your target falsy?
- Does this error occur on the server and is the sheet falsy?

`, 5: `The clone method cannot be used on the client!

- Are you running in a client-like environment on the server?
- Are you trying to run SSR on the client?

`, 6: `Trying to insert a new style tag, but the given Node is unmounted!

- Are you using a custom target that isn't mounted?
- Does your document not have a valid head element?
- Have you accidentally removed a style tag manually?

`, 7: 'ThemeProvider: Please return an object from your "theme" prop function, e.g.\n\n```js\ntheme={() => ({})}\n```\n\n', 8: `ThemeProvider: Please make your "theme" prop an object.

`, 9: "Missing document `<head>`\n\n", 10: `Cannot find a StyleSheet instance. Usually this happens if there are multiple copies of styled-components loaded at once. Check out this issue for how to troubleshoot and fix the common cases where this situation can happen: https://github.com/styled-components/styled-components/issues/1941#issuecomment-417862021

`, 11: `_This error was replaced with a dev-time warning, it will be deleted for v4 final._ [createGlobalStyle] received children which will not be rendered. Please use the component without passing children elements.

`, 12: "It seems you are interpolating a keyframe declaration (%s) into an untagged string. This was supported in styled-components v3, but is not longer supported in v4 as keyframes are now injected on-demand. Please wrap your string in the css\\`\\` helper which ensures the styles are injected correctly. See https://www.styled-components.com/docs/api#css\n\n", 13: `%s is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details.

`, 14: `ThemeProvider: "theme" prop is required.

`, 15: "A stylis plugin has been supplied that is not named. We need a name for each plugin to be able to prevent styling collisions between different stylis configurations within the same app. Before you pass your plugin to `<StyleSheetManager stylisPlugins={[]}>`, please make sure each plugin is uniquely-named, e.g.\n\n```js\nObject.defineProperty(importedPlugin, 'name', { value: 'some-unique-name' });\n```\n\n", 16: `Reached the limit of how many styled components may be created at group %s.
You may only create up to 1,073,741,824 components. If you're creating components dynamically,
as for instance in your render method then you may be running into this limitation.

`, 17: `CSSStyleSheet could not be found on HTMLStyleElement.
Has styled-components' style tag been unmounted or altered by another script?
` } : {};
function uR() {
  for (var t4 = arguments.length <= 0 ? void 0 : arguments[0], e = [], n = 1, r = arguments.length; n < r; n += 1)
    e.push(n < 0 || arguments.length <= n ? void 0 : arguments[n]);
  return e.forEach(function(i) {
    t4 = t4.replace(/%[a-z]/, i);
  }), t4;
}
function Wa(t4) {
  for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++)
    n[r - 1] = arguments[r];
  throw false ? new Error("An error occurred. See https://git.io/JUIaE#" + t4 + " for more information." + (n.length > 0 ? " Args: " + n.join(", ") : "")) : new Error(uR.apply(void 0, [cR[t4]].concat(n)).trim());
}
var fR = function() {
  function t4(n) {
    this.groupSizes = new Uint32Array(512), this.length = 512, this.tag = n;
  }
  var e = t4.prototype;
  return e.indexOfGroup = function(n) {
    for (var r = 0, i = 0; i < n; i++)
      r += this.groupSizes[i];
    return r;
  }, e.insertRules = function(n, r) {
    if (n >= this.groupSizes.length) {
      for (var i = this.groupSizes, o = i.length, s = o; n >= s; )
        (s <<= 1) < 0 && Wa(16, "" + n);
      this.groupSizes = new Uint32Array(s), this.groupSizes.set(i), this.length = s;
      for (var a = o; a < s; a++)
        this.groupSizes[a] = 0;
    }
    for (var l = this.indexOfGroup(n + 1), c = 0, u = r.length; c < u; c++)
      this.tag.insertRule(l, r[c]) && (this.groupSizes[n]++, l++);
  }, e.clearGroup = function(n) {
    if (n < this.length) {
      var r = this.groupSizes[n], i = this.indexOfGroup(n), o = i + r;
      this.groupSizes[n] = 0;
      for (var s = i; s < o; s++)
        this.tag.deleteRule(i);
    }
  }, e.getGroup = function(n) {
    var r = "";
    if (n >= this.length || this.groupSizes[n] === 0)
      return r;
    for (var i = this.groupSizes[n], o = this.indexOfGroup(n), s = o + i, a = o; a < s; a++)
      r += this.tag.getRule(a) + `/*!sc*/
`;
    return r;
  }, t4;
}();
var Uu = /* @__PURE__ */ new Map();
var Cf = /* @__PURE__ */ new Map();
var Ml = 1;
var su = function(t4) {
  if (Uu.has(t4))
    return Uu.get(t4);
  for (; Cf.has(Ml); )
    Ml++;
  var e = Ml++;
  return ((0 | e) < 0 || e > 1 << 30) && Wa(16, "" + e), Uu.set(t4, e), Cf.set(e, t4), e;
};
var dR = function(t4) {
  return Cf.get(t4);
};
var hR = function(t4, e) {
  e >= Ml && (Ml = e + 1), Uu.set(t4, e), Cf.set(e, t4);
};
var pR = "style[" + ma + '][data-styled-version="5.3.11"]';
var gR = new RegExp("^" + ma + '\\.g(\\d+)\\[id="([\\w\\d-]+)"\\].*?"([^"]*)');
var mR = function(t4, e, n) {
  for (var r, i = n.split(","), o = 0, s = i.length; o < s; o++)
    (r = i[o]) && t4.registerName(e, r);
};
var OR = function(t4, e) {
  for (var n = (e.textContent || "").split(`/*!sc*/
`), r = [], i = 0, o = n.length; i < o; i++) {
    var s = n[i].trim();
    if (s) {
      var a = s.match(gR);
      if (a) {
        var l = 0 | parseInt(a[1], 10), c = a[2];
        l !== 0 && (hR(c, l), mR(t4, c, a[3]), t4.getTag().insertRules(l, r)), r.length = 0;
      } else
        r.push(s);
    }
  }
};
var xR = function() {
  return typeof __webpack_nonce__ < "u" ? __webpack_nonce__ : null;
};
var cA = function(t4) {
  var e = document.head, n = t4 || e, r = document.createElement("style"), i = function(a) {
    for (var l = a.childNodes, c = l.length; c >= 0; c--) {
      var u = l[c];
      if (u && u.nodeType === 1 && u.hasAttribute(ma))
        return u;
    }
  }(n), o = i !== void 0 ? i.nextSibling : null;
  r.setAttribute(ma, "active"), r.setAttribute("data-styled-version", "5.3.11");
  var s = xR();
  return s && r.setAttribute("nonce", s), n.insertBefore(r, o), r;
};
var vR = function() {
  function t4(n) {
    var r = this.element = cA(n);
    r.appendChild(document.createTextNode("")), this.sheet = function(i) {
      if (i.sheet)
        return i.sheet;
      for (var o = document.styleSheets, s = 0, a = o.length; s < a; s++) {
        var l = o[s];
        if (l.ownerNode === i)
          return l;
      }
      Wa(17);
    }(r), this.length = 0;
  }
  var e = t4.prototype;
  return e.insertRule = function(n, r) {
    try {
      return this.sheet.insertRule(r, n), this.length++, true;
    } catch {
      return false;
    }
  }, e.deleteRule = function(n) {
    this.sheet.deleteRule(n), this.length--;
  }, e.getRule = function(n) {
    var r = this.sheet.cssRules[n];
    return r !== void 0 && typeof r.cssText == "string" ? r.cssText : "";
  }, t4;
}();
var yR = function() {
  function t4(n) {
    var r = this.element = cA(n);
    this.nodes = r.childNodes, this.length = 0;
  }
  var e = t4.prototype;
  return e.insertRule = function(n, r) {
    if (n <= this.length && n >= 0) {
      var i = document.createTextNode(r), o = this.nodes[n];
      return this.element.insertBefore(i, o || null), this.length++, true;
    }
    return false;
  }, e.deleteRule = function(n) {
    this.element.removeChild(this.nodes[n]), this.length--;
  }, e.getRule = function(n) {
    return n < this.length ? this.nodes[n].textContent : "";
  }, t4;
}();
var bR = function() {
  function t4(n) {
    this.rules = [], this.length = 0;
  }
  var e = t4.prototype;
  return e.insertRule = function(n, r) {
    return n <= this.length && (this.rules.splice(n, 0, r), this.length++, true);
  }, e.deleteRule = function(n) {
    this.rules.splice(n, 1), this.length--;
  }, e.getRule = function(n) {
    return n < this.length ? this.rules[n] : "";
  }, t4;
}();
var Kv = FO;
var SR = { isServer: !FO, useCSSOMInjection: !lR };
var uA = function() {
  function t4(n, r, i) {
    n === void 0 && (n = bo), r === void 0 && (r = {}), this.options = zi({}, SR, {}, n), this.gs = r, this.names = new Map(i), this.server = !!n.isServer, !this.server && FO && Kv && (Kv = false, function(o) {
      for (var s = document.querySelectorAll(pR), a = 0, l = s.length; a < l; a++) {
        var c = s[a];
        c && c.getAttribute(ma) !== "active" && (OR(o, c), c.parentNode && c.parentNode.removeChild(c));
      }
    }(this));
  }
  t4.registerId = function(n) {
    return su(n);
  };
  var e = t4.prototype;
  return e.reconstructWithOptions = function(n, r) {
    return r === void 0 && (r = true), new t4(zi({}, this.options, {}, n), this.gs, r && this.names || void 0);
  }, e.allocateGSInstance = function(n) {
    return this.gs[n] = (this.gs[n] || 0) + 1;
  }, e.getTag = function() {
    return this.tag || (this.tag = (i = (r = this.options).isServer, o = r.useCSSOMInjection, s = r.target, n = i ? new bR(s) : o ? new vR(s) : new yR(s), new fR(n)));
    var n, r, i, o, s;
  }, e.hasNameForId = function(n, r) {
    return this.names.has(n) && this.names.get(n).has(r);
  }, e.registerName = function(n, r) {
    if (su(n), this.names.has(n))
      this.names.get(n).add(r);
    else {
      var i = /* @__PURE__ */ new Set();
      i.add(r), this.names.set(n, i);
    }
  }, e.insertRules = function(n, r, i) {
    this.registerName(n, r), this.getTag().insertRules(su(n), i);
  }, e.clearNames = function(n) {
    this.names.has(n) && this.names.get(n).clear();
  }, e.clearRules = function(n) {
    this.getTag().clearGroup(su(n)), this.clearNames(n);
  }, e.clearTag = function() {
    this.tag = void 0;
  }, e.toString = function() {
    return function(n) {
      for (var r = n.getTag(), i = r.length, o = "", s = 0; s < i; s++) {
        var a = dR(s);
        if (a !== void 0) {
          var l = n.names.get(a), c = r.getGroup(s);
          if (l && c && l.size) {
            var u = ma + ".g" + s + '[id="' + a + '"]', f = "";
            l !== void 0 && l.forEach(function(d) {
              d.length > 0 && (f += d + ",");
            }), o += "" + c + u + '{content:"' + f + `"}/*!sc*/
`;
          }
        }
      }
      return o;
    }(this);
  }, t4;
}();
var wR = /(a)(d)/gi;
var ey = function(t4) {
  return String.fromCharCode(t4 + (t4 > 25 ? 39 : 97));
};
function sg(t4) {
  var e, n = "";
  for (e = Math.abs(t4); e > 52; e = e / 52 | 0)
    n = ey(e % 52) + n;
  return (ey(e % 52) + n).replace(wR, "$1-$2");
}
var es = function(t4, e) {
  for (var n = e.length; n; )
    t4 = 33 * t4 ^ e.charCodeAt(--n);
  return t4;
};
var fA = function(t4) {
  return es(5381, t4);
};
var kR = fA("5.3.11");
var AR = function() {
  function t4(e, n, r) {
    this.rules = e, this.staticRulesId = "", this.isStatic = false, this.componentId = n, this.baseHash = es(kR, n), this.baseStyle = r, uA.registerId(n);
  }
  return t4.prototype.generateAndInjectStyles = function(e, n, r) {
    var i = this.componentId, o = [];
    if (this.baseStyle && o.push(this.baseStyle.generateAndInjectStyles(e, n, r)), this.isStatic && !r.hash)
      if (this.staticRulesId && n.hasNameForId(i, this.staticRulesId))
        o.push(this.staticRulesId);
      else {
        var s = Oa(this.rules, e, n, r).join(""), a = sg(es(this.baseHash, s) >>> 0);
        if (!n.hasNameForId(i, a)) {
          var l = r(s, "." + a, void 0, i);
          n.insertRules(i, a, l);
        }
        o.push(a), this.staticRulesId = a;
      }
    else {
      for (var c = this.rules.length, u = es(this.baseHash, r.hash), f = "", d = 0; d < c; d++) {
        var h = this.rules[d];
        if (typeof h == "string")
          f += h, u = es(u, h + d);
        else if (h) {
          var p = Oa(h, e, n, r), O = Array.isArray(p) ? p.join("") : p;
          u = es(u, O + d), f += O;
        }
      }
      if (f) {
        var m = sg(u >>> 0);
        if (!n.hasNameForId(i, m)) {
          var x = r(f, "." + m, void 0, i);
          n.insertRules(i, m, x);
        }
        o.push(m);
      }
    }
    return o.join(" ");
  }, t4;
}();
var PR = /^\s*\/\/.*$/gm;
var ER = [":", "[", ".", "#"];
function TR(t4) {
  var e, n, r, i, o = bo, s = o.options, a = s === void 0 ? bo : s, l = o.plugins, c = l === void 0 ? wf : l, u = new G4(a), f = [], d = /* @__PURE__ */ function(O) {
    function m(x) {
      if (x)
        try {
          O(x + "}");
        } catch {
        }
    }
    return function(x, v, y, S, b, w, C, k, T, A) {
      switch (x) {
        case 1:
          if (T === 0 && v.charCodeAt(0) === 64)
            return O(v + ";"), "";
          break;
        case 2:
          if (k === 0)
            return v + "/*|*/";
          break;
        case 3:
          switch (k) {
            case 102:
            case 112:
              return O(y[0] + v), "";
            default:
              return v + (A === 0 ? "/*|*/" : "");
          }
        case -2:
          v.split("/*|*/}").forEach(m);
      }
    };
  }(function(O) {
    f.push(O);
  }), h = function(O, m, x) {
    return m === 0 && ER.indexOf(x[n.length]) !== -1 || x.match(i) ? O : "." + e;
  };
  function p(O, m, x, v) {
    v === void 0 && (v = "&");
    var y = O.replace(PR, ""), S = m && x ? x + " " + m + " { " + y + " }" : y;
    return e = v, n = m, r = new RegExp("\\" + n + "\\b", "g"), i = new RegExp("(\\" + n + "\\b){2,}"), u(x || !m ? "" : m, S);
  }
  return u.use([].concat(c, [function(O, m, x) {
    O === 2 && x.length && x[0].lastIndexOf(n) > 0 && (x[0] = x[0].replace(r, h));
  }, d, function(O) {
    if (O === -2) {
      var m = f;
      return f = [], m;
    }
  }])), p.hash = c.length ? c.reduce(function(O, m) {
    return m.name || Wa(15), es(O, m.name);
  }, 5381).toString() : "", p;
}
var dA = it.createContext();
dA.Consumer;
var hA = it.createContext();
var IR = (hA.Consumer, new uA());
var ag = TR();
function $R() {
  return Ii(dA) || IR;
}
function jR() {
  return Ii(hA) || ag;
}
var pA = function() {
  function t4(e, n) {
    var r = this;
    this.inject = function(i, o) {
      o === void 0 && (o = ag);
      var s = r.name + o.hash;
      i.hasNameForId(r.id, s) || i.insertRules(r.id, s, o(r.rules, s, "@keyframes"));
    }, this.toString = function() {
      return Wa(12, String(r.name));
    }, this.name = e, this.id = "sc-keyframes-" + e, this.rules = n;
  }
  return t4.prototype.getName = function(e) {
    return e === void 0 && (e = ag), this.name + e.hash;
  }, t4;
}();
var RR = /([A-Z])/;
var DR = /([A-Z])/g;
var QR = /^ms-/;
var BR = function(t4) {
  return "-" + t4.toLowerCase();
};
function ty(t4) {
  return RR.test(t4) ? t4.replace(DR, BR).replace(QR, "-ms-") : t4;
}
var ny = function(t4) {
  return t4 == null || t4 === false || t4 === "";
};
function Oa(t4, e, n, r) {
  if (Array.isArray(t4)) {
    for (var i, o = [], s = 0, a = t4.length; s < a; s += 1)
      (i = Oa(t4[s], e, n, r)) !== "" && (Array.isArray(i) ? o.push.apply(o, i) : o.push(i));
    return o;
  }
  if (ny(t4))
    return "";
  if (NO(t4))
    return "." + t4.styledComponentId;
  if (Yl(t4)) {
    if (typeof (c = t4) != "function" || c.prototype && c.prototype.isReactComponent || !e)
      return t4;
    var l = t4(e);
    return ss.isElement(l) && console.warn(og(t4) + " is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details."), Oa(l, e, n, r);
  }
  var c;
  return t4 instanceof pA ? n ? (t4.inject(n, r), t4.getName(r)) : t4 : ig(t4) ? function u(f, d) {
    var h, p, O = [];
    for (var m in f)
      f.hasOwnProperty(m) && !ny(f[m]) && (Array.isArray(f[m]) && f[m].isCss || Yl(f[m]) ? O.push(ty(m) + ":", f[m], ";") : ig(f[m]) ? O.push.apply(O, u(f[m], m)) : O.push(ty(m) + ": " + (h = m, (p = f[m]) == null || typeof p == "boolean" || p === "" ? "" : typeof p != "number" || p === 0 || h in Y4 || h.startsWith("--") ? String(p).trim() : p + "px") + ";"));
    return d ? [d + " {"].concat(O, ["}"]) : O;
  }(t4) : t4.toString();
}
var ry = function(t4) {
  return Array.isArray(t4) && (t4.isCss = true), t4;
};
function ql(t4) {
  for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++)
    n[r - 1] = arguments[r];
  return Yl(t4) || ig(t4) ? ry(Oa(Jv(wf, [t4].concat(n)))) : n.length === 0 && t4.length === 1 && typeof t4[0] == "string" ? t4 : ry(Oa(Jv(t4, n)));
}
var iy = /invalid hook call/i;
var au = /* @__PURE__ */ new Set();
var _R = function(t4, e) {
  if (true) {
    var n = "The component " + t4 + (e ? ' with the id of "' + e + '"' : "") + ` has been created dynamically.
You may see this warning because you've called styled inside another component.
To resolve this only create new StyledComponents outside of any render method and function component.`, r = console.error;
    try {
      var i = true;
      console.error = function(o) {
        if (iy.test(o))
          i = false, au.delete(n);
        else {
          for (var s = arguments.length, a = new Array(s > 1 ? s - 1 : 0), l = 1; l < s; l++)
            a[l - 1] = arguments[l];
          r.apply(void 0, [o].concat(a));
        }
      }, Ke(), i && !au.has(n) && (console.warn(n), au.add(n));
    } catch (o) {
      iy.test(o.message) && au.delete(n);
    } finally {
      console.error = r;
    }
  }
};
var MR = function(t4, e, n) {
  return n === void 0 && (n = bo), t4.theme !== n.theme && t4.theme || e || n.theme;
};
var NR = /[!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~-]+/g;
var FR = /(^-|-$)/g;
function tp(t4) {
  return t4.replace(NR, "-").replace(FR, "");
}
var gA = function(t4) {
  return sg(fA(t4) >>> 0);
};
function lu(t4) {
  return typeof t4 == "string" && t4.charAt(0) === t4.charAt(0).toLowerCase();
}
var lg = function(t4) {
  return typeof t4 == "function" || typeof t4 == "object" && t4 !== null && !Array.isArray(t4);
};
var ZR = function(t4) {
  return t4 !== "__proto__" && t4 !== "constructor" && t4 !== "prototype";
};
function WR(t4, e, n) {
  var r = t4[n];
  lg(e) && lg(r) ? mA(r, e) : t4[n] = e;
}
function mA(t4) {
  for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++)
    n[r - 1] = arguments[r];
  for (var i = 0, o = n; i < o.length; i++) {
    var s = o[i];
    if (lg(s))
      for (var a in s)
        ZR(a) && WR(t4, s[a], a);
  }
  return t4;
}
var OA = it.createContext();
OA.Consumer;
var np = {};
function xA(t4, e, n) {
  var r = NO(t4), i = !lu(t4), o = e.attrs, s = o === void 0 ? wf : o, a = e.componentId, l = a === void 0 ? function(v, y) {
    var S = typeof v != "string" ? "sc" : tp(v);
    np[S] = (np[S] || 0) + 1;
    var b = S + "-" + gA("5.3.11" + S + np[S]);
    return y ? y + "-" + b : b;
  }(e.displayName, e.parentComponentId) : a, c = e.displayName, u = c === void 0 ? function(v) {
    return lu(v) ? "styled." + v : "Styled(" + og(v) + ")";
  }(t4) : c, f = e.displayName && e.componentId ? tp(e.displayName) + "-" + e.componentId : e.componentId || l, d = r && t4.attrs ? Array.prototype.concat(t4.attrs, s).filter(Boolean) : s, h = e.shouldForwardProp;
  r && t4.shouldForwardProp && (h = e.shouldForwardProp ? function(v, y, S) {
    return t4.shouldForwardProp(v, y, S) && e.shouldForwardProp(v, y, S);
  } : t4.shouldForwardProp);
  var p, O = new AR(n, f, r ? t4.componentStyle : void 0), m = O.isStatic && s.length === 0, x = function(v, y) {
    return function(S, b, w, C) {
      var k = S.attrs, T = S.componentStyle, A = S.defaultProps, E = S.foldedComponentIds, $ = S.shouldForwardProp, j = S.styledComponentId, B = S.target, D = function(G, M, K) {
        G === void 0 && (G = bo);
        var V = zi({}, M, { theme: G }), ae = {};
        return K.forEach(function(te) {
          var oe, Y, he, X = te;
          for (oe in Yl(X) && (X = X(V)), X)
            V[oe] = ae[oe] = oe === "className" ? (Y = ae[oe], he = X[oe], Y && he ? Y + " " + he : Y || he) : X[oe];
        }), [V, ae];
      }(MR(b, Ii(OA), A) || bo, b, k), N = D[0], z = D[1], Z = function(G, M, K, V) {
        var ae = $R(), te = jR(), oe = M ? G.generateAndInjectStyles(bo, ae, te) : G.generateAndInjectStyles(K, ae, te);
        return !M && V && V(oe), oe;
      }(T, C, N, true ? S.warnTooManyClasses : void 0), J = w, L = z.$as || b.$as || z.as || b.as || B, W = lu(L), R = z !== b ? zi({}, b, {}, z) : b, Q = {};
      for (var _ in R)
        _[0] !== "$" && _ !== "as" && (_ === "forwardedAs" ? Q.as = R[_] : ($ ? $(_, Xv, L) : !W || Xv(_)) && (Q[_] = R[_]));
      return b.style && z.style !== b.style && (Q.style = zi({}, b.style, {}, z.style)), Q.className = Array.prototype.concat(E, j, Z !== j ? Z : null, b.className, z.className).filter(Boolean).join(" "), Q.ref = J, Xi(L, Q);
    }(p, v, y, m);
  };
  return x.displayName = u, (p = it.forwardRef(x)).attrs = d, p.componentStyle = O, p.displayName = u, p.shouldForwardProp = h, p.foldedComponentIds = r ? Array.prototype.concat(t4.foldedComponentIds, t4.styledComponentId) : wf, p.styledComponentId = f, p.target = r ? t4.target : t4, p.withComponent = function(v) {
    var y = e.componentId, S = function(w, C) {
      if (w == null)
        return {};
      var k, T, A = {}, E = Object.keys(w);
      for (T = 0; T < E.length; T++)
        k = E[T], C.indexOf(k) >= 0 || (A[k] = w[k]);
      return A;
    }(e, ["componentId"]), b = y && y + "-" + (lu(v) ? v : tp(og(v)));
    return xA(v, zi({}, S, { attrs: d, componentId: b }), n);
  }, Object.defineProperty(p, "defaultProps", { get: function() {
    return this._foldedDefaultProps;
  }, set: function(v) {
    this._foldedDefaultProps = r ? mA({}, t4.defaultProps, v) : v;
  } }), _R(u, f), p.warnTooManyClasses = /* @__PURE__ */ function(v, y) {
    var S = {}, b = false;
    return function(w) {
      if (!b && (S[w] = true, Object.keys(S).length >= 200)) {
        var C = y ? ' with the id of "' + y + '"' : "";
        console.warn("Over 200 classes were generated for component " + v + C + `.
Consider using the attrs method, together with a style object for frequently changed styles.
Example:
  const Component = styled.div.attrs(props => ({
    style: {
      background: props.background,
    },
  }))\`width: 100%;\`

  <Component />`), b = true, S = {};
      }
    };
  }(u, f), Object.defineProperty(p, "toString", { value: function() {
    return "." + p.styledComponentId;
  } }), i && aR(p, t4, { attrs: true, componentStyle: true, displayName: true, foldedComponentIds: true, shouldForwardProp: true, styledComponentId: true, target: true, withComponent: true }), p;
}
var I = function(t4) {
  return function e(n, r, i) {
    if (i === void 0 && (i = bo), !ss.isValidElementType(r))
      return Wa(1, String(r));
    var o = function() {
      return n(r, i, ql.apply(void 0, arguments));
    };
    return o.withConfig = function(s) {
      return e(n, r, zi({}, i, {}, s));
    }, o.attrs = function(s) {
      return e(n, r, zi({}, i, { attrs: Array.prototype.concat(i.attrs, s).filter(Boolean) }));
    }, o;
  }(xA, t4);
};
["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "marquee", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "marker", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "textPath", "tspan"].forEach(function(t4) {
  I[t4] = I(t4);
});
function VR(t4) {
  typeof navigator < "u" && navigator.product === "ReactNative" && console.warn("`keyframes` cannot be used on ReactNative, only on the web. To do animation in ReactNative please use Animated.");
  for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++)
    n[r - 1] = arguments[r];
  var i = ql.apply(void 0, [t4].concat(n)).join(""), o = gA(i);
  return new pA(o, i);
}
typeof navigator < "u" && navigator.product === "ReactNative" && console.warn(`It looks like you've imported 'styled-components' on React Native.
Perhaps you're looking to import 'styled-components/native'?
Read more about this at https://www.styled-components.com/docs/basics#react-native`), typeof window < "u" && (window["__styled-components-init__"] = window["__styled-components-init__"] || 0, window["__styled-components-init__"] === 1 && console.warn(`It looks like there are several instances of 'styled-components' initialized in this application. This may cause dynamic styles to not render properly, errors during the rehydration process, a missing theme prop, and makes your application bigger without good reason.

See https://s-c.sh/2BAXzed for more info.`), window["__styled-components-init__"] += 1);
var cg = function(t4, e) {
  return cg = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, r) {
    n.__proto__ = r;
  } || function(n, r) {
    for (var i in r)
      Object.prototype.hasOwnProperty.call(r, i) && (n[i] = r[i]);
  }, cg(t4, e);
};
function zR(t4, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
  cg(t4, e);
  function n() {
    this.constructor = t4;
  }
  t4.prototype = e === null ? Object.create(e) : (n.prototype = e.prototype, new n());
}
var kf = function() {
  return kf = Object.assign || function(e) {
    for (var n, r = 1, i = arguments.length; r < i; r++) {
      n = arguments[r];
      for (var o in n)
        Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o]);
    }
    return e;
  }, kf.apply(this, arguments);
};
var LR = Object.prototype.hasOwnProperty;
function oy(t4, e) {
  return t4 === e ? t4 !== 0 || e !== 0 || 1 / t4 === 1 / e : t4 !== t4 && e !== e;
}
function XR(t4, e) {
  if (oy(t4, e))
    return true;
  if (typeof t4 != "object" || t4 === null || typeof e != "object" || e === null)
    return false;
  var n = Object.keys(t4), r = Object.keys(e);
  if (n.length !== r.length)
    return false;
  for (var i = 0; i < n.length; i++)
    if (!LR.call(e, n[i]) || !oy(t4[n[i]], e[n[i]]))
      return false;
  return true;
}
var pt = Symbol("none");
var GR = Symbol("__state");
function ZO(t4, e) {
  var n = vA(t4);
  n.activate(e);
  var r = n.toMethods();
  return r.self();
}
function YR(t4, e) {
  var n = Object(t4) === t4 ? t4[WO] : void 0;
  if (n)
    if (n.isMounted) {
      var r = function() {
        var O = n.store, m = function() {
          return s({
            store: O,
            state: x,
            source: o.source
            // mutable, get the latest from value
          });
        }, x = new Ku(O, n.path, O.get(n.path), O.edition, m);
        return {
          store: O,
          state: x,
          source: t4
        };
      }, i = it.useState(r), o = i[0], s = i[1];
      if (o.store !== n.store || !("source" in o))
        throw new Qn(n.path, St.InitStateStoreSwitchover);
      Object.defineProperty(o, "store", { enumerable: false }), Object.defineProperty(o, "state", { enumerable: false }), Object.defineProperty(o, "source", { enumerable: false }), o.state.reconstruct(
        n.path,
        o.store.get(n.path),
        o.store.edition,
        // parent state object has changed its reference object
        // so the scopped state should change too
        o.source !== t4
      ), o.source = t4, n.subscribe(o.state), op(function() {
        return o.state.onMount(), n.subscribe(o.state), function() {
          o.state.onUnmount(), n.unsubscribe(o.state);
        };
      }, []);
      var a = o.state.self();
      return o["[hookstate(scoped)]"] = a, a;
    } else {
      var r = function() {
        var x = n.store, v = function() {
          return u({
            store: x,
            state: y,
            source: c.source
            // mutable, get the latest from value
          });
        }, y = new Ku(x, Cn, x.get(Cn), x.edition, v);
        return {
          store: x,
          state: y,
          source: t4
        };
      }, l = it.useState(r), c = l[0], u = l[1];
      if (c.store !== n.store || !("source" in c))
        throw new Qn(n.path, St.InitStateStoreSwitchover);
      Object.defineProperty(c, "store", { enumerable: false }), Object.defineProperty(c, "state", { enumerable: false }), Object.defineProperty(c, "source", { enumerable: false }), c.state.reconstruct(
        Cn,
        c.store.get(Cn),
        c.store.edition,
        // parent state object has changed its reference object
        // so the scopped state should change too
        c.source !== t4
      ), c.source = t4, c.store.subscribe(c.state), op(function() {
        return c.state.onMount(), c.store.subscribe(c.state), function() {
          c.state.onUnmount(), c.store.unsubscribe(c.state);
        };
      }, []);
      for (var a = c.state.self(), f = 0; f < n.path.length; f += 1)
        a = a.nested(n.path[f]);
      return c["[hookstate(global)]"] = a, a;
    }
  else {
    var r = function() {
      var x = vA(t4), v = function() {
        return p({
          store: x,
          state: y
        });
      }, y = new Ku(x, Cn, x.get(Cn), x.edition, v);
      return {
        store: x,
        state: y
      };
    }, d = it.useState(r), h = d[0], p = d[1];
    if ("source" in h)
      throw new Qn(Cn, St.InitStateStoreSwitchover);
    Object.defineProperty(h, "store", { enumerable: false }), Object.defineProperty(h, "state", { enumerable: false }), h.state.reconstruct(Cn, h.store.get(Cn), h.store.edition, false), h.store.subscribe(h.state), h.store.activate(e), op(function() {
      return h.state.onMount(), h.store.subscribe(h.state), h.store.activate(e), function() {
        h.state.onUnmount(), h.store.unsubscribe(h.state), h.store.deactivate();
      };
    }, []);
    var a = h.state.self();
    return h["[hookstate(local)]"] = a, a;
  }
}
var WO = Symbol("self");
var St;
(function(t4) {
  t4[t4.StateUsedInDependencyList = 100] = "StateUsedInDependencyList", t4[t4.InitStateToValueFromState = 101] = "InitStateToValueFromState", t4[t4.SetStateToValueFromState = 102] = "SetStateToValueFromState", t4[t4.GetStateWhenPromised = 103] = "GetStateWhenPromised", t4[t4.SetStateWhenPromised = 104] = "SetStateWhenPromised", t4[t4.SetStateNestedToPromised = 105] = "SetStateNestedToPromised", t4[t4.SetStateWhenDestroyed = 106] = "SetStateWhenDestroyed", t4[t4.ToJson_Value = 108] = "ToJson_Value", t4[t4.ToJson_State = 109] = "ToJson_State", t4[t4.GetProperty_Function = 110] = "GetProperty_Function", t4[t4.InitStateStoreSwitchover = 111] = "InitStateStoreSwitchover", t4[t4.GetUnknownPlugin = 120] = "GetUnknownPlugin", t4[t4.SetProperty_State = 201] = "SetProperty_State", t4[t4.SetProperty_Value = 202] = "SetProperty_Value", t4[t4.SetPrototypeOf_State = 203] = "SetPrototypeOf_State", t4[t4.SetPrototypeOf_Value = 204] = "SetPrototypeOf_Value", t4[t4.PreventExtensions_State = 205] = "PreventExtensions_State", t4[t4.PreventExtensions_Value = 206] = "PreventExtensions_Value", t4[t4.DefineProperty_State = 207] = "DefineProperty_State", t4[t4.DefineProperty_Value = 208] = "DefineProperty_Value", t4[t4.DeleteProperty_State = 209] = "DeleteProperty_State", t4[t4.DeleteProperty_Value = 210] = "DeleteProperty_Value", t4[t4.Construct_State = 211] = "Construct_State", t4[t4.Construct_Value = 212] = "Construct_Value", t4[t4.Apply_State = 213] = "Apply_State", t4[t4.Apply_Value = 214] = "Apply_Value";
})(St || (St = {}));
var Qn = (
  /** @class */
  function(t4) {
    zR(e, t4);
    function e(n, r, i) {
      return t4.call(this, "Error: HOOKSTATE-".concat(r, " [path: /").concat(n.join("/")).concat(i ? ", details: ".concat(i) : "", "]. ") + "See https://hookstate.js.org/docs/exceptions#hookstate-".concat(r)) || this;
    }
    return e;
  }(Error)
);
var Hu = Symbol("ProxyMarker");
var Cn = [];
var qR = (
  /** @class */
  function() {
    function t4(e) {
      var n = this;
      this._value = e, this.edition = 1, this._subscribers = /* @__PURE__ */ new Set(), Object(e) === e && ip.promiseDetector(e) ? this.setPromised(e) : e === pt && this.setPromised(void 0);
      var r = function() {
        n._stateMethods.reconstruct(Cn, n.get(Cn), n.edition, false);
      };
      r[Ju] = true, this._stateMethods = new Ku(this, Cn, this.get(Cn), this.edition, r), this.subscribe(this._stateMethods);
    }
    return t4.prototype.setPromised = function(e) {
      var n = this;
      if (this._value = pt, this._promiseError = void 0, this._promiseResolver = void 0, !e) {
        this._promise = new Promise(function(r) {
          n._promiseResolver = r;
        });
        return;
      }
      e = e.then(function(r) {
        n._promise === e && (n._promise = void 0, n._promiseError = void 0, n._promiseResolver, n.update(n._stateMethods.self(), n.set(Cn, r)));
      }).catch(function(r) {
        if (n._promise === e) {
          n._promise = void 0, n._promiseResolver = void 0, n._promiseError = r, n.edition += 1;
          var i = { path: Cn };
          n.update(n._stateMethods.self(), i);
        }
      }), this._promise = e;
    }, t4.prototype.activate = function(e) {
      var n, r, i, o;
      this.edition < 0 && (this.edition = -this.edition), this._extension === void 0 && (this._extension = e == null ? void 0 : e(), this._extensionMethods = (r = (n = this._extension) === null || n === void 0 ? void 0 : n.onCreate) === null || r === void 0 ? void 0 : r.call(n, this._stateMethods.self(), {}), (o = (i = this._extension) === null || i === void 0 ? void 0 : i.onInit) === null || o === void 0 || o.call(i, this._stateMethods.self(), this._extensionMethods || {}));
    }, t4.prototype.deactivate = function() {
      var e, n;
      this._extension && ((n = (e = this._extension).onDestroy) === null || n === void 0 || n.call(e, this._stateMethods.self()), delete this._extension, delete this._extensionMethods), this.edition > 0 && (this.edition = -this.edition);
    }, Object.defineProperty(t4.prototype, "extension", {
      get: function() {
        return this._extensionMethods;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t4.prototype, "promise", {
      get: function() {
        return this._promise;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t4.prototype, "promiseError", {
      get: function() {
        return this._promiseError;
      },
      enumerable: false,
      configurable: true
    }), t4.prototype.get = function(e) {
      var n = this._value;
      return n === pt || e.forEach(function(r) {
        n = n[r];
      }), n;
    }, t4.prototype.set = function(e, n) {
      var r, i;
      if (this.edition < 0)
        throw new Qn(e, St.SetStateWhenDestroyed);
      if (e.length === 0) {
        if (n === pt)
          this.setPromised(void 0);
        else if (Object(n) === n && ip.promiseDetector(n))
          this.setPromised(n), n = pt;
        else {
          if (this._promise && !this._promiseResolver)
            throw new Qn(e, St.SetStateWhenPromised);
          this._promiseError = void 0;
        }
        var o = this._value;
        if (this._value = n, this.afterSet(), o === pt && this._value !== pt && this._promiseResolver) {
          this._promise = void 0, this._promiseError = void 0;
          var s = this._promiseResolver;
          this._promiseResolver, s(this._value);
        }
        return {
          path: e
        };
      }
      if (Object(n) === n && ip.promiseDetector(n))
        throw new Qn(e, St.SetStateNestedToPromised);
      for (var a = this._value, l = 0; l < e.length - 1; l += 1)
        a = a[e[l]];
      var c = e[e.length - 1];
      return c in a ? n !== pt ? (a[c] = n, this.afterSet(), {
        path: e
      }) : (Array.isArray(a) && typeof c == "number" ? a.splice(c, 1) : delete a[c], this.afterSet(), {
        path: e.slice(0, -1),
        actions: (r = {}, r[c] = "D", r)
      }) : n !== pt ? (a[c] = n, this.afterSet(), {
        path: e.slice(0, -1),
        actions: (i = {}, i[c] = "I", i)
      }) : {
        path: e
      };
    }, t4.prototype.preset = function(e, n) {
      var r, i;
      (i = (r = this._extension) === null || r === void 0 ? void 0 : r.onPreset) === null || i === void 0 || i.call(r, e, n, this._stateMethods.self());
    }, t4.prototype.premerge = function(e, n) {
      var r, i;
      (i = (r = this._extension) === null || r === void 0 ? void 0 : r.onPremerge) === null || i === void 0 || i.call(r, e, n, this._stateMethods.self());
    }, t4.prototype.update = function(e, n) {
      var r = this, i, o;
      (o = (i = this._extension) === null || i === void 0 ? void 0 : i.onSet) === null || o === void 0 || o.call(i, e, n, this._stateMethods.self());
      var s = /* @__PURE__ */ new Set();
      n.actions && Object.values(n.actions).findIndex(function(a) {
        return a !== "U";
      }) === -1 ? Object.keys(n.actions).forEach(function(a) {
        r._subscribers.forEach(function(l) {
          return l.onSet({ path: n.path.concat(a) }, s);
        });
      }) : this._subscribers.forEach(function(a) {
        return a.onSet(n, s);
      }), s.forEach(function(a) {
        return a();
      });
    }, t4.prototype.afterSet = function() {
      this.edition > 0 && (this.edition += 1), this.edition < 0 && (this.edition -= 1);
    }, t4.prototype.toMethods = function() {
      return this._stateMethods;
    }, t4.prototype.subscribe = function(e) {
      this._subscribers.add(e);
    }, t4.prototype.unsubscribe = function(e) {
      this._subscribers.delete(e);
    }, t4.prototype.toJSON = function() {
      throw new Qn(Cn, St.ToJson_Value);
    }, t4;
  }()
);
var qo = Symbol("UnusedValue");
var Ju = Symbol("IsUnmounted");
var Ku = (
  /** @class */
  function() {
    function t4(e, n, r, i, o) {
      this.store = e, this.path = n, this.valueSource = r, this.valueEdition = i, this.onSetUsed = o, this.valueUsed = qo;
    }
    return Object.defineProperty(t4.prototype, GR, {
      get: function() {
        return [this.get(), this.self()];
      },
      enumerable: false,
      configurable: true
    }), t4.prototype.reconstruct = function(e, n, r, i) {
      this.path = e, this.valueSource = n, this.valueEdition = r, this.valueUsed = qo, i ? (delete this.selfUsed, delete this.childrenCreated, delete this.childrenUsedPrevious) : (this.valueUsedNoProxyPrevious = this.valueUsedNoProxy, this.childrenUsedPrevious = this.childrenUsed), delete this.valueUsedNoProxy, delete this.childrenUsed;
    }, t4.prototype.reconnect = function() {
      this.get({ __internalAllowPromised: true, noproxy: this.valueUsedNoProxyPrevious }), this.childrenUsed = kf(kf({}, this.childrenUsedPrevious), this.childrenUsed);
    }, t4.prototype.getUntracked = function(e) {
      if (this.valueEdition !== this.store.edition && (this.valueSource = this.store.get(this.path), this.valueEdition = this.store.edition, this.valueUsed !== qo && (this.valueUsed = qo, this.get({ __internalAllowPromised: true }))), e)
        return this.valueSource;
      if (this.store.promiseError)
        throw this.store.promiseError;
      if (this.store.promise)
        throw new Qn(this.path, St.GetStateWhenPromised);
      return this.valueSource;
    }, t4.prototype.get = function(e) {
      var n, r = this.getUntracked(e == null ? void 0 : e.__internalAllowPromised);
      return e != null && e.stealth ? r : (this.valueUsed === qo && (Array.isArray(r) ? this.valueUsed = this.valueArrayImpl(r) : Object(r) === r ? ((n = r.constructor) === null || n === void 0 ? void 0 : n.name) === "Object" ? this.valueUsed = this.valueObjectImpl(r) : (this.valueUsedNoProxy = true, this.valueUsed = r) : this.valueUsed = r), e != null && e.noproxy ? (this.valueUsedNoProxy = true, r) : this.valueUsed);
    }, Object.defineProperty(t4.prototype, "value", {
      get: function() {
        return this.get();
      },
      enumerable: false,
      configurable: true
    }), t4.prototype.setUntrackedV4 = function(e) {
      if (typeof e == "function" && (e = e(this.getUntracked())), this.store.preset(this.self(), e), Object(e) === e && e[Hu])
        throw new Qn(this.path, St.SetStateToValueFromState);
      return e !== Object(e) && e === this.getUntracked(true) ? null : this.store.set(this.path, e);
    }, t4.prototype.set = function(e) {
      var n = this.setUntrackedV4(e);
      n && this.store.update(this.self(), n);
    }, t4.prototype.mergeUntracked = function(e) {
      var n = this.mergeUntrackedV4(e);
      return n ? [n.path] : [];
    }, t4.prototype.mergeUntrackedV4 = function(e) {
      var n = this.getUntracked();
      if (typeof e == "function" && (e = e(n)), this.store.premerge(this.self(), e), Array.isArray(n))
        if (Array.isArray(e)) {
          var r = { path: this.path, actions: {} };
          return e.forEach(function(a, l) {
            r.actions[n.push(a) - 1] = "I";
          }), Object.keys(r.actions).length > 0 ? (this.setUntrackedV4(n), r) : null;
        } else {
          var i = { path: this.path, actions: {} }, o = [];
          return Object.keys(e).map(function(a) {
            return Number(a);
          }).sort(function(a, l) {
            return a - l;
          }).forEach(function(a) {
            var l = Number(a), c = e[l];
            c === pt ? (i.actions[l] = "D", o.push(l)) : (l in n ? i.actions[l] = "U" : i.actions[l] = "I", n[l] = c);
          }), o.reverse().forEach(function(a) {
            n.splice(a, 1);
          }), Object.keys(i.actions).length > 0 ? (this.setUntrackedV4(n), i) : null;
        }
      else if (Object(n) === n) {
        var s = { path: this.path, actions: {} };
        return Object.keys(e).forEach(function(a) {
          var l = e[a];
          l === pt ? (s.actions[a] = "D", delete n[a]) : (a in n ? s.actions[a] = "U" : s.actions[a] = "I", n[a] = l);
        }), Object.keys(s.actions).length > 0 ? (this.setUntrackedV4(n), s) : null;
      } else
        return typeof n == "string" ? this.setUntrackedV4(n + String(e)) : this.setUntrackedV4(e);
    }, t4.prototype.merge = function(e) {
      var n = this.mergeUntrackedV4(e);
      n && this.store.update(this.self(), n);
    }, t4.prototype.nested = function(e) {
      return this.child(e).self();
    }, t4.prototype.rerender = function(e) {
      for (var n = 0, r = e; n < r.length; n++) {
        var i = r[n];
        this.store.update(this.self(), { path: i });
      }
    }, t4.prototype.activate = function(e) {
      this.store.activate(e);
    }, t4.prototype.deactivate = function() {
      this.store.deactivate();
    }, t4.prototype.subscribe = function(e) {
      this.subscribers === void 0 && (this.subscribers = /* @__PURE__ */ new Set()), this.subscribers.add(e);
    }, t4.prototype.unsubscribe = function(e) {
      this.subscribers && this.subscribers.delete(e);
    }, Object.defineProperty(t4.prototype, "isMounted", {
      get: function() {
        return !this.onSetUsed[Ju];
      },
      enumerable: false,
      configurable: true
    }), t4.prototype.onMount = function() {
      delete this.onSetUsed[Ju];
    }, t4.prototype.onUnmount = function() {
      this.onSetUsed[Ju] = true;
    }, t4.prototype.onSet = function(e, n) {
      var r = this, i = function() {
        var s, a = false;
        r.valueUsedNoProxy && r.valueUsed !== qo && (n.add(r.onSetUsed), delete r.selfUsed, a = true);
        var l = e.path, c = l[r.path.length];
        if (c === void 0) {
          if (r.valueUsed !== qo) {
            if (n.add(r.onSetUsed), delete r.selfUsed, delete r.childrenUsed, e.actions && r.childrenCreated)
              if (Array.isArray(r.valueSource) && Object.values(e.actions).includes("D")) {
                var u = Object.keys(e.actions).map(function(h) {
                  return Number(h);
                }).sort(function(h, p) {
                  return h - p;
                }).find(function(h) {
                  var p;
                  return ((p = e.actions) === null || p === void 0 ? void 0 : p[h]) === "D";
                });
                for (var f in r.childrenCreated)
                  (Number(f) >= u || f in e.actions) && delete r.childrenCreated[f];
              } else
                for (var f in e.actions)
                  delete r.childrenCreated[f];
            else
              delete r.childrenCreated;
            return true;
          }
        } else {
          var d = (s = r.childrenUsed) === null || s === void 0 ? void 0 : s[c];
          if (d && d.onSet(e, n))
            return delete r.selfUsed, true;
        }
        return a;
      }, o = i();
      return !o && this.subscribers !== void 0 && this.subscribers.forEach(function(s) {
        s.onSet(e, n) && delete r.selfUsed;
      }), o;
    }, Object.defineProperty(t4.prototype, "keys", {
      get: function() {
        var e = this.get();
        if (Array.isArray(e))
          return Object.keys(e).map(function(n) {
            return Number(n);
          }).filter(function(n) {
            return Number.isInteger(n);
          });
        if (Object(e) === e)
          return Object.keys(e);
      },
      enumerable: false,
      configurable: true
    }), t4.prototype.child = function(e) {
      this.childrenUsed = this.childrenUsed || {};
      var n = this.childrenUsed.hasOwnProperty(e) && this.childrenUsed[e];
      if (n)
        return n;
      var r = this.valueSource[e];
      if (typeof r == "function")
        throw new Qn(this.path, St.GetProperty_Function);
      this.childrenCreated = this.childrenCreated || {};
      var i = this.childrenCreated[e], o;
      return i ? (i.reconstruct(this.path.concat(e), r, this.valueEdition, false), o = i) : (o = new t4(this.store, this.path.concat(e), r, this.valueEdition, this.onSetUsed), this.childrenCreated[e] = o), this.valueUsedNoProxy && (o.valueUsedNoProxy = true), this.childrenUsed[e] = o, o;
    }, t4.prototype.valueArrayImpl = function(e) {
      var n = this;
      return rp(this.path, e, function() {
        return e;
      }, function(r, i) {
        if (i === "length")
          return r.length;
        if (i in Array.prototype)
          return Array.prototype[i];
        if (i === Hu)
          return n;
        if (typeof i == "symbol")
          return r[i];
        var o = Number(i);
        if (Number.isInteger(o))
          return n.child(o).get();
      }, function(r, i, o) {
        if (typeof i == "symbol")
          return r[i] = o, true;
        throw new Qn(n.path, St.SetProperty_Value);
      }, true);
    }, t4.prototype.valueObjectImpl = function(e) {
      var n = this;
      return rp(this.path, e, function() {
        return e;
      }, function(r, i) {
        return i in Object.prototype ? Object.prototype[i] : i === Hu ? n : typeof i == "symbol" ? r[i] : n.child(i).get();
      }, function(r, i, o) {
        if (typeof i == "symbol")
          return r[i] = o, true;
        throw new Qn(n.path, St.SetProperty_Value);
      }, true);
    }, t4.prototype.self = function() {
      var e = this;
      if (this.selfUsed)
        return this.selfUsed;
      var n = function(r, i) {
        if (i === WO)
          return e;
        if (typeof i != "symbol") {
          if (i === "toJSON")
            throw new Qn(e.path, St.ToJson_State);
          var o = function(a) {
            var l = e.get({ __internalAllowPromised: a === "$$typeof" || a === "constructor" });
            if (a in Object.prototype)
              return Object.prototype[a];
            if (
              // if currentValue is primitive type
              !(Object(l) !== l && // if promised, it will be none
              l !== pt)
            ) {
              if (Array.isArray(l)) {
                if (a === "length")
                  return l.length;
                if (a in Array.prototype)
                  return Array.prototype[a];
                var c = Number(a);
                return Number.isInteger(c) ? e.nested(c) : void 0;
              }
              return e.nested(a.toString());
            }
          };
          switch (i) {
            case "path":
              return e.path;
            case "keys":
              return e.keys;
            case "value":
              return e.value;
            case "ornull":
              return e.ornull;
            case "promised":
              return e.promised;
            case "promise":
              return e.promise;
            case "error":
              return e.error;
            case "get":
              return function(a) {
                return e.get(a);
              };
            case "set":
              return function(a) {
                return e.set(a);
              };
            case "merge":
              return function(a) {
                return e.merge(a);
              };
            case "nested":
              return function(a) {
                return o(a);
              };
            default:
              var s = e.store.extension;
              return s && i in s ? s[i](e.self()) : o(i);
          }
        }
      };
      return this.selfUsed = rp(this.path, this.valueSource, function(r) {
        return e.get({ __internalAllowPromised: true, stealth: r == null ? void 0 : r.stealth });
      }, n, function(r, i, o) {
        throw new Qn(e.path, St.SetProperty_State);
      }, false), this.selfUsed;
    }, Object.defineProperty(t4.prototype, "promised", {
      get: function() {
        return this.get({ __internalAllowPromised: true }), !!this.store.promise;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t4.prototype, "promise", {
      get: function() {
        var e = this, n;
        return this.get({ __internalAllowPromised: true }), (n = this.store.promise) === null || n === void 0 ? void 0 : n.then(function(r) {
          return e.self();
        });
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t4.prototype, "error", {
      get: function() {
        return this.get({ __internalAllowPromised: !!this.store.promiseError }), this.store.promiseError;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t4.prototype, "ornull", {
      get: function() {
        var e = this.get();
        return e == null ? e : this.self();
      },
      enumerable: false,
      configurable: true
    }), t4;
  }()
);
function rp(t4, e, n, r, i, o) {
  var s = function(a) {
    throw new Qn(t4, a);
  };
  return Object(e) !== e && (e = {}), new Proxy(e, {
    getPrototypeOf: function(a) {
      var l = n();
      return l == null ? null : Object.getPrototypeOf(l === pt ? new Promise(function() {
      }) : l);
    },
    setPrototypeOf: function(a, l) {
      return s(o ? St.SetPrototypeOf_State : St.SetPrototypeOf_Value);
    },
    isExtensible: function(a) {
      return true;
    },
    preventExtensions: function(a) {
      return s(o ? St.PreventExtensions_State : St.PreventExtensions_Value);
    },
    getOwnPropertyDescriptor: function(a, l) {
      var c = n();
      if (Object(c) === c) {
        var u = Object.getOwnPropertyDescriptor(c, l);
        return Array.isArray(c) && l in Array.prototype ? u : u && {
          // should be configurable as may not exist on proxy target
          configurable: true,
          enumerable: u.enumerable,
          get: function() {
            return r(c, l);
          },
          set: void 0
        };
      }
      if (!(o || c === pt)) {
        if (l === "value")
          return {
            // should be configurable as does not exist on proxy target
            configurable: true,
            enumerable: true,
            get: function() {
              return n({ stealth: true });
            },
            set: void 0
          };
        if (l === "path")
          return {
            // should be configurable as does not exist on proxy target
            configurable: true,
            enumerable: true,
            get: function() {
              return t4;
            },
            set: void 0
          };
      }
    },
    has: function(a, l) {
      if (typeof l == "symbol")
        return false;
      var c = n();
      return Object(c) === c ? l in c : o || c === pt ? false : l === "value" || l === "path";
    },
    get: r,
    set: i,
    deleteProperty: function(a, l) {
      return s(o ? St.DeleteProperty_State : St.DeleteProperty_Value);
    },
    defineProperty: function(a, l, c) {
      return s(o ? St.DefineProperty_State : St.DefineProperty_Value);
    },
    ownKeys: function(a) {
      var l = n();
      return Array.isArray(l) && a.length === void 0 && Object.defineProperty(e, "length", {
        value: 0,
        writable: true,
        enumerable: false,
        configurable: false
      }), Object(l) === l ? Object.getOwnPropertyNames(l) : o || l === pt ? [] : ["value", "path"];
    },
    apply: function(a, l, c) {
      return s(o ? St.Apply_State : St.Apply_Value);
    },
    construct: function(a, l, c) {
      return s(o ? St.Construct_State : St.Construct_Value);
    }
  });
}
function vA(t4) {
  var e = t4;
  if (typeof t4 == "function" && (e = t4()), Object(e) === e && e[Hu])
    throw new Qn(Cn, St.InitStateToValueFromState);
  return new qR(e);
}
var ip = {
  interceptDependencyListsMode: "always",
  isDevelopmentMode: typeof process == "object" && typeof process.env == "object" && true,
  promiseDetector: function(t4) {
    return Promise.resolve(t4) === t4;
  },
  hiddenInterceptDependencyListsModeDebug: false
};
function ys(t4, e) {
  for (var n = 0, r = t4 || []; n < r.length; n++) {
    var i = r[n];
    if (i === Object(i)) {
      var o = i[WO];
      o && o.reconnect();
    }
  }
  return t4;
}
var Af;
function UR(t4, e) {
  return ys(e), Af(t4, e);
}
var Pf;
function HR(t4, e) {
  return ys(e), Pf(t4, e);
}
var ug;
function JR(t4, e) {
  return ys(e), ug(t4, e);
}
var fg;
function KR(t4, e, n) {
  return ys(n), fg(t4, e, n);
}
var dg;
function eD(t4, e) {
  return ys(e), dg(t4, e);
}
var hg;
function tD(t4, e) {
  return ys(e), hg(t4, e);
}
var pg;
function nD(t4, e) {
  return pg(t4, function(n, r) {
    return ys(Object.keys(r).map(function(i) {
      return r[i];
    })), (e || XR)(n, r);
  });
}
function rD() {
  !Af && it.useEffect && (Af = it.useEffect, it.useEffect = UR), !Pf && it.useLayoutEffect && (Pf = it.useLayoutEffect, it.useLayoutEffect = HR), !ug && it.useInsertionEffect && (ug = it.useInsertionEffect, it.useInsertionEffect = JR), !fg && it.useImperativeHandle && (fg = it.useImperativeHandle, it.useImperativeHandle = KR), !dg && it.useMemo && (dg = it.useMemo, it.useMemo = eD), !hg && it.useCallback && (hg = it.useCallback, it.useCallback = tD), !pg && it.memo && (pg = it.memo, it.memo = nD);
}
rD();
var op = typeof window < "u" ? Pf : Af;
var VO = { active: true, key: "", value: "" };
var H = /* @__PURE__ */ ((t4) => (t4.NoAuth = "No Auth", t4.BasicAuth = "Basic Auth", t4.DigestAuth = "Digest Auth", t4.JWT = "JWT", t4.APIKey = "API key", t4.OAuth2 = "OAuth 2.0", t4.OpenIDConnect = "OpenID Connect", t4))(H || {});
var ie = /* @__PURE__ */ ((t4) => (t4.ClientCredentials = "Client Credentials", t4.ClientCredentialsWithJwtAssertion = "Client Credentials with JWT Assertion", t4.AuthorizationCode = "Authorization Code", t4.Implicit = "Implicit", t4.Password = "Password", t4))(ie || {});
var Qr = /* @__PURE__ */ ((t4) => (t4.Body = "Body", t4.Header = "Header", t4.URL = "URL", t4))(Qr || {});
var bs = "{{";
var Ss = "}}";
var yA = `${bs}(.*?)${Ss}`;
function Va(t4) {
  const e = new RegExp(`${bs}(.*?)${Ss}`, "g"), n = [];
  let r;
  for (; (r = e.exec(t4)) !== null; )
    n.push({
      start: r.index,
      end: r.index + r[0].length,
      content: r[1]
    });
  return n;
}
var iD = I.span`
  border-radius: var(--border-radius);
  border: 1px solid var(--border-color-primary);
  padding: 0 calc(var(--spacing-xxs) / 2);
`;
var qe = (t4, e, n = /* @__PURE__ */ new Set()) => {
  const r = Va(t4);
  if (!r.length)
    return t4;
  let i = 0;
  const o = r.flatMap(({ start: s, end: a, content: l }) => {
    if (n.has(l))
      return null;
    const c = e.findLast((f) => f.name === l), u = t4.slice(i, c ? s : a);
    if (i = a, c) {
      n.add(l);
      const f = qe(c.value, e, n);
      return n.delete(l), [u.length ? u : null, f || t4.slice(s, a)];
    }
    return [u.length ? u : null];
  });
  return t4.slice(i).length && o.push(t4.slice(i)), o.join("");
};
var oD = (t4, e, n = /* @__PURE__ */ new Set()) => {
  const r = Va(t4), i = [];
  if (!r.length)
    return {
      content: t4,
      sourceMap: []
    };
  let o = 0;
  const s = r.flatMap(({ start: a, end: l, content: c }) => {
    const u = l - a;
    if (n.has(c))
      return null;
    const f = e.findLast((h) => h.name === c), d = t4.slice(o, f ? a : l);
    if (o = l, f) {
      n.add(c);
      const h = qe(f.value, e, n);
      n.delete(c);
      const p = h || t4.slice(a, l);
      return i.push({ pos: a, offset: p.length - u }), [d.length ? d : null, p];
    }
    return [d.length ? d : null];
  });
  return t4.slice(o).length && s.push(t4.slice(o)), {
    content: s.join(""),
    sourceMap: i
  };
};
var bA = (t4, e) => {
  const n = Va(t4);
  if (!n.length)
    return [t4];
  let r = 0;
  const i = n.flatMap(({ start: o, end: s }) => {
    const a = t4.slice(r, o), l = qe(t4.slice(o, s), e), c = /* @__PURE__ */ g.jsx(iD, { children: l });
    return r = s, [a.length ? a : null, c];
  });
  return t4.slice(r).length && i.push(t4.slice(r)), i;
};
function sp(t4) {
  return [...t4.map((n) => ({
    id: crypto.randomUUID(),
    key: n.name,
    value: n.example ? String(n.example) : "",
    active: !!n.example
  })), mn()];
}
function SA(t4, e) {
  const [n] = t4.split("?"), r = e.slice(0, -1).filter((i) => i.active).map((i) => `${i.key}=${i.value}`).join("&");
  return `${n}${r ? `?${r}` : ""}`;
}
function mn() {
  return { id: crypto.randomUUID(), ...VO };
}
function na() {
  return { id: crypto.randomUUID(), ...VO, type: "text", files: null };
}
function wA() {
  return { id: crypto.randomUUID(), ...VO, sendIn: Qr.URL };
}
function Ef(t4) {
  return t4.map((e) => ({
    id: crypto.randomUUID(),
    key: "",
    value: e,
    active: true
  }));
}
function Yd(t4, e) {
  return t4.filter((n) => n.active && n.value).map(({ value: n }) => (e ? qe(n, e) : n).trim());
}
var $r = {
  JSON: "application/json",
  XML: "application/xml",
  HTML: "text/html",
  Text: "text/plain",
  Image: "image/png"
};
var gg = {
  FormData: "multipart/form-data",
  "application/x-www-form-urlencoded": "application/x-www-form-urlencoded"
};
var sD = {
  Binary: "application/octet-stream"
};
var aD = {
  Image: "image/png"
};
var ut = {
  ...$r,
  ...gg,
  ...sD,
  ...aD
};
function po() {
  return {
    type: $r.Text,
    content: "",
    activeExampleName: "",
    formData: {
      [gg.FormData]: [na()],
      [gg["application/x-www-form-urlencoded"]]: [na()]
    },
    binary: null
  };
}
var lD = {
  id: crypto.randomUUID(),
  name: "Default",
  state: "Normal",
  canBeRemoved: false,
  canBeEdited: false,
  variables: []
};
var fi = /* @__PURE__ */ ((t4) => (t4.Idle = "idle", t4.Loading = "loading", t4.Success = "success", t4.Error = "error", t4))(fi || {});
var za = /* @__PURE__ */ ((t4) => (t4.Query = "Query", t4.Header = "Header", t4.Cookie = "Cookie", t4))(za || {});
var Fe = I.div`
  border-bottom: 1px solid var(--border-color-secondary);
  width: 100%;
`;
var Qe = I.div`
  border-right: 1px solid var(--border-color-primary);
  align-self: stretch;
`;
function Hr(t4) {
  "@babel/helpers - typeof";
  return Hr = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Hr(t4);
}
function cD(t4, e) {
  if (Hr(t4) != "object" || !t4)
    return t4;
  var n = t4[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(t4, e || "default");
    if (Hr(r) != "object")
      return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t4);
}
function CA(t4) {
  var e = cD(t4, "string");
  return Hr(e) == "symbol" ? e : e + "";
}
function cn(t4, e, n) {
  return (e = CA(e)) in t4 ? Object.defineProperty(t4, e, {
    value: n,
    enumerable: true,
    configurable: true,
    writable: true
  }) : t4[e] = n, t4;
}
function sy(t4, e) {
  var n = Object.keys(t4);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t4);
    e && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(t4, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function se(t4) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? sy(Object(n), true).forEach(function(r) {
      cn(t4, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t4, Object.getOwnPropertyDescriptors(n)) : sy(Object(n)).forEach(function(r) {
      Object.defineProperty(t4, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return t4;
}
function uD(t4) {
  if (Array.isArray(t4))
    return t4;
}
function fD(t4, e) {
  var n = t4 == null ? null : typeof Symbol < "u" && t4[Symbol.iterator] || t4["@@iterator"];
  if (n != null) {
    var r, i, o, s, a = [], l = true, c = false;
    try {
      if (o = (n = n.call(t4)).next, e === 0) {
        if (Object(n) !== n)
          return;
        l = false;
      } else
        for (; !(l = (r = o.call(n)).done) && (a.push(r.value), a.length !== e); l = true)
          ;
    } catch (u) {
      c = true, i = u;
    } finally {
      try {
        if (!l && n.return != null && (s = n.return(), Object(s) !== s))
          return;
      } finally {
        if (c)
          throw i;
      }
    }
    return a;
  }
}
function mg(t4, e) {
  (e == null || e > t4.length) && (e = t4.length);
  for (var n = 0, r = Array(e); n < e; n++)
    r[n] = t4[n];
  return r;
}
function kA(t4, e) {
  if (t4) {
    if (typeof t4 == "string")
      return mg(t4, e);
    var n = {}.toString.call(t4).slice(8, -1);
    return n === "Object" && t4.constructor && (n = t4.constructor.name), n === "Map" || n === "Set" ? Array.from(t4) : n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? mg(t4, e) : void 0;
  }
}
function dD() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Le(t4, e) {
  return uD(t4) || fD(t4, e) || kA(t4, e) || dD();
}
function AA(t4, e) {
  if (t4 == null)
    return {};
  var n = {};
  for (var r in t4)
    if ({}.hasOwnProperty.call(t4, r)) {
      if (e.includes(r))
        continue;
      n[r] = t4[r];
    }
  return n;
}
function Mr(t4, e) {
  if (t4 == null)
    return {};
  var n, r, i = AA(t4, e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(t4);
    for (r = 0; r < o.length; r++)
      n = o[r], e.includes(n) || {}.propertyIsEnumerable.call(t4, n) && (i[n] = t4[n]);
  }
  return i;
}
var hD = ["defaultInputValue", "defaultMenuIsOpen", "defaultValue", "inputValue", "menuIsOpen", "onChange", "onInputChange", "onMenuClose", "onMenuOpen", "value"];
function pD(t4) {
  var e = t4.defaultInputValue, n = e === void 0 ? "" : e, r = t4.defaultMenuIsOpen, i = r === void 0 ? false : r, o = t4.defaultValue, s = o === void 0 ? null : o, a = t4.inputValue, l = t4.menuIsOpen, c = t4.onChange, u = t4.onInputChange, f = t4.onMenuClose, d = t4.onMenuOpen, h = t4.value, p = Mr(t4, hD), O = fe(a !== void 0 ? a : n), m = Le(O, 2), x = m[0], v = m[1], y = fe(l !== void 0 ? l : i), S = Le(y, 2), b = S[0], w = S[1], C = fe(h !== void 0 ? h : s), k = Le(C, 2), T = k[0], A = k[1], E = Ue(function(Z, J) {
    typeof c == "function" && c(Z, J), A(Z);
  }, [c]), $ = Ue(function(Z, J) {
    var L;
    typeof u == "function" && (L = u(Z, J)), v(L !== void 0 ? L : Z);
  }, [u]), j = Ue(function() {
    typeof d == "function" && d(), w(true);
  }, [d]), B = Ue(function() {
    typeof f == "function" && f(), w(false);
  }, [f]), D = a !== void 0 ? a : x, N = l !== void 0 ? l : b, z = h !== void 0 ? h : T;
  return se(se({}, p), {}, {
    inputValue: D,
    menuIsOpen: N,
    onChange: E,
    onInputChange: $,
    onMenuClose: B,
    onMenuOpen: j,
    value: z
  });
}
function Ae() {
  return Ae = Object.assign ? Object.assign.bind() : function(t4) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var r in n)
        ({}).hasOwnProperty.call(n, r) && (t4[r] = n[r]);
    }
    return t4;
  }, Ae.apply(null, arguments);
}
function qd(t4, e) {
  if (!(t4 instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function ay(t4, e) {
  for (var n = 0; n < e.length; n++) {
    var r = e[n];
    r.enumerable = r.enumerable || false, r.configurable = true, "value" in r && (r.writable = true), Object.defineProperty(t4, CA(r.key), r);
  }
}
function Ud(t4, e, n) {
  return e && ay(t4.prototype, e), n && ay(t4, n), Object.defineProperty(t4, "prototype", {
    writable: false
  }), t4;
}
function Og(t4, e) {
  return Og = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, r) {
    return n.__proto__ = r, n;
  }, Og(t4, e);
}
function Hd(t4, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Super expression must either be null or a function");
  t4.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: t4,
      writable: true,
      configurable: true
    }
  }), Object.defineProperty(t4, "prototype", {
    writable: false
  }), e && Og(t4, e);
}
function Tf(t4) {
  return Tf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e) {
    return e.__proto__ || Object.getPrototypeOf(e);
  }, Tf(t4);
}
function PA() {
  try {
    var t4 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (PA = function() {
    return !!t4;
  })();
}
function xg(t4) {
  if (t4 === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t4;
}
function gD(t4, e) {
  if (e && (Hr(e) == "object" || typeof e == "function"))
    return e;
  if (e !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return xg(t4);
}
function Jd(t4) {
  var e = PA();
  return function() {
    var n, r = Tf(t4);
    if (e) {
      var i = Tf(this).constructor;
      n = Reflect.construct(r, arguments, i);
    } else
      n = r.apply(this, arguments);
    return gD(this, n);
  };
}
function mD(t4) {
  if (Array.isArray(t4))
    return mg(t4);
}
function OD(t4) {
  if (typeof Symbol < "u" && t4[Symbol.iterator] != null || t4["@@iterator"] != null)
    return Array.from(t4);
}
function xD() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function xa(t4) {
  return mD(t4) || OD(t4) || kA(t4) || xD();
}
function vD(t4) {
  if (t4.sheet)
    return t4.sheet;
  for (var e = 0; e < document.styleSheets.length; e++)
    if (document.styleSheets[e].ownerNode === t4)
      return document.styleSheets[e];
}
function yD(t4) {
  var e = document.createElement("style");
  return e.setAttribute("data-emotion", t4.key), t4.nonce !== void 0 && e.setAttribute("nonce", t4.nonce), e.appendChild(document.createTextNode("")), e.setAttribute("data-s", ""), e;
}
var bD = /* @__PURE__ */ function() {
  function t4(n) {
    var r = this;
    this._insertTag = function(i) {
      var o;
      r.tags.length === 0 ? r.insertionPoint ? o = r.insertionPoint.nextSibling : r.prepend ? o = r.container.firstChild : o = r.before : o = r.tags[r.tags.length - 1].nextSibling, r.container.insertBefore(i, o), r.tags.push(i);
    }, this.isSpeedy = n.speedy === void 0 ? false : n.speedy, this.tags = [], this.ctr = 0, this.nonce = n.nonce, this.key = n.key, this.container = n.container, this.prepend = n.prepend, this.insertionPoint = n.insertionPoint, this.before = null;
  }
  var e = t4.prototype;
  return e.hydrate = function(r) {
    r.forEach(this._insertTag);
  }, e.insert = function(r) {
    this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 && this._insertTag(yD(this));
    var i = this.tags[this.tags.length - 1];
    if (true) {
      var o = r.charCodeAt(0) === 64 && r.charCodeAt(1) === 105;
      o && this._alreadyInsertedOrderInsensitiveRule && console.error(`You're attempting to insert the following rule:
` + r + "\n\n`@import` rules must be before all other types of rules in a stylesheet but other rules have already been inserted. Please ensure that `@import` rules are before all other rules."), this._alreadyInsertedOrderInsensitiveRule = this._alreadyInsertedOrderInsensitiveRule || !o;
    }
    if (this.isSpeedy) {
      var s = vD(i);
      try {
        s.insertRule(r, s.cssRules.length);
      } catch (a) {
        !/:(-moz-placeholder|-moz-focus-inner|-moz-focusring|-ms-input-placeholder|-moz-read-write|-moz-read-only|-ms-clear|-ms-expand|-ms-reveal){/.test(r) && console.error('There was a problem inserting the following rule: "' + r + '"', a);
      }
    } else
      i.appendChild(document.createTextNode(r));
    this.ctr++;
  }, e.flush = function() {
    this.tags.forEach(function(r) {
      return r.parentNode && r.parentNode.removeChild(r);
    }), this.tags = [], this.ctr = 0, this._alreadyInsertedOrderInsensitiveRule = false;
  }, t4;
}();
var Dn = "-ms-";
var If = "-moz-";
var dt = "-webkit-";
var zO = "comm";
var LO = "rule";
var XO = "decl";
var SD = "@import";
var EA = "@keyframes";
var wD = Math.abs;
var Kd = String.fromCharCode;
var CD = Object.assign;
function kD(t4, e) {
  return kn(t4, 0) ^ 45 ? (((e << 2 ^ kn(t4, 0)) << 2 ^ kn(t4, 1)) << 2 ^ kn(t4, 2)) << 2 ^ kn(t4, 3) : 0;
}
function TA(t4) {
  return t4.trim();
}
function AD(t4, e) {
  return (t4 = e.exec(t4)) ? t4[0] : t4;
}
function yt(t4, e, n) {
  return t4.replace(e, n);
}
function vg(t4, e) {
  return t4.indexOf(e);
}
function kn(t4, e) {
  return t4.charCodeAt(e) | 0;
}
function Ul(t4, e, n) {
  return t4.slice(e, n);
}
function hi(t4) {
  return t4.length;
}
function GO(t4) {
  return t4.length;
}
function cu(t4, e) {
  return e.push(t4), t4;
}
function PD(t4, e) {
  return t4.map(e).join("");
}
var eh = 1;
var va = 1;
var IA = 0;
var ar = 0;
var Kt = 0;
var La = "";
function th(t4, e, n, r, i, o, s) {
  return { value: t4, root: e, parent: n, type: r, props: i, children: o, line: eh, column: va, length: s, return: "" };
}
function ul(t4, e) {
  return CD(th("", null, null, "", null, null, 0), t4, { length: -t4.length }, e);
}
function ED() {
  return Kt;
}
function TD() {
  return Kt = ar > 0 ? kn(La, --ar) : 0, va--, Kt === 10 && (va = 1, eh--), Kt;
}
function wr() {
  return Kt = ar < IA ? kn(La, ar++) : 0, va++, Kt === 10 && (va = 1, eh++), Kt;
}
function bi() {
  return kn(La, ar);
}
function ef() {
  return ar;
}
function Tc(t4, e) {
  return Ul(La, t4, e);
}
function Hl(t4) {
  switch (t4) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function $A(t4) {
  return eh = va = 1, IA = hi(La = t4), ar = 0, [];
}
function jA(t4) {
  return La = "", t4;
}
function tf(t4) {
  return TA(Tc(ar - 1, yg(t4 === 91 ? t4 + 2 : t4 === 40 ? t4 + 1 : t4)));
}
function ID(t4) {
  for (; (Kt = bi()) && Kt < 33; )
    wr();
  return Hl(t4) > 2 || Hl(Kt) > 3 ? "" : " ";
}
function $D(t4, e) {
  for (; --e && wr() && !(Kt < 48 || Kt > 102 || Kt > 57 && Kt < 65 || Kt > 70 && Kt < 97); )
    ;
  return Tc(t4, ef() + (e < 6 && bi() == 32 && wr() == 32));
}
function yg(t4) {
  for (; wr(); )
    switch (Kt) {
      case t4:
        return ar;
      case 34:
      case 39:
        t4 !== 34 && t4 !== 39 && yg(Kt);
        break;
      case 40:
        t4 === 41 && yg(t4);
        break;
      case 92:
        wr();
        break;
    }
  return ar;
}
function jD(t4, e) {
  for (; wr() && t4 + Kt !== 57; )
    if (t4 + Kt === 84 && bi() === 47)
      break;
  return "/*" + Tc(e, ar - 1) + "*" + Kd(t4 === 47 ? t4 : wr());
}
function RD(t4) {
  for (; !Hl(bi()); )
    wr();
  return Tc(t4, ar);
}
function DD(t4) {
  return jA(nf("", null, null, null, [""], t4 = $A(t4), 0, [0], t4));
}
function nf(t4, e, n, r, i, o, s, a, l) {
  for (var c = 0, u = 0, f = s, d = 0, h = 0, p = 0, O = 1, m = 1, x = 1, v = 0, y = "", S = i, b = o, w = r, C = y; m; )
    switch (p = v, v = wr()) {
      case 40:
        if (p != 108 && kn(C, f - 1) == 58) {
          vg(C += yt(tf(v), "&", "&\f"), "&\f") != -1 && (x = -1);
          break;
        }
      case 34:
      case 39:
      case 91:
        C += tf(v);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        C += ID(p);
        break;
      case 92:
        C += $D(ef() - 1, 7);
        continue;
      case 47:
        switch (bi()) {
          case 42:
          case 47:
            cu(QD(jD(wr(), ef()), e, n), l);
            break;
          default:
            C += "/";
        }
        break;
      case 123 * O:
        a[c++] = hi(C) * x;
      case 125 * O:
      case 59:
      case 0:
        switch (v) {
          case 0:
          case 125:
            m = 0;
          case 59 + u:
            h > 0 && hi(C) - f && cu(h > 32 ? cy(C + ";", r, n, f - 1) : cy(yt(C, " ", "") + ";", r, n, f - 2), l);
            break;
          case 59:
            C += ";";
          default:
            if (cu(w = ly(C, e, n, c, u, i, a, y, S = [], b = [], f), o), v === 123)
              if (u === 0)
                nf(C, e, w, w, S, o, f, a, b);
              else
                switch (d === 99 && kn(C, 3) === 110 ? 100 : d) {
                  case 100:
                  case 109:
                  case 115:
                    nf(t4, w, w, r && cu(ly(t4, w, w, 0, 0, i, a, y, i, S = [], f), b), i, b, f, a, r ? S : b);
                    break;
                  default:
                    nf(C, w, w, w, [""], b, 0, a, b);
                }
        }
        c = u = h = 0, O = x = 1, y = C = "", f = s;
        break;
      case 58:
        f = 1 + hi(C), h = p;
      default:
        if (O < 1) {
          if (v == 123)
            --O;
          else if (v == 125 && O++ == 0 && TD() == 125)
            continue;
        }
        switch (C += Kd(v), v * O) {
          case 38:
            x = u > 0 ? 1 : (C += "\f", -1);
            break;
          case 44:
            a[c++] = (hi(C) - 1) * x, x = 1;
            break;
          case 64:
            bi() === 45 && (C += tf(wr())), d = bi(), u = f = hi(y = C += RD(ef())), v++;
            break;
          case 45:
            p === 45 && hi(C) == 2 && (O = 0);
        }
    }
  return o;
}
function ly(t4, e, n, r, i, o, s, a, l, c, u) {
  for (var f = i - 1, d = i === 0 ? o : [""], h = GO(d), p = 0, O = 0, m = 0; p < r; ++p)
    for (var x = 0, v = Ul(t4, f + 1, f = wD(O = s[p])), y = t4; x < h; ++x)
      (y = TA(O > 0 ? d[x] + " " + v : yt(v, /&\f/g, d[x]))) && (l[m++] = y);
  return th(t4, e, n, i === 0 ? LO : a, l, c, u);
}
function QD(t4, e, n) {
  return th(t4, e, n, zO, Kd(ED()), Ul(t4, 2, -2), 0);
}
function cy(t4, e, n, r) {
  return th(t4, e, n, XO, Ul(t4, 0, r), Ul(t4, r + 1, -1), r);
}
function ra(t4, e) {
  for (var n = "", r = GO(t4), i = 0; i < r; i++)
    n += e(t4[i], i, t4, e) || "";
  return n;
}
function BD(t4, e, n, r) {
  switch (t4.type) {
    case SD:
    case XO:
      return t4.return = t4.return || t4.value;
    case zO:
      return "";
    case EA:
      return t4.return = t4.value + "{" + ra(t4.children, r) + "}";
    case LO:
      t4.value = t4.props.join(",");
  }
  return hi(n = ra(t4.children, r)) ? t4.return = t4.value + "{" + n + "}" : "";
}
function _D(t4) {
  var e = GO(t4);
  return function(n, r, i, o) {
    for (var s = "", a = 0; a < e; a++)
      s += t4[a](n, r, i, o) || "";
    return s;
  };
}
var ND = function(e, n, r) {
  for (var i = 0, o = 0; i = o, o = bi(), i === 38 && o === 12 && (n[r] = 1), !Hl(o); )
    wr();
  return Tc(e, ar);
};
var FD = function(e, n) {
  var r = -1, i = 44;
  do
    switch (Hl(i)) {
      case 0:
        i === 38 && bi() === 12 && (n[r] = 1), e[r] += ND(ar - 1, n, r);
        break;
      case 2:
        e[r] += tf(i);
        break;
      case 4:
        if (i === 44) {
          e[++r] = bi() === 58 ? "&\f" : "", n[r] = e[r].length;
          break;
        }
      default:
        e[r] += Kd(i);
    }
  while (i = wr());
  return e;
};
var ZD = function(e, n) {
  return jA(FD($A(e), n));
};
var uy = /* @__PURE__ */ new WeakMap();
var WD = function(e) {
  if (!(e.type !== "rule" || !e.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  e.length < 1)) {
    for (var n = e.value, r = e.parent, i = e.column === r.column && e.line === r.line; r.type !== "rule"; )
      if (r = r.parent, !r)
        return;
    if (!(e.props.length === 1 && n.charCodeAt(0) !== 58 && !uy.get(r)) && !i) {
      uy.set(e, true);
      for (var o = [], s = ZD(n, o), a = r.props, l = 0, c = 0; l < s.length; l++)
        for (var u = 0; u < a.length; u++, c++)
          e.props[c] = o[l] ? s[l].replace(/&\f/g, a[u]) : a[u] + " " + s[l];
    }
  }
};
var VD = function(e) {
  if (e.type === "decl") {
    var n = e.value;
    n.charCodeAt(0) === 108 && // charcode for b
    n.charCodeAt(2) === 98 && (e.return = "", e.value = "");
  }
};
var zD = "emotion-disable-server-rendering-unsafe-selector-warning-please-do-not-use-this-the-warning-exists-for-a-reason";
var LD = function(e) {
  return e.type === "comm" && e.children.indexOf(zD) > -1;
};
var XD = function(e) {
  return function(n, r, i) {
    if (!(n.type !== "rule" || e.compat)) {
      var o = n.value.match(/(:first|:nth|:nth-last)-child/g);
      if (o) {
        for (var s = n.parent === i[0], a = s ? i[0].children : (
          // global rule at the root level
          i
        ), l = a.length - 1; l >= 0; l--) {
          var c = a[l];
          if (c.line < n.line)
            break;
          if (c.column < n.column) {
            if (LD(c))
              return;
            break;
          }
        }
        o.forEach(function(u) {
          console.error('The pseudo class "' + u + '" is potentially unsafe when doing server-side rendering. Try changing it to "' + u.split("-child")[0] + '-of-type".');
        });
      }
    }
  };
};
var RA = function(e) {
  return e.type.charCodeAt(1) === 105 && e.type.charCodeAt(0) === 64;
};
var GD = function(e, n) {
  for (var r = e - 1; r >= 0; r--)
    if (!RA(n[r]))
      return true;
  return false;
};
var fy = function(e) {
  e.type = "", e.value = "", e.return = "", e.children = "", e.props = "";
};
var YD = function(e, n, r) {
  RA(e) && (e.parent ? (console.error("`@import` rules can't be nested inside other rules. Please move it to the top level and put it before regular rules. Keep in mind that they can only be used within global styles."), fy(e)) : GD(n, r) && (console.error("`@import` rules can't be after other rules. Please put your `@import` rules before your other rules."), fy(e)));
};
function DA(t4, e) {
  switch (kD(t4, e)) {
    case 5103:
      return dt + "print-" + t4 + t4;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return dt + t4 + t4;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return dt + t4 + If + t4 + Dn + t4 + t4;
    case 6828:
    case 4268:
      return dt + t4 + Dn + t4 + t4;
    case 6165:
      return dt + t4 + Dn + "flex-" + t4 + t4;
    case 5187:
      return dt + t4 + yt(t4, /(\w+).+(:[^]+)/, dt + "box-$1$2" + Dn + "flex-$1$2") + t4;
    case 5443:
      return dt + t4 + Dn + "flex-item-" + yt(t4, /flex-|-self/, "") + t4;
    case 4675:
      return dt + t4 + Dn + "flex-line-pack" + yt(t4, /align-content|flex-|-self/, "") + t4;
    case 5548:
      return dt + t4 + Dn + yt(t4, "shrink", "negative") + t4;
    case 5292:
      return dt + t4 + Dn + yt(t4, "basis", "preferred-size") + t4;
    case 6060:
      return dt + "box-" + yt(t4, "-grow", "") + dt + t4 + Dn + yt(t4, "grow", "positive") + t4;
    case 4554:
      return dt + yt(t4, /([^-])(transform)/g, "$1" + dt + "$2") + t4;
    case 6187:
      return yt(yt(yt(t4, /(zoom-|grab)/, dt + "$1"), /(image-set)/, dt + "$1"), t4, "") + t4;
    case 5495:
    case 3959:
      return yt(t4, /(image-set\([^]*)/, dt + "$1$`$1");
    case 4968:
      return yt(yt(t4, /(.+:)(flex-)?(.*)/, dt + "box-pack:$3" + Dn + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + dt + t4 + t4;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return yt(t4, /(.+)-inline(.+)/, dt + "$1$2") + t4;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (hi(t4) - 1 - e > 6)
        switch (kn(t4, e + 1)) {
          case 109:
            if (kn(t4, e + 4) !== 45)
              break;
          case 102:
            return yt(t4, /(.+:)(.+)-([^]+)/, "$1" + dt + "$2-$3$1" + If + (kn(t4, e + 3) == 108 ? "$3" : "$2-$3")) + t4;
          case 115:
            return ~vg(t4, "stretch") ? DA(yt(t4, "stretch", "fill-available"), e) + t4 : t4;
        }
      break;
    case 4949:
      if (kn(t4, e + 1) !== 115)
        break;
    case 6444:
      switch (kn(t4, hi(t4) - 3 - (~vg(t4, "!important") && 10))) {
        case 107:
          return yt(t4, ":", ":" + dt) + t4;
        case 101:
          return yt(t4, /(.+:)([^;!]+)(;|!.+)?/, "$1" + dt + (kn(t4, 14) === 45 ? "inline-" : "") + "box$3$1" + dt + "$2$3$1" + Dn + "$2box$3") + t4;
      }
      break;
    case 5936:
      switch (kn(t4, e + 11)) {
        case 114:
          return dt + t4 + Dn + yt(t4, /[svh]\w+-[tblr]{2}/, "tb") + t4;
        case 108:
          return dt + t4 + Dn + yt(t4, /[svh]\w+-[tblr]{2}/, "tb-rl") + t4;
        case 45:
          return dt + t4 + Dn + yt(t4, /[svh]\w+-[tblr]{2}/, "lr") + t4;
      }
      return dt + t4 + Dn + t4 + t4;
  }
  return t4;
}
var qD = function(e, n, r, i) {
  if (e.length > -1 && !e.return)
    switch (e.type) {
      case XO:
        e.return = DA(e.value, e.length);
        break;
      case EA:
        return ra([ul(e, {
          value: yt(e.value, "@", "@" + dt)
        })], i);
      case LO:
        if (e.length)
          return PD(e.props, function(o) {
            switch (AD(o, /(::plac\w+|:read-\w+)/)) {
              case ":read-only":
              case ":read-write":
                return ra([ul(e, {
                  props: [yt(o, /:(read-\w+)/, ":" + If + "$1")]
                })], i);
              case "::placeholder":
                return ra([ul(e, {
                  props: [yt(o, /:(plac\w+)/, ":" + dt + "input-$1")]
                }), ul(e, {
                  props: [yt(o, /:(plac\w+)/, ":" + If + "$1")]
                }), ul(e, {
                  props: [yt(o, /:(plac\w+)/, Dn + "input-$1")]
                })], i);
            }
            return "";
          });
    }
};
var UD = [qD];
var HD = function(e) {
  var n = e.key;
  if (!n)
    throw new Error(`You have to configure \`key\` for your cache. Please make sure it's unique (and not equal to 'css') as it's used for linking styles to your cache.
If multiple caches share the same key they might "fight" for each other's style elements.`);
  if (n === "css") {
    var r = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(r, function(O) {
      var m = O.getAttribute("data-emotion");
      m.indexOf(" ") !== -1 && (document.head.appendChild(O), O.setAttribute("data-s", ""));
    });
  }
  var i = e.stylisPlugins || UD;
  if (/[^a-z-]/.test(n))
    throw new Error('Emotion key must only contain lower case alphabetical characters and - but "' + n + '" was passed');
  var o = {}, s, a = [];
  s = e.container || document.head, Array.prototype.forEach.call(
    // this means we will ignore elements which don't have a space in them which
    // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
    document.querySelectorAll('style[data-emotion^="' + n + ' "]'),
    function(O) {
      for (var m = O.getAttribute("data-emotion").split(" "), x = 1; x < m.length; x++)
        o[m[x]] = true;
      a.push(O);
    }
  );
  var l, c = [WD, VD];
  c.push(XD({
    get compat() {
      return p.compat;
    }
  }), YD);
  {
    var u, f = [BD, true ? function(O) {
      O.root || (O.return ? u.insert(O.return) : O.value && O.type !== zO && u.insert(O.value + "{}"));
    } : MD(function(O) {
      u.insert(O);
    })], d = _D(c.concat(i, f)), h = function(m) {
      return ra(DD(m), d);
    };
    l = function(m, x, v, y) {
      u = v, x.map !== void 0 && (u = {
        insert: function(b) {
          v.insert(b + x.map);
        }
      }), h(m ? m + "{" + x.styles + "}" : x.styles), y && (p.inserted[x.name] = true);
    };
  }
  var p = {
    key: n,
    sheet: new bD({
      key: n,
      container: s,
      nonce: e.nonce,
      speedy: e.speedy,
      prepend: e.prepend,
      insertionPoint: e.insertionPoint
    }),
    nonce: e.nonce,
    inserted: o,
    registered: {},
    insert: l
  };
  return p.sheet.hydrate(a), p;
};
var JD = true;
function QA(t4, e, n) {
  var r = "";
  return n.split(" ").forEach(function(i) {
    t4[i] !== void 0 ? e.push(t4[i] + ";") : r += i + " ";
  }), r;
}
var YO = function(e, n, r) {
  var i = e.key + "-" + n.name;
  (r === false || // we need to always store it if we're in compat mode and
  // in node since emotion-server relies on whether a style is in
  // the registered cache to know whether a style is global or not
  // also, note that this check will be dead code eliminated in the browser
  JD === false) && e.registered[i] === void 0 && (e.registered[i] = n.styles);
};
var qO = function(e, n, r) {
  YO(e, n, r);
  var i = e.key + "-" + n.name;
  if (e.inserted[n.name] === void 0) {
    var o = n;
    do
      e.insert(n === o ? "." + i : "", o, e.sheet, true), o = o.next;
    while (o !== void 0);
  }
};
function KD(t4) {
  for (var e = 0, n, r = 0, i = t4.length; i >= 4; ++r, i -= 4)
    n = t4.charCodeAt(r) & 255 | (t4.charCodeAt(++r) & 255) << 8 | (t4.charCodeAt(++r) & 255) << 16 | (t4.charCodeAt(++r) & 255) << 24, n = /* Math.imul(k, m): */
    (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16), n ^= /* k >>> r: */
    n >>> 24, e = /* Math.imul(k, m): */
    (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (e & 65535) * 1540483477 + ((e >>> 16) * 59797 << 16);
  switch (i) {
    case 3:
      e ^= (t4.charCodeAt(r + 2) & 255) << 16;
    case 2:
      e ^= (t4.charCodeAt(r + 1) & 255) << 8;
    case 1:
      e ^= t4.charCodeAt(r) & 255, e = /* Math.imul(h, m): */
      (e & 65535) * 1540483477 + ((e >>> 16) * 59797 << 16);
  }
  return e ^= e >>> 13, e = /* Math.imul(h, m): */
  (e & 65535) * 1540483477 + ((e >>> 16) * 59797 << 16), ((e ^ e >>> 15) >>> 0).toString(36);
}
var eQ = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};
var dy = `You have illegal escape sequence in your template literal, most likely inside content's property value.
Because you write your CSS inside a JavaScript string you actually have to do double escaping, so for example "content: '\\00d7';" should become "content: '\\\\00d7';".
You can read more about this here:
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences`;
var tQ = "You have passed in falsy value as style object's key (can happen when in example you pass unexported component as computed key).";
var nQ = /[A-Z]|^ms/g;
var BA = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
var UO = function(e) {
  return e.charCodeAt(1) === 45;
};
var hy = function(e) {
  return e != null && typeof e != "boolean";
};
var ap = /* @__PURE__ */ sA(function(t4) {
  return UO(t4) ? t4 : t4.replace(nQ, "-$&").toLowerCase();
});
var $f = function(e, n) {
  switch (e) {
    case "animation":
    case "animationName":
      if (typeof n == "string")
        return n.replace(BA, function(r, i, o) {
          return Gr = {
            name: i,
            styles: o,
            next: Gr
          }, i;
        });
  }
  return eQ[e] !== 1 && !UO(e) && typeof n == "number" && n !== 0 ? n + "px" : n;
};
if (true) {
  rQ = /(var|attr|counters?|url|element|(((repeating-)?(linear|radial))|conic)-gradient)\(|(no-)?(open|close)-quote/, iQ = ["normal", "none", "initial", "inherit", "unset"], oQ = $f, sQ = /^-ms-/, aQ = /-(.)/g, py = {};
  $f = function(e, n) {
    if (e === "content" && (typeof n != "string" || iQ.indexOf(n) === -1 && !rQ.test(n) && (n.charAt(0) !== n.charAt(n.length - 1) || n.charAt(0) !== '"' && n.charAt(0) !== "'")))
      throw new Error("You seem to be using a value for 'content' without quotes, try replacing it with `content: '\"" + n + "\"'`");
    var r = oQ(e, n);
    return r !== "" && !UO(e) && e.indexOf("-") !== -1 && py[e] === void 0 && (py[e] = true, console.error("Using kebab-case for css properties in objects is not supported. Did you mean " + e.replace(sQ, "ms-").replace(aQ, function(i, o) {
      return o.toUpperCase();
    }) + "?")), r;
  };
}
var rQ;
var iQ;
var oQ;
var sQ;
var aQ;
var py;
var _A = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
function Jl(t4, e, n) {
  if (n == null)
    return "";
  if (n.__emotion_styles !== void 0) {
    if (n.toString() === "NO_COMPONENT_SELECTOR")
      throw new Error(_A);
    return n;
  }
  switch (typeof n) {
    case "boolean":
      return "";
    case "object": {
      if (n.anim === 1)
        return Gr = {
          name: n.name,
          styles: n.styles,
          next: Gr
        }, n.name;
      if (n.styles !== void 0) {
        var r = n.next;
        if (r !== void 0)
          for (; r !== void 0; )
            Gr = {
              name: r.name,
              styles: r.styles,
              next: Gr
            }, r = r.next;
        var i = n.styles + ";";
        return n.map !== void 0 && (i += n.map), i;
      }
      return lQ(t4, e, n);
    }
    case "function": {
      if (t4 !== void 0) {
        var o = Gr, s = n(t4);
        return Gr = o, Jl(t4, e, s);
      } else
        console.error("Functions that are interpolated in css calls will be stringified.\nIf you want to have a css call based on props, create a function that returns a css call like this\nlet dynamicStyle = (props) => css`color: ${props.color}`\nIt can be called directly with props or interpolated in a styled call like this\nlet SomeComponent = styled('div')`${dynamicStyle}`");
      break;
    }
    case "string":
      if (true) {
        var a = [], l = n.replace(BA, function(u, f, d) {
          var h = "animation" + a.length;
          return a.push("const " + h + " = keyframes`" + d.replace(/^@keyframes animation-\w+/, "") + "`"), "${" + h + "}";
        });
        a.length && console.error("`keyframes` output got interpolated into plain string, please wrap it with `css`.\n\nInstead of doing this:\n\n" + [].concat(a, ["`" + l + "`"]).join(`
`) + `

You should wrap it with \`css\` like this:

` + ("css`" + l + "`"));
      }
      break;
  }
  if (e == null)
    return n;
  var c = e[n];
  return c !== void 0 ? c : n;
}
function lQ(t4, e, n) {
  var r = "";
  if (Array.isArray(n))
    for (var i = 0; i < n.length; i++)
      r += Jl(t4, e, n[i]) + ";";
  else
    for (var o in n) {
      var s = n[o];
      if (typeof s != "object")
        e != null && e[s] !== void 0 ? r += o + "{" + e[s] + "}" : hy(s) && (r += ap(o) + ":" + $f(o, s) + ";");
      else {
        if (o === "NO_COMPONENT_SELECTOR" && true)
          throw new Error(_A);
        if (Array.isArray(s) && typeof s[0] == "string" && (e == null || e[s[0]] === void 0))
          for (var a = 0; a < s.length; a++)
            hy(s[a]) && (r += ap(o) + ":" + $f(o, s[a]) + ";");
        else {
          var l = Jl(t4, e, s);
          switch (o) {
            case "animation":
            case "animationName": {
              r += ap(o) + ":" + l + ";";
              break;
            }
            default:
              o === "undefined" && console.error(tQ), r += o + "{" + l + "}";
          }
        }
      }
    }
  return r;
}
var gy = /label:\s*([^\s;\n{]+)\s*(;|$)/g;
var MA;
MA = /\/\*#\ssourceMappingURL=data:application\/json;\S+\s+\*\//g;
var Gr;
var Kl = function(e, n, r) {
  if (e.length === 1 && typeof e[0] == "object" && e[0] !== null && e[0].styles !== void 0)
    return e[0];
  var i = true, o = "";
  Gr = void 0;
  var s = e[0];
  s == null || s.raw === void 0 ? (i = false, o += Jl(r, n, s)) : (s[0] === void 0 && console.error(dy), o += s[0]);
  for (var a = 1; a < e.length; a++)
    o += Jl(r, n, e[a]), i && (s[a] === void 0 && console.error(dy), o += s[a]);
  var l;
  o = o.replace(MA, function(d) {
    return l = d, "";
  }), gy.lastIndex = 0;
  for (var c = "", u; (u = gy.exec(o)) !== null; )
    c += "-" + // $FlowFixMe we know it's not null
    u[1];
  var f = KD(o) + c;
  return true ? {
    name: f,
    styles: o,
    map: l,
    next: Gr,
    toString: function() {
      return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
    }
  } : {
    name: f,
    styles: o,
    next: Gr
  };
};
var cQ = function(e) {
  return e();
};
var NA = q.useInsertionEffect ? q.useInsertionEffect : false;
var FA = NA || cQ;
var my = NA || q.useLayoutEffect;
var HO = {}.hasOwnProperty;
var JO = /* @__PURE__ */ Ac(
  // we're doing this to avoid preconstruct's dead code elimination in this one case
  // because this module is primarily intended for the browser and node
  // but it's also required in react native and similar environments sometimes
  // and we could have a special build just for that
  // but this is much easier and the native packages
  // might use a different theme context in the future anyway
  typeof HTMLElement < "u" ? /* @__PURE__ */ HD({
    key: "css"
  }) : null
);
JO.displayName = "EmotionCacheContext";
JO.Provider;
var KO = function(e) {
  return /* @__PURE__ */ xs(function(n, r) {
    var i = Ii(JO);
    return e(n, i, r);
  });
};
var nh = /* @__PURE__ */ Ac({});
nh.displayName = "EmotionThemeContext";
var Oy = function(e) {
  var n = e.split(".");
  return n[n.length - 1];
};
var uQ = function(e) {
  var n = /^\s+at\s+([A-Za-z0-9$.]+)\s/.exec(e);
  if (n || (n = /^([A-Za-z0-9$.]+)@/.exec(e), n))
    return Oy(n[1]);
};
var fQ = /* @__PURE__ */ new Set(["renderWithHooks", "processChild", "finishClassComponent", "renderToString"]);
var dQ = function(e) {
  return e.replace(/\$/g, "-");
};
var hQ = function(e) {
  if (e)
    for (var n = e.split(`
`), r = 0; r < n.length; r++) {
      var i = uQ(n[r]);
      if (i) {
        if (fQ.has(i))
          break;
        if (/^[A-Z]/.test(i))
          return dQ(i);
      }
    }
};
var bg = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__";
var Sg = "__EMOTION_LABEL_PLEASE_DO_NOT_USE__";
var pQ = function(e, n) {
  if (typeof n.css == "string" && // check if there is a css declaration
  n.css.indexOf(":") !== -1)
    throw new Error("Strings are not allowed as css prop values, please wrap it in a css template literal from '@emotion/react' like this: css`" + n.css + "`");
  var r = {};
  for (var i in n)
    HO.call(n, i) && (r[i] = n[i]);
  if (r[bg] = e, n.css && (typeof n.css != "object" || typeof n.css.name != "string" || n.css.name.indexOf("-") === -1)) {
    var o = hQ(new Error().stack);
    o && (r[Sg] = o);
  }
  return r;
};
var gQ = function(e) {
  var n = e.cache, r = e.serialized, i = e.isStringTag;
  return YO(n, r, i), FA(function() {
    return qO(n, r, i);
  }), null;
};
var ZA = /* @__PURE__ */ KO(function(t4, e, n) {
  var r = t4.css;
  typeof r == "string" && e.registered[r] !== void 0 && (r = e.registered[r]);
  var i = t4[bg], o = [r], s = "";
  typeof t4.className == "string" ? s = QA(e.registered, o, t4.className) : t4.className != null && (s = t4.className + " ");
  var a = Kl(o, void 0, Ii(nh));
  if (a.name.indexOf("-") === -1) {
    var l = t4[Sg];
    l && (a = Kl([a, "label:" + l + ";"]));
  }
  s += e.key + "-" + a.name;
  var c = {};
  for (var u in t4)
    HO.call(t4, u) && u !== "css" && u !== bg && u !== Sg && (c[u] = t4[u]);
  return c.ref = n, c.className = s, /* @__PURE__ */ Xi(_r, null, /* @__PURE__ */ Xi(gQ, {
    cache: e,
    serialized: a,
    isStringTag: typeof i == "string"
  }), /* @__PURE__ */ Xi(i, c));
});
ZA.displayName = "EmotionCssPropInternal";
var mQ = {
  name: "@emotion/react",
  version: "11.10.6",
  main: "dist/emotion-react.cjs.js",
  module: "dist/emotion-react.esm.js",
  browser: {
    "./dist/emotion-react.esm.js": "./dist/emotion-react.browser.esm.js"
  },
  exports: {
    ".": {
      module: {
        worker: "./dist/emotion-react.worker.esm.js",
        browser: "./dist/emotion-react.browser.esm.js",
        default: "./dist/emotion-react.esm.js"
      },
      default: "./dist/emotion-react.cjs.js"
    },
    "./jsx-runtime": {
      module: {
        worker: "./jsx-runtime/dist/emotion-react-jsx-runtime.worker.esm.js",
        browser: "./jsx-runtime/dist/emotion-react-jsx-runtime.browser.esm.js",
        default: "./jsx-runtime/dist/emotion-react-jsx-runtime.esm.js"
      },
      default: "./jsx-runtime/dist/emotion-react-jsx-runtime.cjs.js"
    },
    "./_isolated-hnrs": {
      module: {
        worker: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.worker.esm.js",
        browser: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.esm.js",
        default: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.esm.js"
      },
      default: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.cjs.js"
    },
    "./jsx-dev-runtime": {
      module: {
        worker: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.worker.esm.js",
        browser: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.browser.esm.js",
        default: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.esm.js"
      },
      default: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.cjs.js"
    },
    "./package.json": "./package.json",
    "./types/css-prop": "./types/css-prop.d.ts",
    "./macro": "./macro.js"
  },
  types: "types/index.d.ts",
  files: [
    "src",
    "dist",
    "jsx-runtime",
    "jsx-dev-runtime",
    "_isolated-hnrs",
    "types/*.d.ts",
    "macro.js",
    "macro.d.ts",
    "macro.js.flow"
  ],
  sideEffects: false,
  author: "Emotion Contributors",
  license: "MIT",
  scripts: {
    "test:typescript": "dtslint types"
  },
  dependencies: {
    "@babel/runtime": "^7.18.3",
    "@emotion/babel-plugin": "^11.10.6",
    "@emotion/cache": "^11.10.5",
    "@emotion/serialize": "^1.1.1",
    "@emotion/use-insertion-effect-with-fallbacks": "^1.0.0",
    "@emotion/utils": "^1.2.0",
    "@emotion/weak-memoize": "^0.3.0",
    "hoist-non-react-statics": "^3.3.1"
  },
  peerDependencies: {
    react: ">=16.8.0"
  },
  peerDependenciesMeta: {
    "@types/react": {
      optional: true
    }
  },
  devDependencies: {
    "@definitelytyped/dtslint": "0.0.112",
    "@emotion/css": "11.10.6",
    "@emotion/css-prettifier": "1.1.1",
    "@emotion/server": "11.10.0",
    "@emotion/styled": "11.10.6",
    "html-tag-names": "^1.1.2",
    react: "16.14.0",
    "svg-tag-names": "^1.1.1",
    typescript: "^4.5.5"
  },
  repository: "https://github.com/emotion-js/emotion/tree/main/packages/react",
  publishConfig: {
    access: "public"
  },
  "umd:main": "dist/emotion-react.umd.min.js",
  preconstruct: {
    entrypoints: [
      "./index.js",
      "./jsx-runtime.js",
      "./jsx-dev-runtime.js",
      "./_isolated-hnrs.js"
    ],
    umdName: "emotionReact",
    exports: {
      envConditions: [
        "browser",
        "worker"
      ],
      extra: {
        "./types/css-prop": "./types/css-prop.d.ts",
        "./macro": "./macro.js"
      }
    }
  }
};
var Pe = function(e, n) {
  var r = arguments;
  if (n == null || !HO.call(n, "css"))
    return Xi.apply(void 0, r);
  var i = r.length, o = new Array(i);
  o[0] = ZA, o[1] = pQ(e, n);
  for (var s = 2; s < i; s++)
    o[s] = r[s];
  return Xi.apply(null, o);
};
var xy = false;
var OQ = /* @__PURE__ */ KO(function(t4, e) {
  !xy && // check for className as well since the user is
  // probably using the custom createElement which
  // means it will be turned into a className prop
  // $FlowFixMe I don't really want to add it to the type since it shouldn't be used
  (t4.className || t4.css) && (console.error("It looks like you're using the css prop on Global, did you mean to use the styles prop instead?"), xy = true);
  var n = t4.styles, r = Kl([n], void 0, Ii(nh)), i = Ke();
  return my(function() {
    var o = e.key + "-global", s = new e.sheet.constructor({
      key: o,
      nonce: e.sheet.nonce,
      container: e.sheet.container,
      speedy: e.sheet.isSpeedy
    }), a = false, l = document.querySelector('style[data-emotion="' + o + " " + r.name + '"]');
    return e.sheet.tags.length && (s.before = e.sheet.tags[0]), l !== null && (a = true, l.setAttribute("data-emotion", o), s.hydrate([l])), i.current = [s, a], function() {
      s.flush();
    };
  }, [e]), my(function() {
    var o = i.current, s = o[0], a = o[1];
    if (a) {
      o[1] = false;
      return;
    }
    if (r.next !== void 0 && qO(e, r.next, true), s.tags.length) {
      var l = s.tags[s.tags.length - 1].nextElementSibling;
      s.before = l, s.flush();
    }
    e.insert("", r, s, false);
  }, [e, r.name]), null;
});
OQ.displayName = "EmotionGlobal";
function ex() {
  for (var t4 = arguments.length, e = new Array(t4), n = 0; n < t4; n++)
    e[n] = arguments[n];
  return Kl(e);
}
var xQ = function() {
  var e = ex.apply(void 0, arguments), n = "animation-" + e.name;
  return {
    name: n,
    styles: "@keyframes " + n + "{" + e.styles + "}",
    anim: 1,
    toString: function() {
      return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
    }
  };
};
var vQ = function t(e) {
  for (var n = e.length, r = 0, i = ""; r < n; r++) {
    var o = e[r];
    if (o != null) {
      var s = void 0;
      switch (typeof o) {
        case "boolean":
          break;
        case "object": {
          if (Array.isArray(o))
            s = t(o);
          else {
            o.styles !== void 0 && o.name !== void 0 && console.error("You have passed styles created with `css` from `@emotion/react` package to the `cx`.\n`cx` is meant to compose class names (strings) so you should convert those styles to a class name by passing them to the `css` received from <ClassNames/> component."), s = "";
            for (var a in o)
              o[a] && a && (s && (s += " "), s += a);
          }
          break;
        }
        default:
          s = o;
      }
      s && (i && (i += " "), i += s);
    }
  }
  return i;
};
function yQ(t4, e, n) {
  var r = [], i = QA(t4, r, n);
  return r.length < 2 ? n : i + e(r);
}
var bQ = function(e) {
  var n = e.cache, r = e.serializedArr;
  return FA(function() {
    for (var i = 0; i < r.length; i++)
      qO(n, r[i], false);
  }), null;
};
var SQ = /* @__PURE__ */ KO(function(t4, e) {
  var n = false, r = [], i = function() {
    if (n && true)
      throw new Error("css can only be used during render");
    for (var c = arguments.length, u = new Array(c), f = 0; f < c; f++)
      u[f] = arguments[f];
    var d = Kl(u, e.registered);
    return r.push(d), YO(e, d, false), e.key + "-" + d.name;
  }, o = function() {
    if (n && true)
      throw new Error("cx can only be used during render");
    for (var c = arguments.length, u = new Array(c), f = 0; f < c; f++)
      u[f] = arguments[f];
    return yQ(e.registered, i, vQ(u));
  }, s = {
    css: i,
    cx: o,
    theme: Ii(nh)
  }, a = t4.children(s);
  return n = true, /* @__PURE__ */ Xi(_r, null, /* @__PURE__ */ Xi(bQ, {
    cache: e,
    serializedArr: r
  }), a);
});
SQ.displayName = "EmotionClassNames";
if (true) {
  vy = true, wQ = typeof jest < "u" || typeof vi < "u";
  if (vy && !wQ) {
    yy = // $FlowIgnore
    typeof globalThis < "u" ? globalThis : vy ? window : global, by = "__EMOTION_REACT_" + mQ.version.split(".")[0] + "__";
    yy[by] && console.warn("You are loading @emotion/react when it is already loaded. Running multiple instances may cause problems. This can happen if multiple versions are used, or if multiple builds of the same version are used."), yy[by] = true;
  }
}
var vy;
var wQ;
var yy;
var by;
function CQ(t4, e) {
  return e || (e = t4.slice(0)), Object.freeze(Object.defineProperties(t4, {
    raw: {
      value: Object.freeze(e)
    }
  }));
}
var kQ = Math.min;
var AQ = Math.max;
var jf = Math.round;
var uu = Math.floor;
var Rf = (t4) => ({
  x: t4,
  y: t4
});
function PQ(t4) {
  return {
    ...t4,
    top: t4.y,
    left: t4.x,
    right: t4.x + t4.width,
    bottom: t4.y + t4.height
  };
}
function WA(t4) {
  return zA(t4) ? (t4.nodeName || "").toLowerCase() : "#document";
}
function qi(t4) {
  var e;
  return (t4 == null || (e = t4.ownerDocument) == null ? void 0 : e.defaultView) || window;
}
function VA(t4) {
  var e;
  return (e = (zA(t4) ? t4.ownerDocument : t4.document) || window.document) == null ? void 0 : e.documentElement;
}
function zA(t4) {
  return t4 instanceof Node || t4 instanceof qi(t4).Node;
}
function EQ(t4) {
  return t4 instanceof Element || t4 instanceof qi(t4).Element;
}
function tx(t4) {
  return t4 instanceof HTMLElement || t4 instanceof qi(t4).HTMLElement;
}
function Sy(t4) {
  return typeof ShadowRoot > "u" ? false : t4 instanceof ShadowRoot || t4 instanceof qi(t4).ShadowRoot;
}
function LA(t4) {
  const {
    overflow: e,
    overflowX: n,
    overflowY: r,
    display: i
  } = nx(t4);
  return /auto|scroll|overlay|hidden|clip/.test(e + r + n) && !["inline", "contents"].includes(i);
}
function TQ() {
  return typeof CSS > "u" || !CSS.supports ? false : CSS.supports("-webkit-backdrop-filter", "none");
}
function IQ(t4) {
  return ["html", "body", "#document"].includes(WA(t4));
}
function nx(t4) {
  return qi(t4).getComputedStyle(t4);
}
function $Q(t4) {
  if (WA(t4) === "html")
    return t4;
  const e = (
    // Step into the shadow DOM of the parent of a slotted node.
    t4.assignedSlot || // DOM Element detected.
    t4.parentNode || // ShadowRoot detected.
    Sy(t4) && t4.host || // Fallback.
    VA(t4)
  );
  return Sy(e) ? e.host : e;
}
function XA(t4) {
  const e = $Q(t4);
  return IQ(e) ? t4.ownerDocument ? t4.ownerDocument.body : t4.body : tx(e) && LA(e) ? e : XA(e);
}
function Df(t4, e, n) {
  var r;
  e === void 0 && (e = []), n === void 0 && (n = true);
  const i = XA(t4), o = i === ((r = t4.ownerDocument) == null ? void 0 : r.body), s = qi(i);
  return o ? e.concat(s, s.visualViewport || [], LA(i) ? i : [], s.frameElement && n ? Df(s.frameElement) : []) : e.concat(i, Df(i, [], n));
}
function jQ(t4) {
  const e = nx(t4);
  let n = parseFloat(e.width) || 0, r = parseFloat(e.height) || 0;
  const i = tx(t4), o = i ? t4.offsetWidth : n, s = i ? t4.offsetHeight : r, a = jf(n) !== o || jf(r) !== s;
  return a && (n = o, r = s), {
    width: n,
    height: r,
    $: a
  };
}
function rx(t4) {
  return EQ(t4) ? t4 : t4.contextElement;
}
function wy(t4) {
  const e = rx(t4);
  if (!tx(e))
    return Rf(1);
  const n = e.getBoundingClientRect(), {
    width: r,
    height: i,
    $: o
  } = jQ(e);
  let s = (o ? jf(n.width) : n.width) / r, a = (o ? jf(n.height) : n.height) / i;
  return (!s || !Number.isFinite(s)) && (s = 1), (!a || !Number.isFinite(a)) && (a = 1), {
    x: s,
    y: a
  };
}
var RQ = /* @__PURE__ */ Rf(0);
function DQ(t4) {
  const e = qi(t4);
  return !TQ() || !e.visualViewport ? RQ : {
    x: e.visualViewport.offsetLeft,
    y: e.visualViewport.offsetTop
  };
}
function QQ(t4, e, n) {
  return false;
}
function Cy(t4, e, n, r) {
  e === void 0 && (e = false);
  const i = t4.getBoundingClientRect(), o = rx(t4);
  let s = Rf(1);
  e && (s = wy(t4));
  const a = QQ() ? DQ(o) : Rf(0);
  let l = (i.left + a.x) / s.x, c = (i.top + a.y) / s.y, u = i.width / s.x, f = i.height / s.y;
  if (o) {
    const d = qi(o), h = r;
    let p = d.frameElement;
    for (; p && r && h !== d; ) {
      const O = wy(p), m = p.getBoundingClientRect(), x = nx(p), v = m.left + (p.clientLeft + parseFloat(x.paddingLeft)) * O.x, y = m.top + (p.clientTop + parseFloat(x.paddingTop)) * O.y;
      l *= O.x, c *= O.y, u *= O.x, f *= O.y, l += v, c += y, p = qi(p).frameElement;
    }
  }
  return PQ({
    width: u,
    height: f,
    x: l,
    y: c
  });
}
function BQ(t4, e) {
  let n = null, r;
  const i = VA(t4);
  function o() {
    clearTimeout(r), n && n.disconnect(), n = null;
  }
  function s(a, l) {
    a === void 0 && (a = false), l === void 0 && (l = 1), o();
    const {
      left: c,
      top: u,
      width: f,
      height: d
    } = t4.getBoundingClientRect();
    if (a || e(), !f || !d)
      return;
    const h = uu(u), p = uu(i.clientWidth - (c + f)), O = uu(i.clientHeight - (u + d)), m = uu(c), v = {
      rootMargin: -h + "px " + -p + "px " + -O + "px " + -m + "px",
      threshold: AQ(0, kQ(1, l)) || 1
    };
    let y = true;
    function S(b) {
      const w = b[0].intersectionRatio;
      if (w !== l) {
        if (!y)
          return s();
        w ? s(false, w) : r = setTimeout(() => {
          s(false, 1e-7);
        }, 100);
      }
      y = false;
    }
    try {
      n = new IntersectionObserver(S, {
        ...v,
        // Handle <iframe>s
        root: i.ownerDocument
      });
    } catch {
      n = new IntersectionObserver(S, v);
    }
    n.observe(t4);
  }
  return s(true), o;
}
function _Q(t4, e, n, r) {
  r === void 0 && (r = {});
  const {
    ancestorScroll: i = true,
    ancestorResize: o = true,
    elementResize: s = typeof ResizeObserver == "function",
    layoutShift: a = typeof IntersectionObserver == "function",
    animationFrame: l = false
  } = r, c = rx(t4), u = i || o ? [...c ? Df(c) : [], ...Df(e)] : [];
  u.forEach((x) => {
    i && x.addEventListener("scroll", n, {
      passive: true
    }), o && x.addEventListener("resize", n);
  });
  const f = c && a ? BQ(c, n) : null;
  let d = -1, h = null;
  s && (h = new ResizeObserver((x) => {
    let [v] = x;
    v && v.target === c && h && (h.unobserve(e), cancelAnimationFrame(d), d = requestAnimationFrame(() => {
      h && h.observe(e);
    })), n();
  }), c && !l && h.observe(c), h.observe(e));
  let p, O = l ? Cy(t4) : null;
  l && m();
  function m() {
    const x = Cy(t4);
    O && (x.x !== O.x || x.y !== O.y || x.width !== O.width || x.height !== O.height) && n(), O = x, p = requestAnimationFrame(m);
  }
  return n(), () => {
    u.forEach((x) => {
      i && x.removeEventListener("scroll", n), o && x.removeEventListener("resize", n);
    }), f && f(), h && h.disconnect(), h = null, l && cancelAnimationFrame(p);
  };
}
var wg = qk;
var MQ = ["className", "clearValue", "cx", "getStyles", "getClassNames", "getValue", "hasValue", "isMulti", "isRtl", "options", "selectOption", "selectProps", "setValue", "theme"];
var Qf = function() {
};
function NQ(t4, e) {
  return e ? e[0] === "-" ? t4 + e : t4 + "__" + e : t4;
}
function FQ(t4, e) {
  for (var n = arguments.length, r = new Array(n > 2 ? n - 2 : 0), i = 2; i < n; i++)
    r[i - 2] = arguments[i];
  var o = [].concat(r);
  if (e && t4)
    for (var s in e)
      e.hasOwnProperty(s) && e[s] && o.push("".concat(NQ(t4, s)));
  return o.filter(function(a) {
    return a;
  }).map(function(a) {
    return String(a).trim();
  }).join(" ");
}
var ky = function(e) {
  return qQ(e) ? e.filter(Boolean) : Hr(e) === "object" && e !== null ? [e] : [];
};
var GA = function(e) {
  e.className, e.clearValue, e.cx, e.getStyles, e.getClassNames, e.getValue, e.hasValue, e.isMulti, e.isRtl, e.options, e.selectOption, e.selectProps, e.setValue, e.theme;
  var n = Mr(e, MQ);
  return se({}, n);
};
var Xt = function(e, n, r) {
  var i = e.cx, o = e.getStyles, s = e.getClassNames, a = e.className;
  return {
    css: o(n, e),
    className: i(r ?? {}, s(n, e), a)
  };
};
function rh(t4) {
  return [document.documentElement, document.body, window].indexOf(t4) > -1;
}
function ZQ(t4) {
  return rh(t4) ? window.innerHeight : t4.clientHeight;
}
function YA(t4) {
  return rh(t4) ? window.pageYOffset : t4.scrollTop;
}
function Bf(t4, e) {
  if (rh(t4)) {
    window.scrollTo(0, e);
    return;
  }
  t4.scrollTop = e;
}
function WQ(t4) {
  var e = getComputedStyle(t4), n = e.position === "absolute", r = /(auto|scroll)/;
  if (e.position === "fixed")
    return document.documentElement;
  for (var i = t4; i = i.parentElement; )
    if (e = getComputedStyle(i), !(n && e.position === "static") && r.test(e.overflow + e.overflowY + e.overflowX))
      return i;
  return document.documentElement;
}
function VQ(t4, e, n, r) {
  return n * ((t4 = t4 / r - 1) * t4 * t4 + 1) + e;
}
function fu(t4, e) {
  var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 200, r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : Qf, i = YA(t4), o = e - i, s = 10, a = 0;
  function l() {
    a += s;
    var c = VQ(a, i, o, n);
    Bf(t4, c), a < n ? window.requestAnimationFrame(l) : r(t4);
  }
  l();
}
function Ay(t4, e) {
  var n = t4.getBoundingClientRect(), r = e.getBoundingClientRect(), i = e.offsetHeight / 3;
  r.bottom + i > n.bottom ? Bf(t4, Math.min(e.offsetTop + e.clientHeight - t4.offsetHeight + i, t4.scrollHeight)) : r.top - i < n.top && Bf(t4, Math.max(e.offsetTop - i, 0));
}
function zQ(t4) {
  var e = t4.getBoundingClientRect();
  return {
    bottom: e.bottom,
    height: e.height,
    left: e.left,
    right: e.right,
    top: e.top,
    width: e.width
  };
}
function Py() {
  try {
    return document.createEvent("TouchEvent"), true;
  } catch {
    return false;
  }
}
function LQ() {
  try {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  } catch {
    return false;
  }
}
var qA = false;
var XQ = {
  get passive() {
    return qA = true;
  }
};
var du = typeof window < "u" ? window : {};
du.addEventListener && du.removeEventListener && (du.addEventListener("p", Qf, XQ), du.removeEventListener("p", Qf, false));
var GQ = qA;
function YQ(t4) {
  return t4 != null;
}
function qQ(t4) {
  return Array.isArray(t4);
}
function hu(t4, e, n) {
  return t4 ? e : n;
}
var UQ = function(e) {
  for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++)
    r[i - 1] = arguments[i];
  var o = Object.entries(e).filter(function(s) {
    var a = Le(s, 1), l = a[0];
    return !r.includes(l);
  });
  return o.reduce(function(s, a) {
    var l = Le(a, 2), c = l[0], u = l[1];
    return s[c] = u, s;
  }, {});
};
var HQ = ["children", "innerProps"];
var JQ = ["children", "innerProps"];
function KQ(t4) {
  var e = t4.maxHeight, n = t4.menuEl, r = t4.minHeight, i = t4.placement, o = t4.shouldScroll, s = t4.isFixedPosition, a = t4.controlHeight, l = WQ(n), c = {
    placement: "bottom",
    maxHeight: e
  };
  if (!n || !n.offsetParent)
    return c;
  var u = l.getBoundingClientRect(), f = u.height, d = n.getBoundingClientRect(), h = d.bottom, p = d.height, O = d.top, m = n.offsetParent.getBoundingClientRect(), x = m.top, v = s ? window.innerHeight : ZQ(l), y = YA(l), S = parseInt(getComputedStyle(n).marginBottom, 10), b = parseInt(getComputedStyle(n).marginTop, 10), w = x - b, C = v - O, k = w + y, T = f - y - O, A = h - v + y + S, E = y + O - b, $ = 160;
  switch (i) {
    case "auto":
    case "bottom":
      if (C >= p)
        return {
          placement: "bottom",
          maxHeight: e
        };
      if (T >= p && !s)
        return o && fu(l, A, $), {
          placement: "bottom",
          maxHeight: e
        };
      if (!s && T >= r || s && C >= r) {
        o && fu(l, A, $);
        var j = s ? C - S : T - S;
        return {
          placement: "bottom",
          maxHeight: j
        };
      }
      if (i === "auto" || s) {
        var B = e, D = s ? w : k;
        return D >= r && (B = Math.min(D - S - a, e)), {
          placement: "top",
          maxHeight: B
        };
      }
      if (i === "bottom")
        return o && Bf(l, A), {
          placement: "bottom",
          maxHeight: e
        };
      break;
    case "top":
      if (w >= p)
        return {
          placement: "top",
          maxHeight: e
        };
      if (k >= p && !s)
        return o && fu(l, E, $), {
          placement: "top",
          maxHeight: e
        };
      if (!s && k >= r || s && w >= r) {
        var N = e;
        return (!s && k >= r || s && w >= r) && (N = s ? w - b : k - b), o && fu(l, E, $), {
          placement: "top",
          maxHeight: N
        };
      }
      return {
        placement: "bottom",
        maxHeight: e
      };
    default:
      throw new Error('Invalid placement provided "'.concat(i, '".'));
  }
  return c;
}
function e3(t4) {
  var e = {
    bottom: "top",
    top: "bottom"
  };
  return t4 ? e[t4] : "bottom";
}
var UA = function(e) {
  return e === "auto" ? "bottom" : e;
};
var t3 = function(e, n) {
  var r, i = e.placement, o = e.theme, s = o.borderRadius, a = o.spacing, l = o.colors;
  return se((r = {
    label: "menu"
  }, cn(r, e3(i), "100%"), cn(r, "position", "absolute"), cn(r, "width", "100%"), cn(r, "zIndex", 1), r), n ? {} : {
    backgroundColor: l.neutral0,
    borderRadius: s,
    boxShadow: "0 0 0 1px hsla(0, 0%, 0%, 0.1), 0 4px 11px hsla(0, 0%, 0%, 0.1)",
    marginBottom: a.menuGutter,
    marginTop: a.menuGutter
  });
};
var HA = /* @__PURE__ */ Ac(null);
var n3 = function(e) {
  var n = e.children, r = e.minMenuHeight, i = e.maxMenuHeight, o = e.menuPlacement, s = e.menuPosition, a = e.menuShouldScrollIntoView, l = e.theme, c = Ii(HA) || {}, u = c.setPortalPlacement, f = Ke(null), d = fe(i), h = Le(d, 2), p = h[0], O = h[1], m = fe(null), x = Le(m, 2), v = x[0], y = x[1], S = l.spacing.controlHeight;
  return wg(function() {
    var b = f.current;
    if (b) {
      var w = s === "fixed", C = a && !w, k = KQ({
        maxHeight: i,
        menuEl: b,
        minHeight: r,
        placement: o,
        shouldScroll: C,
        isFixedPosition: w,
        controlHeight: S
      });
      O(k.maxHeight), y(k.placement), u == null || u(k.placement);
    }
  }, [i, o, s, a, r, u, S]), n({
    ref: f,
    placerProps: se(se({}, e), {}, {
      placement: v || UA(o),
      maxHeight: p
    })
  });
};
var r3 = function(e) {
  var n = e.children, r = e.innerRef, i = e.innerProps;
  return Pe("div", Ae({}, Xt(e, "menu", {
    menu: true
  }), {
    ref: r
  }, i), n);
};
var i3 = r3;
var o3 = function(e, n) {
  var r = e.maxHeight, i = e.theme.spacing.baseUnit;
  return se({
    maxHeight: r,
    overflowY: "auto",
    position: "relative",
    // required for offset[Height, Top] > keyboard scroll
    WebkitOverflowScrolling: "touch"
  }, n ? {} : {
    paddingBottom: i,
    paddingTop: i
  });
};
var s3 = function(e) {
  var n = e.children, r = e.innerProps, i = e.innerRef, o = e.isMulti;
  return Pe("div", Ae({}, Xt(e, "menuList", {
    "menu-list": true,
    "menu-list--is-multi": o
  }), {
    ref: i
  }, r), n);
};
var JA = function(e, n) {
  var r = e.theme, i = r.spacing.baseUnit, o = r.colors;
  return se({
    textAlign: "center"
  }, n ? {} : {
    color: o.neutral40,
    padding: "".concat(i * 2, "px ").concat(i * 3, "px")
  });
};
var a3 = JA;
var l3 = JA;
var c3 = function(e) {
  var n = e.children, r = n === void 0 ? "No options" : n, i = e.innerProps, o = Mr(e, HQ);
  return Pe("div", Ae({}, Xt(se(se({}, o), {}, {
    children: r,
    innerProps: i
  }), "noOptionsMessage", {
    "menu-notice": true,
    "menu-notice--no-options": true
  }), i), r);
};
var u3 = function(e) {
  var n = e.children, r = n === void 0 ? "Loading..." : n, i = e.innerProps, o = Mr(e, JQ);
  return Pe("div", Ae({}, Xt(se(se({}, o), {}, {
    children: r,
    innerProps: i
  }), "loadingMessage", {
    "menu-notice": true,
    "menu-notice--loading": true
  }), i), r);
};
var f3 = function(e) {
  var n = e.rect, r = e.offset, i = e.position;
  return {
    left: n.left,
    position: i,
    top: r,
    width: n.width,
    zIndex: 1
  };
};
var d3 = function(e) {
  var n = e.appendTo, r = e.children, i = e.controlElement, o = e.innerProps, s = e.menuPlacement, a = e.menuPosition, l = Ke(null), c = Ke(null), u = fe(UA(s)), f = Le(u, 2), d = f[0], h = f[1], p = We(function() {
    return {
      setPortalPlacement: h
    };
  }, []), O = fe(null), m = Le(O, 2), x = m[0], v = m[1], y = Ue(function() {
    if (i) {
      var C = zQ(i), k = a === "fixed" ? 0 : window.pageYOffset, T = C[d] + k;
      (T !== (x == null ? void 0 : x.offset) || C.left !== (x == null ? void 0 : x.rect.left) || C.width !== (x == null ? void 0 : x.rect.width)) && v({
        offset: T,
        rect: C
      });
    }
  }, [i, a, d, x == null ? void 0 : x.offset, x == null ? void 0 : x.rect.left, x == null ? void 0 : x.rect.width]);
  wg(function() {
    y();
  }, [y]);
  var S = Ue(function() {
    typeof c.current == "function" && (c.current(), c.current = null), i && l.current && (c.current = _Q(i, l.current, y, {
      elementResize: "ResizeObserver" in window
    }));
  }, [i, y]);
  wg(function() {
    S();
  }, [S]);
  var b = Ue(function(C) {
    l.current = C, S();
  }, [S]);
  if (!n && a !== "fixed" || !x)
    return null;
  var w = Pe("div", Ae({
    ref: b
  }, Xt(se(se({}, e), {}, {
    offset: x.offset,
    position: a,
    rect: x.rect
  }), "menuPortal", {
    "menu-portal": true
  }), o), r);
  return Pe(HA.Provider, {
    value: p
  }, n ? /* @__PURE__ */ (0, import_react_dom.createPortal)(w, n) : w);
};
var h3 = function(e) {
  var n = e.isDisabled, r = e.isRtl;
  return {
    label: "container",
    direction: r ? "rtl" : void 0,
    pointerEvents: n ? "none" : void 0,
    // cancel mouse events when disabled
    position: "relative"
  };
};
var p3 = function(e) {
  var n = e.children, r = e.innerProps, i = e.isDisabled, o = e.isRtl;
  return Pe("div", Ae({}, Xt(e, "container", {
    "--is-disabled": i,
    "--is-rtl": o
  }), r), n);
};
var g3 = function(e, n) {
  var r = e.theme.spacing, i = e.isMulti, o = e.hasValue, s = e.selectProps.controlShouldRenderValue;
  return se({
    alignItems: "center",
    display: i && o && s ? "flex" : "grid",
    flex: 1,
    flexWrap: "wrap",
    WebkitOverflowScrolling: "touch",
    position: "relative",
    overflow: "hidden"
  }, n ? {} : {
    padding: "".concat(r.baseUnit / 2, "px ").concat(r.baseUnit * 2, "px")
  });
};
var m3 = function(e) {
  var n = e.children, r = e.innerProps, i = e.isMulti, o = e.hasValue;
  return Pe("div", Ae({}, Xt(e, "valueContainer", {
    "value-container": true,
    "value-container--is-multi": i,
    "value-container--has-value": o
  }), r), n);
};
var O3 = function() {
  return {
    alignItems: "center",
    alignSelf: "stretch",
    display: "flex",
    flexShrink: 0
  };
};
var x3 = function(e) {
  var n = e.children, r = e.innerProps;
  return Pe("div", Ae({}, Xt(e, "indicatorsContainer", {
    indicators: true
  }), r), n);
};
var Ey;
var v3 = ["size"];
var y3 = ["innerProps", "isRtl", "size"];
function b3() {
  return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
}
var S3 = false ? {
  name: "8mmkcg",
  styles: "display:inline-block;fill:currentColor;line-height:1;stroke:currentColor;stroke-width:0"
} : {
  name: "tj5bde-Svg",
  styles: "display:inline-block;fill:currentColor;line-height:1;stroke:currentColor;stroke-width:0;label:Svg;",
  map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImluZGljYXRvcnMudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQXlCSSIsImZpbGUiOiJpbmRpY2F0b3JzLnRzeCIsInNvdXJjZXNDb250ZW50IjpbIi8qKiBAanN4IGpzeCAqL1xuaW1wb3J0IHsgUmVhY3ROb2RlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsganN4LCBrZXlmcmFtZXMgfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5cbmltcG9ydCB7XG4gIENvbW1vblByb3BzQW5kQ2xhc3NOYW1lLFxuICBDU1NPYmplY3RXaXRoTGFiZWwsXG4gIEdyb3VwQmFzZSxcbn0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgZ2V0U3R5bGVQcm9wcyB9IGZyb20gJy4uL3V0aWxzJztcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBEcm9wZG93biAmIENsZWFyIEljb25zXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuY29uc3QgU3ZnID0gKHtcbiAgc2l6ZSxcbiAgLi4ucHJvcHNcbn06IEpTWC5JbnRyaW5zaWNFbGVtZW50c1snc3ZnJ10gJiB7IHNpemU6IG51bWJlciB9KSA9PiAoXG4gIDxzdmdcbiAgICBoZWlnaHQ9e3NpemV9XG4gICAgd2lkdGg9e3NpemV9XG4gICAgdmlld0JveD1cIjAgMCAyMCAyMFwiXG4gICAgYXJpYS1oaWRkZW49XCJ0cnVlXCJcbiAgICBmb2N1c2FibGU9XCJmYWxzZVwiXG4gICAgY3NzPXt7XG4gICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICAgIGZpbGw6ICdjdXJyZW50Q29sb3InLFxuICAgICAgbGluZUhlaWdodDogMSxcbiAgICAgIHN0cm9rZTogJ2N1cnJlbnRDb2xvcicsXG4gICAgICBzdHJva2VXaWR0aDogMCxcbiAgICB9fVxuICAgIHsuLi5wcm9wc31cbiAgLz5cbik7XG5cbmV4cG9ydCB0eXBlIENyb3NzSWNvblByb3BzID0gSlNYLkludHJpbnNpY0VsZW1lbnRzWydzdmcnXSAmIHsgc2l6ZT86IG51bWJlciB9O1xuZXhwb3J0IGNvbnN0IENyb3NzSWNvbiA9IChwcm9wczogQ3Jvc3NJY29uUHJvcHMpID0+IChcbiAgPFN2ZyBzaXplPXsyMH0gey4uLnByb3BzfT5cbiAgICA8cGF0aCBkPVwiTTE0LjM0OCAxNC44NDljLTAuNDY5IDAuNDY5LTEuMjI5IDAuNDY5LTEuNjk3IDBsLTIuNjUxLTMuMDMwLTIuNjUxIDMuMDI5Yy0wLjQ2OSAwLjQ2OS0xLjIyOSAwLjQ2OS0xLjY5NyAwLTAuNDY5LTAuNDY5LTAuNDY5LTEuMjI5IDAtMS42OTdsMi43NTgtMy4xNS0yLjc1OS0zLjE1MmMtMC40NjktMC40NjktMC40NjktMS4yMjggMC0xLjY5N3MxLjIyOC0wLjQ2OSAxLjY5NyAwbDIuNjUyIDMuMDMxIDIuNjUxLTMuMDMxYzAuNDY5LTAuNDY5IDEuMjI4LTAuNDY5IDEuNjk3IDBzMC40NjkgMS4yMjkgMCAxLjY5N2wtMi43NTggMy4xNTIgMi43NTggMy4xNWMwLjQ2OSAwLjQ2OSAwLjQ2OSAxLjIyOSAwIDEuNjk4elwiIC8+XG4gIDwvU3ZnPlxuKTtcbmV4cG9ydCB0eXBlIERvd25DaGV2cm9uUHJvcHMgPSBKU1guSW50cmluc2ljRWxlbWVudHNbJ3N2ZyddICYgeyBzaXplPzogbnVtYmVyIH07XG5leHBvcnQgY29uc3QgRG93bkNoZXZyb24gPSAocHJvcHM6IERvd25DaGV2cm9uUHJvcHMpID0+IChcbiAgPFN2ZyBzaXplPXsyMH0gey4uLnByb3BzfT5cbiAgICA8cGF0aCBkPVwiTTQuNTE2IDcuNTQ4YzAuNDM2LTAuNDQ2IDEuMDQzLTAuNDgxIDEuNTc2IDBsMy45MDggMy43NDcgMy45MDgtMy43NDdjMC41MzMtMC40ODEgMS4xNDEtMC40NDYgMS41NzQgMCAwLjQzNiAwLjQ0NSAwLjQwOCAxLjE5NyAwIDEuNjE1LTAuNDA2IDAuNDE4LTQuNjk1IDQuNTAyLTQuNjk1IDQuNTAyLTAuMjE3IDAuMjIzLTAuNTAyIDAuMzM1LTAuNzg3IDAuMzM1cy0wLjU3LTAuMTEyLTAuNzg5LTAuMzM1YzAgMC00LjI4Ny00LjA4NC00LjY5NS00LjUwMnMtMC40MzYtMS4xNyAwLTEuNjE1elwiIC8+XG4gIDwvU3ZnPlxuKTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBEcm9wZG93biAmIENsZWFyIEJ1dHRvbnNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5leHBvcnQgaW50ZXJmYWNlIERyb3Bkb3duSW5kaWNhdG9yUHJvcHM8XG4gIE9wdGlvbiA9IHVua25vd24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuID0gYm9vbGVhbixcbiAgR3JvdXAgZXh0ZW5kcyBHcm91cEJhc2U8T3B0aW9uPiA9IEdyb3VwQmFzZTxPcHRpb24+XG4+IGV4dGVuZHMgQ29tbW9uUHJvcHNBbmRDbGFzc05hbWU8T3B0aW9uLCBJc011bHRpLCBHcm91cD4ge1xuICAvKiogVGhlIGNoaWxkcmVuIHRvIGJlIHJlbmRlcmVkIGluc2lkZSB0aGUgaW5kaWNhdG9yLiAqL1xuICBjaGlsZHJlbj86IFJlYWN0Tm9kZTtcbiAgLyoqIFByb3BzIHRoYXQgd2lsbCBiZSBwYXNzZWQgb24gdG8gdGhlIGNoaWxkcmVuLiAqL1xuICBpbm5lclByb3BzOiBKU1guSW50cmluc2ljRWxlbWVudHNbJ2RpdiddO1xuICAvKiogVGhlIGZvY3VzZWQgc3RhdGUgb2YgdGhlIHNlbGVjdC4gKi9cbiAgaXNGb2N1c2VkOiBib29sZWFuO1xuICBpc0Rpc2FibGVkOiBib29sZWFuO1xufVxuXG5jb25zdCBiYXNlQ1NTID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KFxuICB7XG4gICAgaXNGb2N1c2VkLFxuICAgIHRoZW1lOiB7XG4gICAgICBzcGFjaW5nOiB7IGJhc2VVbml0IH0sXG4gICAgICBjb2xvcnMsXG4gICAgfSxcbiAgfTpcbiAgICB8IERyb3Bkb3duSW5kaWNhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD5cbiAgICB8IENsZWFySW5kaWNhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD4sXG4gIHVuc3R5bGVkOiBib29sZWFuXG4pOiBDU1NPYmplY3RXaXRoTGFiZWwgPT4gKHtcbiAgbGFiZWw6ICdpbmRpY2F0b3JDb250YWluZXInLFxuICBkaXNwbGF5OiAnZmxleCcsXG4gIHRyYW5zaXRpb246ICdjb2xvciAxNTBtcycsXG4gIC4uLih1bnN0eWxlZFxuICAgID8ge31cbiAgICA6IHtcbiAgICAgICAgY29sb3I6IGlzRm9jdXNlZCA/IGNvbG9ycy5uZXV0cmFsNjAgOiBjb2xvcnMubmV1dHJhbDIwLFxuICAgICAgICBwYWRkaW5nOiBiYXNlVW5pdCAqIDIsXG4gICAgICAgICc6aG92ZXInOiB7XG4gICAgICAgICAgY29sb3I6IGlzRm9jdXNlZCA/IGNvbG9ycy5uZXV0cmFsODAgOiBjb2xvcnMubmV1dHJhbDQwLFxuICAgICAgICB9LFxuICAgICAgfSksXG59KTtcblxuZXhwb3J0IGNvbnN0IGRyb3Bkb3duSW5kaWNhdG9yQ1NTID0gYmFzZUNTUztcbmV4cG9ydCBjb25zdCBEcm9wZG93bkluZGljYXRvciA9IDxcbiAgT3B0aW9uLFxuICBJc011bHRpIGV4dGVuZHMgYm9vbGVhbixcbiAgR3JvdXAgZXh0ZW5kcyBHcm91cEJhc2U8T3B0aW9uPlxuPihcbiAgcHJvcHM6IERyb3Bkb3duSW5kaWNhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD5cbikgPT4ge1xuICBjb25zdCB7IGNoaWxkcmVuLCBpbm5lclByb3BzIH0gPSBwcm9wcztcbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICB7Li4uZ2V0U3R5bGVQcm9wcyhwcm9wcywgJ2Ryb3Bkb3duSW5kaWNhdG9yJywge1xuICAgICAgICBpbmRpY2F0b3I6IHRydWUsXG4gICAgICAgICdkcm9wZG93bi1pbmRpY2F0b3InOiB0cnVlLFxuICAgICAgfSl9XG4gICAgICB7Li4uaW5uZXJQcm9wc31cbiAgICA+XG4gICAgICB7Y2hpbGRyZW4gfHwgPERvd25DaGV2cm9uIC8+fVxuICAgIDwvZGl2PlxuICApO1xufTtcblxuZXhwb3J0IGludGVyZmFjZSBDbGVhckluZGljYXRvclByb3BzPFxuICBPcHRpb24gPSB1bmtub3duLFxuICBJc011bHRpIGV4dGVuZHMgYm9vbGVhbiA9IGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj4gPSBHcm91cEJhc2U8T3B0aW9uPlxuPiBleHRlbmRzIENvbW1vblByb3BzQW5kQ2xhc3NOYW1lPE9wdGlvbiwgSXNNdWx0aSwgR3JvdXA+IHtcbiAgLyoqIFRoZSBjaGlsZHJlbiB0byBiZSByZW5kZXJlZCBpbnNpZGUgdGhlIGluZGljYXRvci4gKi9cbiAgY2hpbGRyZW4/OiBSZWFjdE5vZGU7XG4gIC8qKiBQcm9wcyB0aGF0IHdpbGwgYmUgcGFzc2VkIG9uIHRvIHRoZSBjaGlsZHJlbi4gKi9cbiAgaW5uZXJQcm9wczogSlNYLkludHJpbnNpY0VsZW1lbnRzWydkaXYnXTtcbiAgLyoqIFRoZSBmb2N1c2VkIHN0YXRlIG9mIHRoZSBzZWxlY3QuICovXG4gIGlzRm9jdXNlZDogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGNvbnN0IGNsZWFySW5kaWNhdG9yQ1NTID0gYmFzZUNTUztcbmV4cG9ydCBjb25zdCBDbGVhckluZGljYXRvciA9IDxcbiAgT3B0aW9uLFxuICBJc011bHRpIGV4dGVuZHMgYm9vbGVhbixcbiAgR3JvdXAgZXh0ZW5kcyBHcm91cEJhc2U8T3B0aW9uPlxuPihcbiAgcHJvcHM6IENsZWFySW5kaWNhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD5cbikgPT4ge1xuICBjb25zdCB7IGNoaWxkcmVuLCBpbm5lclByb3BzIH0gPSBwcm9wcztcbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICB7Li4uZ2V0U3R5bGVQcm9wcyhwcm9wcywgJ2NsZWFySW5kaWNhdG9yJywge1xuICAgICAgICBpbmRpY2F0b3I6IHRydWUsXG4gICAgICAgICdjbGVhci1pbmRpY2F0b3InOiB0cnVlLFxuICAgICAgfSl9XG4gICAgICB7Li4uaW5uZXJQcm9wc31cbiAgICA+XG4gICAgICB7Y2hpbGRyZW4gfHwgPENyb3NzSWNvbiAvPn1cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gU2VwYXJhdG9yXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuZXhwb3J0IGludGVyZmFjZSBJbmRpY2F0b3JTZXBhcmF0b3JQcm9wczxcbiAgT3B0aW9uID0gdW5rbm93bixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4gPSBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+ID0gR3JvdXBCYXNlPE9wdGlvbj5cbj4gZXh0ZW5kcyBDb21tb25Qcm9wc0FuZENsYXNzTmFtZTxPcHRpb24sIElzTXVsdGksIEdyb3VwPiB7XG4gIGlzRGlzYWJsZWQ6IGJvb2xlYW47XG4gIGlzRm9jdXNlZDogYm9vbGVhbjtcbiAgaW5uZXJQcm9wcz86IEpTWC5JbnRyaW5zaWNFbGVtZW50c1snc3BhbiddO1xufVxuXG5leHBvcnQgY29uc3QgaW5kaWNhdG9yU2VwYXJhdG9yQ1NTID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KFxuICB7XG4gICAgaXNEaXNhYmxlZCxcbiAgICB0aGVtZToge1xuICAgICAgc3BhY2luZzogeyBiYXNlVW5pdCB9LFxuICAgICAgY29sb3JzLFxuICAgIH0sXG4gIH06IEluZGljYXRvclNlcGFyYXRvclByb3BzPE9wdGlvbiwgSXNNdWx0aSwgR3JvdXA+LFxuICB1bnN0eWxlZDogYm9vbGVhblxuKTogQ1NTT2JqZWN0V2l0aExhYmVsID0+ICh7XG4gIGxhYmVsOiAnaW5kaWNhdG9yU2VwYXJhdG9yJyxcbiAgYWxpZ25TZWxmOiAnc3RyZXRjaCcsXG4gIHdpZHRoOiAxLFxuICAuLi4odW5zdHlsZWRcbiAgICA/IHt9XG4gICAgOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogaXNEaXNhYmxlZCA/IGNvbG9ycy5uZXV0cmFsMTAgOiBjb2xvcnMubmV1dHJhbDIwLFxuICAgICAgICBtYXJnaW5Cb3R0b206IGJhc2VVbml0ICogMixcbiAgICAgICAgbWFyZ2luVG9wOiBiYXNlVW5pdCAqIDIsXG4gICAgICB9KSxcbn0pO1xuXG5leHBvcnQgY29uc3QgSW5kaWNhdG9yU2VwYXJhdG9yID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KFxuICBwcm9wczogSW5kaWNhdG9yU2VwYXJhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD5cbikgPT4ge1xuICBjb25zdCB7IGlubmVyUHJvcHMgfSA9IHByb3BzO1xuICByZXR1cm4gKFxuICAgIDxzcGFuXG4gICAgICB7Li4uaW5uZXJQcm9wc31cbiAgICAgIHsuLi5nZXRTdHlsZVByb3BzKHByb3BzLCAnaW5kaWNhdG9yU2VwYXJhdG9yJywge1xuICAgICAgICAnaW5kaWNhdG9yLXNlcGFyYXRvcic6IHRydWUsXG4gICAgICB9KX1cbiAgICAvPlxuICApO1xufTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBMb2FkaW5nXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuY29uc3QgbG9hZGluZ0RvdEFuaW1hdGlvbnMgPSBrZXlmcmFtZXNgXG4gIDAlLCA4MCUsIDEwMCUgeyBvcGFjaXR5OiAwOyB9XG4gIDQwJSB7IG9wYWNpdHk6IDE7IH1cbmA7XG5cbmV4cG9ydCBjb25zdCBsb2FkaW5nSW5kaWNhdG9yQ1NTID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KFxuICB7XG4gICAgaXNGb2N1c2VkLFxuICAgIHNpemUsXG4gICAgdGhlbWU6IHtcbiAgICAgIGNvbG9ycyxcbiAgICAgIHNwYWNpbmc6IHsgYmFzZVVuaXQgfSxcbiAgICB9LFxuICB9OiBMb2FkaW5nSW5kaWNhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD4sXG4gIHVuc3R5bGVkOiBib29sZWFuXG4pOiBDU1NPYmplY3RXaXRoTGFiZWwgPT4gKHtcbiAgbGFiZWw6ICdsb2FkaW5nSW5kaWNhdG9yJyxcbiAgZGlzcGxheTogJ2ZsZXgnLFxuICB0cmFuc2l0aW9uOiAnY29sb3IgMTUwbXMnLFxuICBhbGlnblNlbGY6ICdjZW50ZXInLFxuICBmb250U2l6ZTogc2l6ZSxcbiAgbGluZUhlaWdodDogMSxcbiAgbWFyZ2luUmlnaHQ6IHNpemUsXG4gIHRleHRBbGlnbjogJ2NlbnRlcicsXG4gIHZlcnRpY2FsQWxpZ246ICdtaWRkbGUnLFxuICAuLi4odW5zdHlsZWRcbiAgICA/IHt9XG4gICAgOiB7XG4gICAgICAgIGNvbG9yOiBpc0ZvY3VzZWQgPyBjb2xvcnMubmV1dHJhbDYwIDogY29sb3JzLm5ldXRyYWwyMCxcbiAgICAgICAgcGFkZGluZzogYmFzZVVuaXQgKiAyLFxuICAgICAgfSksXG59KTtcblxuaW50ZXJmYWNlIExvYWRpbmdEb3RQcm9wcyB7XG4gIGRlbGF5OiBudW1iZXI7XG4gIG9mZnNldDogYm9vbGVhbjtcbn1cbmNvbnN0IExvYWRpbmdEb3QgPSAoeyBkZWxheSwgb2Zmc2V0IH06IExvYWRpbmdEb3RQcm9wcykgPT4gKFxuICA8c3BhblxuICAgIGNzcz17e1xuICAgICAgYW5pbWF0aW9uOiBgJHtsb2FkaW5nRG90QW5pbWF0aW9uc30gMXMgZWFzZS1pbi1vdXQgJHtkZWxheX1tcyBpbmZpbml0ZTtgLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiAnY3VycmVudENvbG9yJyxcbiAgICAgIGJvcmRlclJhZGl1czogJzFlbScsXG4gICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICAgIG1hcmdpbkxlZnQ6IG9mZnNldCA/ICcxZW0nIDogdW5kZWZpbmVkLFxuICAgICAgaGVpZ2h0OiAnMWVtJyxcbiAgICAgIHZlcnRpY2FsQWxpZ246ICd0b3AnLFxuICAgICAgd2lkdGg6ICcxZW0nLFxuICAgIH19XG4gIC8+XG4pO1xuXG5leHBvcnQgaW50ZXJmYWNlIExvYWRpbmdJbmRpY2F0b3JQcm9wczxcbiAgT3B0aW9uID0gdW5rbm93bixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4gPSBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+ID0gR3JvdXBCYXNlPE9wdGlvbj5cbj4gZXh0ZW5kcyBDb21tb25Qcm9wc0FuZENsYXNzTmFtZTxPcHRpb24sIElzTXVsdGksIEdyb3VwPiB7XG4gIC8qKiBQcm9wcyB0aGF0IHdpbGwgYmUgcGFzc2VkIG9uIHRvIHRoZSBjaGlsZHJlbi4gKi9cbiAgaW5uZXJQcm9wczogSlNYLkludHJpbnNpY0VsZW1lbnRzWydkaXYnXTtcbiAgLyoqIFRoZSBmb2N1c2VkIHN0YXRlIG9mIHRoZSBzZWxlY3QuICovXG4gIGlzRm9jdXNlZDogYm9vbGVhbjtcbiAgaXNEaXNhYmxlZDogYm9vbGVhbjtcbiAgLyoqIFNldCBzaXplIG9mIHRoZSBjb250YWluZXIuICovXG4gIHNpemU6IG51bWJlcjtcbn1cbmV4cG9ydCBjb25zdCBMb2FkaW5nSW5kaWNhdG9yID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KHtcbiAgaW5uZXJQcm9wcyxcbiAgaXNSdGwsXG4gIHNpemUgPSA0LFxuICAuLi5yZXN0UHJvcHNcbn06IExvYWRpbmdJbmRpY2F0b3JQcm9wczxPcHRpb24sIElzTXVsdGksIEdyb3VwPikgPT4ge1xuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIHsuLi5nZXRTdHlsZVByb3BzKFxuICAgICAgICB7IC4uLnJlc3RQcm9wcywgaW5uZXJQcm9wcywgaXNSdGwsIHNpemUgfSxcbiAgICAgICAgJ2xvYWRpbmdJbmRpY2F0b3InLFxuICAgICAgICB7XG4gICAgICAgICAgaW5kaWNhdG9yOiB0cnVlLFxuICAgICAgICAgICdsb2FkaW5nLWluZGljYXRvcic6IHRydWUsXG4gICAgICAgIH1cbiAgICAgICl9XG4gICAgICB7Li4uaW5uZXJQcm9wc31cbiAgICA+XG4gICAgICA8TG9hZGluZ0RvdCBkZWxheT17MH0gb2Zmc2V0PXtpc1J0bH0gLz5cbiAgICAgIDxMb2FkaW5nRG90IGRlbGF5PXsxNjB9IG9mZnNldCAvPlxuICAgICAgPExvYWRpbmdEb3QgZGVsYXk9ezMyMH0gb2Zmc2V0PXshaXNSdGx9IC8+XG4gICAgPC9kaXY+XG4gICk7XG59O1xuIl19 */",
  toString: b3
};
var KA = function(e) {
  var n = e.size, r = Mr(e, v3);
  return Pe("svg", Ae({
    height: n,
    width: n,
    viewBox: "0 0 20 20",
    "aria-hidden": "true",
    focusable: "false",
    css: S3
  }, r));
};
var ix = function(e) {
  return Pe(KA, Ae({
    size: 20
  }, e), Pe("path", {
    d: "M14.348 14.849c-0.469 0.469-1.229 0.469-1.697 0l-2.651-3.030-2.651 3.029c-0.469 0.469-1.229 0.469-1.697 0-0.469-0.469-0.469-1.229 0-1.697l2.758-3.15-2.759-3.152c-0.469-0.469-0.469-1.228 0-1.697s1.228-0.469 1.697 0l2.652 3.031 2.651-3.031c0.469-0.469 1.228-0.469 1.697 0s0.469 1.229 0 1.697l-2.758 3.152 2.758 3.15c0.469 0.469 0.469 1.229 0 1.698z"
  }));
};
var eP = function(e) {
  return Pe(KA, Ae({
    size: 20
  }, e), Pe("path", {
    d: "M4.516 7.548c0.436-0.446 1.043-0.481 1.576 0l3.908 3.747 3.908-3.747c0.533-0.481 1.141-0.446 1.574 0 0.436 0.445 0.408 1.197 0 1.615-0.406 0.418-4.695 4.502-4.695 4.502-0.217 0.223-0.502 0.335-0.787 0.335s-0.57-0.112-0.789-0.335c0 0-4.287-4.084-4.695-4.502s-0.436-1.17 0-1.615z"
  }));
};
var tP = function(e, n) {
  var r = e.isFocused, i = e.theme, o = i.spacing.baseUnit, s = i.colors;
  return se({
    label: "indicatorContainer",
    display: "flex",
    transition: "color 150ms"
  }, n ? {} : {
    color: r ? s.neutral60 : s.neutral20,
    padding: o * 2,
    ":hover": {
      color: r ? s.neutral80 : s.neutral40
    }
  });
};
var w3 = tP;
var C3 = function(e) {
  var n = e.children, r = e.innerProps;
  return Pe("div", Ae({}, Xt(e, "dropdownIndicator", {
    indicator: true,
    "dropdown-indicator": true
  }), r), n || Pe(eP, null));
};
var k3 = tP;
var A3 = function(e) {
  var n = e.children, r = e.innerProps;
  return Pe("div", Ae({}, Xt(e, "clearIndicator", {
    indicator: true,
    "clear-indicator": true
  }), r), n || Pe(ix, null));
};
var P3 = function(e, n) {
  var r = e.isDisabled, i = e.theme, o = i.spacing.baseUnit, s = i.colors;
  return se({
    label: "indicatorSeparator",
    alignSelf: "stretch",
    width: 1
  }, n ? {} : {
    backgroundColor: r ? s.neutral10 : s.neutral20,
    marginBottom: o * 2,
    marginTop: o * 2
  });
};
var E3 = function(e) {
  var n = e.innerProps;
  return Pe("span", Ae({}, n, Xt(e, "indicatorSeparator", {
    "indicator-separator": true
  })));
};
var T3 = xQ(Ey || (Ey = CQ([`
  0%, 80%, 100% { opacity: 0; }
  40% { opacity: 1; }
`])));
var I3 = function(e, n) {
  var r = e.isFocused, i = e.size, o = e.theme, s = o.colors, a = o.spacing.baseUnit;
  return se({
    label: "loadingIndicator",
    display: "flex",
    transition: "color 150ms",
    alignSelf: "center",
    fontSize: i,
    lineHeight: 1,
    marginRight: i,
    textAlign: "center",
    verticalAlign: "middle"
  }, n ? {} : {
    color: r ? s.neutral60 : s.neutral20,
    padding: a * 2
  });
};
var lp = function(e) {
  var n = e.delay, r = e.offset;
  return Pe("span", {
    css: /* @__PURE__ */ ex({
      animation: "".concat(T3, " 1s ease-in-out ").concat(n, "ms infinite;"),
      backgroundColor: "currentColor",
      borderRadius: "1em",
      display: "inline-block",
      marginLeft: r ? "1em" : void 0,
      height: "1em",
      verticalAlign: "top",
      width: "1em"
    }, false ? "" : ";label:LoadingDot;", false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImluZGljYXRvcnMudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQW1RSSIsImZpbGUiOiJpbmRpY2F0b3JzLnRzeCIsInNvdXJjZXNDb250ZW50IjpbIi8qKiBAanN4IGpzeCAqL1xuaW1wb3J0IHsgUmVhY3ROb2RlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsganN4LCBrZXlmcmFtZXMgfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5cbmltcG9ydCB7XG4gIENvbW1vblByb3BzQW5kQ2xhc3NOYW1lLFxuICBDU1NPYmplY3RXaXRoTGFiZWwsXG4gIEdyb3VwQmFzZSxcbn0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgZ2V0U3R5bGVQcm9wcyB9IGZyb20gJy4uL3V0aWxzJztcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBEcm9wZG93biAmIENsZWFyIEljb25zXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuY29uc3QgU3ZnID0gKHtcbiAgc2l6ZSxcbiAgLi4ucHJvcHNcbn06IEpTWC5JbnRyaW5zaWNFbGVtZW50c1snc3ZnJ10gJiB7IHNpemU6IG51bWJlciB9KSA9PiAoXG4gIDxzdmdcbiAgICBoZWlnaHQ9e3NpemV9XG4gICAgd2lkdGg9e3NpemV9XG4gICAgdmlld0JveD1cIjAgMCAyMCAyMFwiXG4gICAgYXJpYS1oaWRkZW49XCJ0cnVlXCJcbiAgICBmb2N1c2FibGU9XCJmYWxzZVwiXG4gICAgY3NzPXt7XG4gICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICAgIGZpbGw6ICdjdXJyZW50Q29sb3InLFxuICAgICAgbGluZUhlaWdodDogMSxcbiAgICAgIHN0cm9rZTogJ2N1cnJlbnRDb2xvcicsXG4gICAgICBzdHJva2VXaWR0aDogMCxcbiAgICB9fVxuICAgIHsuLi5wcm9wc31cbiAgLz5cbik7XG5cbmV4cG9ydCB0eXBlIENyb3NzSWNvblByb3BzID0gSlNYLkludHJpbnNpY0VsZW1lbnRzWydzdmcnXSAmIHsgc2l6ZT86IG51bWJlciB9O1xuZXhwb3J0IGNvbnN0IENyb3NzSWNvbiA9IChwcm9wczogQ3Jvc3NJY29uUHJvcHMpID0+IChcbiAgPFN2ZyBzaXplPXsyMH0gey4uLnByb3BzfT5cbiAgICA8cGF0aCBkPVwiTTE0LjM0OCAxNC44NDljLTAuNDY5IDAuNDY5LTEuMjI5IDAuNDY5LTEuNjk3IDBsLTIuNjUxLTMuMDMwLTIuNjUxIDMuMDI5Yy0wLjQ2OSAwLjQ2OS0xLjIyOSAwLjQ2OS0xLjY5NyAwLTAuNDY5LTAuNDY5LTAuNDY5LTEuMjI5IDAtMS42OTdsMi43NTgtMy4xNS0yLjc1OS0zLjE1MmMtMC40NjktMC40NjktMC40NjktMS4yMjggMC0xLjY5N3MxLjIyOC0wLjQ2OSAxLjY5NyAwbDIuNjUyIDMuMDMxIDIuNjUxLTMuMDMxYzAuNDY5LTAuNDY5IDEuMjI4LTAuNDY5IDEuNjk3IDBzMC40NjkgMS4yMjkgMCAxLjY5N2wtMi43NTggMy4xNTIgMi43NTggMy4xNWMwLjQ2OSAwLjQ2OSAwLjQ2OSAxLjIyOSAwIDEuNjk4elwiIC8+XG4gIDwvU3ZnPlxuKTtcbmV4cG9ydCB0eXBlIERvd25DaGV2cm9uUHJvcHMgPSBKU1guSW50cmluc2ljRWxlbWVudHNbJ3N2ZyddICYgeyBzaXplPzogbnVtYmVyIH07XG5leHBvcnQgY29uc3QgRG93bkNoZXZyb24gPSAocHJvcHM6IERvd25DaGV2cm9uUHJvcHMpID0+IChcbiAgPFN2ZyBzaXplPXsyMH0gey4uLnByb3BzfT5cbiAgICA8cGF0aCBkPVwiTTQuNTE2IDcuNTQ4YzAuNDM2LTAuNDQ2IDEuMDQzLTAuNDgxIDEuNTc2IDBsMy45MDggMy43NDcgMy45MDgtMy43NDdjMC41MzMtMC40ODEgMS4xNDEtMC40NDYgMS41NzQgMCAwLjQzNiAwLjQ0NSAwLjQwOCAxLjE5NyAwIDEuNjE1LTAuNDA2IDAuNDE4LTQuNjk1IDQuNTAyLTQuNjk1IDQuNTAyLTAuMjE3IDAuMjIzLTAuNTAyIDAuMzM1LTAuNzg3IDAuMzM1cy0wLjU3LTAuMTEyLTAuNzg5LTAuMzM1YzAgMC00LjI4Ny00LjA4NC00LjY5NS00LjUwMnMtMC40MzYtMS4xNyAwLTEuNjE1elwiIC8+XG4gIDwvU3ZnPlxuKTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBEcm9wZG93biAmIENsZWFyIEJ1dHRvbnNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5leHBvcnQgaW50ZXJmYWNlIERyb3Bkb3duSW5kaWNhdG9yUHJvcHM8XG4gIE9wdGlvbiA9IHVua25vd24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuID0gYm9vbGVhbixcbiAgR3JvdXAgZXh0ZW5kcyBHcm91cEJhc2U8T3B0aW9uPiA9IEdyb3VwQmFzZTxPcHRpb24+XG4+IGV4dGVuZHMgQ29tbW9uUHJvcHNBbmRDbGFzc05hbWU8T3B0aW9uLCBJc011bHRpLCBHcm91cD4ge1xuICAvKiogVGhlIGNoaWxkcmVuIHRvIGJlIHJlbmRlcmVkIGluc2lkZSB0aGUgaW5kaWNhdG9yLiAqL1xuICBjaGlsZHJlbj86IFJlYWN0Tm9kZTtcbiAgLyoqIFByb3BzIHRoYXQgd2lsbCBiZSBwYXNzZWQgb24gdG8gdGhlIGNoaWxkcmVuLiAqL1xuICBpbm5lclByb3BzOiBKU1guSW50cmluc2ljRWxlbWVudHNbJ2RpdiddO1xuICAvKiogVGhlIGZvY3VzZWQgc3RhdGUgb2YgdGhlIHNlbGVjdC4gKi9cbiAgaXNGb2N1c2VkOiBib29sZWFuO1xuICBpc0Rpc2FibGVkOiBib29sZWFuO1xufVxuXG5jb25zdCBiYXNlQ1NTID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KFxuICB7XG4gICAgaXNGb2N1c2VkLFxuICAgIHRoZW1lOiB7XG4gICAgICBzcGFjaW5nOiB7IGJhc2VVbml0IH0sXG4gICAgICBjb2xvcnMsXG4gICAgfSxcbiAgfTpcbiAgICB8IERyb3Bkb3duSW5kaWNhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD5cbiAgICB8IENsZWFySW5kaWNhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD4sXG4gIHVuc3R5bGVkOiBib29sZWFuXG4pOiBDU1NPYmplY3RXaXRoTGFiZWwgPT4gKHtcbiAgbGFiZWw6ICdpbmRpY2F0b3JDb250YWluZXInLFxuICBkaXNwbGF5OiAnZmxleCcsXG4gIHRyYW5zaXRpb246ICdjb2xvciAxNTBtcycsXG4gIC4uLih1bnN0eWxlZFxuICAgID8ge31cbiAgICA6IHtcbiAgICAgICAgY29sb3I6IGlzRm9jdXNlZCA/IGNvbG9ycy5uZXV0cmFsNjAgOiBjb2xvcnMubmV1dHJhbDIwLFxuICAgICAgICBwYWRkaW5nOiBiYXNlVW5pdCAqIDIsXG4gICAgICAgICc6aG92ZXInOiB7XG4gICAgICAgICAgY29sb3I6IGlzRm9jdXNlZCA/IGNvbG9ycy5uZXV0cmFsODAgOiBjb2xvcnMubmV1dHJhbDQwLFxuICAgICAgICB9LFxuICAgICAgfSksXG59KTtcblxuZXhwb3J0IGNvbnN0IGRyb3Bkb3duSW5kaWNhdG9yQ1NTID0gYmFzZUNTUztcbmV4cG9ydCBjb25zdCBEcm9wZG93bkluZGljYXRvciA9IDxcbiAgT3B0aW9uLFxuICBJc011bHRpIGV4dGVuZHMgYm9vbGVhbixcbiAgR3JvdXAgZXh0ZW5kcyBHcm91cEJhc2U8T3B0aW9uPlxuPihcbiAgcHJvcHM6IERyb3Bkb3duSW5kaWNhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD5cbikgPT4ge1xuICBjb25zdCB7IGNoaWxkcmVuLCBpbm5lclByb3BzIH0gPSBwcm9wcztcbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICB7Li4uZ2V0U3R5bGVQcm9wcyhwcm9wcywgJ2Ryb3Bkb3duSW5kaWNhdG9yJywge1xuICAgICAgICBpbmRpY2F0b3I6IHRydWUsXG4gICAgICAgICdkcm9wZG93bi1pbmRpY2F0b3InOiB0cnVlLFxuICAgICAgfSl9XG4gICAgICB7Li4uaW5uZXJQcm9wc31cbiAgICA+XG4gICAgICB7Y2hpbGRyZW4gfHwgPERvd25DaGV2cm9uIC8+fVxuICAgIDwvZGl2PlxuICApO1xufTtcblxuZXhwb3J0IGludGVyZmFjZSBDbGVhckluZGljYXRvclByb3BzPFxuICBPcHRpb24gPSB1bmtub3duLFxuICBJc011bHRpIGV4dGVuZHMgYm9vbGVhbiA9IGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj4gPSBHcm91cEJhc2U8T3B0aW9uPlxuPiBleHRlbmRzIENvbW1vblByb3BzQW5kQ2xhc3NOYW1lPE9wdGlvbiwgSXNNdWx0aSwgR3JvdXA+IHtcbiAgLyoqIFRoZSBjaGlsZHJlbiB0byBiZSByZW5kZXJlZCBpbnNpZGUgdGhlIGluZGljYXRvci4gKi9cbiAgY2hpbGRyZW4/OiBSZWFjdE5vZGU7XG4gIC8qKiBQcm9wcyB0aGF0IHdpbGwgYmUgcGFzc2VkIG9uIHRvIHRoZSBjaGlsZHJlbi4gKi9cbiAgaW5uZXJQcm9wczogSlNYLkludHJpbnNpY0VsZW1lbnRzWydkaXYnXTtcbiAgLyoqIFRoZSBmb2N1c2VkIHN0YXRlIG9mIHRoZSBzZWxlY3QuICovXG4gIGlzRm9jdXNlZDogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGNvbnN0IGNsZWFySW5kaWNhdG9yQ1NTID0gYmFzZUNTUztcbmV4cG9ydCBjb25zdCBDbGVhckluZGljYXRvciA9IDxcbiAgT3B0aW9uLFxuICBJc011bHRpIGV4dGVuZHMgYm9vbGVhbixcbiAgR3JvdXAgZXh0ZW5kcyBHcm91cEJhc2U8T3B0aW9uPlxuPihcbiAgcHJvcHM6IENsZWFySW5kaWNhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD5cbikgPT4ge1xuICBjb25zdCB7IGNoaWxkcmVuLCBpbm5lclByb3BzIH0gPSBwcm9wcztcbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICB7Li4uZ2V0U3R5bGVQcm9wcyhwcm9wcywgJ2NsZWFySW5kaWNhdG9yJywge1xuICAgICAgICBpbmRpY2F0b3I6IHRydWUsXG4gICAgICAgICdjbGVhci1pbmRpY2F0b3InOiB0cnVlLFxuICAgICAgfSl9XG4gICAgICB7Li4uaW5uZXJQcm9wc31cbiAgICA+XG4gICAgICB7Y2hpbGRyZW4gfHwgPENyb3NzSWNvbiAvPn1cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gU2VwYXJhdG9yXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuZXhwb3J0IGludGVyZmFjZSBJbmRpY2F0b3JTZXBhcmF0b3JQcm9wczxcbiAgT3B0aW9uID0gdW5rbm93bixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4gPSBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+ID0gR3JvdXBCYXNlPE9wdGlvbj5cbj4gZXh0ZW5kcyBDb21tb25Qcm9wc0FuZENsYXNzTmFtZTxPcHRpb24sIElzTXVsdGksIEdyb3VwPiB7XG4gIGlzRGlzYWJsZWQ6IGJvb2xlYW47XG4gIGlzRm9jdXNlZDogYm9vbGVhbjtcbiAgaW5uZXJQcm9wcz86IEpTWC5JbnRyaW5zaWNFbGVtZW50c1snc3BhbiddO1xufVxuXG5leHBvcnQgY29uc3QgaW5kaWNhdG9yU2VwYXJhdG9yQ1NTID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KFxuICB7XG4gICAgaXNEaXNhYmxlZCxcbiAgICB0aGVtZToge1xuICAgICAgc3BhY2luZzogeyBiYXNlVW5pdCB9LFxuICAgICAgY29sb3JzLFxuICAgIH0sXG4gIH06IEluZGljYXRvclNlcGFyYXRvclByb3BzPE9wdGlvbiwgSXNNdWx0aSwgR3JvdXA+LFxuICB1bnN0eWxlZDogYm9vbGVhblxuKTogQ1NTT2JqZWN0V2l0aExhYmVsID0+ICh7XG4gIGxhYmVsOiAnaW5kaWNhdG9yU2VwYXJhdG9yJyxcbiAgYWxpZ25TZWxmOiAnc3RyZXRjaCcsXG4gIHdpZHRoOiAxLFxuICAuLi4odW5zdHlsZWRcbiAgICA/IHt9XG4gICAgOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogaXNEaXNhYmxlZCA/IGNvbG9ycy5uZXV0cmFsMTAgOiBjb2xvcnMubmV1dHJhbDIwLFxuICAgICAgICBtYXJnaW5Cb3R0b206IGJhc2VVbml0ICogMixcbiAgICAgICAgbWFyZ2luVG9wOiBiYXNlVW5pdCAqIDIsXG4gICAgICB9KSxcbn0pO1xuXG5leHBvcnQgY29uc3QgSW5kaWNhdG9yU2VwYXJhdG9yID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KFxuICBwcm9wczogSW5kaWNhdG9yU2VwYXJhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD5cbikgPT4ge1xuICBjb25zdCB7IGlubmVyUHJvcHMgfSA9IHByb3BzO1xuICByZXR1cm4gKFxuICAgIDxzcGFuXG4gICAgICB7Li4uaW5uZXJQcm9wc31cbiAgICAgIHsuLi5nZXRTdHlsZVByb3BzKHByb3BzLCAnaW5kaWNhdG9yU2VwYXJhdG9yJywge1xuICAgICAgICAnaW5kaWNhdG9yLXNlcGFyYXRvcic6IHRydWUsXG4gICAgICB9KX1cbiAgICAvPlxuICApO1xufTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBMb2FkaW5nXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuY29uc3QgbG9hZGluZ0RvdEFuaW1hdGlvbnMgPSBrZXlmcmFtZXNgXG4gIDAlLCA4MCUsIDEwMCUgeyBvcGFjaXR5OiAwOyB9XG4gIDQwJSB7IG9wYWNpdHk6IDE7IH1cbmA7XG5cbmV4cG9ydCBjb25zdCBsb2FkaW5nSW5kaWNhdG9yQ1NTID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KFxuICB7XG4gICAgaXNGb2N1c2VkLFxuICAgIHNpemUsXG4gICAgdGhlbWU6IHtcbiAgICAgIGNvbG9ycyxcbiAgICAgIHNwYWNpbmc6IHsgYmFzZVVuaXQgfSxcbiAgICB9LFxuICB9OiBMb2FkaW5nSW5kaWNhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD4sXG4gIHVuc3R5bGVkOiBib29sZWFuXG4pOiBDU1NPYmplY3RXaXRoTGFiZWwgPT4gKHtcbiAgbGFiZWw6ICdsb2FkaW5nSW5kaWNhdG9yJyxcbiAgZGlzcGxheTogJ2ZsZXgnLFxuICB0cmFuc2l0aW9uOiAnY29sb3IgMTUwbXMnLFxuICBhbGlnblNlbGY6ICdjZW50ZXInLFxuICBmb250U2l6ZTogc2l6ZSxcbiAgbGluZUhlaWdodDogMSxcbiAgbWFyZ2luUmlnaHQ6IHNpemUsXG4gIHRleHRBbGlnbjogJ2NlbnRlcicsXG4gIHZlcnRpY2FsQWxpZ246ICdtaWRkbGUnLFxuICAuLi4odW5zdHlsZWRcbiAgICA/IHt9XG4gICAgOiB7XG4gICAgICAgIGNvbG9yOiBpc0ZvY3VzZWQgPyBjb2xvcnMubmV1dHJhbDYwIDogY29sb3JzLm5ldXRyYWwyMCxcbiAgICAgICAgcGFkZGluZzogYmFzZVVuaXQgKiAyLFxuICAgICAgfSksXG59KTtcblxuaW50ZXJmYWNlIExvYWRpbmdEb3RQcm9wcyB7XG4gIGRlbGF5OiBudW1iZXI7XG4gIG9mZnNldDogYm9vbGVhbjtcbn1cbmNvbnN0IExvYWRpbmdEb3QgPSAoeyBkZWxheSwgb2Zmc2V0IH06IExvYWRpbmdEb3RQcm9wcykgPT4gKFxuICA8c3BhblxuICAgIGNzcz17e1xuICAgICAgYW5pbWF0aW9uOiBgJHtsb2FkaW5nRG90QW5pbWF0aW9uc30gMXMgZWFzZS1pbi1vdXQgJHtkZWxheX1tcyBpbmZpbml0ZTtgLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiAnY3VycmVudENvbG9yJyxcbiAgICAgIGJvcmRlclJhZGl1czogJzFlbScsXG4gICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICAgIG1hcmdpbkxlZnQ6IG9mZnNldCA/ICcxZW0nIDogdW5kZWZpbmVkLFxuICAgICAgaGVpZ2h0OiAnMWVtJyxcbiAgICAgIHZlcnRpY2FsQWxpZ246ICd0b3AnLFxuICAgICAgd2lkdGg6ICcxZW0nLFxuICAgIH19XG4gIC8+XG4pO1xuXG5leHBvcnQgaW50ZXJmYWNlIExvYWRpbmdJbmRpY2F0b3JQcm9wczxcbiAgT3B0aW9uID0gdW5rbm93bixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4gPSBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+ID0gR3JvdXBCYXNlPE9wdGlvbj5cbj4gZXh0ZW5kcyBDb21tb25Qcm9wc0FuZENsYXNzTmFtZTxPcHRpb24sIElzTXVsdGksIEdyb3VwPiB7XG4gIC8qKiBQcm9wcyB0aGF0IHdpbGwgYmUgcGFzc2VkIG9uIHRvIHRoZSBjaGlsZHJlbi4gKi9cbiAgaW5uZXJQcm9wczogSlNYLkludHJpbnNpY0VsZW1lbnRzWydkaXYnXTtcbiAgLyoqIFRoZSBmb2N1c2VkIHN0YXRlIG9mIHRoZSBzZWxlY3QuICovXG4gIGlzRm9jdXNlZDogYm9vbGVhbjtcbiAgaXNEaXNhYmxlZDogYm9vbGVhbjtcbiAgLyoqIFNldCBzaXplIG9mIHRoZSBjb250YWluZXIuICovXG4gIHNpemU6IG51bWJlcjtcbn1cbmV4cG9ydCBjb25zdCBMb2FkaW5nSW5kaWNhdG9yID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KHtcbiAgaW5uZXJQcm9wcyxcbiAgaXNSdGwsXG4gIHNpemUgPSA0LFxuICAuLi5yZXN0UHJvcHNcbn06IExvYWRpbmdJbmRpY2F0b3JQcm9wczxPcHRpb24sIElzTXVsdGksIEdyb3VwPikgPT4ge1xuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIHsuLi5nZXRTdHlsZVByb3BzKFxuICAgICAgICB7IC4uLnJlc3RQcm9wcywgaW5uZXJQcm9wcywgaXNSdGwsIHNpemUgfSxcbiAgICAgICAgJ2xvYWRpbmdJbmRpY2F0b3InLFxuICAgICAgICB7XG4gICAgICAgICAgaW5kaWNhdG9yOiB0cnVlLFxuICAgICAgICAgICdsb2FkaW5nLWluZGljYXRvcic6IHRydWUsXG4gICAgICAgIH1cbiAgICAgICl9XG4gICAgICB7Li4uaW5uZXJQcm9wc31cbiAgICA+XG4gICAgICA8TG9hZGluZ0RvdCBkZWxheT17MH0gb2Zmc2V0PXtpc1J0bH0gLz5cbiAgICAgIDxMb2FkaW5nRG90IGRlbGF5PXsxNjB9IG9mZnNldCAvPlxuICAgICAgPExvYWRpbmdEb3QgZGVsYXk9ezMyMH0gb2Zmc2V0PXshaXNSdGx9IC8+XG4gICAgPC9kaXY+XG4gICk7XG59O1xuIl19 */")
  });
};
var $3 = function(e) {
  var n = e.innerProps, r = e.isRtl, i = e.size, o = i === void 0 ? 4 : i, s = Mr(e, y3);
  return Pe("div", Ae({}, Xt(se(se({}, s), {}, {
    innerProps: n,
    isRtl: r,
    size: o
  }), "loadingIndicator", {
    indicator: true,
    "loading-indicator": true
  }), n), Pe(lp, {
    delay: 0,
    offset: r
  }), Pe(lp, {
    delay: 160,
    offset: true
  }), Pe(lp, {
    delay: 320,
    offset: !r
  }));
};
var j3 = function(e, n) {
  var r = e.isDisabled, i = e.isFocused, o = e.theme, s = o.colors, a = o.borderRadius, l = o.spacing;
  return se({
    label: "control",
    alignItems: "center",
    cursor: "default",
    display: "flex",
    flexWrap: "wrap",
    justifyContent: "space-between",
    minHeight: l.controlHeight,
    outline: "0 !important",
    position: "relative",
    transition: "all 100ms"
  }, n ? {} : {
    backgroundColor: r ? s.neutral5 : s.neutral0,
    borderColor: r ? s.neutral10 : i ? s.primary : s.neutral20,
    borderRadius: a,
    borderStyle: "solid",
    borderWidth: 1,
    boxShadow: i ? "0 0 0 1px ".concat(s.primary) : void 0,
    "&:hover": {
      borderColor: i ? s.primary : s.neutral30
    }
  });
};
var R3 = function(e) {
  var n = e.children, r = e.isDisabled, i = e.isFocused, o = e.innerRef, s = e.innerProps, a = e.menuIsOpen;
  return Pe("div", Ae({
    ref: o
  }, Xt(e, "control", {
    control: true,
    "control--is-disabled": r,
    "control--is-focused": i,
    "control--menu-is-open": a
  }), s, {
    "aria-disabled": r || void 0
  }), n);
};
var D3 = R3;
var Q3 = ["data"];
var B3 = function(e, n) {
  var r = e.theme.spacing;
  return n ? {} : {
    paddingBottom: r.baseUnit * 2,
    paddingTop: r.baseUnit * 2
  };
};
var _3 = function(e) {
  var n = e.children, r = e.cx, i = e.getStyles, o = e.getClassNames, s = e.Heading, a = e.headingProps, l = e.innerProps, c = e.label, u = e.theme, f = e.selectProps;
  return Pe("div", Ae({}, Xt(e, "group", {
    group: true
  }), l), Pe(s, Ae({}, a, {
    selectProps: f,
    theme: u,
    getStyles: i,
    getClassNames: o,
    cx: r
  }), c), Pe("div", null, n));
};
var M3 = function(e, n) {
  var r = e.theme, i = r.colors, o = r.spacing;
  return se({
    label: "group",
    cursor: "default",
    display: "block"
  }, n ? {} : {
    color: i.neutral40,
    fontSize: "75%",
    fontWeight: 500,
    marginBottom: "0.25em",
    paddingLeft: o.baseUnit * 3,
    paddingRight: o.baseUnit * 3,
    textTransform: "uppercase"
  });
};
var N3 = function(e) {
  var n = GA(e);
  n.data;
  var r = Mr(n, Q3);
  return Pe("div", Ae({}, Xt(e, "groupHeading", {
    "group-heading": true
  }), r));
};
var F3 = _3;
var Z3 = ["innerRef", "isDisabled", "isHidden", "inputClassName"];
var W3 = function(e, n) {
  var r = e.isDisabled, i = e.value, o = e.theme, s = o.spacing, a = o.colors;
  return se(se({
    visibility: r ? "hidden" : "visible",
    // force css to recompute when value change due to @emotion bug.
    // We can remove it whenever the bug is fixed.
    transform: i ? "translateZ(0)" : ""
  }, V3), n ? {} : {
    margin: s.baseUnit / 2,
    paddingBottom: s.baseUnit / 2,
    paddingTop: s.baseUnit / 2,
    color: a.neutral80
  });
};
var nP = {
  gridArea: "1 / 2",
  font: "inherit",
  minWidth: "2px",
  border: 0,
  margin: 0,
  outline: 0,
  padding: 0
};
var V3 = {
  flex: "1 1 auto",
  display: "inline-grid",
  gridArea: "1 / 1 / 2 / 3",
  gridTemplateColumns: "0 min-content",
  "&:after": se({
    content: 'attr(data-value) " "',
    visibility: "hidden",
    whiteSpace: "pre"
  }, nP)
};
var z3 = function(e) {
  return se({
    label: "input",
    color: "inherit",
    background: 0,
    opacity: e ? 0 : 1,
    width: "100%"
  }, nP);
};
var L3 = function(e) {
  var n = e.cx, r = e.value, i = GA(e), o = i.innerRef, s = i.isDisabled, a = i.isHidden, l = i.inputClassName, c = Mr(i, Z3);
  return Pe("div", Ae({}, Xt(e, "input", {
    "input-container": true
  }), {
    "data-value": r || ""
  }), Pe("input", Ae({
    className: n({
      input: true
    }, l),
    ref: o,
    style: z3(a),
    disabled: s
  }, c)));
};
var X3 = L3;
var G3 = function(e, n) {
  var r = e.theme, i = r.spacing, o = r.borderRadius, s = r.colors;
  return se({
    label: "multiValue",
    display: "flex",
    minWidth: 0
  }, n ? {} : {
    backgroundColor: s.neutral10,
    borderRadius: o / 2,
    margin: i.baseUnit / 2
  });
};
var Y3 = function(e, n) {
  var r = e.theme, i = r.borderRadius, o = r.colors, s = e.cropWithEllipsis;
  return se({
    overflow: "hidden",
    textOverflow: s || s === void 0 ? "ellipsis" : void 0,
    whiteSpace: "nowrap"
  }, n ? {} : {
    borderRadius: i / 2,
    color: o.neutral80,
    fontSize: "85%",
    padding: 3,
    paddingLeft: 6
  });
};
var q3 = function(e, n) {
  var r = e.theme, i = r.spacing, o = r.borderRadius, s = r.colors, a = e.isFocused;
  return se({
    alignItems: "center",
    display: "flex"
  }, n ? {} : {
    borderRadius: o / 2,
    backgroundColor: a ? s.dangerLight : void 0,
    paddingLeft: i.baseUnit,
    paddingRight: i.baseUnit,
    ":hover": {
      backgroundColor: s.dangerLight,
      color: s.danger
    }
  });
};
var rP = function(e) {
  var n = e.children, r = e.innerProps;
  return Pe("div", r, n);
};
var U3 = rP;
var H3 = rP;
function J3(t4) {
  var e = t4.children, n = t4.innerProps;
  return Pe("div", Ae({
    role: "button"
  }, n), e || Pe(ix, {
    size: 14
  }));
}
var K3 = function(e) {
  var n = e.children, r = e.components, i = e.data, o = e.innerProps, s = e.isDisabled, a = e.removeProps, l = e.selectProps, c = r.Container, u = r.Label, f = r.Remove;
  return Pe(c, {
    data: i,
    innerProps: se(se({}, Xt(e, "multiValue", {
      "multi-value": true,
      "multi-value--is-disabled": s
    })), o),
    selectProps: l
  }, Pe(u, {
    data: i,
    innerProps: se({}, Xt(e, "multiValueLabel", {
      "multi-value__label": true
    })),
    selectProps: l
  }, n), Pe(f, {
    data: i,
    innerProps: se(se({}, Xt(e, "multiValueRemove", {
      "multi-value__remove": true
    })), {}, {
      "aria-label": "Remove ".concat(n || "option")
    }, a),
    selectProps: l
  }));
};
var eB = K3;
var tB = function(e, n) {
  var r = e.isDisabled, i = e.isFocused, o = e.isSelected, s = e.theme, a = s.spacing, l = s.colors;
  return se({
    label: "option",
    cursor: "default",
    display: "block",
    fontSize: "inherit",
    width: "100%",
    userSelect: "none",
    WebkitTapHighlightColor: "rgba(0, 0, 0, 0)"
  }, n ? {} : {
    backgroundColor: o ? l.primary : i ? l.primary25 : "transparent",
    color: r ? l.neutral20 : o ? l.neutral0 : "inherit",
    padding: "".concat(a.baseUnit * 2, "px ").concat(a.baseUnit * 3, "px"),
    // provide some affordance on touch devices
    ":active": {
      backgroundColor: r ? void 0 : o ? l.primary : l.primary50
    }
  });
};
var nB = function(e) {
  var n = e.children, r = e.isDisabled, i = e.isFocused, o = e.isSelected, s = e.innerRef, a = e.innerProps;
  return Pe("div", Ae({}, Xt(e, "option", {
    option: true,
    "option--is-disabled": r,
    "option--is-focused": i,
    "option--is-selected": o
  }), {
    ref: s,
    "aria-disabled": r
  }, a), n);
};
var rB = nB;
var iB = function(e, n) {
  var r = e.theme, i = r.spacing, o = r.colors;
  return se({
    label: "placeholder",
    gridArea: "1 / 1 / 2 / 3"
  }, n ? {} : {
    color: o.neutral50,
    marginLeft: i.baseUnit / 2,
    marginRight: i.baseUnit / 2
  });
};
var oB = function(e) {
  var n = e.children, r = e.innerProps;
  return Pe("div", Ae({}, Xt(e, "placeholder", {
    placeholder: true
  }), r), n);
};
var sB = oB;
var aB = function(e, n) {
  var r = e.isDisabled, i = e.theme, o = i.spacing, s = i.colors;
  return se({
    label: "singleValue",
    gridArea: "1 / 1 / 2 / 3",
    maxWidth: "100%",
    overflow: "hidden",
    textOverflow: "ellipsis",
    whiteSpace: "nowrap"
  }, n ? {} : {
    color: r ? s.neutral40 : s.neutral80,
    marginLeft: o.baseUnit / 2,
    marginRight: o.baseUnit / 2
  });
};
var lB = function(e) {
  var n = e.children, r = e.isDisabled, i = e.innerProps;
  return Pe("div", Ae({}, Xt(e, "singleValue", {
    "single-value": true,
    "single-value--is-disabled": r
  }), i), n);
};
var cB = lB;
var rf = {
  ClearIndicator: A3,
  Control: D3,
  DropdownIndicator: C3,
  DownChevron: eP,
  CrossIcon: ix,
  Group: F3,
  GroupHeading: N3,
  IndicatorsContainer: x3,
  IndicatorSeparator: E3,
  Input: X3,
  LoadingIndicator: $3,
  Menu: i3,
  MenuList: s3,
  MenuPortal: d3,
  LoadingMessage: u3,
  NoOptionsMessage: c3,
  MultiValue: eB,
  MultiValueContainer: U3,
  MultiValueLabel: H3,
  MultiValueRemove: J3,
  Option: rB,
  Placeholder: sB,
  SelectContainer: p3,
  SingleValue: cB,
  ValueContainer: m3
};
var uB = function(e) {
  return se(se({}, rf), e.components);
};
var Ty = Number.isNaN || function(e) {
  return typeof e == "number" && e !== e;
};
function fB(t4, e) {
  return !!(t4 === e || Ty(t4) && Ty(e));
}
function dB(t4, e) {
  if (t4.length !== e.length)
    return false;
  for (var n = 0; n < t4.length; n++)
    if (!fB(t4[n], e[n]))
      return false;
  return true;
}
function hB(t4, e) {
  e === void 0 && (e = dB);
  var n = null;
  function r() {
    for (var i = [], o = 0; o < arguments.length; o++)
      i[o] = arguments[o];
    if (n && n.lastThis === this && e(i, n.lastArgs))
      return n.lastResult;
    var s = t4.apply(this, i);
    return n = {
      lastResult: s,
      lastArgs: i,
      lastThis: this
    }, s;
  }
  return r.clear = function() {
    n = null;
  }, r;
}
function pB() {
  return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
}
var gB = false ? {
  name: "7pg0cj-a11yText",
  styles: "label:a11yText;z-index:9999;border:0;clip:rect(1px, 1px, 1px, 1px);height:1px;width:1px;position:absolute;overflow:hidden;padding:0;white-space:nowrap"
} : {
  name: "1f43avz-a11yText-A11yText",
  styles: "label:a11yText;z-index:9999;border:0;clip:rect(1px, 1px, 1px, 1px);height:1px;width:1px;position:absolute;overflow:hidden;padding:0;white-space:nowrap;label:A11yText;",
  map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkExMXlUZXh0LnRzeCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFNSSIsImZpbGUiOiJBMTF5VGV4dC50c3giLCJzb3VyY2VzQ29udGVudCI6WyIvKiogQGpzeCBqc3ggKi9cbmltcG9ydCB7IGpzeCB9IGZyb20gJ0BlbW90aW9uL3JlYWN0JztcblxuLy8gQXNzaXN0aXZlIHRleHQgdG8gZGVzY3JpYmUgdmlzdWFsIGVsZW1lbnRzLiBIaWRkZW4gZm9yIHNpZ2h0ZWQgdXNlcnMuXG5jb25zdCBBMTF5VGV4dCA9IChwcm9wczogSlNYLkludHJpbnNpY0VsZW1lbnRzWydzcGFuJ10pID0+IChcbiAgPHNwYW5cbiAgICBjc3M9e3tcbiAgICAgIGxhYmVsOiAnYTExeVRleHQnLFxuICAgICAgekluZGV4OiA5OTk5LFxuICAgICAgYm9yZGVyOiAwLFxuICAgICAgY2xpcDogJ3JlY3QoMXB4LCAxcHgsIDFweCwgMXB4KScsXG4gICAgICBoZWlnaHQ6IDEsXG4gICAgICB3aWR0aDogMSxcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICAgcGFkZGluZzogMCxcbiAgICAgIHdoaXRlU3BhY2U6ICdub3dyYXAnLFxuICAgIH19XG4gICAgey4uLnByb3BzfVxuICAvPlxuKTtcblxuZXhwb3J0IGRlZmF1bHQgQTExeVRleHQ7XG4iXX0= */",
  toString: pB
};
var mB = function(e) {
  return Pe("span", Ae({
    css: gB
  }, e));
};
var Iy = mB;
var OB = {
  guidance: function(e) {
    var n = e.isSearchable, r = e.isMulti, i = e.tabSelectsValue, o = e.context, s = e.isInitialFocus;
    switch (o) {
      case "menu":
        return "Use Up and Down to choose options, press Enter to select the currently focused option, press Escape to exit the menu".concat(i ? ", press Tab to select the option and exit the menu" : "", ".");
      case "input":
        return s ? "".concat(e["aria-label"] || "Select", " is focused ").concat(n ? ",type to refine list" : "", ", press Down to open the menu, ").concat(r ? " press left to focus selected values" : "") : "";
      case "value":
        return "Use left and right to toggle between focused values, press Backspace to remove the currently focused value";
      default:
        return "";
    }
  },
  onChange: function(e) {
    var n = e.action, r = e.label, i = r === void 0 ? "" : r, o = e.labels, s = e.isDisabled;
    switch (n) {
      case "deselect-option":
      case "pop-value":
      case "remove-value":
        return "option ".concat(i, ", deselected.");
      case "clear":
        return "All selected options have been cleared.";
      case "initial-input-focus":
        return "option".concat(o.length > 1 ? "s" : "", " ").concat(o.join(","), ", selected.");
      case "select-option":
        return s ? "option ".concat(i, " is disabled. Select another option.") : "option ".concat(i, ", selected.");
      default:
        return "";
    }
  },
  onFocus: function(e) {
    var n = e.context, r = e.focused, i = e.options, o = e.label, s = o === void 0 ? "" : o, a = e.selectValue, l = e.isDisabled, c = e.isSelected, u = e.isAppleDevice, f = function(O, m) {
      return O && O.length ? "".concat(O.indexOf(m) + 1, " of ").concat(O.length) : "";
    };
    if (n === "value" && a)
      return "value ".concat(s, " focused, ").concat(f(a, r), ".");
    if (n === "menu" && u) {
      var d = l ? " disabled" : "", h = "".concat(c ? " selected" : "").concat(d);
      return "".concat(s).concat(h, ", ").concat(f(i, r), ".");
    }
    return "";
  },
  onFilter: function(e) {
    var n = e.inputValue, r = e.resultsMessage;
    return "".concat(r).concat(n ? " for search term " + n : "", ".");
  }
};
var xB = function(e) {
  var n = e.ariaSelection, r = e.focusedOption, i = e.focusedValue, o = e.focusableOptions, s = e.isFocused, a = e.selectValue, l = e.selectProps, c = e.id, u = e.isAppleDevice, f = l.ariaLiveMessages, d = l.getOptionLabel, h = l.inputValue, p = l.isMulti, O = l.isOptionDisabled, m = l.isSearchable, x = l.menuIsOpen, v = l.options, y = l.screenReaderStatus, S = l.tabSelectsValue, b = l.isLoading, w = l["aria-label"], C = l["aria-live"], k = We(function() {
    return se(se({}, OB), f || {});
  }, [f]), T = We(function() {
    var D = "";
    if (n && k.onChange) {
      var N = n.option, z = n.options, Z = n.removedValue, J = n.removedValues, L = n.value, W = function(V) {
        return Array.isArray(V) ? null : V;
      }, R = Z || N || W(L), Q = R ? d(R) : "", _ = z || J || void 0, G = _ ? _.map(d) : [], M = se({
        // multiSelected items are usually items that have already been selected
        // or set by the user as a default value so we assume they are not disabled
        isDisabled: R && O(R, a),
        label: Q,
        labels: G
      }, n);
      D = k.onChange(M);
    }
    return D;
  }, [n, k, O, a, d]), A = We(function() {
    var D = "", N = r || i, z = !!(r && a && a.includes(r));
    if (N && k.onFocus) {
      var Z = {
        focused: N,
        label: d(N),
        isDisabled: O(N, a),
        isSelected: z,
        options: o,
        context: N === r ? "menu" : "value",
        selectValue: a,
        isAppleDevice: u
      };
      D = k.onFocus(Z);
    }
    return D;
  }, [r, i, d, O, k, o, a, u]), E = We(function() {
    var D = "";
    if (x && v.length && !b && k.onFilter) {
      var N = y({
        count: o.length
      });
      D = k.onFilter({
        inputValue: h,
        resultsMessage: N
      });
    }
    return D;
  }, [o, h, x, k, v, y, b]), $ = (n == null ? void 0 : n.action) === "initial-input-focus", j = We(function() {
    var D = "";
    if (k.guidance) {
      var N = i ? "value" : x ? "menu" : "input";
      D = k.guidance({
        "aria-label": w,
        context: N,
        isDisabled: r && O(r, a),
        isMulti: p,
        isSearchable: m,
        tabSelectsValue: S,
        isInitialFocus: $
      });
    }
    return D;
  }, [w, r, i, p, O, m, x, k, a, S, $]), B = Pe(_r, null, Pe("span", {
    id: "aria-selection"
  }, T), Pe("span", {
    id: "aria-focused"
  }, A), Pe("span", {
    id: "aria-results"
  }, E), Pe("span", {
    id: "aria-guidance"
  }, j));
  return Pe(_r, null, Pe(Iy, {
    id: c
  }, $ && B), Pe(Iy, {
    "aria-live": C,
    "aria-atomic": "false",
    "aria-relevant": "additions text",
    role: "log"
  }, s && !$ && B));
};
var vB = xB;
var Cg = [{
  base: "A",
  letters: "A\u24B6\uFF21\xC0\xC1\xC2\u1EA6\u1EA4\u1EAA\u1EA8\xC3\u0100\u0102\u1EB0\u1EAE\u1EB4\u1EB2\u0226\u01E0\xC4\u01DE\u1EA2\xC5\u01FA\u01CD\u0200\u0202\u1EA0\u1EAC\u1EB6\u1E00\u0104\u023A\u2C6F"
}, {
  base: "AA",
  letters: "\uA732"
}, {
  base: "AE",
  letters: "\xC6\u01FC\u01E2"
}, {
  base: "AO",
  letters: "\uA734"
}, {
  base: "AU",
  letters: "\uA736"
}, {
  base: "AV",
  letters: "\uA738\uA73A"
}, {
  base: "AY",
  letters: "\uA73C"
}, {
  base: "B",
  letters: "B\u24B7\uFF22\u1E02\u1E04\u1E06\u0243\u0182\u0181"
}, {
  base: "C",
  letters: "C\u24B8\uFF23\u0106\u0108\u010A\u010C\xC7\u1E08\u0187\u023B\uA73E"
}, {
  base: "D",
  letters: "D\u24B9\uFF24\u1E0A\u010E\u1E0C\u1E10\u1E12\u1E0E\u0110\u018B\u018A\u0189\uA779"
}, {
  base: "DZ",
  letters: "\u01F1\u01C4"
}, {
  base: "Dz",
  letters: "\u01F2\u01C5"
}, {
  base: "E",
  letters: "E\u24BA\uFF25\xC8\xC9\xCA\u1EC0\u1EBE\u1EC4\u1EC2\u1EBC\u0112\u1E14\u1E16\u0114\u0116\xCB\u1EBA\u011A\u0204\u0206\u1EB8\u1EC6\u0228\u1E1C\u0118\u1E18\u1E1A\u0190\u018E"
}, {
  base: "F",
  letters: "F\u24BB\uFF26\u1E1E\u0191\uA77B"
}, {
  base: "G",
  letters: "G\u24BC\uFF27\u01F4\u011C\u1E20\u011E\u0120\u01E6\u0122\u01E4\u0193\uA7A0\uA77D\uA77E"
}, {
  base: "H",
  letters: "H\u24BD\uFF28\u0124\u1E22\u1E26\u021E\u1E24\u1E28\u1E2A\u0126\u2C67\u2C75\uA78D"
}, {
  base: "I",
  letters: "I\u24BE\uFF29\xCC\xCD\xCE\u0128\u012A\u012C\u0130\xCF\u1E2E\u1EC8\u01CF\u0208\u020A\u1ECA\u012E\u1E2C\u0197"
}, {
  base: "J",
  letters: "J\u24BF\uFF2A\u0134\u0248"
}, {
  base: "K",
  letters: "K\u24C0\uFF2B\u1E30\u01E8\u1E32\u0136\u1E34\u0198\u2C69\uA740\uA742\uA744\uA7A2"
}, {
  base: "L",
  letters: "L\u24C1\uFF2C\u013F\u0139\u013D\u1E36\u1E38\u013B\u1E3C\u1E3A\u0141\u023D\u2C62\u2C60\uA748\uA746\uA780"
}, {
  base: "LJ",
  letters: "\u01C7"
}, {
  base: "Lj",
  letters: "\u01C8"
}, {
  base: "M",
  letters: "M\u24C2\uFF2D\u1E3E\u1E40\u1E42\u2C6E\u019C"
}, {
  base: "N",
  letters: "N\u24C3\uFF2E\u01F8\u0143\xD1\u1E44\u0147\u1E46\u0145\u1E4A\u1E48\u0220\u019D\uA790\uA7A4"
}, {
  base: "NJ",
  letters: "\u01CA"
}, {
  base: "Nj",
  letters: "\u01CB"
}, {
  base: "O",
  letters: "O\u24C4\uFF2F\xD2\xD3\xD4\u1ED2\u1ED0\u1ED6\u1ED4\xD5\u1E4C\u022C\u1E4E\u014C\u1E50\u1E52\u014E\u022E\u0230\xD6\u022A\u1ECE\u0150\u01D1\u020C\u020E\u01A0\u1EDC\u1EDA\u1EE0\u1EDE\u1EE2\u1ECC\u1ED8\u01EA\u01EC\xD8\u01FE\u0186\u019F\uA74A\uA74C"
}, {
  base: "OI",
  letters: "\u01A2"
}, {
  base: "OO",
  letters: "\uA74E"
}, {
  base: "OU",
  letters: "\u0222"
}, {
  base: "P",
  letters: "P\u24C5\uFF30\u1E54\u1E56\u01A4\u2C63\uA750\uA752\uA754"
}, {
  base: "Q",
  letters: "Q\u24C6\uFF31\uA756\uA758\u024A"
}, {
  base: "R",
  letters: "R\u24C7\uFF32\u0154\u1E58\u0158\u0210\u0212\u1E5A\u1E5C\u0156\u1E5E\u024C\u2C64\uA75A\uA7A6\uA782"
}, {
  base: "S",
  letters: "S\u24C8\uFF33\u1E9E\u015A\u1E64\u015C\u1E60\u0160\u1E66\u1E62\u1E68\u0218\u015E\u2C7E\uA7A8\uA784"
}, {
  base: "T",
  letters: "T\u24C9\uFF34\u1E6A\u0164\u1E6C\u021A\u0162\u1E70\u1E6E\u0166\u01AC\u01AE\u023E\uA786"
}, {
  base: "TZ",
  letters: "\uA728"
}, {
  base: "U",
  letters: "U\u24CA\uFF35\xD9\xDA\xDB\u0168\u1E78\u016A\u1E7A\u016C\xDC\u01DB\u01D7\u01D5\u01D9\u1EE6\u016E\u0170\u01D3\u0214\u0216\u01AF\u1EEA\u1EE8\u1EEE\u1EEC\u1EF0\u1EE4\u1E72\u0172\u1E76\u1E74\u0244"
}, {
  base: "V",
  letters: "V\u24CB\uFF36\u1E7C\u1E7E\u01B2\uA75E\u0245"
}, {
  base: "VY",
  letters: "\uA760"
}, {
  base: "W",
  letters: "W\u24CC\uFF37\u1E80\u1E82\u0174\u1E86\u1E84\u1E88\u2C72"
}, {
  base: "X",
  letters: "X\u24CD\uFF38\u1E8A\u1E8C"
}, {
  base: "Y",
  letters: "Y\u24CE\uFF39\u1EF2\xDD\u0176\u1EF8\u0232\u1E8E\u0178\u1EF6\u1EF4\u01B3\u024E\u1EFE"
}, {
  base: "Z",
  letters: "Z\u24CF\uFF3A\u0179\u1E90\u017B\u017D\u1E92\u1E94\u01B5\u0224\u2C7F\u2C6B\uA762"
}, {
  base: "a",
  letters: "a\u24D0\uFF41\u1E9A\xE0\xE1\xE2\u1EA7\u1EA5\u1EAB\u1EA9\xE3\u0101\u0103\u1EB1\u1EAF\u1EB5\u1EB3\u0227\u01E1\xE4\u01DF\u1EA3\xE5\u01FB\u01CE\u0201\u0203\u1EA1\u1EAD\u1EB7\u1E01\u0105\u2C65\u0250"
}, {
  base: "aa",
  letters: "\uA733"
}, {
  base: "ae",
  letters: "\xE6\u01FD\u01E3"
}, {
  base: "ao",
  letters: "\uA735"
}, {
  base: "au",
  letters: "\uA737"
}, {
  base: "av",
  letters: "\uA739\uA73B"
}, {
  base: "ay",
  letters: "\uA73D"
}, {
  base: "b",
  letters: "b\u24D1\uFF42\u1E03\u1E05\u1E07\u0180\u0183\u0253"
}, {
  base: "c",
  letters: "c\u24D2\uFF43\u0107\u0109\u010B\u010D\xE7\u1E09\u0188\u023C\uA73F\u2184"
}, {
  base: "d",
  letters: "d\u24D3\uFF44\u1E0B\u010F\u1E0D\u1E11\u1E13\u1E0F\u0111\u018C\u0256\u0257\uA77A"
}, {
  base: "dz",
  letters: "\u01F3\u01C6"
}, {
  base: "e",
  letters: "e\u24D4\uFF45\xE8\xE9\xEA\u1EC1\u1EBF\u1EC5\u1EC3\u1EBD\u0113\u1E15\u1E17\u0115\u0117\xEB\u1EBB\u011B\u0205\u0207\u1EB9\u1EC7\u0229\u1E1D\u0119\u1E19\u1E1B\u0247\u025B\u01DD"
}, {
  base: "f",
  letters: "f\u24D5\uFF46\u1E1F\u0192\uA77C"
}, {
  base: "g",
  letters: "g\u24D6\uFF47\u01F5\u011D\u1E21\u011F\u0121\u01E7\u0123\u01E5\u0260\uA7A1\u1D79\uA77F"
}, {
  base: "h",
  letters: "h\u24D7\uFF48\u0125\u1E23\u1E27\u021F\u1E25\u1E29\u1E2B\u1E96\u0127\u2C68\u2C76\u0265"
}, {
  base: "hv",
  letters: "\u0195"
}, {
  base: "i",
  letters: "i\u24D8\uFF49\xEC\xED\xEE\u0129\u012B\u012D\xEF\u1E2F\u1EC9\u01D0\u0209\u020B\u1ECB\u012F\u1E2D\u0268\u0131"
}, {
  base: "j",
  letters: "j\u24D9\uFF4A\u0135\u01F0\u0249"
}, {
  base: "k",
  letters: "k\u24DA\uFF4B\u1E31\u01E9\u1E33\u0137\u1E35\u0199\u2C6A\uA741\uA743\uA745\uA7A3"
}, {
  base: "l",
  letters: "l\u24DB\uFF4C\u0140\u013A\u013E\u1E37\u1E39\u013C\u1E3D\u1E3B\u017F\u0142\u019A\u026B\u2C61\uA749\uA781\uA747"
}, {
  base: "lj",
  letters: "\u01C9"
}, {
  base: "m",
  letters: "m\u24DC\uFF4D\u1E3F\u1E41\u1E43\u0271\u026F"
}, {
  base: "n",
  letters: "n\u24DD\uFF4E\u01F9\u0144\xF1\u1E45\u0148\u1E47\u0146\u1E4B\u1E49\u019E\u0272\u0149\uA791\uA7A5"
}, {
  base: "nj",
  letters: "\u01CC"
}, {
  base: "o",
  letters: "o\u24DE\uFF4F\xF2\xF3\xF4\u1ED3\u1ED1\u1ED7\u1ED5\xF5\u1E4D\u022D\u1E4F\u014D\u1E51\u1E53\u014F\u022F\u0231\xF6\u022B\u1ECF\u0151\u01D2\u020D\u020F\u01A1\u1EDD\u1EDB\u1EE1\u1EDF\u1EE3\u1ECD\u1ED9\u01EB\u01ED\xF8\u01FF\u0254\uA74B\uA74D\u0275"
}, {
  base: "oi",
  letters: "\u01A3"
}, {
  base: "ou",
  letters: "\u0223"
}, {
  base: "oo",
  letters: "\uA74F"
}, {
  base: "p",
  letters: "p\u24DF\uFF50\u1E55\u1E57\u01A5\u1D7D\uA751\uA753\uA755"
}, {
  base: "q",
  letters: "q\u24E0\uFF51\u024B\uA757\uA759"
}, {
  base: "r",
  letters: "r\u24E1\uFF52\u0155\u1E59\u0159\u0211\u0213\u1E5B\u1E5D\u0157\u1E5F\u024D\u027D\uA75B\uA7A7\uA783"
}, {
  base: "s",
  letters: "s\u24E2\uFF53\xDF\u015B\u1E65\u015D\u1E61\u0161\u1E67\u1E63\u1E69\u0219\u015F\u023F\uA7A9\uA785\u1E9B"
}, {
  base: "t",
  letters: "t\u24E3\uFF54\u1E6B\u1E97\u0165\u1E6D\u021B\u0163\u1E71\u1E6F\u0167\u01AD\u0288\u2C66\uA787"
}, {
  base: "tz",
  letters: "\uA729"
}, {
  base: "u",
  letters: "u\u24E4\uFF55\xF9\xFA\xFB\u0169\u1E79\u016B\u1E7B\u016D\xFC\u01DC\u01D8\u01D6\u01DA\u1EE7\u016F\u0171\u01D4\u0215\u0217\u01B0\u1EEB\u1EE9\u1EEF\u1EED\u1EF1\u1EE5\u1E73\u0173\u1E77\u1E75\u0289"
}, {
  base: "v",
  letters: "v\u24E5\uFF56\u1E7D\u1E7F\u028B\uA75F\u028C"
}, {
  base: "vy",
  letters: "\uA761"
}, {
  base: "w",
  letters: "w\u24E6\uFF57\u1E81\u1E83\u0175\u1E87\u1E85\u1E98\u1E89\u2C73"
}, {
  base: "x",
  letters: "x\u24E7\uFF58\u1E8B\u1E8D"
}, {
  base: "y",
  letters: "y\u24E8\uFF59\u1EF3\xFD\u0177\u1EF9\u0233\u1E8F\xFF\u1EF7\u1E99\u1EF5\u01B4\u024F\u1EFF"
}, {
  base: "z",
  letters: "z\u24E9\uFF5A\u017A\u1E91\u017C\u017E\u1E93\u1E95\u01B6\u0225\u0240\u2C6C\uA763"
}];
var yB = new RegExp("[" + Cg.map(function(t4) {
  return t4.letters;
}).join("") + "]", "g");
var iP = {};
for (cp = 0; cp < Cg.length; cp++)
  for (up = Cg[cp], fp = 0; fp < up.letters.length; fp++)
    iP[up.letters[fp]] = up.base;
var up;
var fp;
var cp;
var oP = function(e) {
  return e.replace(yB, function(n) {
    return iP[n];
  });
};
var bB = hB(oP);
var $y = function(e) {
  return e.replace(/^\s+|\s+$/g, "");
};
var SB = function(e) {
  return "".concat(e.label, " ").concat(e.value);
};
var wB = function(e) {
  return function(n, r) {
    if (n.data.__isNew__)
      return true;
    var i = se({
      ignoreCase: true,
      ignoreAccents: true,
      stringify: SB,
      trim: true,
      matchFrom: "any"
    }, e), o = i.ignoreCase, s = i.ignoreAccents, a = i.stringify, l = i.trim, c = i.matchFrom, u = l ? $y(r) : r, f = l ? $y(a(n)) : a(n);
    return o && (u = u.toLowerCase(), f = f.toLowerCase()), s && (u = bB(u), f = oP(f)), c === "start" ? f.substr(0, u.length) === u : f.indexOf(u) > -1;
  };
};
var CB = ["innerRef"];
function kB(t4) {
  var e = t4.innerRef, n = Mr(t4, CB), r = UQ(n, "onExited", "in", "enter", "exit", "appear");
  return Pe("input", Ae({
    ref: e
  }, r, {
    css: /* @__PURE__ */ ex({
      label: "dummyInput",
      // get rid of any default styles
      background: 0,
      border: 0,
      // important! this hides the flashing cursor
      caretColor: "transparent",
      fontSize: "inherit",
      gridArea: "1 / 1 / 2 / 3",
      outline: 0,
      padding: 0,
      // important! without `width` browsers won't allow focus
      width: 1,
      // remove cursor on desktop
      color: "transparent",
      // remove cursor on mobile whilst maintaining "scroll into view" behaviour
      left: -100,
      opacity: 0,
      position: "relative",
      transform: "scale(.01)"
    }, false ? "" : ";label:DummyInput;", false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkR1bW15SW5wdXQudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQXlCTSIsImZpbGUiOiJEdW1teUlucHV0LnRzeCIsInNvdXJjZXNDb250ZW50IjpbIi8qKiBAanN4IGpzeCAqL1xuaW1wb3J0IHsgUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsganN4IH0gZnJvbSAnQGVtb3Rpb24vcmVhY3QnO1xuaW1wb3J0IHsgcmVtb3ZlUHJvcHMgfSBmcm9tICcuLi91dGlscyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIER1bW15SW5wdXQoe1xuICBpbm5lclJlZixcbiAgLi4ucHJvcHNcbn06IEpTWC5JbnRyaW5zaWNFbGVtZW50c1snaW5wdXQnXSAmIHtcbiAgcmVhZG9ubHkgaW5uZXJSZWY6IFJlZjxIVE1MSW5wdXRFbGVtZW50Pjtcbn0pIHtcbiAgLy8gUmVtb3ZlIGFuaW1hdGlvbiBwcm9wcyBub3QgbWVhbnQgZm9yIEhUTUwgZWxlbWVudHNcbiAgY29uc3QgZmlsdGVyZWRQcm9wcyA9IHJlbW92ZVByb3BzKFxuICAgIHByb3BzLFxuICAgICdvbkV4aXRlZCcsXG4gICAgJ2luJyxcbiAgICAnZW50ZXInLFxuICAgICdleGl0JyxcbiAgICAnYXBwZWFyJ1xuICApO1xuXG4gIHJldHVybiAoXG4gICAgPGlucHV0XG4gICAgICByZWY9e2lubmVyUmVmfVxuICAgICAgey4uLmZpbHRlcmVkUHJvcHN9XG4gICAgICBjc3M9e3tcbiAgICAgICAgbGFiZWw6ICdkdW1teUlucHV0JyxcbiAgICAgICAgLy8gZ2V0IHJpZCBvZiBhbnkgZGVmYXVsdCBzdHlsZXNcbiAgICAgICAgYmFja2dyb3VuZDogMCxcbiAgICAgICAgYm9yZGVyOiAwLFxuICAgICAgICAvLyBpbXBvcnRhbnQhIHRoaXMgaGlkZXMgdGhlIGZsYXNoaW5nIGN1cnNvclxuICAgICAgICBjYXJldENvbG9yOiAndHJhbnNwYXJlbnQnLFxuICAgICAgICBmb250U2l6ZTogJ2luaGVyaXQnLFxuICAgICAgICBncmlkQXJlYTogJzEgLyAxIC8gMiAvIDMnLFxuICAgICAgICBvdXRsaW5lOiAwLFxuICAgICAgICBwYWRkaW5nOiAwLFxuICAgICAgICAvLyBpbXBvcnRhbnQhIHdpdGhvdXQgYHdpZHRoYCBicm93c2VycyB3b24ndCBhbGxvdyBmb2N1c1xuICAgICAgICB3aWR0aDogMSxcblxuICAgICAgICAvLyByZW1vdmUgY3Vyc29yIG9uIGRlc2t0b3BcbiAgICAgICAgY29sb3I6ICd0cmFuc3BhcmVudCcsXG5cbiAgICAgICAgLy8gcmVtb3ZlIGN1cnNvciBvbiBtb2JpbGUgd2hpbHN0IG1haW50YWluaW5nIFwic2Nyb2xsIGludG8gdmlld1wiIGJlaGF2aW91clxuICAgICAgICBsZWZ0OiAtMTAwLFxuICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgICAgdHJhbnNmb3JtOiAnc2NhbGUoLjAxKScsXG4gICAgICB9fVxuICAgIC8+XG4gICk7XG59XG4iXX0= */")
  }));
}
var AB = function(e) {
  e.cancelable && e.preventDefault(), e.stopPropagation();
};
function PB(t4) {
  var e = t4.isEnabled, n = t4.onBottomArrive, r = t4.onBottomLeave, i = t4.onTopArrive, o = t4.onTopLeave, s = Ke(false), a = Ke(false), l = Ke(0), c = Ke(null), u = Ue(function(m, x) {
    if (c.current !== null) {
      var v = c.current, y = v.scrollTop, S = v.scrollHeight, b = v.clientHeight, w = c.current, C = x > 0, k = S - b - y, T = false;
      k > x && s.current && (r && r(m), s.current = false), C && a.current && (o && o(m), a.current = false), C && x > k ? (n && !s.current && n(m), w.scrollTop = S, T = true, s.current = true) : !C && -x > y && (i && !a.current && i(m), w.scrollTop = 0, T = true, a.current = true), T && AB(m);
    }
  }, [n, r, i, o]), f = Ue(function(m) {
    u(m, m.deltaY);
  }, [u]), d = Ue(function(m) {
    l.current = m.changedTouches[0].clientY;
  }, []), h = Ue(function(m) {
    var x = l.current - m.changedTouches[0].clientY;
    u(m, x);
  }, [u]), p = Ue(function(m) {
    if (m) {
      var x = GQ ? {
        passive: false
      } : false;
      m.addEventListener("wheel", f, x), m.addEventListener("touchstart", d, x), m.addEventListener("touchmove", h, x);
    }
  }, [h, d, f]), O = Ue(function(m) {
    m && (m.removeEventListener("wheel", f, false), m.removeEventListener("touchstart", d, false), m.removeEventListener("touchmove", h, false));
  }, [h, d, f]);
  return _e(function() {
    if (e) {
      var m = c.current;
      return p(m), function() {
        O(m);
      };
    }
  }, [e, p, O]), function(m) {
    c.current = m;
  };
}
var jy = ["boxSizing", "height", "overflow", "paddingRight", "position"];
var Ry = {
  boxSizing: "border-box",
  // account for possible declaration `width: 100%;` on body
  overflow: "hidden",
  position: "relative",
  height: "100%"
};
function Dy(t4) {
  t4.preventDefault();
}
function Qy(t4) {
  t4.stopPropagation();
}
function By() {
  var t4 = this.scrollTop, e = this.scrollHeight, n = t4 + this.offsetHeight;
  t4 === 0 ? this.scrollTop = 1 : n === e && (this.scrollTop = t4 - 1);
}
function _y() {
  return "ontouchstart" in window || navigator.maxTouchPoints;
}
var My = !!(typeof window < "u" && window.document && window.document.createElement);
var fl = 0;
var $s = {
  capture: false,
  passive: false
};
function EB(t4) {
  var e = t4.isEnabled, n = t4.accountForScrollbars, r = n === void 0 ? true : n, i = Ke({}), o = Ke(null), s = Ue(function(l) {
    if (My) {
      var c = document.body, u = c && c.style;
      if (r && jy.forEach(function(p) {
        var O = u && u[p];
        i.current[p] = O;
      }), r && fl < 1) {
        var f = parseInt(i.current.paddingRight, 10) || 0, d = document.body ? document.body.clientWidth : 0, h = window.innerWidth - d + f || 0;
        Object.keys(Ry).forEach(function(p) {
          var O = Ry[p];
          u && (u[p] = O);
        }), u && (u.paddingRight = "".concat(h, "px"));
      }
      c && _y() && (c.addEventListener("touchmove", Dy, $s), l && (l.addEventListener("touchstart", By, $s), l.addEventListener("touchmove", Qy, $s))), fl += 1;
    }
  }, [r]), a = Ue(function(l) {
    if (My) {
      var c = document.body, u = c && c.style;
      fl = Math.max(fl - 1, 0), r && fl < 1 && jy.forEach(function(f) {
        var d = i.current[f];
        u && (u[f] = d);
      }), c && _y() && (c.removeEventListener("touchmove", Dy, $s), l && (l.removeEventListener("touchstart", By, $s), l.removeEventListener("touchmove", Qy, $s)));
    }
  }, [r]);
  return _e(function() {
    if (e) {
      var l = o.current;
      return s(l), function() {
        a(l);
      };
    }
  }, [e, s, a]), function(l) {
    o.current = l;
  };
}
function TB() {
  return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
}
var IB = function(e) {
  var n = e.target;
  return n.ownerDocument.activeElement && n.ownerDocument.activeElement.blur();
};
var $B = false ? {
  name: "1kfdb0e",
  styles: "position:fixed;left:0;bottom:0;right:0;top:0"
} : {
  name: "bp8cua-ScrollManager",
  styles: "position:fixed;left:0;bottom:0;right:0;top:0;label:ScrollManager;",
  map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIlNjcm9sbE1hbmFnZXIudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQW9EVSIsImZpbGUiOiJTY3JvbGxNYW5hZ2VyLnRzeCIsInNvdXJjZXNDb250ZW50IjpbIi8qKiBAanN4IGpzeCAqL1xuaW1wb3J0IHsganN4IH0gZnJvbSAnQGVtb3Rpb24vcmVhY3QnO1xuaW1wb3J0IHsgRnJhZ21lbnQsIFJlYWN0RWxlbWVudCwgUmVmQ2FsbGJhY2ssIE1vdXNlRXZlbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgdXNlU2Nyb2xsQ2FwdHVyZSBmcm9tICcuL3VzZVNjcm9sbENhcHR1cmUnO1xuaW1wb3J0IHVzZVNjcm9sbExvY2sgZnJvbSAnLi91c2VTY3JvbGxMb2NrJztcblxuaW50ZXJmYWNlIFByb3BzIHtcbiAgcmVhZG9ubHkgY2hpbGRyZW46IChyZWY6IFJlZkNhbGxiYWNrPEhUTUxFbGVtZW50PikgPT4gUmVhY3RFbGVtZW50O1xuICByZWFkb25seSBsb2NrRW5hYmxlZDogYm9vbGVhbjtcbiAgcmVhZG9ubHkgY2FwdHVyZUVuYWJsZWQ6IGJvb2xlYW47XG4gIHJlYWRvbmx5IG9uQm90dG9tQXJyaXZlPzogKGV2ZW50OiBXaGVlbEV2ZW50IHwgVG91Y2hFdmVudCkgPT4gdm9pZDtcbiAgcmVhZG9ubHkgb25Cb3R0b21MZWF2ZT86IChldmVudDogV2hlZWxFdmVudCB8IFRvdWNoRXZlbnQpID0+IHZvaWQ7XG4gIHJlYWRvbmx5IG9uVG9wQXJyaXZlPzogKGV2ZW50OiBXaGVlbEV2ZW50IHwgVG91Y2hFdmVudCkgPT4gdm9pZDtcbiAgcmVhZG9ubHkgb25Ub3BMZWF2ZT86IChldmVudDogV2hlZWxFdmVudCB8IFRvdWNoRXZlbnQpID0+IHZvaWQ7XG59XG5cbmNvbnN0IGJsdXJTZWxlY3RJbnB1dCA9IChldmVudDogTW91c2VFdmVudDxIVE1MRGl2RWxlbWVudD4pID0+IHtcbiAgY29uc3QgZWxlbWVudCA9IGV2ZW50LnRhcmdldCBhcyBIVE1MRGl2RWxlbWVudDtcbiAgcmV0dXJuIChcbiAgICBlbGVtZW50Lm93bmVyRG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJlxuICAgIChlbGVtZW50Lm93bmVyRG9jdW1lbnQuYWN0aXZlRWxlbWVudCBhcyBIVE1MRWxlbWVudCkuYmx1cigpXG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBTY3JvbGxNYW5hZ2VyKHtcbiAgY2hpbGRyZW4sXG4gIGxvY2tFbmFibGVkLFxuICBjYXB0dXJlRW5hYmxlZCA9IHRydWUsXG4gIG9uQm90dG9tQXJyaXZlLFxuICBvbkJvdHRvbUxlYXZlLFxuICBvblRvcEFycml2ZSxcbiAgb25Ub3BMZWF2ZSxcbn06IFByb3BzKSB7XG4gIGNvbnN0IHNldFNjcm9sbENhcHR1cmVUYXJnZXQgPSB1c2VTY3JvbGxDYXB0dXJlKHtcbiAgICBpc0VuYWJsZWQ6IGNhcHR1cmVFbmFibGVkLFxuICAgIG9uQm90dG9tQXJyaXZlLFxuICAgIG9uQm90dG9tTGVhdmUsXG4gICAgb25Ub3BBcnJpdmUsXG4gICAgb25Ub3BMZWF2ZSxcbiAgfSk7XG4gIGNvbnN0IHNldFNjcm9sbExvY2tUYXJnZXQgPSB1c2VTY3JvbGxMb2NrKHsgaXNFbmFibGVkOiBsb2NrRW5hYmxlZCB9KTtcblxuICBjb25zdCB0YXJnZXRSZWY6IFJlZkNhbGxiYWNrPEhUTUxFbGVtZW50PiA9IChlbGVtZW50KSA9PiB7XG4gICAgc2V0U2Nyb2xsQ2FwdHVyZVRhcmdldChlbGVtZW50KTtcbiAgICBzZXRTY3JvbGxMb2NrVGFyZ2V0KGVsZW1lbnQpO1xuICB9O1xuXG4gIHJldHVybiAoXG4gICAgPEZyYWdtZW50PlxuICAgICAge2xvY2tFbmFibGVkICYmIChcbiAgICAgICAgPGRpdlxuICAgICAgICAgIG9uQ2xpY2s9e2JsdXJTZWxlY3RJbnB1dH1cbiAgICAgICAgICBjc3M9e3sgcG9zaXRpb246ICdmaXhlZCcsIGxlZnQ6IDAsIGJvdHRvbTogMCwgcmlnaHQ6IDAsIHRvcDogMCB9fVxuICAgICAgICAvPlxuICAgICAgKX1cbiAgICAgIHtjaGlsZHJlbih0YXJnZXRSZWYpfVxuICAgIDwvRnJhZ21lbnQ+XG4gICk7XG59XG4iXX0= */",
  toString: TB
};
function jB(t4) {
  var e = t4.children, n = t4.lockEnabled, r = t4.captureEnabled, i = r === void 0 ? true : r, o = t4.onBottomArrive, s = t4.onBottomLeave, a = t4.onTopArrive, l = t4.onTopLeave, c = PB({
    isEnabled: i,
    onBottomArrive: o,
    onBottomLeave: s,
    onTopArrive: a,
    onTopLeave: l
  }), u = EB({
    isEnabled: n
  }), f = function(h) {
    c(h), u(h);
  };
  return Pe(_r, null, n && Pe("div", {
    onClick: IB,
    css: $B
  }), e(f));
}
function RB() {
  return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
}
var DB = false ? {
  name: "1a0ro4n-requiredInput",
  styles: "label:requiredInput;opacity:0;pointer-events:none;position:absolute;bottom:0;left:0;right:0;width:100%"
} : {
  name: "5kkxb2-requiredInput-RequiredInput",
  styles: "label:requiredInput;opacity:0;pointer-events:none;position:absolute;bottom:0;left:0;right:0;width:100%;label:RequiredInput;",
  map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIlJlcXVpcmVkSW5wdXQudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQWNJIiwiZmlsZSI6IlJlcXVpcmVkSW5wdXQudHN4Iiwic291cmNlc0NvbnRlbnQiOlsiLyoqIEBqc3gganN4ICovXG5pbXBvcnQgeyBGb2N1c0V2ZW50SGFuZGxlciwgRnVuY3Rpb25Db21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBqc3ggfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5cbmNvbnN0IFJlcXVpcmVkSW5wdXQ6IEZ1bmN0aW9uQ29tcG9uZW50PHtcbiAgcmVhZG9ubHkgbmFtZT86IHN0cmluZztcbiAgcmVhZG9ubHkgb25Gb2N1czogRm9jdXNFdmVudEhhbmRsZXI8SFRNTElucHV0RWxlbWVudD47XG59PiA9ICh7IG5hbWUsIG9uRm9jdXMgfSkgPT4gKFxuICA8aW5wdXRcbiAgICByZXF1aXJlZFxuICAgIG5hbWU9e25hbWV9XG4gICAgdGFiSW5kZXg9ey0xfVxuICAgIGFyaWEtaGlkZGVuPVwidHJ1ZVwiXG4gICAgb25Gb2N1cz17b25Gb2N1c31cbiAgICBjc3M9e3tcbiAgICAgIGxhYmVsOiAncmVxdWlyZWRJbnB1dCcsXG4gICAgICBvcGFjaXR5OiAwLFxuICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnLFxuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICBib3R0b206IDAsXG4gICAgICBsZWZ0OiAwLFxuICAgICAgcmlnaHQ6IDAsXG4gICAgICB3aWR0aDogJzEwMCUnLFxuICAgIH19XG4gICAgLy8gUHJldmVudCBgU3dpdGNoaW5nIGZyb20gdW5jb250cm9sbGVkIHRvIGNvbnRyb2xsZWRgIGVycm9yXG4gICAgdmFsdWU9XCJcIlxuICAgIG9uQ2hhbmdlPXsoKSA9PiB7fX1cbiAgLz5cbik7XG5cbmV4cG9ydCBkZWZhdWx0IFJlcXVpcmVkSW5wdXQ7XG4iXX0= */",
  toString: RB
};
var QB = function(e) {
  var n = e.name, r = e.onFocus;
  return Pe("input", {
    required: true,
    name: n,
    tabIndex: -1,
    "aria-hidden": "true",
    onFocus: r,
    css: DB,
    value: "",
    onChange: function() {
    }
  });
};
var BB = QB;
function ox(t4) {
  var e;
  return typeof window < "u" && window.navigator != null ? t4.test(((e = window.navigator.userAgentData) === null || e === void 0 ? void 0 : e.platform) || window.navigator.platform) : false;
}
function _B() {
  return ox(/^iPhone/i);
}
function sP() {
  return ox(/^Mac/i);
}
function MB() {
  return ox(/^iPad/i) || // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.
  sP() && navigator.maxTouchPoints > 1;
}
function NB() {
  return _B() || MB();
}
function FB() {
  return sP() || NB();
}
var ZB = function(e) {
  return e.label;
};
var WB = function(e) {
  return e.label;
};
var VB = function(e) {
  return e.value;
};
var zB = function(e) {
  return !!e.isDisabled;
};
var LB = {
  clearIndicator: k3,
  container: h3,
  control: j3,
  dropdownIndicator: w3,
  group: B3,
  groupHeading: M3,
  indicatorsContainer: O3,
  indicatorSeparator: P3,
  input: W3,
  loadingIndicator: I3,
  loadingMessage: l3,
  menu: t3,
  menuList: o3,
  menuPortal: f3,
  multiValue: G3,
  multiValueLabel: Y3,
  multiValueRemove: q3,
  noOptionsMessage: a3,
  option: tB,
  placeholder: iB,
  singleValue: aB,
  valueContainer: g3
};
var XB = {
  primary: "#2684FF",
  primary75: "#4C9AFF",
  primary50: "#B2D4FF",
  primary25: "#DEEBFF",
  danger: "#DE350B",
  dangerLight: "#FFBDAD",
  neutral0: "hsl(0, 0%, 100%)",
  neutral5: "hsl(0, 0%, 95%)",
  neutral10: "hsl(0, 0%, 90%)",
  neutral20: "hsl(0, 0%, 80%)",
  neutral30: "hsl(0, 0%, 70%)",
  neutral40: "hsl(0, 0%, 60%)",
  neutral50: "hsl(0, 0%, 50%)",
  neutral60: "hsl(0, 0%, 40%)",
  neutral70: "hsl(0, 0%, 30%)",
  neutral80: "hsl(0, 0%, 20%)",
  neutral90: "hsl(0, 0%, 10%)"
};
var GB = 4;
var aP = 4;
var YB = 38;
var qB = aP * 2;
var UB = {
  baseUnit: aP,
  controlHeight: YB,
  menuGutter: qB
};
var dp = {
  borderRadius: GB,
  colors: XB,
  spacing: UB
};
var HB = {
  "aria-live": "polite",
  backspaceRemovesValue: true,
  blurInputOnSelect: Py(),
  captureMenuScroll: !Py(),
  classNames: {},
  closeMenuOnSelect: true,
  closeMenuOnScroll: false,
  components: {},
  controlShouldRenderValue: true,
  escapeClearsValue: false,
  filterOption: wB(),
  formatGroupLabel: ZB,
  getOptionLabel: WB,
  getOptionValue: VB,
  isDisabled: false,
  isLoading: false,
  isMulti: false,
  isRtl: false,
  isSearchable: true,
  isOptionDisabled: zB,
  loadingMessage: function() {
    return "Loading...";
  },
  maxMenuHeight: 300,
  minMenuHeight: 140,
  menuIsOpen: false,
  menuPlacement: "bottom",
  menuPosition: "absolute",
  menuShouldBlockScroll: false,
  menuShouldScrollIntoView: !LQ(),
  noOptionsMessage: function() {
    return "No options";
  },
  openMenuOnFocus: false,
  openMenuOnClick: true,
  options: [],
  pageSize: 5,
  placeholder: "Select...",
  screenReaderStatus: function(e) {
    var n = e.count;
    return "".concat(n, " result").concat(n !== 1 ? "s" : "", " available");
  },
  styles: {},
  tabIndex: 0,
  tabSelectsValue: true,
  unstyled: false
};
function Ny(t4, e, n, r) {
  var i = uP(t4, e, n), o = fP(t4, e, n), s = cP(t4, e), a = _f(t4, e);
  return {
    type: "option",
    data: e,
    isDisabled: i,
    isSelected: o,
    label: s,
    value: a,
    index: r
  };
}
function of(t4, e) {
  return t4.options.map(function(n, r) {
    if ("options" in n) {
      var i = n.options.map(function(s, a) {
        return Ny(t4, s, e, a);
      }).filter(function(s) {
        return Zy(t4, s);
      });
      return i.length > 0 ? {
        type: "group",
        data: n,
        options: i,
        index: r
      } : void 0;
    }
    var o = Ny(t4, n, e, r);
    return Zy(t4, o) ? o : void 0;
  }).filter(YQ);
}
function lP(t4) {
  return t4.reduce(function(e, n) {
    return n.type === "group" ? e.push.apply(e, xa(n.options.map(function(r) {
      return r.data;
    }))) : e.push(n.data), e;
  }, []);
}
function Fy(t4, e) {
  return t4.reduce(function(n, r) {
    return r.type === "group" ? n.push.apply(n, xa(r.options.map(function(i) {
      return {
        data: i.data,
        id: "".concat(e, "-").concat(r.index, "-").concat(i.index)
      };
    }))) : n.push({
      data: r.data,
      id: "".concat(e, "-").concat(r.index)
    }), n;
  }, []);
}
function JB(t4, e) {
  return lP(of(t4, e));
}
function Zy(t4, e) {
  var n = t4.inputValue, r = n === void 0 ? "" : n, i = e.data, o = e.isSelected, s = e.label, a = e.value;
  return (!hP(t4) || !o) && dP(t4, {
    label: s,
    value: a,
    data: i
  }, r);
}
function KB(t4, e) {
  var n = t4.focusedValue, r = t4.selectValue, i = r.indexOf(n);
  if (i > -1) {
    var o = e.indexOf(n);
    if (o > -1)
      return n;
    if (i < e.length)
      return e[i];
  }
  return null;
}
function e_(t4, e) {
  var n = t4.focusedOption;
  return n && e.indexOf(n) > -1 ? n : e[0];
}
var hp = function(e, n) {
  var r, i = (r = e.find(function(o) {
    return o.data === n;
  })) === null || r === void 0 ? void 0 : r.id;
  return i || null;
};
var cP = function(e, n) {
  return e.getOptionLabel(n);
};
var _f = function(e, n) {
  return e.getOptionValue(n);
};
function uP(t4, e, n) {
  return typeof t4.isOptionDisabled == "function" ? t4.isOptionDisabled(e, n) : false;
}
function fP(t4, e, n) {
  if (n.indexOf(e) > -1)
    return true;
  if (typeof t4.isOptionSelected == "function")
    return t4.isOptionSelected(e, n);
  var r = _f(t4, e);
  return n.some(function(i) {
    return _f(t4, i) === r;
  });
}
function dP(t4, e, n) {
  return t4.filterOption ? t4.filterOption(e, n) : true;
}
var hP = function(e) {
  var n = e.hideSelectedOptions, r = e.isMulti;
  return n === void 0 ? r : n;
};
var t_ = 1;
var pP = /* @__PURE__ */ function(t4) {
  Hd(n, t4);
  var e = Jd(n);
  function n(r) {
    var i;
    if (qd(this, n), i = e.call(this, r), i.state = {
      ariaSelection: null,
      focusedOption: null,
      focusedOptionId: null,
      focusableOptionsWithIds: [],
      focusedValue: null,
      inputIsHidden: false,
      isFocused: false,
      selectValue: [],
      clearFocusValueOnUpdate: false,
      prevWasFocused: false,
      inputIsHiddenAfterUpdate: void 0,
      prevProps: void 0,
      instancePrefix: ""
    }, i.blockOptionHover = false, i.isComposing = false, i.commonProps = void 0, i.initialTouchX = 0, i.initialTouchY = 0, i.openAfterFocus = false, i.scrollToFocusedOptionOnUpdate = false, i.userIsDragging = void 0, i.isAppleDevice = FB(), i.controlRef = null, i.getControlRef = function(l) {
      i.controlRef = l;
    }, i.focusedOptionRef = null, i.getFocusedOptionRef = function(l) {
      i.focusedOptionRef = l;
    }, i.menuListRef = null, i.getMenuListRef = function(l) {
      i.menuListRef = l;
    }, i.inputRef = null, i.getInputRef = function(l) {
      i.inputRef = l;
    }, i.focus = i.focusInput, i.blur = i.blurInput, i.onChange = function(l, c) {
      var u = i.props, f = u.onChange, d = u.name;
      c.name = d, i.ariaOnChange(l, c), f(l, c);
    }, i.setValue = function(l, c, u) {
      var f = i.props, d = f.closeMenuOnSelect, h = f.isMulti, p = f.inputValue;
      i.onInputChange("", {
        action: "set-value",
        prevInputValue: p
      }), d && (i.setState({
        inputIsHiddenAfterUpdate: !h
      }), i.onMenuClose()), i.setState({
        clearFocusValueOnUpdate: true
      }), i.onChange(l, {
        action: c,
        option: u
      });
    }, i.selectOption = function(l) {
      var c = i.props, u = c.blurInputOnSelect, f = c.isMulti, d = c.name, h = i.state.selectValue, p = f && i.isOptionSelected(l, h), O = i.isOptionDisabled(l, h);
      if (p) {
        var m = i.getOptionValue(l);
        i.setValue(h.filter(function(x) {
          return i.getOptionValue(x) !== m;
        }), "deselect-option", l);
      } else if (!O)
        f ? i.setValue([].concat(xa(h), [l]), "select-option", l) : i.setValue(l, "select-option");
      else {
        i.ariaOnChange(l, {
          action: "select-option",
          option: l,
          name: d
        });
        return;
      }
      u && i.blurInput();
    }, i.removeValue = function(l) {
      var c = i.props.isMulti, u = i.state.selectValue, f = i.getOptionValue(l), d = u.filter(function(p) {
        return i.getOptionValue(p) !== f;
      }), h = hu(c, d, d[0] || null);
      i.onChange(h, {
        action: "remove-value",
        removedValue: l
      }), i.focusInput();
    }, i.clearValue = function() {
      var l = i.state.selectValue;
      i.onChange(hu(i.props.isMulti, [], null), {
        action: "clear",
        removedValues: l
      });
    }, i.popValue = function() {
      var l = i.props.isMulti, c = i.state.selectValue, u = c[c.length - 1], f = c.slice(0, c.length - 1), d = hu(l, f, f[0] || null);
      u && i.onChange(d, {
        action: "pop-value",
        removedValue: u
      });
    }, i.getFocusedOptionId = function(l) {
      return hp(i.state.focusableOptionsWithIds, l);
    }, i.getFocusableOptionsWithIds = function() {
      return Fy(of(i.props, i.state.selectValue), i.getElementId("option"));
    }, i.getValue = function() {
      return i.state.selectValue;
    }, i.cx = function() {
      for (var l = arguments.length, c = new Array(l), u = 0; u < l; u++)
        c[u] = arguments[u];
      return FQ.apply(void 0, [i.props.classNamePrefix].concat(c));
    }, i.getOptionLabel = function(l) {
      return cP(i.props, l);
    }, i.getOptionValue = function(l) {
      return _f(i.props, l);
    }, i.getStyles = function(l, c) {
      var u = i.props.unstyled, f = LB[l](c, u);
      f.boxSizing = "border-box";
      var d = i.props.styles[l];
      return d ? d(f, c) : f;
    }, i.getClassNames = function(l, c) {
      var u, f;
      return (u = (f = i.props.classNames)[l]) === null || u === void 0 ? void 0 : u.call(f, c);
    }, i.getElementId = function(l) {
      return "".concat(i.state.instancePrefix, "-").concat(l);
    }, i.getComponents = function() {
      return uB(i.props);
    }, i.buildCategorizedOptions = function() {
      return of(i.props, i.state.selectValue);
    }, i.getCategorizedOptions = function() {
      return i.props.menuIsOpen ? i.buildCategorizedOptions() : [];
    }, i.buildFocusableOptions = function() {
      return lP(i.buildCategorizedOptions());
    }, i.getFocusableOptions = function() {
      return i.props.menuIsOpen ? i.buildFocusableOptions() : [];
    }, i.ariaOnChange = function(l, c) {
      i.setState({
        ariaSelection: se({
          value: l
        }, c)
      });
    }, i.onMenuMouseDown = function(l) {
      l.button === 0 && (l.stopPropagation(), l.preventDefault(), i.focusInput());
    }, i.onMenuMouseMove = function(l) {
      i.blockOptionHover = false;
    }, i.onControlMouseDown = function(l) {
      if (!l.defaultPrevented) {
        var c = i.props.openMenuOnClick;
        i.state.isFocused ? i.props.menuIsOpen ? l.target.tagName !== "INPUT" && l.target.tagName !== "TEXTAREA" && i.onMenuClose() : c && i.openMenu("first") : (c && (i.openAfterFocus = true), i.focusInput()), l.target.tagName !== "INPUT" && l.target.tagName !== "TEXTAREA" && l.preventDefault();
      }
    }, i.onDropdownIndicatorMouseDown = function(l) {
      if (!(l && l.type === "mousedown" && l.button !== 0) && !i.props.isDisabled) {
        var c = i.props, u = c.isMulti, f = c.menuIsOpen;
        i.focusInput(), f ? (i.setState({
          inputIsHiddenAfterUpdate: !u
        }), i.onMenuClose()) : i.openMenu("first"), l.preventDefault();
      }
    }, i.onClearIndicatorMouseDown = function(l) {
      l && l.type === "mousedown" && l.button !== 0 || (i.clearValue(), l.preventDefault(), i.openAfterFocus = false, l.type === "touchend" ? i.focusInput() : setTimeout(function() {
        return i.focusInput();
      }));
    }, i.onScroll = function(l) {
      typeof i.props.closeMenuOnScroll == "boolean" ? l.target instanceof HTMLElement && rh(l.target) && i.props.onMenuClose() : typeof i.props.closeMenuOnScroll == "function" && i.props.closeMenuOnScroll(l) && i.props.onMenuClose();
    }, i.onCompositionStart = function() {
      i.isComposing = true;
    }, i.onCompositionEnd = function() {
      i.isComposing = false;
    }, i.onTouchStart = function(l) {
      var c = l.touches, u = c && c.item(0);
      u && (i.initialTouchX = u.clientX, i.initialTouchY = u.clientY, i.userIsDragging = false);
    }, i.onTouchMove = function(l) {
      var c = l.touches, u = c && c.item(0);
      if (u) {
        var f = Math.abs(u.clientX - i.initialTouchX), d = Math.abs(u.clientY - i.initialTouchY), h = 5;
        i.userIsDragging = f > h || d > h;
      }
    }, i.onTouchEnd = function(l) {
      i.userIsDragging || (i.controlRef && !i.controlRef.contains(l.target) && i.menuListRef && !i.menuListRef.contains(l.target) && i.blurInput(), i.initialTouchX = 0, i.initialTouchY = 0);
    }, i.onControlTouchEnd = function(l) {
      i.userIsDragging || i.onControlMouseDown(l);
    }, i.onClearIndicatorTouchEnd = function(l) {
      i.userIsDragging || i.onClearIndicatorMouseDown(l);
    }, i.onDropdownIndicatorTouchEnd = function(l) {
      i.userIsDragging || i.onDropdownIndicatorMouseDown(l);
    }, i.handleInputChange = function(l) {
      var c = i.props.inputValue, u = l.currentTarget.value;
      i.setState({
        inputIsHiddenAfterUpdate: false
      }), i.onInputChange(u, {
        action: "input-change",
        prevInputValue: c
      }), i.props.menuIsOpen || i.onMenuOpen();
    }, i.onInputFocus = function(l) {
      i.props.onFocus && i.props.onFocus(l), i.setState({
        inputIsHiddenAfterUpdate: false,
        isFocused: true
      }), (i.openAfterFocus || i.props.openMenuOnFocus) && i.openMenu("first"), i.openAfterFocus = false;
    }, i.onInputBlur = function(l) {
      var c = i.props.inputValue;
      if (i.menuListRef && i.menuListRef.contains(document.activeElement)) {
        i.inputRef.focus();
        return;
      }
      i.props.onBlur && i.props.onBlur(l), i.onInputChange("", {
        action: "input-blur",
        prevInputValue: c
      }), i.onMenuClose(), i.setState({
        focusedValue: null,
        isFocused: false
      });
    }, i.onOptionHover = function(l) {
      if (!(i.blockOptionHover || i.state.focusedOption === l)) {
        var c = i.getFocusableOptions(), u = c.indexOf(l);
        i.setState({
          focusedOption: l,
          focusedOptionId: u > -1 ? i.getFocusedOptionId(l) : null
        });
      }
    }, i.shouldHideSelectedOptions = function() {
      return hP(i.props);
    }, i.onValueInputFocus = function(l) {
      l.preventDefault(), l.stopPropagation(), i.focus();
    }, i.onKeyDown = function(l) {
      var c = i.props, u = c.isMulti, f = c.backspaceRemovesValue, d = c.escapeClearsValue, h = c.inputValue, p = c.isClearable, O = c.isDisabled, m = c.menuIsOpen, x = c.onKeyDown, v = c.tabSelectsValue, y = c.openMenuOnFocus, S = i.state, b = S.focusedOption, w = S.focusedValue, C = S.selectValue;
      if (!O && !(typeof x == "function" && (x(l), l.defaultPrevented))) {
        switch (i.blockOptionHover = true, l.key) {
          case "ArrowLeft":
            if (!u || h)
              return;
            i.focusValue("previous");
            break;
          case "ArrowRight":
            if (!u || h)
              return;
            i.focusValue("next");
            break;
          case "Delete":
          case "Backspace":
            if (h)
              return;
            if (w)
              i.removeValue(w);
            else {
              if (!f)
                return;
              u ? i.popValue() : p && i.clearValue();
            }
            break;
          case "Tab":
            if (i.isComposing || l.shiftKey || !m || !v || !b || // don't capture the event if the menu opens on focus and the focused
            // option is already selected; it breaks the flow of navigation
            y && i.isOptionSelected(b, C))
              return;
            i.selectOption(b);
            break;
          case "Enter":
            if (l.keyCode === 229)
              break;
            if (m) {
              if (!b || i.isComposing)
                return;
              i.selectOption(b);
              break;
            }
            return;
          case "Escape":
            m ? (i.setState({
              inputIsHiddenAfterUpdate: false
            }), i.onInputChange("", {
              action: "menu-close",
              prevInputValue: h
            }), i.onMenuClose()) : p && d && i.clearValue();
            break;
          case " ":
            if (h)
              return;
            if (!m) {
              i.openMenu("first");
              break;
            }
            if (!b)
              return;
            i.selectOption(b);
            break;
          case "ArrowUp":
            m ? i.focusOption("up") : i.openMenu("last");
            break;
          case "ArrowDown":
            m ? i.focusOption("down") : i.openMenu("first");
            break;
          case "PageUp":
            if (!m)
              return;
            i.focusOption("pageup");
            break;
          case "PageDown":
            if (!m)
              return;
            i.focusOption("pagedown");
            break;
          case "Home":
            if (!m)
              return;
            i.focusOption("first");
            break;
          case "End":
            if (!m)
              return;
            i.focusOption("last");
            break;
          default:
            return;
        }
        l.preventDefault();
      }
    }, i.state.instancePrefix = "react-select-" + (i.props.instanceId || ++t_), i.state.selectValue = ky(r.value), r.menuIsOpen && i.state.selectValue.length) {
      var o = i.getFocusableOptionsWithIds(), s = i.buildFocusableOptions(), a = s.indexOf(i.state.selectValue[0]);
      i.state.focusableOptionsWithIds = o, i.state.focusedOption = s[a], i.state.focusedOptionId = hp(o, s[a]);
    }
    return i;
  }
  return Ud(n, [{
    key: "componentDidMount",
    value: function() {
      this.startListeningComposition(), this.startListeningToTouch(), this.props.closeMenuOnScroll && document && document.addEventListener && document.addEventListener("scroll", this.onScroll, true), this.props.autoFocus && this.focusInput(), this.props.menuIsOpen && this.state.focusedOption && this.menuListRef && this.focusedOptionRef && Ay(this.menuListRef, this.focusedOptionRef);
    }
  }, {
    key: "componentDidUpdate",
    value: function(i) {
      var o = this.props, s = o.isDisabled, a = o.menuIsOpen, l = this.state.isFocused;
      (l && !s && i.isDisabled || // ensure focus is on the Input when the menu opens
      l && a && !i.menuIsOpen) && this.focusInput(), l && s && !i.isDisabled ? this.setState({
        isFocused: false
      }, this.onMenuClose) : !l && !s && i.isDisabled && this.inputRef === document.activeElement && this.setState({
        isFocused: true
      }), this.menuListRef && this.focusedOptionRef && this.scrollToFocusedOptionOnUpdate && (Ay(this.menuListRef, this.focusedOptionRef), this.scrollToFocusedOptionOnUpdate = false);
    }
  }, {
    key: "componentWillUnmount",
    value: function() {
      this.stopListeningComposition(), this.stopListeningToTouch(), document.removeEventListener("scroll", this.onScroll, true);
    }
    // ==============================
    // Consumer Handlers
    // ==============================
  }, {
    key: "onMenuOpen",
    value: function() {
      this.props.onMenuOpen();
    }
  }, {
    key: "onMenuClose",
    value: function() {
      this.onInputChange("", {
        action: "menu-close",
        prevInputValue: this.props.inputValue
      }), this.props.onMenuClose();
    }
  }, {
    key: "onInputChange",
    value: function(i, o) {
      this.props.onInputChange(i, o);
    }
    // ==============================
    // Methods
    // ==============================
  }, {
    key: "focusInput",
    value: function() {
      this.inputRef && this.inputRef.focus();
    }
  }, {
    key: "blurInput",
    value: function() {
      this.inputRef && this.inputRef.blur();
    }
    // aliased for consumers
  }, {
    key: "openMenu",
    value: function(i) {
      var o = this, s = this.state, a = s.selectValue, l = s.isFocused, c = this.buildFocusableOptions(), u = i === "first" ? 0 : c.length - 1;
      if (!this.props.isMulti) {
        var f = c.indexOf(a[0]);
        f > -1 && (u = f);
      }
      this.scrollToFocusedOptionOnUpdate = !(l && this.menuListRef), this.setState({
        inputIsHiddenAfterUpdate: false,
        focusedValue: null,
        focusedOption: c[u],
        focusedOptionId: this.getFocusedOptionId(c[u])
      }, function() {
        return o.onMenuOpen();
      });
    }
  }, {
    key: "focusValue",
    value: function(i) {
      var o = this.state, s = o.selectValue, a = o.focusedValue;
      if (this.props.isMulti) {
        this.setState({
          focusedOption: null
        });
        var l = s.indexOf(a);
        a || (l = -1);
        var c = s.length - 1, u = -1;
        if (s.length) {
          switch (i) {
            case "previous":
              l === 0 ? u = 0 : l === -1 ? u = c : u = l - 1;
              break;
            case "next":
              l > -1 && l < c && (u = l + 1);
              break;
          }
          this.setState({
            inputIsHidden: u !== -1,
            focusedValue: s[u]
          });
        }
      }
    }
  }, {
    key: "focusOption",
    value: function() {
      var i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "first", o = this.props.pageSize, s = this.state.focusedOption, a = this.getFocusableOptions();
      if (a.length) {
        var l = 0, c = a.indexOf(s);
        s || (c = -1), i === "up" ? l = c > 0 ? c - 1 : a.length - 1 : i === "down" ? l = (c + 1) % a.length : i === "pageup" ? (l = c - o, l < 0 && (l = 0)) : i === "pagedown" ? (l = c + o, l > a.length - 1 && (l = a.length - 1)) : i === "last" && (l = a.length - 1), this.scrollToFocusedOptionOnUpdate = true, this.setState({
          focusedOption: a[l],
          focusedValue: null,
          focusedOptionId: this.getFocusedOptionId(a[l])
        });
      }
    }
  }, {
    key: "getTheme",
    value: (
      // ==============================
      // Getters
      // ==============================
      function() {
        return this.props.theme ? typeof this.props.theme == "function" ? this.props.theme(dp) : se(se({}, dp), this.props.theme) : dp;
      }
    )
  }, {
    key: "getCommonProps",
    value: function() {
      var i = this.clearValue, o = this.cx, s = this.getStyles, a = this.getClassNames, l = this.getValue, c = this.selectOption, u = this.setValue, f = this.props, d = f.isMulti, h = f.isRtl, p = f.options, O = this.hasValue();
      return {
        clearValue: i,
        cx: o,
        getStyles: s,
        getClassNames: a,
        getValue: l,
        hasValue: O,
        isMulti: d,
        isRtl: h,
        options: p,
        selectOption: c,
        selectProps: f,
        setValue: u,
        theme: this.getTheme()
      };
    }
  }, {
    key: "hasValue",
    value: function() {
      var i = this.state.selectValue;
      return i.length > 0;
    }
  }, {
    key: "hasOptions",
    value: function() {
      return !!this.getFocusableOptions().length;
    }
  }, {
    key: "isClearable",
    value: function() {
      var i = this.props, o = i.isClearable, s = i.isMulti;
      return o === void 0 ? s : o;
    }
  }, {
    key: "isOptionDisabled",
    value: function(i, o) {
      return uP(this.props, i, o);
    }
  }, {
    key: "isOptionSelected",
    value: function(i, o) {
      return fP(this.props, i, o);
    }
  }, {
    key: "filterOption",
    value: function(i, o) {
      return dP(this.props, i, o);
    }
  }, {
    key: "formatOptionLabel",
    value: function(i, o) {
      if (typeof this.props.formatOptionLabel == "function") {
        var s = this.props.inputValue, a = this.state.selectValue;
        return this.props.formatOptionLabel(i, {
          context: o,
          inputValue: s,
          selectValue: a
        });
      } else
        return this.getOptionLabel(i);
    }
  }, {
    key: "formatGroupLabel",
    value: function(i) {
      return this.props.formatGroupLabel(i);
    }
    // ==============================
    // Mouse Handlers
    // ==============================
  }, {
    key: "startListeningComposition",
    value: (
      // ==============================
      // Composition Handlers
      // ==============================
      function() {
        document && document.addEventListener && (document.addEventListener("compositionstart", this.onCompositionStart, false), document.addEventListener("compositionend", this.onCompositionEnd, false));
      }
    )
  }, {
    key: "stopListeningComposition",
    value: function() {
      document && document.removeEventListener && (document.removeEventListener("compositionstart", this.onCompositionStart), document.removeEventListener("compositionend", this.onCompositionEnd));
    }
  }, {
    key: "startListeningToTouch",
    value: (
      // ==============================
      // Touch Handlers
      // ==============================
      function() {
        document && document.addEventListener && (document.addEventListener("touchstart", this.onTouchStart, false), document.addEventListener("touchmove", this.onTouchMove, false), document.addEventListener("touchend", this.onTouchEnd, false));
      }
    )
  }, {
    key: "stopListeningToTouch",
    value: function() {
      document && document.removeEventListener && (document.removeEventListener("touchstart", this.onTouchStart), document.removeEventListener("touchmove", this.onTouchMove), document.removeEventListener("touchend", this.onTouchEnd));
    }
  }, {
    key: "renderInput",
    value: (
      // ==============================
      // Renderers
      // ==============================
      function() {
        var i = this.props, o = i.isDisabled, s = i.isSearchable, a = i.inputId, l = i.inputValue, c = i.tabIndex, u = i.form, f = i.menuIsOpen, d = i.required, h = this.getComponents(), p = h.Input, O = this.state, m = O.inputIsHidden, x = O.ariaSelection, v = this.commonProps, y = a || this.getElementId("input"), S = se(se(se({
          "aria-autocomplete": "list",
          "aria-expanded": f,
          "aria-haspopup": true,
          "aria-errormessage": this.props["aria-errormessage"],
          "aria-invalid": this.props["aria-invalid"],
          "aria-label": this.props["aria-label"],
          "aria-labelledby": this.props["aria-labelledby"],
          "aria-required": d,
          role: "combobox",
          "aria-activedescendant": this.isAppleDevice ? void 0 : this.state.focusedOptionId || ""
        }, f && {
          "aria-controls": this.getElementId("listbox")
        }), !s && {
          "aria-readonly": true
        }), this.hasValue() ? (x == null ? void 0 : x.action) === "initial-input-focus" && {
          "aria-describedby": this.getElementId("live-region")
        } : {
          "aria-describedby": this.getElementId("placeholder")
        });
        return s ? /* @__PURE__ */ q.createElement(p, Ae({}, v, {
          autoCapitalize: "none",
          autoComplete: "off",
          autoCorrect: "off",
          id: y,
          innerRef: this.getInputRef,
          isDisabled: o,
          isHidden: m,
          onBlur: this.onInputBlur,
          onChange: this.handleInputChange,
          onFocus: this.onInputFocus,
          spellCheck: "false",
          tabIndex: c,
          form: u,
          type: "text",
          value: l
        }, S)) : /* @__PURE__ */ q.createElement(kB, Ae({
          id: y,
          innerRef: this.getInputRef,
          onBlur: this.onInputBlur,
          onChange: Qf,
          onFocus: this.onInputFocus,
          disabled: o,
          tabIndex: c,
          inputMode: "none",
          form: u,
          value: ""
        }, S));
      }
    )
  }, {
    key: "renderPlaceholderOrValue",
    value: function() {
      var i = this, o = this.getComponents(), s = o.MultiValue, a = o.MultiValueContainer, l = o.MultiValueLabel, c = o.MultiValueRemove, u = o.SingleValue, f = o.Placeholder, d = this.commonProps, h = this.props, p = h.controlShouldRenderValue, O = h.isDisabled, m = h.isMulti, x = h.inputValue, v = h.placeholder, y = this.state, S = y.selectValue, b = y.focusedValue, w = y.isFocused;
      if (!this.hasValue() || !p)
        return x ? null : /* @__PURE__ */ q.createElement(f, Ae({}, d, {
          key: "placeholder",
          isDisabled: O,
          isFocused: w,
          innerProps: {
            id: this.getElementId("placeholder")
          }
        }), v);
      if (m)
        return S.map(function(k, T) {
          var A = k === b, E = "".concat(i.getOptionLabel(k), "-").concat(i.getOptionValue(k));
          return /* @__PURE__ */ q.createElement(s, Ae({}, d, {
            components: {
              Container: a,
              Label: l,
              Remove: c
            },
            isFocused: A,
            isDisabled: O,
            key: E,
            index: T,
            removeProps: {
              onClick: function() {
                return i.removeValue(k);
              },
              onTouchEnd: function() {
                return i.removeValue(k);
              },
              onMouseDown: function(j) {
                j.preventDefault();
              }
            },
            data: k
          }), i.formatOptionLabel(k, "value"));
        });
      if (x)
        return null;
      var C = S[0];
      return /* @__PURE__ */ q.createElement(u, Ae({}, d, {
        data: C,
        isDisabled: O
      }), this.formatOptionLabel(C, "value"));
    }
  }, {
    key: "renderClearIndicator",
    value: function() {
      var i = this.getComponents(), o = i.ClearIndicator, s = this.commonProps, a = this.props, l = a.isDisabled, c = a.isLoading, u = this.state.isFocused;
      if (!this.isClearable() || !o || l || !this.hasValue() || c)
        return null;
      var f = {
        onMouseDown: this.onClearIndicatorMouseDown,
        onTouchEnd: this.onClearIndicatorTouchEnd,
        "aria-hidden": "true"
      };
      return /* @__PURE__ */ q.createElement(o, Ae({}, s, {
        innerProps: f,
        isFocused: u
      }));
    }
  }, {
    key: "renderLoadingIndicator",
    value: function() {
      var i = this.getComponents(), o = i.LoadingIndicator, s = this.commonProps, a = this.props, l = a.isDisabled, c = a.isLoading, u = this.state.isFocused;
      if (!o || !c)
        return null;
      var f = {
        "aria-hidden": "true"
      };
      return /* @__PURE__ */ q.createElement(o, Ae({}, s, {
        innerProps: f,
        isDisabled: l,
        isFocused: u
      }));
    }
  }, {
    key: "renderIndicatorSeparator",
    value: function() {
      var i = this.getComponents(), o = i.DropdownIndicator, s = i.IndicatorSeparator;
      if (!o || !s)
        return null;
      var a = this.commonProps, l = this.props.isDisabled, c = this.state.isFocused;
      return /* @__PURE__ */ q.createElement(s, Ae({}, a, {
        isDisabled: l,
        isFocused: c
      }));
    }
  }, {
    key: "renderDropdownIndicator",
    value: function() {
      var i = this.getComponents(), o = i.DropdownIndicator;
      if (!o)
        return null;
      var s = this.commonProps, a = this.props.isDisabled, l = this.state.isFocused, c = {
        onMouseDown: this.onDropdownIndicatorMouseDown,
        onTouchEnd: this.onDropdownIndicatorTouchEnd,
        "aria-hidden": "true"
      };
      return /* @__PURE__ */ q.createElement(o, Ae({}, s, {
        innerProps: c,
        isDisabled: a,
        isFocused: l
      }));
    }
  }, {
    key: "renderMenu",
    value: function() {
      var i = this, o = this.getComponents(), s = o.Group, a = o.GroupHeading, l = o.Menu, c = o.MenuList, u = o.MenuPortal, f = o.LoadingMessage, d = o.NoOptionsMessage, h = o.Option, p = this.commonProps, O = this.state.focusedOption, m = this.props, x = m.captureMenuScroll, v = m.inputValue, y = m.isLoading, S = m.loadingMessage, b = m.minMenuHeight, w = m.maxMenuHeight, C = m.menuIsOpen, k = m.menuPlacement, T = m.menuPosition, A = m.menuPortalTarget, E = m.menuShouldBlockScroll, $ = m.menuShouldScrollIntoView, j = m.noOptionsMessage, B = m.onMenuScrollToTop, D = m.onMenuScrollToBottom;
      if (!C)
        return null;
      var N = function(Q, _) {
        var G = Q.type, M = Q.data, K = Q.isDisabled, V = Q.isSelected, ae = Q.label, te = Q.value, oe = O === M, Y = K ? void 0 : function() {
          return i.onOptionHover(M);
        }, he = K ? void 0 : function() {
          return i.selectOption(M);
        }, X = "".concat(i.getElementId("option"), "-").concat(_), ee = {
          id: X,
          onClick: he,
          onMouseMove: Y,
          onMouseOver: Y,
          tabIndex: -1,
          role: "option",
          "aria-selected": i.isAppleDevice ? void 0 : V
          // is not supported on Apple devices
        };
        return /* @__PURE__ */ q.createElement(h, Ae({}, p, {
          innerProps: ee,
          data: M,
          isDisabled: K,
          isSelected: V,
          key: X,
          label: ae,
          type: G,
          value: te,
          isFocused: oe,
          innerRef: oe ? i.getFocusedOptionRef : void 0
        }), i.formatOptionLabel(Q.data, "menu"));
      }, z;
      if (this.hasOptions())
        z = this.getCategorizedOptions().map(function(R) {
          if (R.type === "group") {
            var Q = R.data, _ = R.options, G = R.index, M = "".concat(i.getElementId("group"), "-").concat(G), K = "".concat(M, "-heading");
            return /* @__PURE__ */ q.createElement(s, Ae({}, p, {
              key: M,
              data: Q,
              options: _,
              Heading: a,
              headingProps: {
                id: K,
                data: R.data
              },
              label: i.formatGroupLabel(R.data)
            }), R.options.map(function(V) {
              return N(V, "".concat(G, "-").concat(V.index));
            }));
          } else if (R.type === "option")
            return N(R, "".concat(R.index));
        });
      else if (y) {
        var Z = S({
          inputValue: v
        });
        if (Z === null)
          return null;
        z = /* @__PURE__ */ q.createElement(f, p, Z);
      } else {
        var J = j({
          inputValue: v
        });
        if (J === null)
          return null;
        z = /* @__PURE__ */ q.createElement(d, p, J);
      }
      var L = {
        minMenuHeight: b,
        maxMenuHeight: w,
        menuPlacement: k,
        menuPosition: T,
        menuShouldScrollIntoView: $
      }, W = /* @__PURE__ */ q.createElement(n3, Ae({}, p, L), function(R) {
        var Q = R.ref, _ = R.placerProps, G = _.placement, M = _.maxHeight;
        return /* @__PURE__ */ q.createElement(l, Ae({}, p, L, {
          innerRef: Q,
          innerProps: {
            onMouseDown: i.onMenuMouseDown,
            onMouseMove: i.onMenuMouseMove
          },
          isLoading: y,
          placement: G
        }), /* @__PURE__ */ q.createElement(jB, {
          captureEnabled: x,
          onTopArrive: B,
          onBottomArrive: D,
          lockEnabled: E
        }, function(K) {
          return /* @__PURE__ */ q.createElement(c, Ae({}, p, {
            innerRef: function(ae) {
              i.getMenuListRef(ae), K(ae);
            },
            innerProps: {
              role: "listbox",
              "aria-multiselectable": p.isMulti,
              id: i.getElementId("listbox")
            },
            isLoading: y,
            maxHeight: M,
            focusedOption: O
          }), z);
        }));
      });
      return A || T === "fixed" ? /* @__PURE__ */ q.createElement(u, Ae({}, p, {
        appendTo: A,
        controlElement: this.controlRef,
        menuPlacement: k,
        menuPosition: T
      }), W) : W;
    }
  }, {
    key: "renderFormField",
    value: function() {
      var i = this, o = this.props, s = o.delimiter, a = o.isDisabled, l = o.isMulti, c = o.name, u = o.required, f = this.state.selectValue;
      if (u && !this.hasValue() && !a)
        return /* @__PURE__ */ q.createElement(BB, {
          name: c,
          onFocus: this.onValueInputFocus
        });
      if (!(!c || a))
        if (l)
          if (s) {
            var d = f.map(function(O) {
              return i.getOptionValue(O);
            }).join(s);
            return /* @__PURE__ */ q.createElement("input", {
              name: c,
              type: "hidden",
              value: d
            });
          } else {
            var h = f.length > 0 ? f.map(function(O, m) {
              return /* @__PURE__ */ q.createElement("input", {
                key: "i-".concat(m),
                name: c,
                type: "hidden",
                value: i.getOptionValue(O)
              });
            }) : /* @__PURE__ */ q.createElement("input", {
              name: c,
              type: "hidden",
              value: ""
            });
            return /* @__PURE__ */ q.createElement("div", null, h);
          }
        else {
          var p = f[0] ? this.getOptionValue(f[0]) : "";
          return /* @__PURE__ */ q.createElement("input", {
            name: c,
            type: "hidden",
            value: p
          });
        }
    }
  }, {
    key: "renderLiveRegion",
    value: function() {
      var i = this.commonProps, o = this.state, s = o.ariaSelection, a = o.focusedOption, l = o.focusedValue, c = o.isFocused, u = o.selectValue, f = this.getFocusableOptions();
      return /* @__PURE__ */ q.createElement(vB, Ae({}, i, {
        id: this.getElementId("live-region"),
        ariaSelection: s,
        focusedOption: a,
        focusedValue: l,
        isFocused: c,
        selectValue: u,
        focusableOptions: f,
        isAppleDevice: this.isAppleDevice
      }));
    }
  }, {
    key: "render",
    value: function() {
      var i = this.getComponents(), o = i.Control, s = i.IndicatorsContainer, a = i.SelectContainer, l = i.ValueContainer, c = this.props, u = c.className, f = c.id, d = c.isDisabled, h = c.menuIsOpen, p = this.state.isFocused, O = this.commonProps = this.getCommonProps();
      return /* @__PURE__ */ q.createElement(a, Ae({}, O, {
        className: u,
        innerProps: {
          id: f,
          onKeyDown: this.onKeyDown
        },
        isDisabled: d,
        isFocused: p
      }), this.renderLiveRegion(), /* @__PURE__ */ q.createElement(o, Ae({}, O, {
        innerRef: this.getControlRef,
        innerProps: {
          onMouseDown: this.onControlMouseDown,
          onTouchEnd: this.onControlTouchEnd
        },
        isDisabled: d,
        isFocused: p,
        menuIsOpen: h
      }), /* @__PURE__ */ q.createElement(l, Ae({}, O, {
        isDisabled: d
      }), this.renderPlaceholderOrValue(), this.renderInput()), /* @__PURE__ */ q.createElement(s, Ae({}, O, {
        isDisabled: d
      }), this.renderClearIndicator(), this.renderLoadingIndicator(), this.renderIndicatorSeparator(), this.renderDropdownIndicator())), this.renderMenu(), this.renderFormField());
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function(i, o) {
      var s = o.prevProps, a = o.clearFocusValueOnUpdate, l = o.inputIsHiddenAfterUpdate, c = o.ariaSelection, u = o.isFocused, f = o.prevWasFocused, d = o.instancePrefix, h = i.options, p = i.value, O = i.menuIsOpen, m = i.inputValue, x = i.isMulti, v = ky(p), y = {};
      if (s && (p !== s.value || h !== s.options || O !== s.menuIsOpen || m !== s.inputValue)) {
        var S = O ? JB(i, v) : [], b = O ? Fy(of(i, v), "".concat(d, "-option")) : [], w = a ? KB(o, v) : null, C = e_(o, S), k = hp(b, C);
        y = {
          selectValue: v,
          focusedOption: C,
          focusedOptionId: k,
          focusableOptionsWithIds: b,
          focusedValue: w,
          clearFocusValueOnUpdate: false
        };
      }
      var T = l != null && i !== s ? {
        inputIsHidden: l,
        inputIsHiddenAfterUpdate: void 0
      } : {}, A = c, E = u && f;
      return u && !E && (A = {
        value: hu(x, v, v[0] || null),
        options: v,
        action: "initial-input-focus"
      }, E = !f), (c == null ? void 0 : c.action) === "initial-input-focus" && (A = null), se(se(se({}, y), T), {}, {
        prevProps: i,
        ariaSelection: A,
        prevWasFocused: E
      });
    }
  }]), n;
}(i4);
pP.defaultProps = HB;
var n_ = /* @__PURE__ */ xs(function(t4, e) {
  var n = pD(t4);
  return /* @__PURE__ */ q.createElement(pP, Ae({
    ref: e
  }, n));
});
var r_ = n_;
var i_ = () => /* @__PURE__ */ g.jsx("svg", { width: "14", height: "14", viewBox: "0 0 14 14", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ g.jsx(
  "path",
  {
    d: "M7 0.875C3.63125 0.875 0.875 3.63125 0.875 7C0.875 10.3687 3.63125 13.125 7 13.125C10.3687 13.125 13.125 10.3687 13.125 7C13.125 3.63125 10.3687 0.875 7 0.875ZM6.51875 3.5H7.48125V8.3125H6.51875V3.5ZM7 10.9375C6.65 10.9375 6.34375 10.6313 6.34375 10.2812C6.34375 9.93125 6.65 9.625 7 9.625C7.35 9.625 7.65625 9.93125 7.65625 10.2812C7.65625 10.6313 7.35 10.9375 7 10.9375Z",
    fill: "#FFA02E"
  }
) });
var o_ = () => /* @__PURE__ */ g.jsx("svg", { width: "14", height: "14", viewBox: "0 0 14 14", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ g.jsx(
  "path",
  {
    d: "M7 0.875C3.5875 0.875 0.875 3.5875 0.875 7C0.875 10.4125 3.5875 13.125 7 13.125C10.4125 13.125 13.125 10.4125 13.125 7C13.125 3.5875 10.4125 0.875 7 0.875ZM9.3625 10.0625L7 7.7L4.6375 10.0625L3.9375 9.3625L6.3 7L3.9375 4.6375L4.6375 3.9375L7 6.3L9.3625 3.9375L10.0625 4.6375L7.7 7L10.0625 9.3625L9.3625 10.0625Z",
    fill: "#F9316D"
  }
) });
var Mo = ({
  options: t4,
  isClearable: e = false,
  isSearchable: n = false,
  isDisabled: r = false,
  isMulti: i = false,
  isWarning: o = false,
  isError: s = false,
  withArrow: a = true,
  placeholder: l,
  defaultValue: c,
  className: u,
  value: f,
  ariaLabel: d = "select",
  ariaLabeledBy: h,
  size: p = "medium",
  menuAlignment: O = "left",
  icon: m,
  formatGroupLabel: x,
  onChange: v,
  dataTestId: y
}) => {
  const S = (k) => {
    const { selectProps: T } = k, { menuIsOpen: A } = T, E = A ? /* @__PURE__ */ g.jsx(ChevronUpIcon, { size: "14px" }) : /* @__PURE__ */ g.jsx(ChevronDownIcon, { size: "14px" });
    return a && !i ? /* @__PURE__ */ g.jsxs(rf.DropdownIndicator, { ...k, children: [
      o && /* @__PURE__ */ g.jsx(i_, {}),
      s && /* @__PURE__ */ g.jsx(o_, {}),
      m || E
    ] }) : null;
  }, b = (k) => /* @__PURE__ */ g.jsxs(
    rf.Option,
    {
      ...k,
      innerProps: {
        ...k.innerProps,
        "data-testid": "select-option"
      },
      children: [
        k.children,
        " ",
        k.isSelected && /* @__PURE__ */ g.jsx(CheckmarkIcon, {})
      ]
    }
  ), w = (k) => /* @__PURE__ */ g.jsx(
    rf.SingleValue,
    {
      ...k,
      innerProps: {
        ...k.innerProps,
        "data-testid": y || "select-singleValue"
      },
      children: k.children
    }
  ), C = We(() => ({
    menu: (k) => ({
      ...k,
      maxWidth: "424px",
      width: "auto",
      boxShadow: "0px 0px 4px 0px rgba(51, 51, 51, 0.15)",
      border: "1px solid var(--border-color-secondary)",
      borderRadius: "var(--border-radius-md)",
      overflow: "hidden",
      textOverflow: "ellipsis",
      zIndex: 3,
      opacity: 1,
      backgroundColor: "var(--bg-color)",
      minWidth: "max-content",
      right: O === "right" ? 0 : "unset"
    })
  }), [O]);
  return /* @__PURE__ */ g.jsx(
    r_,
    {
      className: `${u} react-select-${p}`,
      options: t4,
      onChange: v,
      isSearchable: n,
      isClearable: e,
      isDisabled: r,
      isMulti: i,
      placeholder: l,
      defaultValue: c,
      value: f,
      formatGroupLabel: x,
      components: {
        Option: b,
        SingleValue: w,
        DropdownIndicator: S,
        IndicatorSeparator: null
      },
      styles: { ...s_, ...C },
      "aria-label": d,
      "aria-labelledby": h
    }
  );
};
var s_ = {
  container: (t4) => ({
    ...t4
  }),
  control: (t4, e) => ({
    ...t4,
    display: "flex",
    gap: "var(--spacing-xxs)",
    boxShadow: "none",
    maxWidth: "424px",
    overflow: "hidden",
    textOverflow: "ellipsis",
    minHeight: "24px",
    padding: e.isMulti ? "0px var(--spacing-unit)" : "0px var(--spacing-xs)",
    alignItems: "center",
    backgroundColor: e.isDisabled ? "var(--bg-raised-shadow)" : "var(--bg-color)",
    border: "none",
    "&:hover": {
      cursor: "pointer"
    }
  }),
  singleValue: (t4, e) => ({
    ...t4,
    color: e.isDisabled ? "var(--color-content-disabled)" : "var(--color-content)",
    fontSize: "var(--font-size-base)",
    lineHeight: "var(--line-height-base)",
    overflow: "hidden",
    margin: 0,
    "&:hover": {
      color: "var(--text-primary)"
    }
  }),
  dropdownIndicator: (t4, e) => ({
    ...t4,
    color: e.isDisabled ? "var(--color-content-disabled)" : "var(--color-content)",
    fill: e.isDisabled ? "var(--color-content-disabled)" : "var(--color-content)",
    display: "flex",
    alignItems: "center",
    alignSelf: "auto",
    justifyContent: "center",
    padding: 0,
    gap: "var(--spacing-xs)",
    "&:hover": {
      color: "var(--icon-color-additional)",
      fill: "var(--icon-color-additional)"
    }
  }),
  clearIndicator: (t4) => ({
    ...t4,
    padding: 0,
    width: "14px",
    height: "14px",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    overflow: "hidden",
    fill: "var(--color-content-placeholder)"
  }),
  valueContainer: (t4) => ({
    ...t4,
    padding: 0,
    overflow: "visible"
  }),
  indicatorsContainer: (t4) => ({
    ...t4,
    gap: "var(--spacing-unit)"
  }),
  placeholder: (t4, e) => ({
    ...t4,
    color: "var(--color-content-placeholder)",
    fontSize: "var(--font-size-base)",
    margin: 0,
    padding: e.isMulti ? "0px var(--spacing-xs)" : 0
  }),
  input: (t4) => ({
    ...t4,
    fontSize: "var(--font-size-base)",
    color: "var(--color-content)",
    margin: 0,
    padding: 0
  }),
  group: (t4) => ({
    ...t4,
    paddingLeft: "var(--spacing-xs)"
  }),
  menuList: (t4) => ({
    ...t4,
    backgroundColor: "var(--bg-color)",
    padding: "var(--spacing-unit)",
    overflowX: "hidden",
    "& > div:not(:last-child)": {
      margin: "0px 0px calc(var(--spacing-unit)/2) 0px"
    }
  }),
  option: (t4, e) => ({
    ...t4,
    minWidth: "max-content",
    cursor: "pointer",
    borderRadius: "var(--border-radius-md)",
    fontSize: "var(--font-size-base)",
    lineHeight: "var(--line-height-base)",
    padding: "0px var(--spacing-xs)",
    minHeight: "32px",
    color: "var(--color-content)",
    fill: "var(--color-content)",
    fontWeight: e.isSelected ? "var(--font-weight-medium)" : "var(--font-weight-regular)",
    display: "flex",
    alignItems: "center",
    justifyContent: "space-between",
    gap: "var(--spacing-xs)",
    backgroundColor: "unset",
    div: {
      maxWidth: "400px",
      textOverflow: "ellipsis",
      overflow: "hidden"
    },
    "&:hover": {
      backgroundColor: "var(--menu-item-bg-color-hover)"
    }
  })
};
I.div`
  display: flex;
  flex-direction: column;
  gap: var(--spacing-xs);
`;
var He = I.span`
  font-size: var(--font-size-base);
  line-height: var(--line-height-base);
  color: var(--text-color-secondary);

  ${({ required: t4 }) => t4 && ql`
      &:after {
        content: '*';
        color: var(--color-error-base);
        margin-left: var(--spacing-xxs);
      }
    `}
`;
I.div`
  display: flex;
  flex-direction: column;
  border-top: 1px solid var(--border-color-secondary);
`;
I.div`
  display: flex;
  flex-direction: row;
  border-bottom: 1px solid var(--border-color-secondary);
  align-items: center;
`;
I.div`
  display: flex;
  justify-content: center;
  min-width: 40px;
`;
var gP = I.div`
  display: flex;
  justify-content: center;
  min-width: 40px;
`;
var $i = I.div`
  display: flex;
  ${({ direction: t4 = "column" }) => t4 === "row" ? ql`
          flex-direction: ${t4};
          align-items: center;
        ` : ql`
          flex-direction: ${t4};
        `};
  ${({ withBorder: t4 }) => t4 && "border-bottom: 1px solid var(--border-color-secondary);"};

  ${He} {
    flex: 0 0 204px;
  }
`;
var st = I.div`
  display: flex;
  flex-direction: row;
  align-items: center;
`;
var mP = I.div`
  display: flex;
  align-items: start;
  height: 100%;
  min-width: 204px;
  padding-top: var(--spacing-xs);
`;
var kg = I(Mo)`
  display: flex;
  height: 40px;
  --select-text-color: var(--dropdown-text-color);
  border: none;
`;
var Ic = I.div`
  padding: var(--spacing-md) 0;
  --button-margin: 0;
`;
function hn() {
  const t4 = je(), { environments: e, selectedEnvironmentId: n } = t4, r = We(() => n.get(), [n]);
  return We(() => e.find((o) => o.get().id === r) || e[0], [e, r]);
}
var a_ = function() {
  var t4 = document.getSelection();
  if (!t4.rangeCount)
    return function() {
    };
  for (var e = document.activeElement, n = [], r = 0; r < t4.rangeCount; r++)
    n.push(t4.getRangeAt(r));
  switch (e.tagName.toUpperCase()) {
    case "INPUT":
    case "TEXTAREA":
      e.blur();
      break;
    default:
      e = null;
      break;
  }
  return t4.removeAllRanges(), function() {
    t4.type === "Caret" && t4.removeAllRanges(), t4.rangeCount || n.forEach(function(i) {
      t4.addRange(i);
    }), e && e.focus();
  };
};
var l_ = a_;
var Wy = {
  "text/plain": "Text",
  "text/html": "Url",
  default: "Text"
};
var c_ = "Copy to clipboard: #{key}, Enter";
function u_(t4) {
  var e = (/mac os x/i.test(navigator.userAgent) ? "\u2318" : "Ctrl") + "+C";
  return t4.replace(/#{\s*key\s*}/g, e);
}
function f_(t4, e) {
  var n, r, i, o, s, a, l = false;
  e || (e = {}), n = e.debug || false;
  try {
    i = l_(), o = document.createRange(), s = document.getSelection(), a = document.createElement("span"), a.textContent = t4, a.ariaHidden = "true", a.style.all = "unset", a.style.position = "fixed", a.style.top = 0, a.style.clip = "rect(0, 0, 0, 0)", a.style.whiteSpace = "pre", a.style.webkitUserSelect = "text", a.style.MozUserSelect = "text", a.style.msUserSelect = "text", a.style.userSelect = "text", a.addEventListener("copy", function(u) {
      if (u.stopPropagation(), e.format)
        if (u.preventDefault(), typeof u.clipboardData > "u") {
          n && console.warn("unable to use e.clipboardData"), n && console.warn("trying IE specific stuff"), window.clipboardData.clearData();
          var f = Wy[e.format] || Wy.default;
          window.clipboardData.setData(f, t4);
        } else
          u.clipboardData.clearData(), u.clipboardData.setData(e.format, t4);
      e.onCopy && (u.preventDefault(), e.onCopy(u.clipboardData));
    }), document.body.appendChild(a), o.selectNodeContents(a), s.addRange(o);
    var c = document.execCommand("copy");
    if (!c)
      throw new Error("copy command was unsuccessful");
    l = true;
  } catch (u) {
    n && console.error("unable to copy using execCommand: ", u), n && console.warn("trying IE specific stuff");
    try {
      window.clipboardData.setData(e.format || "text", t4), e.onCopy && e.onCopy(window.clipboardData), l = true;
    } catch (f) {
      n && console.error("unable to copy using clipboardData: ", f), n && console.error("falling back to prompt"), r = u_("message" in e ? e.message : c_), window.prompt(r, t4);
    }
  } finally {
    s && (typeof s.removeRange == "function" ? s.removeRange(o) : s.removeAllRanges()), a && document.body.removeChild(a), i();
  }
  return l;
}
var d_ = f_;
var h_ = /* @__PURE__ */ Za(d_);
var p_ = class {
  static copyCustom(e) {
    return h_(e);
  }
  static selectElement(e) {
    if (!e)
      return;
    let n, r;
    document.body.createTextRange ? (n = document.body.createTextRange(), n.moveToElementText(e), n.select()) : document.createRange && window.getSelection && (r = window.getSelection(), n = document.createRange(), n.selectNodeContents(e), r == null || r.removeAllRanges(), r == null || r.addRange(n));
  }
};
var OP = {
  hide: {
    type: "boolean",
    default: false
  },
  component: {
    type: "string",
    enum: ["radio", "checkbox"],
    default: "checkbox"
  },
  label: { type: "string" },
  items: { type: "array", items: { type: "string" } }
};
var dl = {
  type: "object",
  properties: OP,
  additionalProperties: false
};
var ih = {
  type: "object",
  properties: {
    hide: {
      type: "boolean",
      default: false
    },
    type: {
      type: "string",
      enum: ["rating", "sentiment", "comment", "reasons", "mood", "scale"],
      default: "sentiment"
    },
    settings: {
      type: "object",
      properties: {
        label: { type: "string" },
        submitText: { type: "string" },
        buttonText: { type: "string" },
        component: {
          type: "string",
          enum: ["radio", "checkbox"],
          default: "checkbox"
        },
        items: { type: "array", items: { type: "string" }, minItems: 1 },
        leftScaleLabel: { type: "string" },
        rightScaleLabel: { type: "string" },
        reasons: {
          type: "object",
          properties: Object.assign(Object.assign({}, OP), { like: dl, dislike: dl, satisfied: dl, neutral: dl, dissatisfied: dl }),
          additionalProperties: false
        },
        comment: {
          type: "object",
          properties: {
            hide: {
              type: "boolean",
              default: false
            },
            label: { type: "string" },
            likeLabel: { type: "string" },
            dislikeLabel: { type: "string" },
            satisfiedLabel: { type: "string" },
            neutralLabel: { type: "string" },
            dissatisfiedLabel: { type: "string" }
          },
          additionalProperties: false
        }
      },
      additionalProperties: false
    }
  },
  additionalProperties: false
};
var js = {
  type: "object",
  properties: {
    includeByName: {
      type: "array",
      items: {
        type: "string"
      }
    },
    excludeByName: {
      type: "array",
      items: {
        type: "string"
      }
    }
  },
  additionalProperties: false
};
var g_ = {
  type: "object",
  properties: {
    name: {
      type: "string"
    },
    items: js,
    queries: js,
    mutations: js,
    subscriptions: js,
    types: js,
    directives: js
  },
  required: ["name"],
  additionalProperties: false
};
var m_ = {
  type: "object",
  properties: {
    requireExactGroups: {
      type: "boolean"
    },
    groups: {
      type: "array",
      items: g_
    },
    otherItemsGroupName: {
      type: "string"
    }
  },
  required: ["requireExactGroups", "groups", "otherItemsGroupName"],
  additionalProperties: false
};
var Mf = {
  type: "object",
  properties: {
    hidePaginationButtons: {
      type: "boolean"
    },
    menu: {
      type: "object",
      properties: Object.assign({}, m_.properties),
      additionalProperties: false
    },
    sidebar: {
      type: "object",
      properties: {
        hide: {
          type: "boolean"
        }
      }
    },
    apiLogo: {
      type: "object",
      properties: {
        imageUrl: {
          type: "string"
        },
        href: {
          type: "string"
        },
        altText: {
          type: "string"
        },
        backgroundColor: {
          type: "string"
        }
      }
    },
    jsonSamplesDepth: {
      type: "number"
    },
    samplesMaxInlineArgs: {
      type: "number"
    },
    licenseKey: {
      type: "string"
    },
    fieldExpandLevel: {
      type: "number"
    },
    baseUrlPath: {
      type: "string"
    },
    feedback: ih
  },
  additionalProperties: false
};
var O_ = {
  type: "object",
  properties: {
    languages: {
      type: "array",
      items: {
        type: "object",
        properties: {
          lang: {
            type: "string",
            enum: [
              "curl",
              "JavaScript",
              "Node.js",
              "Python",
              "Java8+Apache",
              "Java",
              "C#",
              "C#+Newtonsoft",
              "PHP",
              "Go",
              "Ruby",
              "R",
              "Payload"
            ]
          },
          label: { type: "string" },
          options: {
            type: "object",
            properties: {
              indent: { type: "string" },
              withImports: { type: "boolean" },
              withComments: { type: "boolean" },
              binary: { type: "boolean" },
              credentials: {
                type: "string",
                enum: ["omit", "same-origin", "include"]
              }
            },
            additionalProperties: false
          }
        },
        required: ["lang"],
        additionalProperties: false
      }
    },
    skipOptionalParameters: { type: "boolean" },
    withOAuth2Call: { type: "boolean" }
  },
  required: ["languages"],
  additionalProperties: false
};
var x_ = {
  type: "array",
  items: {
    type: "object",
    properties: {
      title: { type: "string" },
      url: { type: "string" }
    },
    required: ["url"],
    additionalProperties: false
  }
};
var Vy = {
  type: "object",
  properties: {
    licenseKey: { type: "string" },
    hideLoading: { type: "boolean" },
    disableRouter: { type: "boolean" },
    hideSidebar: { type: "boolean" },
    feedback: ih,
    hideReplay: { type: "boolean" },
    oAuth2RedirectURI: { type: "string", nullable: true },
    corsProxyUrl: { type: "string" },
    sortRequiredPropsFirst: { type: "boolean" },
    sanitize: { type: "boolean" },
    hideDownloadButtons: { type: "boolean" },
    downloadUrls: x_,
    onlyRequiredInSamples: { type: "boolean" },
    generatedSamplesMaxDepth: { oneOf: [{ type: "number" }, { type: "string" }] },
    showExtensions: {
      oneOf: [
        { type: "boolean" },
        { type: "string" },
        { type: "array", items: { type: "string" } }
      ]
    },
    hideSchemaTitles: { type: "boolean" },
    jsonSamplesExpandLevel: { oneOf: [{ type: "number" }, { type: "string" }] },
    schemasExpansionLevel: { oneOf: [{ type: "number" }, { type: "string" }] },
    mockServer: {
      type: "object",
      properties: {
        url: { type: "string" },
        position: { type: "string", enum: ["first", "last", "replace", "off"] },
        description: { type: "string" }
      }
    },
    maxDisplayedEnumValues: { type: "number" },
    schemaDefinitionsTagName: { type: "string" },
    layout: { type: "string", enum: ["stacked", "three-panel"] },
    hideInfoMetadata: { type: "boolean" },
    events: { type: "object" },
    skipBundle: { type: "boolean" },
    routingBasePath: { type: "string" },
    codeSamples: O_,
    ignoreNamedSchemas: {
      oneOf: [{ type: "array", items: { type: "string" } }, { type: "string" }]
    },
    hidePropertiesPrefix: { type: "boolean" },
    excludeFromSearch: { type: "boolean" }
  },
  additionalProperties: false
};
var v_ = {
  type: "object",
  properties: {
    label: { type: "string" },
    lang: {
      enum: [
        "curl",
        "C#",
        "Go",
        "Java",
        "Java8+Apache",
        "JavaScript",
        "Node.js",
        "PHP",
        "Python",
        "R",
        "Ruby"
      ]
    }
  },
  required: ["lang"]
};
var y_ = {
  type: "object",
  properties: {
    enum: { type: "string" },
    enumSingleValue: { type: "string" },
    enumArray: { type: "string" },
    default: { type: "string" },
    deprecated: { type: "string" },
    example: { type: "string" },
    examples: { type: "string" },
    nullable: { type: "string" },
    recursive: { type: "string" },
    arrayOf: { type: "string" },
    webhook: { type: "string" },
    authorizations: { type: "string" },
    tryItAuthBasicUsername: { type: "string" },
    tryItAuthBasicPassword: { type: "string" }
  }
};
var zy = {
  type: "object",
  properties: {
    label: { type: "string" },
    link: { type: "string" },
    target: { type: "string" }
  },
  required: ["label", "link"]
};
var b_ = {
  type: "object",
  properties: {
    beforeInfo: { type: "array", items: zy },
    end: { type: "array", items: zy }
  }
};
var ts = {
  type: "object",
  properties: {
    main: { type: "string" },
    light: { type: "string" },
    dark: { type: "string" },
    contrastText: { type: "string" }
  }
};
var pu = {
  type: "object",
  properties: {
    backgroundColor: { type: "string" },
    borderColor: { type: "string" },
    color: { type: "string" },
    tabTextColor: { type: "string" }
  }
};
var S_ = {
  type: "object",
  properties: oh(ts.properties, ["light", "dark"])
};
var w_ = {
  type: "object",
  properties: {
    basic: { type: "string" },
    delete: { type: "string" },
    get: { type: "string" },
    head: { type: "string" },
    link: { type: "string" },
    options: { type: "string" },
    patch: { type: "string" },
    post: { type: "string" },
    put: { type: "string" }
  }
};
var C_ = {
  type: "object",
  properties: {
    error: pu,
    info: pu,
    redirect: pu,
    success: pu
  }
};
var k_ = {
  type: "object",
  properties: Xa(ts.properties, ["dark"])
};
var A_ = {
  type: "object",
  properties: {
    primary: { type: "string" },
    secondary: { type: "string" },
    light: { type: "string" }
  }
};
var P_ = {
  type: "object",
  properties: {
    accent: ts,
    border: S_,
    error: ts,
    http: w_,
    primary: ts,
    responses: C_,
    secondary: k_,
    success: ts,
    text: A_,
    tonalOffset: { type: "number" },
    warning: ts
  }
};
var gu = {
  type: "object",
  properties: {
    fontSize: { type: "string" },
    padding: { type: "string" },
    minWidth: { type: "string" }
  }
};
var E_ = {
  type: "object",
  properties: {
    small: gu,
    medium: gu,
    large: gu,
    xlarge: gu
  }
};
var Ti = {
  type: "object",
  properties: {
    fontFamily: { type: "string" },
    fontSize: { type: "string" },
    fontWeight: { type: "string" },
    lineHeight: { type: "string" }
  }
};
var T_ = {
  type: "object",
  properties: Object.assign(Object.assign({}, Xa(Ti.properties, ["fontSize", "lineHeight"])), { borderRadius: { type: "string" }, hoverStyle: { type: "string" }, boxShadow: { type: "string" }, hoverBoxShadow: { type: "string" }, sizes: E_ })
};
var Ly = {
  type: "object",
  properties: oh(Ti.properties, ["fontSize", "lineHeight"])
};
var I_ = {
  type: "object",
  properties: {
    medium: Ly,
    small: Ly
  }
};
var $_ = {
  type: "object",
  properties: Object.assign(Object.assign({}, Xa(Ti.properties, ["fontSize", "lineHeight"])), { borderRadius: { type: "string" }, color: { type: "string" }, sizes: I_ })
};
var j_ = {
  type: "object",
  properties: {
    top: { type: "string" },
    width: { type: "string" },
    height: { type: "string" }
  }
};
var R_ = {
  type: "object",
  properties: {
    borderRadius: { type: "string" },
    backgroundColor: { type: "string" }
  }
};
var Xy = {
  type: "object",
  properties: {
    fullWidth: { type: "boolean" }
  }
};
var D_ = {
  type: "object",
  properties: {
    buttons: T_,
    httpBadges: $_,
    layoutControls: j_,
    panels: R_,
    tryItButton: Xy,
    tryItSendButton: Xy
  }
};
var Nf = {
  type: "object",
  properties: {
    small: { type: "string" },
    medium: { type: "string" },
    large: { type: "string" }
  }
};
var Q_ = {
  type: "object",
  properties: {
    maxWidth: Nf
  }
};
var B_ = {
  type: "object",
  properties: {
    maxWidth: Nf,
    middlePanelMaxWidth: Nf
  }
};
var __ = {
  type: "object",
  properties: {
    showDarkRightPanel: { type: "boolean" },
    stacked: Q_,
    "three-panel": B_
  }
};
var Gy = {
  type: "object",
  properties: {
    backgroundColor: { type: "string" },
    border: { type: "string" }
  }
};
var M_ = {
  type: "object",
  properties: {
    breakFieldNames: { type: "boolean" },
    caretColor: { type: "string" },
    caretSize: { type: "string" },
    constraints: Gy,
    defaultDetailsWidth: { type: "string" },
    examples: Gy,
    labelsTextSize: { type: "string" },
    linesColor: { type: "string" },
    nestedBackground: { type: "string" },
    nestingSpacing: { type: "string" },
    requireLabelColor: { type: "string" },
    typeNameColor: { type: "string" },
    typeTitleColor: { type: "string" }
  }
};
var xP = {
  type: "object",
  properties: {
    subItemsColor: { type: "string" },
    textTransform: { type: "string" },
    fontWeight: { type: "string" }
  }
};
var N_ = {
  type: "object",
  properties: oh(xP.properties, ["textTransform"])
};
var F_ = {
  type: "object",
  properties: {
    unit: { type: "number" },
    paddingHorizontal: { type: "string" },
    paddingVertical: { type: "string" },
    offsetTop: { type: "string" },
    offsetLeft: { type: "string" },
    offsetNesting: { type: "string" }
  }
};
var Z_ = {
  type: "object",
  properties: Object.assign(Object.assign({}, Xa(Ti.properties, ["fontWeight", "lineHeight"])), { activeBgColor: { type: "string" }, activeTextColor: { type: "string" }, backgroundColor: { type: "string" }, borderRadius: { type: "string" }, breakPath: { type: "boolean" }, caretColor: { type: "string" }, caretSize: { type: "string" }, groupItems: xP, level1items: N_, rightLineColor: { type: "string" }, separatorLabelColor: { type: "string" }, showAtBreakpoint: { type: "string" }, spacing: F_, textColor: { type: "string" }, width: { type: "string" } })
};
var mu = {
  type: "object",
  properties: Object.assign(Object.assign({}, Ti.properties), { color: { type: "string" }, transform: { type: "string" } })
};
var W_ = {
  type: "object",
  properties: Object.assign(Object.assign({}, Ti.properties), { backgroundColor: { type: "string" }, color: { type: "string" }, wordBreak: {
    type: "string",
    enum: [
      "break-all",
      "break-word",
      "keep-all",
      "normal",
      "revert",
      "unset",
      "inherit",
      "initial"
    ]
  }, wrap: { type: "boolean" } })
};
var V_ = {
  type: "object",
  properties: Xa(Ti.properties, ["fontSize"])
};
var z_ = {
  type: "object",
  properties: {
    color: { type: "string" },
    hover: { type: "string" },
    textDecoration: { type: "string" },
    hoverTextDecoration: { type: "string" },
    visited: { type: "string" }
  }
};
var L_ = {
  type: "object",
  properties: Object.assign(Object.assign({ code: W_, fieldName: Ti }, oh(Ti.properties, ["fontSize", "fontFamily"])), { fontWeightBold: { type: "string" }, fontWeightLight: { type: "string" }, fontWeightRegular: { type: "string" }, heading1: mu, heading2: mu, heading3: mu, headings: V_, lineHeight: { type: "string" }, links: z_, optimizeSpeed: { type: "boolean" }, rightPanelHeading: mu, smoothing: {
    type: "string",
    enum: ["auto", "none", "antialiased", "subpixel-antialiased", "grayscale"]
  } })
};
var X_ = {
  type: "object",
  properties: Object.assign({ color: { type: "string" } }, Xa(Ti.properties, ["fontWeight"]))
};
var G_ = {
  type: "object",
  properties: {
    backgroundColor: { type: "string" },
    borderRadius: { type: "string" },
    tokens: X_
  }
};
var Y_ = {
  type: "object",
  properties: {
    gutter: { type: "string" },
    maxHeight: { type: "string" },
    maxWidth: { type: "string" }
  }
};
var q_ = {
  type: "object",
  properties: {
    backgroundColor: { type: "string" },
    color: { type: "string" }
  }
};
var Yy = {
  type: "object",
  properties: {
    custom: { type: "string" }
  }
};
var U_ = {
  type: "object",
  properties: {
    DownloadButton: Yy,
    NextSectionButton: Yy
  }
};
var H_ = {
  type: "object",
  properties: {
    backgroundColor: { type: "string" },
    panelBackgroundColor: { type: "string" },
    panelControlsBackgroundColor: { type: "string" },
    showAtBreakpoint: { type: "string" },
    textColor: { type: "string" },
    width: { type: "string" }
  }
};
var J_ = {
  type: "object",
  properties: { borderRadius: { type: "string" } }
};
var K_ = {
  type: "object",
  properties: {
    sectionHorizontal: { type: "number" },
    sectionVertical: { type: "number" },
    unit: { type: "number" }
  }
};
var e9 = {
  type: "object",
  properties: {
    breakpoints: Nf,
    codeBlock: G_,
    colors: P_,
    components: D_,
    layout: __,
    logo: Y_,
    fab: q_,
    overrides: U_,
    rightPanel: H_,
    schema: M_,
    shape: J_,
    sidebar: Z_,
    spacing: K_,
    typography: L_,
    links: { properties: { color: { type: "string" } } },
    codeSample: { properties: { backgroundColor: { type: "string" } } }
  }
};
var t9 = {
  type: "object",
  properties: {
    skipOptionalParameters: { type: "boolean" },
    languages: { type: "array", items: v_ }
  },
  required: ["languages"]
};
var n9 = {
  type: "object",
  properties: {
    theme: e9,
    ctrlFHijack: { type: "boolean" },
    defaultSampleLanguage: { type: "string" },
    disableDeepLinks: { type: "boolean" },
    disableSearch: { type: "boolean" },
    disableSidebar: { type: "boolean" },
    downloadDefinitionUrl: { type: "string" },
    expandDefaultServerVariables: { type: "boolean" },
    enumSkipQuotes: { type: "boolean" },
    expandDefaultRequest: { type: "boolean" },
    expandDefaultResponse: { type: "boolean" },
    expandResponses: { type: "string" },
    expandSingleSchemaField: { type: "boolean" },
    generateCodeSamples: t9,
    generatedPayloadSamplesMaxDepth: { type: "number" },
    hideDownloadButton: { type: "boolean" },
    hideHostname: { type: "boolean" },
    hideInfoSection: { type: "boolean" },
    hideLogo: { type: "boolean" },
    hideRequestPayloadSample: { type: "boolean" },
    hideRightPanel: { type: "boolean" },
    hideSchemaPattern: { type: "boolean" },
    hideSingleRequestSampleTab: { type: "boolean" },
    hideSecuritySection: { type: "boolean" },
    hideTryItPanel: { type: "boolean" },
    hideFab: { type: "boolean" },
    hideOneOfDescription: { type: "boolean" },
    htmlTemplate: { type: "string" },
    jsonSampleExpandLevel: {
      oneOf: [{ type: "number", minimum: 1 }, { type: "string" }]
    },
    labels: y_,
    menuToggle: { type: "boolean" },
    nativeScrollbars: { type: "boolean" },
    noAutoAuth: { type: "boolean" },
    onDeepLinkClick: { type: "object" },
    pagination: { enum: ["none", "section", "item"] },
    pathInMiddlePanel: { type: "boolean" },
    payloadSampleIdx: { type: "number", minimum: 0 },
    requestInterceptor: { type: "object" },
    requiredPropsFirst: { type: "boolean" },
    routingStrategy: { type: "string" },
    samplesTabsMaxCount: { type: "number" },
    schemaExpansionLevel: {
      oneOf: [{ type: "number", minimum: 0 }, { type: "string" }]
    },
    minCharacterLengthToInitSearch: { type: "number", minimum: 1 },
    maxResponseHeadersToShowInTryIt: { type: "number", minimum: 0 },
    scrollYOffset: {
      oneOf: [{ type: "number" }, { type: "string" }]
    },
    searchAutoExpand: { type: "boolean" },
    searchFieldLevelBoost: { type: "number", minimum: 0 },
    searchMaxDepth: { type: "number", minimum: 1 },
    searchMode: { type: "string", enum: ["default", "path-only"] },
    searchOperationTitleBoost: { type: "number" },
    searchTagTitleBoost: { type: "number" },
    sendXUserAgentInTryIt: { type: "boolean" },
    showChangeLayoutButton: { type: "boolean" },
    showConsole: { type: "boolean" },
    showNextButton: { type: "boolean" },
    showRightPanelToggle: { type: "boolean" },
    showSecuritySchemeType: { type: "boolean" },
    showWebhookVerb: { type: "boolean" },
    showObjectSchemaExamples: { type: "boolean" },
    disableTryItRequestUrlEncoding: { type: "boolean" },
    sidebarLinks: b_,
    sideNavStyle: { type: "string", enum: ["summary-only", "path-first", "id-only"] },
    simpleOneOfTypeLabel: { type: "boolean" },
    sortEnumValuesAlphabetically: { type: "boolean" },
    sortOperationsAlphabetically: { type: "boolean" },
    sortPropsAlphabetically: { type: "boolean" },
    sortTagsAlphabetically: { type: "boolean" },
    suppressWarnings: { type: "boolean" },
    unstable_externalDescription: { type: "boolean" },
    unstable_ignoreMimeParameters: { type: "boolean" },
    untrustedDefinition: { type: "boolean" },
    showAccessMode: { type: "boolean" },
    preserveOriginalExtensionsName: { type: "boolean" },
    markdownHeadingsAnchorLevel: { type: "number" }
  },
  additionalProperties: false
};
function oh(t4, e) {
  return Object.fromEntries(e.filter((n) => n in t4).map((n) => [n, t4[n]]));
}
function Xa(t4, e) {
  return Object.fromEntries(Object.entries(t4).filter(([n]) => !e.includes(n)));
}
var Mn = {
  type: "object",
  properties: {
    hide: { type: "boolean" }
  },
  additionalProperties: false
};
var qy = {
  type: "object",
  properties: {
    src: { type: "string" },
    async: { type: "boolean" },
    crossorigin: { type: "string" },
    defer: { type: "boolean" },
    fetchpriority: { type: "string" },
    integrity: { type: "string" },
    module: { type: "boolean" },
    nomodule: { type: "boolean" },
    nonce: { type: "string" },
    referrerpolicy: { type: "string" },
    type: { type: "string" }
  },
  required: ["src"],
  additionalProperties: true
};
var pp = {
  type: "object",
  properties: {
    page: { type: "string" },
    directory: { type: "string" },
    disconnect: { type: "boolean", default: false },
    group: { type: "string" },
    label: { type: "string" },
    href: { type: "string" },
    external: { type: "boolean" },
    labelTranslationKey: { type: "string" },
    groupTranslationKey: { type: "string" },
    icon: {
      oneOf: [
        { type: "string" },
        { type: "object", properties: { srcSet: { type: "string" } }, required: ["srcSet"] }
      ]
    },
    separator: { type: "string" },
    separatorLine: { type: "boolean" },
    linePosition: {
      type: "string",
      enum: ["top", "bottom"],
      default: "top"
    },
    version: { type: "string" },
    menuStyle: { type: "string", enum: ["drilldown"] },
    expanded: { type: "string", const: "always" },
    selectFirstItemOnExpand: { type: "boolean" },
    flatten: { type: "boolean" },
    linkedSidebars: {
      type: "array",
      items: { type: "string" }
    },
    // Allow users to eject the navbar and implement additional levels of nesting
    items: { type: "array", items: { type: "object", additionalProperties: true } }
  }
};
var sx = {
  type: "array",
  items: Object.assign(Object.assign({}, pp), { properties: Object.assign(Object.assign({}, pp.properties), { items: { type: "array", items: pp } }) })
};
var r9 = {
  type: "object",
  properties: {
    name: { type: "string" },
    icon: { type: "string" },
    folder: { type: "string" }
  },
  additionalProperties: false,
  required: ["name", "folder"]
};
var i9 = {
  type: "object",
  properties: {
    hide: {
      type: "boolean",
      default: false
    },
    prompt: {
      type: "string"
    }
  },
  additionalProperties: false
};
var o9 = {
  type: "array",
  items: {
    type: "object",
    required: ["name", "field", "type"],
    properties: {
      name: { type: "string" },
      field: { type: "string" },
      type: {
        type: "string",
        enum: ["multi-select", "select", "tags"]
      },
      isTop: { type: "boolean" }
    },
    additionalProperties: false
  }
};
var s9 = {
  type: "object",
  properties: {
    page: { type: "string" },
    label: { type: "string" },
    labelTranslationKey: { type: "string" }
  },
  required: ["page"]
};
var vP = {
  type: "object",
  properties: {
    image: { type: "string" },
    srcSet: { type: "string" },
    altText: { type: "string" },
    link: { type: "string" },
    favicon: { type: "string" }
  },
  additionalProperties: false
};
var yP = {
  type: "object",
  properties: Object.assign({ items: sx }, Mn.properties),
  additionalProperties: false
};
var bP = {
  type: "object",
  additionalProperties: r9
};
var SP = {
  type: "object",
  properties: Object.assign({ items: sx, copyrightText: { type: "string" }, logo: Mn }, Mn.properties),
  additionalProperties: false
};
var wP = {
  type: "object",
  properties: Object.assign({ separatorLine: { type: "boolean" }, linePosition: {
    type: "string",
    enum: ["top", "bottom"],
    default: "bottom"
  } }, Mn.properties),
  additionalProperties: false
};
var CP = {
  type: "object",
  properties: {
    head: { type: "array", items: qy },
    body: { type: "array", items: qy }
  },
  additionalProperties: false
};
var kP = {
  type: "array",
  items: {
    type: "object",
    properties: {
      href: { type: "string" },
      as: { type: "string" },
      crossorigin: { type: "string" },
      fetchpriority: { type: "string" },
      hreflang: { type: "string" },
      imagesizes: { type: "string" },
      imagesrcset: { type: "string" },
      integrity: { type: "string" },
      media: { type: "string" },
      prefetch: { type: "string" },
      referrerpolicy: { type: "string" },
      rel: { type: "string" },
      sizes: { type: "string" },
      title: { type: "string" },
      type: { type: "string" }
    },
    required: ["href"],
    additionalProperties: true
  }
};
var AP = {
  type: "object",
  properties: Object.assign({ engine: {
    type: "string",
    enum: ["flexsearch", "typesense"],
    default: "flexsearch"
  }, ai: i9, facets: o9, placement: {
    type: "string",
    default: "navbar"
  }, shortcuts: {
    type: "array",
    items: { type: "string" },
    default: ["/"]
  }, suggestedPages: {
    type: "array",
    items: s9
  } }, Mn.properties),
  additionalProperties: false
};
var PP = {
  type: "object",
  properties: Object.assign({ ignoreDetection: { type: "boolean" }, modes: {
    type: "array",
    items: { type: "string" },
    default: ["light", "dark"]
  } }, Mn.properties),
  additionalProperties: false
};
var EP = {
  type: "object",
  properties: {
    nextButton: {
      type: "object",
      properties: Object.assign({ text: { type: "string", default: "Next page" } }, Mn.properties),
      additionalProperties: false,
      default: {}
    },
    previousButton: {
      type: "object",
      properties: Object.assign({ text: { type: "string", default: "Previous page" } }, Mn.properties),
      additionalProperties: false,
      default: {}
    }
  },
  additionalProperties: false
};
var TP = {
  type: "object",
  properties: {
    elementFormat: { type: "string", default: "icon" },
    copy: {
      type: "object",
      properties: Object.assign({}, Mn.properties),
      additionalProperties: false,
      default: { hide: false }
    },
    report: {
      type: "object",
      properties: Object.assign({ tooltipText: { type: "string" }, buttonText: { type: "string" }, label: { type: "string" } }, Mn.properties),
      additionalProperties: false,
      default: { hide: false }
    },
    expand: {
      type: "object",
      properties: Object.assign({}, Mn.properties),
      additionalProperties: false,
      default: { hide: false }
    },
    collapse: {
      type: "object",
      properties: Object.assign({}, Mn.properties),
      additionalProperties: false,
      default: { hide: false }
    }
  },
  additionalProperties: false
};
var IP = {
  type: "object",
  properties: {
    frontMatterKeysToResolve: {
      type: "array",
      items: { type: "string" },
      default: ["image", "links"]
    },
    partialsFolders: {
      type: "array",
      items: { type: "string" },
      default: ["_partials"]
    },
    lastUpdatedBlock: {
      type: "object",
      properties: Object.assign({ format: {
        type: "string",
        enum: ["timeago", "iso", "long", "short"],
        default: "timeago"
      }, locale: { type: "string" } }, Mn.properties),
      additionalProperties: false,
      default: {}
    },
    toc: {
      type: "object",
      properties: Object.assign({ header: { type: "string", default: "On this page" }, depth: { type: "integer", default: 3, minimum: 1 } }, Mn.properties),
      additionalProperties: false,
      default: {}
    },
    editPage: {
      type: "object",
      properties: Object.assign({ baseUrl: { type: "string" } }, Mn.properties),
      additionalProperties: false,
      default: {}
    }
  },
  additionalProperties: false,
  default: {}
};
var Ff = Object.assign(Object.assign({}, Vy), { properties: Object.assign(Object.assign({}, Vy.properties), n9.properties) });
var a9 = {
  type: "object",
  properties: {
    includeInDevelopment: { type: "boolean" },
    scriptUrl: { type: "string" },
    pageViewEventName: { type: "string" }
  },
  additionalProperties: false,
  required: ["scriptUrl"]
};
var l9 = {
  type: "object",
  properties: {
    includeInDevelopment: { type: "boolean" },
    apiKey: { type: "string" },
    head: { type: "boolean" },
    respectDNT: { type: "boolean" },
    exclude: { type: "array", items: { type: "string" } },
    outboundClickEventName: { type: "string" },
    pageViewEventName: { type: "string" },
    amplitudeConfig: { type: "object", additionalProperties: true }
  },
  additionalProperties: false,
  required: ["apiKey"]
};
var c9 = {
  type: "object",
  properties: {
    includeInDevelopment: { type: "boolean" },
    orgId: { type: "string" }
  },
  additionalProperties: false,
  required: ["orgId"]
};
var u9 = {
  type: "object",
  properties: {
    includeInDevelopment: { type: "boolean" },
    appId: { type: "string" }
  },
  additionalProperties: false,
  required: ["appId"]
};
var f9 = {
  type: "object",
  properties: {
    includeInDevelopment: { type: "boolean" },
    writeKey: { type: "string", minLength: 10 },
    trackPage: { type: "boolean" },
    dataPlaneUrl: { type: "string" },
    controlPlaneUrl: { type: "string" },
    sdkUrl: { type: "string" },
    loadOptions: { type: "object", additionalProperties: true }
  },
  additionalProperties: false,
  required: ["writeKey"]
};
var d9 = {
  type: "object",
  properties: {
    includeInDevelopment: { type: "boolean" },
    writeKey: { type: "string", minLength: 10 },
    trackPage: { type: "boolean" },
    includeTitleInPageCall: { type: "boolean" },
    host: { type: "string" }
  },
  additionalProperties: false,
  required: ["writeKey"]
};
var h9 = {
  type: "object",
  properties: {
    includeInDevelopment: { type: "boolean" },
    trackingId: { type: "string" },
    gtmAuth: { type: "string" },
    gtmPreview: { type: "string" },
    defaultDataLayer: {},
    dataLayerName: { type: "string" },
    enableWebVitalsTracking: { type: "boolean" },
    selfHostedOrigin: { type: "string" },
    pageViewEventName: { type: "string" }
  },
  additionalProperties: false,
  required: ["trackingId"]
};
var $P = {
  type: "object",
  properties: {
    includeInDevelopment: { type: "boolean" },
    trackingId: { type: "string" },
    conversionId: { type: "string" },
    floodlightId: { type: "string" },
    optimizeId: { type: "string" },
    exclude: { type: "array", items: { type: "string" } }
  },
  additionalProperties: false,
  required: ["trackingId"]
};
var p9 = {
  type: "object",
  properties: {
    includeInDevelopment: { type: "boolean" },
    trackingId: { type: "string" },
    conversionId: { type: "string" },
    floodlightId: { type: "string" },
    head: { type: "boolean" },
    respectDNT: { type: "boolean" },
    exclude: { type: "array", items: { type: "string" } },
    optimizeId: { type: "string" },
    anonymizeIp: { type: "boolean" },
    cookieExpires: { type: "number" },
    // All enabled tracking configs
    trackers: {
      type: "object",
      additionalProperties: $P
    }
  },
  additionalProperties: false,
  required: ["trackingId"]
};
var jP = {
  type: "object",
  properties: {
    adobe: a9,
    amplitude: l9,
    fullstory: c9,
    heap: u9,
    rudderstack: f9,
    segment: d9,
    gtm: h9,
    ga: p9
  }
};
var RP = {
  type: "object",
  properties: Object.assign({ items: {
    type: "array",
    items: {
      type: "object",
      properties: {
        label: { type: "string" },
        external: { type: "boolean" },
        link: { type: "string" },
        separatorLine: { type: "boolean" }
      },
      additionalProperties: true
    },
    default: []
  }, hideLoginButton: { type: "boolean" } }, Mn.properties),
  additionalProperties: false
};
var DP = {
  type: "object",
  properties: {
    hide: { type: "boolean" },
    showForUnversioned: {
      type: "boolean"
    }
  }
};
var QP = {
  type: "object",
  properties: {
    hide: { type: "boolean" },
    prefixItems: {
      type: "array",
      items: {
        type: "object",
        properties: {
          label: { type: "string" },
          labelTranslationKey: { type: "string" },
          page: { type: "string" }
        },
        additionalProperties: false,
        default: {}
      }
    }
  },
  additionalProperties: false
};
var g9 = {
  type: "object",
  additionalProperties: false,
  required: ["title", "property"],
  properties: {
    type: {
      type: "string",
      enum: ["select", "checkboxes", "date-range"],
      default: "checkboxes"
    },
    title: { type: "string" },
    titleTranslationKey: { type: "string" },
    property: { type: "string" },
    parentFilter: { type: "string" },
    valuesMapping: { type: "object", additionalProperties: { type: "string" } },
    missingCategoryName: { type: "string" },
    missingCategoryNameTranslationKey: { type: "string" },
    options: { type: "array", items: { type: "string" } }
  }
};
var m9 = {
  type: "object",
  additionalProperties: true,
  required: ["slug", "items"],
  properties: {
    slug: { type: "string" },
    filters: { type: "array", items: g9 },
    groupByFirstFilter: { type: "boolean" },
    filterValuesCasing: {
      type: "string",
      enum: ["sentence", "original", "lowercase", "uppercase"]
    },
    items: sx,
    requiredPermission: { type: "string" },
    separateVersions: { type: "boolean" },
    title: { type: "string" },
    titleTranslationKey: { type: "string" },
    description: { type: "string" },
    descriptionTranslationKey: { type: "string" }
  }
};
var BP = {
  type: "object",
  patternProperties: {
    ".*": m9
  }
};
var _P = {
  type: "object",
  additionalProperties: true,
  required: [],
  properties: {
    /**
     * @deprecated Should use `reunite.ignoreLint` instead
     */
    ignoreNonCompliant: { type: "boolean", default: false },
    teamMetadataProperty: {
      type: "object",
      properties: {
        property: { type: "string" },
        label: { type: "string" },
        default: { type: "string" }
      }
    },
    levels: {
      type: "array",
      items: {
        type: "object",
        required: ["name"],
        properties: {
          name: { type: "string" },
          color: { type: "string" },
          extends: { type: "array", items: { type: "string" } },
          rules: {
            type: "object",
            additionalProperties: {
              oneOf: [{ type: "string" }, { type: "object" }]
            }
          }
        },
        additionalProperties: false
      }
    },
    targets: {
      type: "array",
      items: {
        type: "object",
        required: ["where"],
        properties: {
          minimumLevel: { type: "string" },
          rules: { type: "object", additionalProperties: true },
          where: {
            type: "object",
            required: ["metadata"],
            properties: {
              metadata: { type: "object", additionalProperties: { type: "string" } }
            },
            additionalProperties: false
          }
        },
        additionalProperties: false
      }
    },
    ignore: {
      type: "array",
      items: { type: "string" }
    }
  }
};
var Lr = {
  type: "object",
  properties: {
    /**
     * @deprecated Should use `plugins` instead
     */
    imports: {
      type: "array",
      items: { type: "string" }
    },
    logo: vP,
    navbar: yP,
    products: bP,
    footer: SP,
    sidebar: wP,
    scripts: CP,
    links: kP,
    feedback: ih,
    search: AP,
    colorMode: PP,
    navigation: EP,
    codeSnippet: TP,
    markdown: IP,
    openapi: Ff,
    graphql: Mf,
    analytics: jP,
    userMenu: RP,
    versionPicker: DP,
    breadcrumbs: QP,
    catalog: BP,
    scorecard: _P
  },
  additionalProperties: true
};
Object.assign(Object.assign({}, Lr), { additionalProperties: false });
var O9 = "https://redocly.com/sso/teams";
var Zf;
(function(t4) {
  t4.OIDC = "OIDC", t4.SAML2 = "SAML2";
})(Zf || (Zf = {}));
var Wf;
(function(t4) {
  t4.SERVICE_ACCOUNT = "SERVICE_ACCOUNT", t4.OAUTH2 = "OAUTH2";
})(Wf || (Wf = {}));
var Uy;
(function(t4) {
  t4.STACKED = "stacked", t4.THREE_PANEL = "three-panel";
})(Uy || (Uy = {}));
function Ag(t4, e) {
  return Object.fromEntries(Object.entries(t4).map(([n, r]) => {
    if (n !== e)
      return typeof r != "object" || !r ? [n, r] : Array.isArray(r) ? [
        n,
        r.map((i) => typeof i == "object" ? Ag(i, e) : i)
      ] : [n, Ag(r, e)];
  }).filter(Boolean));
}
var x9 = {
  type: "object",
  additionalProperties: { type: "string" }
};
var v9 = {
  type: "object",
  additionalProperties: false,
  properties: {
    event: {
      type: "string",
      enum: ["schedule"]
    },
    interval: { type: "string", pattern: "^[1-9]\\d*[mhdw]$" }
  },
  required: ["event"]
};
var y9 = {
  type: "object",
  properties: {
    ignoreLint: {
      oneOf: [
        { type: "boolean", default: false },
        {
          type: "object",
          additionalProperties: { type: "boolean" }
        }
      ]
    },
    ignoreLinkChecker: { type: "boolean" },
    ignoreMarkdocErrors: { type: "boolean" },
    jobs: {
      type: "array",
      items: {
        type: "object",
        properties: {
          path: {
            type: "string",
            pattern: "^(?!\\.\\./)(/[a-zA-Z0-9_\\-\\./]+|./[a-zA-Z0-9_\\-\\./]+|[a-zA-Z0-9_\\-\\./]+)$"
          },
          agent: {
            type: "string",
            enum: ["spot"]
          },
          trigger: v9,
          inputs: x9
        },
        required: ["path", "trigger", "agent"],
        additionalProperties: false
      }
    }
  },
  additionalProperties: false
};
var b9 = {
  type: "object",
  properties: {
    end_session_endpoint: { type: "string" },
    token_endpoint: { type: "string" },
    authorization_endpoint: { type: "string" },
    jwks_uri: { type: "string" }
  },
  required: ["token_endpoint", "authorization_endpoint"],
  additionalProperties: true
};
var S9 = {
  type: "object",
  properties: {
    type: { type: "string", const: Zf.OIDC },
    title: { type: "string" },
    pkce: { type: "boolean", default: false },
    configurationUrl: { type: "string", minLength: 1 },
    configuration: b9,
    clientId: { type: "string", minLength: 1 },
    clientSecret: { type: "string", minLength: 0 },
    teamsClaimName: { type: "string" },
    teamsClaimMap: { type: "object", additionalProperties: { type: "string" } },
    defaultTeams: { type: "array", items: { type: "string" } },
    scopes: { type: "array", items: { type: "string" } },
    tokenExpirationTime: { type: "number" },
    authorizationRequestCustomParams: { type: "object", additionalProperties: { type: "string" } },
    tokenRequestCustomParams: { type: "object", additionalProperties: { type: "string" } },
    audience: { type: "array", items: { type: "string" } }
  },
  required: ["type", "clientId"],
  oneOf: [{ required: ["configurationUrl"] }, { required: ["configuration"] }],
  additionalProperties: false
};
var w9 = {
  type: "object",
  properties: {
    type: { type: "string", const: Zf.SAML2 },
    title: { type: "string" },
    issuerId: { type: "string" },
    entityId: { type: "string" },
    ssoUrl: { type: "string" },
    x509PublicCert: { type: "string" },
    teamsAttributeName: { type: "string", default: O9 },
    teamsAttributeMap: { type: "object", additionalProperties: { type: "string" } },
    defaultTeams: { type: "array", items: { type: "string" } }
  },
  additionalProperties: false,
  required: ["type", "issuerId", "ssoUrl", "x509PublicCert"]
};
var C9 = {
  oneOf: [S9, w9],
  discriminator: { propertyName: "type" }
};
var k9 = {
  type: "object",
  additionalProperties: C9
};
var A9 = {
  oneOf: [
    {
      type: "array",
      items: {
        type: "string",
        enum: ["REDOCLY", "CORPORATE", "GUEST"]
      },
      uniqueItems: true
    },
    {
      type: "string",
      enum: ["REDOCLY", "CORPORATE", "GUEST"]
    }
  ]
};
var P9 = {
  type: "object",
  properties: {
    to: { type: "string" },
    type: { type: "number", default: 301 }
  },
  additionalProperties: false
};
var E9 = {
  type: "object",
  additionalProperties: P9,
  default: {}
};
var MP = {
  type: "object",
  additionalProperties: {
    oneOf: [{ type: "string" }, { type: "object" }]
  }
};
var NP = {
  type: "object",
  properties: {
    root: { type: "string" },
    output: { type: "string", pattern: "(.ya?ml|.json)$" },
    rbac: { type: "object", additionalProperties: true },
    openapi: Ff,
    graphql: Mf,
    /**
     * @deprecated left for backwards compatibility
     */
    theme: {
      type: "object",
      properties: {
        openapi: Ff,
        graphql: Mf
      },
      additionalProperties: false
    },
    title: { type: "string" },
    metadata: { type: "object", additionalProperties: true },
    rules: MP,
    decorators: { type: "object", additionalProperties: true },
    preprocessors: { type: "object", additionalProperties: true }
  },
  required: ["root"]
};
var T9 = {
  type: "object",
  additionalProperties: true
};
var I9 = {
  type: "object",
  additionalProperties: {
    type: "object",
    additionalProperties: true
  }
};
var $9 = {
  type: "object",
  properties: {
    title: { type: "string" },
    description: { type: "string" },
    siteUrl: { type: "string" },
    image: { type: "string" },
    keywords: {
      oneOf: [{ type: "array", items: { type: "string" } }, { type: "string" }]
    },
    lang: { type: "string" },
    jsonLd: { type: "object" },
    meta: {
      type: "array",
      items: {
        type: "object",
        properties: {
          name: { type: "string" },
          content: { type: "string" }
        },
        required: ["name", "content"],
        additionalProperties: false
      }
    }
  },
  additionalProperties: false
};
var Rs = {
  type: "object",
  additionalProperties: { type: "string" }
};
var j9 = {
  type: "object",
  properties: {
    teamNamePatterns: { type: "array", items: { type: "string" } },
    teamFolders: { type: "array", items: { type: "string" } },
    teamFoldersBaseRoles: Rs,
    cms: Rs,
    // deprecated in favor of reunite
    reunite: Rs,
    content: {
      type: "object",
      properties: {
        "**": Rs
      },
      additionalProperties: Rs
    }
  },
  additionalProperties: Rs
};
var R9 = {
  type: "object",
  properties: { static: { type: "string" } },
  additionalProperties: false,
  required: ["static"]
};
var D9 = {
  type: "object",
  properties: { idp: { type: "string" } },
  additionalProperties: false,
  required: ["idp"]
};
var Q9 = {
  type: "object",
  properties: {
    type: { type: "string", const: "GRAVITEE" },
    apiBaseUrl: { type: "string" },
    env: { type: "string" },
    allowApiProductsOutsideCatalog: { type: "boolean", default: false },
    stage: { type: "string", default: "non-production" },
    auth: {
      oneOf: [R9, D9]
    }
  },
  additionalProperties: false,
  required: ["type", "apiBaseUrl"]
};
var B9 = {
  type: "object",
  properties: {
    type: { type: "string", const: Wf.OAUTH2 },
    tokenEndpoint: { type: "string" },
    clientId: { type: "string" },
    clientSecret: { type: "string" }
  },
  additionalProperties: false,
  required: ["type", "tokenEndpoint", "clientId", "clientSecret"]
};
var _9 = {
  type: "object",
  properties: {
    type: { type: "string", const: Wf.SERVICE_ACCOUNT },
    serviceAccountEmail: { type: "string" },
    serviceAccountPrivateKey: { type: "string" }
  },
  additionalProperties: false,
  required: ["type", "serviceAccountEmail", "serviceAccountPrivateKey"]
};
var Pg = {
  type: "object",
  properties: {
    type: { type: "string", const: "APIGEE_X" },
    apiUrl: { type: "string" },
    stage: { type: "string", default: "non-production" },
    organizationName: { type: "string" },
    ignoreApiProducts: { type: "array", items: { type: "string" } },
    allowApiProductsOutsideCatalog: { type: "boolean", default: false },
    auth: {
      type: "object",
      oneOf: [B9, _9],
      discriminator: { propertyName: "type" }
    }
  },
  additionalProperties: false,
  required: ["type", "organizationName", "auth"]
};
var M9 = Object.assign(Object.assign({}, Pg), { properties: Object.assign(Object.assign({}, Pg.properties), { type: { type: "string", const: "APIGEE_EDGE" } }) });
var N9 = {
  type: "object",
  oneOf: [Pg, M9, Q9],
  discriminator: { propertyName: "type" }
};
var F9 = {
  type: "object",
  required: ["adapters"],
  additionalProperties: false,
  properties: {
    adapters: {
      type: "array",
      items: N9
    }
  }
};
var Hy = {
  type: "object",
  properties: {
    defaultLocale: {
      type: "string"
    },
    locales: {
      type: "array",
      items: {
        type: "object",
        properties: {
          code: {
            type: "string"
          },
          name: {
            type: "string"
          }
        },
        required: ["code"]
      }
    }
  },
  additionalProperties: false,
  required: ["defaultLocale"]
};
var Z9 = {
  type: "object",
  properties: {
    name: { type: "string" },
    value: { type: "string" }
  },
  additionalProperties: false,
  required: ["name", "value"]
};
var Eg = {
  type: "object",
  properties: {
    /**
     * @deprecated Should use `plugins` instead
     */
    imports: {
      type: "array",
      items: { type: "string" }
    },
    licenseKey: { type: "string" },
    redirects: E9,
    seo: $9,
    rbac: j9,
    requiresLogin: { type: "boolean" },
    responseHeaders: {
      type: "object",
      additionalProperties: {
        type: "array",
        items: Z9
      }
    },
    mockServer: {
      type: "object",
      properties: {
        off: { type: "boolean", default: false },
        position: { type: "string", enum: ["first", "last", "replace", "off"], default: "first" },
        strictExamples: { type: "boolean", default: false },
        errorIfForcedExampleNotFound: { type: "boolean", default: false },
        description: { type: "string" }
      }
    },
    apis: {
      type: "object",
      additionalProperties: NP
    },
    rules: MP,
    decorators: { type: "object", additionalProperties: true },
    preprocessors: { type: "object", additionalProperties: true },
    ssoDirect: k9,
    sso: A9,
    residency: { type: "string" },
    developerOnboarding: F9,
    removeAttribution: { type: "boolean" },
    i18n: Hy,
    // deprecated
    l10n: Hy,
    metadata: T9,
    metadataGlobs: I9,
    ignore: {
      type: "array",
      items: {
        type: "string"
      }
    },
    /**
     * @deprecated properties moved to the root of the config
     */
    theme: Lr,
    reunite: y9,
    // Ex theme properties
    logo: vP,
    navbar: yP,
    products: bP,
    footer: SP,
    sidebar: wP,
    scripts: CP,
    links: kP,
    feedback: ih,
    search: AP,
    colorMode: PP,
    navigation: EP,
    codeSnippet: TP,
    markdown: IP,
    openapi: Ff,
    graphql: Mf,
    analytics: jP,
    userMenu: RP,
    versionPicker: DP,
    breadcrumbs: QP,
    catalog: BP,
    scorecard: _P
  },
  default: { redirects: {} },
  additionalProperties: true
};
var W9 = Object.assign(Object.assign({}, Ag(Eg, "default")), { additionalProperties: false });
Object.assign(Object.assign({ $id: "root-redocly-config" }, Eg), { properties: Object.assign(Object.assign({ plugins: {
  type: "array",
  items: { type: "string" }
} }, Eg.properties), { env: {
  type: "object",
  additionalProperties: W9
  // TODO: if we want full validation we need to override apis, theme and the root
} }), default: {}, additionalProperties: false });
var Jy = {
  type: "object",
  properties: {
    logo: Lr.properties.logo,
    navbar: Lr.properties.navbar,
    footer: Lr.properties.footer,
    sidebar: Lr.properties.sidebar,
    search: Lr.properties.search,
    codeSnippet: Lr.properties.codeSnippet,
    breadcrumbs: Lr.properties.breadcrumbs,
    openapi: Lr.properties.openapi,
    feedback: Lr.properties.feedback,
    analytics: {
      type: "object",
      properties: {
        ga: $P
      }
    }
  },
  additionalProperties: true,
  default: {}
};
Object.assign(Object.assign({}, Jy.properties), {
  apis: {
    type: "object",
    additionalProperties: NP
  },
  /**
   * @deprecated left for backwards compatibility
   */
  theme: Jy
});
var FP = { exports: {} };
(function(t4, e) {
  (function(n, r) {
    t4.exports = r();
  })(Ze, function() {
    var n = {};
    n.version = "0.2.0";
    var r = n.settings = {
      minimum: 0.08,
      easing: "ease",
      positionUsing: "",
      speed: 200,
      trickle: true,
      trickleRate: 0.02,
      trickleSpeed: 800,
      showSpinner: true,
      barSelector: '[role="bar"]',
      spinnerSelector: '[role="spinner"]',
      parent: "body",
      template: '<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'
    };
    n.configure = function(p) {
      var O, m;
      for (O in p)
        m = p[O], m !== void 0 && p.hasOwnProperty(O) && (r[O] = m);
      return this;
    }, n.status = null, n.set = function(p) {
      var O = n.isStarted();
      p = i(p, r.minimum, 1), n.status = p === 1 ? null : p;
      var m = n.render(!O), x = m.querySelector(r.barSelector), v = r.speed, y = r.easing;
      return m.offsetWidth, a(function(S) {
        r.positionUsing === "" && (r.positionUsing = n.getPositioningCSS()), l(x, s(p, v, y)), p === 1 ? (l(m, {
          transition: "none",
          opacity: 1
        }), m.offsetWidth, setTimeout(function() {
          l(m, {
            transition: "all " + v + "ms linear",
            opacity: 0
          }), setTimeout(function() {
            n.remove(), S();
          }, v);
        }, v)) : setTimeout(S, v);
      }), this;
    }, n.isStarted = function() {
      return typeof n.status == "number";
    }, n.start = function() {
      n.status || n.set(0);
      var p = function() {
        setTimeout(function() {
          n.status && (n.trickle(), p());
        }, r.trickleSpeed);
      };
      return r.trickle && p(), this;
    }, n.done = function(p) {
      return !p && !n.status ? this : n.inc(0.3 + 0.5 * Math.random()).set(1);
    }, n.inc = function(p) {
      var O = n.status;
      return O ? (typeof p != "number" && (p = (1 - O) * i(Math.random() * O, 0.1, 0.95)), O = i(O + p, 0, 0.994), n.set(O)) : n.start();
    }, n.trickle = function() {
      return n.inc(Math.random() * r.trickleRate);
    }, function() {
      var p = 0, O = 0;
      n.promise = function(m) {
        return !m || m.state() === "resolved" ? this : (O === 0 && n.start(), p++, O++, m.always(function() {
          O--, O === 0 ? (p = 0, n.done()) : n.set((p - O) / p);
        }), this);
      };
    }(), n.render = function(p) {
      if (n.isRendered())
        return document.getElementById("nprogress");
      u(document.documentElement, "nprogress-busy");
      var O = document.createElement("div");
      O.id = "nprogress", O.innerHTML = r.template;
      var m = O.querySelector(r.barSelector), x = p ? "-100" : o(n.status || 0), v = document.querySelector(r.parent), y;
      return l(m, {
        transition: "all 0 linear",
        transform: "translate3d(" + x + "%,0,0)"
      }), r.showSpinner || (y = O.querySelector(r.spinnerSelector), y && h(y)), v != document.body && u(v, "nprogress-custom-parent"), v.appendChild(O), O;
    }, n.remove = function() {
      f(document.documentElement, "nprogress-busy"), f(document.querySelector(r.parent), "nprogress-custom-parent");
      var p = document.getElementById("nprogress");
      p && h(p);
    }, n.isRendered = function() {
      return !!document.getElementById("nprogress");
    }, n.getPositioningCSS = function() {
      var p = document.body.style, O = "WebkitTransform" in p ? "Webkit" : "MozTransform" in p ? "Moz" : "msTransform" in p ? "ms" : "OTransform" in p ? "O" : "";
      return O + "Perspective" in p ? "translate3d" : O + "Transform" in p ? "translate" : "margin";
    };
    function i(p, O, m) {
      return p < O ? O : p > m ? m : p;
    }
    function o(p) {
      return (-1 + p) * 100;
    }
    function s(p, O, m) {
      var x;
      return r.positionUsing === "translate3d" ? x = { transform: "translate3d(" + o(p) + "%,0,0)" } : r.positionUsing === "translate" ? x = { transform: "translate(" + o(p) + "%,0)" } : x = { "margin-left": o(p) + "%" }, x.transition = "all " + O + "ms " + m, x;
    }
    var a = /* @__PURE__ */ function() {
      var p = [];
      function O() {
        var m = p.shift();
        m && m(O);
      }
      return function(m) {
        p.push(m), p.length == 1 && O();
      };
    }(), l = /* @__PURE__ */ function() {
      var p = ["Webkit", "O", "Moz", "ms"], O = {};
      function m(S) {
        return S.replace(/^-ms-/, "ms-").replace(/-([\da-z])/gi, function(b, w) {
          return w.toUpperCase();
        });
      }
      function x(S) {
        var b = document.body.style;
        if (S in b)
          return S;
        for (var w = p.length, C = S.charAt(0).toUpperCase() + S.slice(1), k; w--; )
          if (k = p[w] + C, k in b)
            return k;
        return S;
      }
      function v(S) {
        return S = m(S), O[S] || (O[S] = x(S));
      }
      function y(S, b, w) {
        b = v(b), S.style[b] = w;
      }
      return function(S, b) {
        var w = arguments, C, k;
        if (w.length == 2)
          for (C in b)
            k = b[C], k !== void 0 && b.hasOwnProperty(C) && y(S, C, k);
        else
          y(S, w[1], w[2]);
      };
    }();
    function c(p, O) {
      var m = typeof p == "string" ? p : d(p);
      return m.indexOf(" " + O + " ") >= 0;
    }
    function u(p, O) {
      var m = d(p), x = m + O;
      c(m, O) || (p.className = x.substring(1));
    }
    function f(p, O) {
      var m = d(p), x;
      c(p, O) && (x = m.replace(" " + O + " ", " "), p.className = x.substring(1, x.length - 1));
    }
    function d(p) {
      return (" " + (p.className || "") + " ").replace(/\s+/gi, " ");
    }
    function h(p) {
      p && p.parentNode && p.parentNode.removeChild(p);
    }
    return n;
  });
})(FP);
var V9 = FP.exports;
var z9 = /* @__PURE__ */ Za(V9);
z9.configure({
  trickleSpeed: 100,
  template: '<div class="bar" role="bar"><div class="peg"></div></div>'
});
var Er = /* @__PURE__ */ ((t4) => (t4.Normal = "Normal", t4.Edit = "Edit", t4.Draft = "Draft", t4))(Er || {});
var Tr = /* @__PURE__ */ ((t4) => (t4.Server = "Server", t4.ServerUrl = "ServerUrl", t4.Path = "Path", t4.UserCreated = "UserCreated", t4.Security = "Security", t4))(Tr || {});
var ZP = { exports: {} };
(function(t4) {
  (function() {
    var e = {}.hasOwnProperty;
    function n() {
      for (var o = "", s = 0; s < arguments.length; s++) {
        var a = arguments[s];
        a && (o = i(o, r(a)));
      }
      return o;
    }
    function r(o) {
      if (typeof o == "string" || typeof o == "number")
        return o;
      if (typeof o != "object")
        return "";
      if (Array.isArray(o))
        return n.apply(null, o);
      if (o.toString !== Object.prototype.toString && !o.toString.toString().includes("[native code]"))
        return o.toString();
      var s = "";
      for (var a in o)
        e.call(o, a) && o[a] && (s = i(s, a));
      return s;
    }
    function i(o, s) {
      return s ? o ? o + " " + s : o + s : o;
    }
    t4.exports ? (n.default = n, t4.exports = n) : window.classNames = n;
  })();
})(ZP);
var L9 = ZP.exports;
var So = /* @__PURE__ */ Za(L9);
function X9(t4) {
  var e = t4.children, n = t4.prefixCls, r = t4.id, i = t4.overlayInnerStyle, o = t4.className, s = t4.style;
  return /* @__PURE__ */ q.createElement("div", {
    className: So("".concat(n, "-content"), o),
    style: s
  }, /* @__PURE__ */ q.createElement("div", {
    className: "".concat(n, "-inner"),
    id: r,
    role: "tooltip",
    style: i
  }, typeof e == "function" ? e() : e));
}
function Tg() {
  return Tg = Object.assign ? Object.assign.bind() : function(t4) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (t4[r] = n[r]);
    }
    return t4;
  }, Tg.apply(this, arguments);
}
function ya(t4) {
  "@babel/helpers - typeof";
  return ya = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, ya(t4);
}
function G9(t4, e) {
  if (ya(t4) != "object" || !t4)
    return t4;
  var n = t4[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(t4, e || "default");
    if (ya(r) != "object")
      return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t4);
}
function Y9(t4) {
  var e = G9(t4, "string");
  return ya(e) == "symbol" ? e : e + "";
}
function q9(t4, e, n) {
  return e = Y9(e), e in t4 ? Object.defineProperty(t4, e, {
    value: n,
    enumerable: true,
    configurable: true,
    writable: true
  }) : t4[e] = n, t4;
}
function Ky(t4, e) {
  var n = Object.keys(t4);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t4);
    e && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(t4, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Vf(t4) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Ky(Object(n), true).forEach(function(r) {
      q9(t4, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t4, Object.getOwnPropertyDescriptors(n)) : Ky(Object(n)).forEach(function(r) {
      Object.defineProperty(t4, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return t4;
}
function U9(t4, e) {
  if (t4 == null)
    return {};
  var n = {}, r = Object.keys(t4), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(e.indexOf(i) >= 0) && (n[i] = t4[i]);
  return n;
}
function H9(t4, e) {
  if (t4 == null)
    return {};
  var n = U9(t4, e), r, i;
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(t4);
    for (i = 0; i < o.length; i++)
      r = o[i], !(e.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(t4, r) && (n[r] = t4[r]);
  }
  return n;
}
function Si() {
  return !!(typeof window < "u" && window.document && window.document.createElement);
}
var Ig = {};
var ax = [];
var J9 = function(e) {
  ax.push(e);
};
function zf(t4, e) {
  if (!t4 && console !== void 0) {
    var n = ax.reduce(function(r, i) {
      return i(r ?? "", "warning");
    }, e);
    n && console.error("Warning: ".concat(n));
  }
}
function K9(t4, e) {
  if (!t4 && console !== void 0) {
    var n = ax.reduce(function(r, i) {
      return i(r ?? "", "note");
    }, e);
    n && console.warn("Note: ".concat(n));
  }
}
function eM() {
  Ig = {};
}
function WP(t4, e, n) {
  !e && !Ig[n] && (t4(false, n), Ig[n] = true);
}
function sh(t4, e) {
  WP(zf, t4, e);
}
function tM(t4, e) {
  WP(K9, t4, e);
}
sh.preMessage = J9;
sh.resetWarned = eM;
sh.noteOnce = tM;
function nM(t4, e, n) {
  var r = q.useRef({});
  return (!("value" in r.current) || n(r.current.condition, e)) && (r.current.value = t4(), r.current.condition = e), r.current.value;
}
function lx(t4, e) {
  typeof t4 == "function" ? t4(e) : ya(t4) === "object" && t4 && "current" in t4 && (t4.current = e);
}
function VP() {
  for (var t4 = arguments.length, e = new Array(t4), n = 0; n < t4; n++)
    e[n] = arguments[n];
  var r = e.filter(function(i) {
    return i;
  });
  return r.length <= 1 ? r[0] : function(i) {
    e.forEach(function(o) {
      lx(o, i);
    });
  };
}
function cx() {
  for (var t4 = arguments.length, e = new Array(t4), n = 0; n < t4; n++)
    e[n] = arguments[n];
  return nM(function() {
    return VP.apply(void 0, e);
  }, e, function(r, i) {
    return r.length !== i.length || r.every(function(o, s) {
      return o !== i[s];
    });
  });
}
function ah(t4) {
  var e, n, r = ss.isMemo(t4) ? t4.type.type : t4.type;
  return !(typeof r == "function" && !((e = r.prototype) !== null && e !== void 0 && e.render) && r.$$typeof !== ss.ForwardRef || typeof t4 == "function" && !((n = t4.prototype) !== null && n !== void 0 && n.render) && t4.$$typeof !== ss.ForwardRef);
}
var zP = /* @__PURE__ */ q.createContext(null);
var eb = Si() ? q.useLayoutEffect : q.useEffect;
var yr = function(e, n) {
  var r = q.useRef(true);
  eb(function() {
    return e(r.current);
  }, n), eb(function() {
    return r.current = false, function() {
      r.current = true;
    };
  }, []);
};
var tb = [];
function rM(t4, e) {
  var n = q.useState(function() {
    if (!Si())
      return null;
    var p = document.createElement("div");
    return e && p.setAttribute("data-debug", e), p;
  }), r = Le(n, 1), i = r[0], o = q.useRef(false), s = q.useContext(zP), a = q.useState(tb), l = Le(a, 2), c = l[0], u = l[1], f = s || (o.current ? void 0 : function(p) {
    u(function(O) {
      var m = [p].concat(xa(O));
      return m;
    });
  });
  function d() {
    i.parentElement || document.body.appendChild(i), o.current = true;
  }
  function h() {
    var p;
    (p = i.parentElement) === null || p === void 0 || p.removeChild(i), o.current = false;
  }
  return yr(function() {
    return t4 ? s ? s(d) : d() : h(), h;
  }, [t4]), yr(function() {
    c.length && (c.forEach(function(p) {
      return p();
    }), u(tb));
  }, [c]), [i, f];
}
function iM(t4, e) {
  if (!t4)
    return false;
  if (t4.contains)
    return t4.contains(e);
  for (var n = e; n; ) {
    if (n === t4)
      return true;
    n = n.parentNode;
  }
  return false;
}
var nb = "data-rc-order";
var rb = "data-rc-priority";
var oM = "rc-util-key";
var $g = /* @__PURE__ */ new Map();
function LP() {
  var t4 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, e = t4.mark;
  return e ? e.startsWith("data-") ? e : "data-".concat(e) : oM;
}
function lh(t4) {
  if (t4.attachTo)
    return t4.attachTo;
  var e = document.querySelector("head");
  return e || document.body;
}
function sM(t4) {
  return t4 === "queue" ? "prependQueue" : t4 ? "prepend" : "append";
}
function ux(t4) {
  return Array.from(($g.get(t4) || t4).children).filter(function(e) {
    return e.tagName === "STYLE";
  });
}
function XP(t4) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (!Si())
    return null;
  var n = e.csp, r = e.prepend, i = e.priority, o = i === void 0 ? 0 : i, s = sM(r), a = s === "prependQueue", l = document.createElement("style");
  l.setAttribute(nb, s), a && o && l.setAttribute(rb, "".concat(o)), n != null && n.nonce && (l.nonce = n == null ? void 0 : n.nonce), l.innerHTML = t4;
  var c = lh(e), u = c.firstChild;
  if (r) {
    if (a) {
      var f = (e.styles || ux(c)).filter(function(d) {
        if (!["prepend", "prependQueue"].includes(d.getAttribute(nb)))
          return false;
        var h = Number(d.getAttribute(rb) || 0);
        return o >= h;
      });
      if (f.length)
        return c.insertBefore(l, f[f.length - 1].nextSibling), l;
    }
    c.insertBefore(l, u);
  } else
    c.appendChild(l);
  return l;
}
function GP(t4) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = lh(e);
  return (e.styles || ux(n)).find(function(r) {
    return r.getAttribute(LP(e)) === t4;
  });
}
function jg(t4) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = GP(t4, e);
  if (n) {
    var r = lh(e);
    r.removeChild(n);
  }
}
function aM(t4, e) {
  var n = $g.get(t4);
  if (!n || !iM(document, n)) {
    var r = XP("", e), i = r.parentNode;
    $g.set(t4, i), t4.removeChild(r);
  }
}
function YP(t4, e) {
  var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, r = lh(n), i = ux(r), o = Vf(Vf({}, n), {}, {
    styles: i
  });
  aM(r, o);
  var s = GP(e, o);
  if (s) {
    var a, l;
    if ((a = o.csp) !== null && a !== void 0 && a.nonce && s.nonce !== ((l = o.csp) === null || l === void 0 ? void 0 : l.nonce)) {
      var c;
      s.nonce = (c = o.csp) === null || c === void 0 ? void 0 : c.nonce;
    }
    return s.innerHTML !== t4 && (s.innerHTML = t4), s;
  }
  var u = XP(t4, o);
  return u.setAttribute(LP(o), e), u;
}
function lM(t4) {
  var e = "rc-scrollbar-measure-".concat(Math.random().toString(36).substring(7)), n = document.createElement("div");
  n.id = e;
  var r = n.style;
  r.position = "absolute", r.left = "0", r.top = "0", r.width = "100px", r.height = "100px", r.overflow = "scroll";
  var i, o;
  if (t4) {
    var s = getComputedStyle(t4);
    r.scrollbarColor = s.scrollbarColor, r.scrollbarWidth = s.scrollbarWidth;
    var a = getComputedStyle(t4, "::-webkit-scrollbar"), l = parseInt(a.width, 10), c = parseInt(a.height, 10);
    try {
      var u = l ? "width: ".concat(a.width, ";") : "", f = c ? "height: ".concat(a.height, ";") : "";
      YP(`
#`.concat(e, `::-webkit-scrollbar {
`).concat(u, `
`).concat(f, `
}`), e);
    } catch (p) {
      console.error(p), i = l, o = c;
    }
  }
  document.body.appendChild(n);
  var d = t4 && i && !isNaN(i) ? i : n.offsetWidth - n.clientWidth, h = t4 && o && !isNaN(o) ? o : n.offsetHeight - n.clientHeight;
  return document.body.removeChild(n), jg(e), {
    width: d,
    height: h
  };
}
function cM(t4) {
  return typeof document > "u" || !t4 || !(t4 instanceof Element) ? {
    width: 0,
    height: 0
  } : lM(t4);
}
function uM() {
  return document.body.scrollHeight > (window.innerHeight || document.documentElement.clientHeight) && window.innerWidth > document.body.offsetWidth;
}
var fM = "rc-util-locker-".concat(Date.now());
var ib = 0;
function dM(t4) {
  var e = !!t4, n = q.useState(function() {
    return ib += 1, "".concat(fM, "_").concat(ib);
  }), r = Le(n, 1), i = r[0];
  yr(function() {
    if (e) {
      var o = cM(document.body).width, s = uM();
      YP(`
html body {
  overflow-y: hidden;
  `.concat(s ? "width: calc(100% - ".concat(o, "px);") : "", `
}`), i);
    } else
      jg(i);
    return function() {
      jg(i);
    };
  }, [e, i]);
}
var hM = false;
function pM(t4) {
  return hM;
}
var ob = function(e) {
  return e === false ? false : !Si() || !e ? null : typeof e == "string" ? document.querySelector(e) : typeof e == "function" ? e() : e;
};
var fx = /* @__PURE__ */ q.forwardRef(function(t4, e) {
  var n = t4.open, r = t4.autoLock, i = t4.getContainer, o = t4.debug, s = t4.autoDestroy, a = s === void 0 ? true : s, l = t4.children, c = q.useState(n), u = Le(c, 2), f = u[0], d = u[1], h = f || n;
  sh(Si() || !n, "Portal only work in client side. Please call 'useEffect' to show Portal instead default render in SSR."), q.useEffect(function() {
    (a || n) && d(n);
  }, [n, a]);
  var p = q.useState(function() {
    return ob(i);
  }), O = Le(p, 2), m = O[0], x = O[1];
  q.useEffect(function() {
    var $ = ob(i);
    x($ ?? null);
  });
  var v = rM(h && !m, o), y = Le(v, 2), S = y[0], b = y[1], w = m ?? S;
  dM(r && n && Si() && (w === S || w === document.body));
  var C = null;
  if (l && ah(l) && e) {
    var k = l;
    C = k.ref;
  }
  var T = cx(C, e);
  if (!h || !Si() || m === void 0)
    return null;
  var A = w === false || pM(), E = l;
  return e && (E = /* @__PURE__ */ q.cloneElement(l, {
    ref: T
  })), /* @__PURE__ */ q.createElement(zP.Provider, {
    value: b
  }, A ? E : /* @__PURE__ */ (0, import_react_dom.createPortal)(E, w));
});
fx.displayName = "Portal";
function Rg(t4) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = [];
  return it.Children.forEach(t4, function(r) {
    r == null && !e.keepEmpty || (Array.isArray(r) ? n = n.concat(Rg(r)) : ss.isFragment(r) && r.props ? n = n.concat(Rg(r.props.children, e)) : n.push(r));
  }), n;
}
function Lf(t4) {
  return t4 instanceof HTMLElement || t4 instanceof SVGElement;
}
function sf(t4) {
  return Lf(t4) ? t4 : t4 instanceof it.Component ? import_react_dom.default.findDOMNode(t4) : null;
}
var Dg = /* @__PURE__ */ q.createContext(null);
function gM(t4) {
  var e = t4.children, n = t4.onBatchResize, r = q.useRef(0), i = q.useRef([]), o = q.useContext(Dg), s = q.useCallback(function(a, l, c) {
    r.current += 1;
    var u = r.current;
    i.current.push({
      size: a,
      element: l,
      data: c
    }), Promise.resolve().then(function() {
      u === r.current && (n == null || n(i.current), i.current = []);
    }), o == null || o(a, l, c);
  }, [n, o]);
  return /* @__PURE__ */ q.createElement(Dg.Provider, {
    value: s
  }, e);
}
var qP = function() {
  if (typeof Map < "u")
    return Map;
  function t4(e, n) {
    var r = -1;
    return e.some(function(i, o) {
      return i[0] === n ? (r = o, true) : false;
    }), r;
  }
  return (
    /** @class */
    function() {
      function e() {
        this.__entries__ = [];
      }
      return Object.defineProperty(e.prototype, "size", {
        /**
         * @returns {boolean}
         */
        get: function() {
          return this.__entries__.length;
        },
        enumerable: true,
        configurable: true
      }), e.prototype.get = function(n) {
        var r = t4(this.__entries__, n), i = this.__entries__[r];
        return i && i[1];
      }, e.prototype.set = function(n, r) {
        var i = t4(this.__entries__, n);
        ~i ? this.__entries__[i][1] = r : this.__entries__.push([n, r]);
      }, e.prototype.delete = function(n) {
        var r = this.__entries__, i = t4(r, n);
        ~i && r.splice(i, 1);
      }, e.prototype.has = function(n) {
        return !!~t4(this.__entries__, n);
      }, e.prototype.clear = function() {
        this.__entries__.splice(0);
      }, e.prototype.forEach = function(n, r) {
        r === void 0 && (r = null);
        for (var i = 0, o = this.__entries__; i < o.length; i++) {
          var s = o[i];
          n.call(r, s[1], s[0]);
        }
      }, e;
    }()
  );
}();
var Qg = typeof window < "u" && typeof document < "u" && window.document === document;
var Xf = function() {
  return typeof global < "u" && global.Math === Math ? global : typeof self < "u" && self.Math === Math ? self : typeof window < "u" && window.Math === Math ? window : Function("return this")();
}();
var mM = function() {
  return typeof requestAnimationFrame == "function" ? requestAnimationFrame.bind(Xf) : function(t4) {
    return setTimeout(function() {
      return t4(Date.now());
    }, 1e3 / 60);
  };
}();
var OM = 2;
function xM(t4, e) {
  var n = false, r = false, i = 0;
  function o() {
    n && (n = false, t4()), r && a();
  }
  function s() {
    mM(o);
  }
  function a() {
    var l = Date.now();
    if (n) {
      if (l - i < OM)
        return;
      r = true;
    } else
      n = true, r = false, setTimeout(s, e);
    i = l;
  }
  return a;
}
var vM = 20;
var yM = ["top", "right", "bottom", "left", "width", "height", "size", "weight"];
var bM = typeof MutationObserver < "u";
var SM = (
  /** @class */
  function() {
    function t4() {
      this.connected_ = false, this.mutationEventsAdded_ = false, this.mutationsObserver_ = null, this.observers_ = [], this.onTransitionEnd_ = this.onTransitionEnd_.bind(this), this.refresh = xM(this.refresh.bind(this), vM);
    }
    return t4.prototype.addObserver = function(e) {
      ~this.observers_.indexOf(e) || this.observers_.push(e), this.connected_ || this.connect_();
    }, t4.prototype.removeObserver = function(e) {
      var n = this.observers_, r = n.indexOf(e);
      ~r && n.splice(r, 1), !n.length && this.connected_ && this.disconnect_();
    }, t4.prototype.refresh = function() {
      var e = this.updateObservers_();
      e && this.refresh();
    }, t4.prototype.updateObservers_ = function() {
      var e = this.observers_.filter(function(n) {
        return n.gatherActive(), n.hasActive();
      });
      return e.forEach(function(n) {
        return n.broadcastActive();
      }), e.length > 0;
    }, t4.prototype.connect_ = function() {
      !Qg || this.connected_ || (document.addEventListener("transitionend", this.onTransitionEnd_), window.addEventListener("resize", this.refresh), bM ? (this.mutationsObserver_ = new MutationObserver(this.refresh), this.mutationsObserver_.observe(document, {
        attributes: true,
        childList: true,
        characterData: true,
        subtree: true
      })) : (document.addEventListener("DOMSubtreeModified", this.refresh), this.mutationEventsAdded_ = true), this.connected_ = true);
    }, t4.prototype.disconnect_ = function() {
      !Qg || !this.connected_ || (document.removeEventListener("transitionend", this.onTransitionEnd_), window.removeEventListener("resize", this.refresh), this.mutationsObserver_ && this.mutationsObserver_.disconnect(), this.mutationEventsAdded_ && document.removeEventListener("DOMSubtreeModified", this.refresh), this.mutationsObserver_ = null, this.mutationEventsAdded_ = false, this.connected_ = false);
    }, t4.prototype.onTransitionEnd_ = function(e) {
      var n = e.propertyName, r = n === void 0 ? "" : n, i = yM.some(function(o) {
        return !!~r.indexOf(o);
      });
      i && this.refresh();
    }, t4.getInstance = function() {
      return this.instance_ || (this.instance_ = new t4()), this.instance_;
    }, t4.instance_ = null, t4;
  }()
);
var UP = function(t4, e) {
  for (var n = 0, r = Object.keys(e); n < r.length; n++) {
    var i = r[n];
    Object.defineProperty(t4, i, {
      value: e[i],
      enumerable: false,
      writable: false,
      configurable: true
    });
  }
  return t4;
};
var ba = function(t4) {
  var e = t4 && t4.ownerDocument && t4.ownerDocument.defaultView;
  return e || Xf;
};
var HP = ch(0, 0, 0, 0);
function Gf(t4) {
  return parseFloat(t4) || 0;
}
function sb(t4) {
  for (var e = [], n = 1; n < arguments.length; n++)
    e[n - 1] = arguments[n];
  return e.reduce(function(r, i) {
    var o = t4["border-" + i + "-width"];
    return r + Gf(o);
  }, 0);
}
function wM(t4) {
  for (var e = ["top", "right", "bottom", "left"], n = {}, r = 0, i = e; r < i.length; r++) {
    var o = i[r], s = t4["padding-" + o];
    n[o] = Gf(s);
  }
  return n;
}
function CM(t4) {
  var e = t4.getBBox();
  return ch(0, 0, e.width, e.height);
}
function kM(t4) {
  var e = t4.clientWidth, n = t4.clientHeight;
  if (!e && !n)
    return HP;
  var r = ba(t4).getComputedStyle(t4), i = wM(r), o = i.left + i.right, s = i.top + i.bottom, a = Gf(r.width), l = Gf(r.height);
  if (r.boxSizing === "border-box" && (Math.round(a + o) !== e && (a -= sb(r, "left", "right") + o), Math.round(l + s) !== n && (l -= sb(r, "top", "bottom") + s)), !PM(t4)) {
    var c = Math.round(a + o) - e, u = Math.round(l + s) - n;
    Math.abs(c) !== 1 && (a -= c), Math.abs(u) !== 1 && (l -= u);
  }
  return ch(i.left, i.top, a, l);
}
var AM = /* @__PURE__ */ function() {
  return typeof SVGGraphicsElement < "u" ? function(t4) {
    return t4 instanceof ba(t4).SVGGraphicsElement;
  } : function(t4) {
    return t4 instanceof ba(t4).SVGElement && typeof t4.getBBox == "function";
  };
}();
function PM(t4) {
  return t4 === ba(t4).document.documentElement;
}
function EM(t4) {
  return Qg ? AM(t4) ? CM(t4) : kM(t4) : HP;
}
function TM(t4) {
  var e = t4.x, n = t4.y, r = t4.width, i = t4.height, o = typeof DOMRectReadOnly < "u" ? DOMRectReadOnly : Object, s = Object.create(o.prototype);
  return UP(s, {
    x: e,
    y: n,
    width: r,
    height: i,
    top: n,
    right: e + r,
    bottom: i + n,
    left: e
  }), s;
}
function ch(t4, e, n, r) {
  return { x: t4, y: e, width: n, height: r };
}
var IM = (
  /** @class */
  function() {
    function t4(e) {
      this.broadcastWidth = 0, this.broadcastHeight = 0, this.contentRect_ = ch(0, 0, 0, 0), this.target = e;
    }
    return t4.prototype.isActive = function() {
      var e = EM(this.target);
      return this.contentRect_ = e, e.width !== this.broadcastWidth || e.height !== this.broadcastHeight;
    }, t4.prototype.broadcastRect = function() {
      var e = this.contentRect_;
      return this.broadcastWidth = e.width, this.broadcastHeight = e.height, e;
    }, t4;
  }()
);
var $M = (
  /** @class */
  /* @__PURE__ */ function() {
    function t4(e, n) {
      var r = TM(n);
      UP(this, { target: e, contentRect: r });
    }
    return t4;
  }()
);
var jM = (
  /** @class */
  function() {
    function t4(e, n, r) {
      if (this.activeObservations_ = [], this.observations_ = new qP(), typeof e != "function")
        throw new TypeError("The callback provided as parameter 1 is not a function.");
      this.callback_ = e, this.controller_ = n, this.callbackCtx_ = r;
    }
    return t4.prototype.observe = function(e) {
      if (!arguments.length)
        throw new TypeError("1 argument required, but only 0 present.");
      if (!(typeof Element > "u" || !(Element instanceof Object))) {
        if (!(e instanceof ba(e).Element))
          throw new TypeError('parameter 1 is not of type "Element".');
        var n = this.observations_;
        n.has(e) || (n.set(e, new IM(e)), this.controller_.addObserver(this), this.controller_.refresh());
      }
    }, t4.prototype.unobserve = function(e) {
      if (!arguments.length)
        throw new TypeError("1 argument required, but only 0 present.");
      if (!(typeof Element > "u" || !(Element instanceof Object))) {
        if (!(e instanceof ba(e).Element))
          throw new TypeError('parameter 1 is not of type "Element".');
        var n = this.observations_;
        n.has(e) && (n.delete(e), n.size || this.controller_.removeObserver(this));
      }
    }, t4.prototype.disconnect = function() {
      this.clearActive(), this.observations_.clear(), this.controller_.removeObserver(this);
    }, t4.prototype.gatherActive = function() {
      var e = this;
      this.clearActive(), this.observations_.forEach(function(n) {
        n.isActive() && e.activeObservations_.push(n);
      });
    }, t4.prototype.broadcastActive = function() {
      if (this.hasActive()) {
        var e = this.callbackCtx_, n = this.activeObservations_.map(function(r) {
          return new $M(r.target, r.broadcastRect());
        });
        this.callback_.call(e, n, e), this.clearActive();
      }
    }, t4.prototype.clearActive = function() {
      this.activeObservations_.splice(0);
    }, t4.prototype.hasActive = function() {
      return this.activeObservations_.length > 0;
    }, t4;
  }()
);
var JP = typeof WeakMap < "u" ? /* @__PURE__ */ new WeakMap() : new qP();
var KP = (
  /** @class */
  /* @__PURE__ */ function() {
    function t4(e) {
      if (!(this instanceof t4))
        throw new TypeError("Cannot call a class as a function.");
      if (!arguments.length)
        throw new TypeError("1 argument required, but only 0 present.");
      var n = SM.getInstance(), r = new jM(e, n, this);
      JP.set(this, r);
    }
    return t4;
  }()
);
[
  "observe",
  "unobserve",
  "disconnect"
].forEach(function(t4) {
  KP.prototype[t4] = function() {
    var e;
    return (e = JP.get(this))[t4].apply(e, arguments);
  };
});
var RM = function() {
  return typeof Xf.ResizeObserver < "u" ? Xf.ResizeObserver : KP;
}();
var Li = /* @__PURE__ */ new Map();
function e2(t4) {
  t4.forEach(function(e) {
    var n, r = e.target;
    (n = Li.get(r)) === null || n === void 0 || n.forEach(function(i) {
      return i(r);
    });
  });
}
var t2 = new RM(e2);
function DM(t4, e) {
  Li.has(t4) || (Li.set(t4, /* @__PURE__ */ new Set()), t2.observe(t4)), Li.get(t4).add(e);
}
function QM(t4, e) {
  Li.has(t4) && (Li.get(t4).delete(e), Li.get(t4).size || (t2.unobserve(t4), Li.delete(t4)));
}
var BM = /* @__PURE__ */ function(t4) {
  Hd(n, t4);
  var e = Jd(n);
  function n() {
    return qd(this, n), e.apply(this, arguments);
  }
  return Ud(n, [{
    key: "render",
    value: function() {
      return this.props.children;
    }
  }]), n;
}(q.Component);
function _M(t4, e) {
  var n = t4.children, r = t4.disabled, i = q.useRef(null), o = q.useRef(null), s = q.useContext(Dg), a = typeof n == "function", l = a ? n(i) : n, c = q.useRef({
    width: -1,
    height: -1,
    offsetWidth: -1,
    offsetHeight: -1
  }), u = !a && /* @__PURE__ */ q.isValidElement(l) && ah(l), f = u ? l.ref : null, d = cx(f, i), h = function() {
    var x;
    return sf(i.current) || // Support `nativeElement` format
    (i.current && Hr(i.current) === "object" ? sf((x = i.current) === null || x === void 0 ? void 0 : x.nativeElement) : null) || sf(o.current);
  };
  q.useImperativeHandle(e, function() {
    return h();
  });
  var p = q.useRef(t4);
  p.current = t4;
  var O = q.useCallback(function(m) {
    var x = p.current, v = x.onResize, y = x.data, S = m.getBoundingClientRect(), b = S.width, w = S.height, C = m.offsetWidth, k = m.offsetHeight, T = Math.floor(b), A = Math.floor(w);
    if (c.current.width !== T || c.current.height !== A || c.current.offsetWidth !== C || c.current.offsetHeight !== k) {
      var E = {
        width: T,
        height: A,
        offsetWidth: C,
        offsetHeight: k
      };
      c.current = E;
      var $ = C === Math.round(b) ? b : C, j = k === Math.round(w) ? w : k, B = se(se({}, E), {}, {
        offsetWidth: $,
        offsetHeight: j
      });
      s == null || s(B, m, y), v && Promise.resolve().then(function() {
        v(B, m);
      });
    }
  }, []);
  return q.useEffect(function() {
    var m = h();
    return m && !r && DM(m, O), function() {
      return QM(m, O);
    };
  }, [i.current, r]), /* @__PURE__ */ q.createElement(BM, {
    ref: o
  }, u ? /* @__PURE__ */ q.cloneElement(l, {
    ref: d
  }) : l);
}
var n2 = /* @__PURE__ */ q.forwardRef(_M);
n2.displayName = "SingleObserver";
var MM = "rc-observer-key";
function NM(t4, e) {
  var n = t4.children, r = typeof n == "function" ? [n] : Rg(n);
  return r.length > 1 ? zf(false, "Find more than one child node with `children` in ResizeObserver. Please use ResizeObserver.Collection instead.") : r.length === 0 && zf(false, "`children` of ResizeObserver is empty. Nothing is in observe."), r.map(function(i, o) {
    var s = (i == null ? void 0 : i.key) || "".concat(MM, "-").concat(o);
    return /* @__PURE__ */ q.createElement(n2, Ae({}, t4, {
      key: s,
      ref: o === 0 ? e : void 0
    }), i);
  });
}
var uh = /* @__PURE__ */ q.forwardRef(NM);
uh.displayName = "ResizeObserver";
uh.Collection = gM;
function r2(t4) {
  var e;
  return t4 == null || (e = t4.getRootNode) === null || e === void 0 ? void 0 : e.call(t4);
}
function FM(t4) {
  return r2(t4) instanceof ShadowRoot;
}
function Bg(t4) {
  return FM(t4) ? r2(t4) : null;
}
function Jo(t4) {
  var e = q.useRef();
  e.current = t4;
  var n = q.useCallback(function() {
    for (var r, i = arguments.length, o = new Array(i), s = 0; s < i; s++)
      o[s] = arguments[s];
    return (r = e.current) === null || r === void 0 ? void 0 : r.call.apply(r, [e].concat(o));
  }, []);
  return n;
}
function ZM(t4) {
  if (Array.isArray(t4))
    return t4;
}
function WM(t4, e) {
  var n = t4 == null ? null : typeof Symbol < "u" && t4[Symbol.iterator] || t4["@@iterator"];
  if (n != null) {
    var r, i, o, s, a = [], l = true, c = false;
    try {
      if (o = (n = n.call(t4)).next, e !== 0)
        for (; !(l = (r = o.call(n)).done) && (a.push(r.value), a.length !== e); l = true)
          ;
    } catch (u) {
      c = true, i = u;
    } finally {
      try {
        if (!l && n.return != null && (s = n.return(), Object(s) !== s))
          return;
      } finally {
        if (c)
          throw i;
      }
    }
    return a;
  }
}
function ab(t4, e) {
  (e == null || e > t4.length) && (e = t4.length);
  for (var n = 0, r = new Array(e); n < e; n++)
    r[n] = t4[n];
  return r;
}
function VM(t4, e) {
  if (t4) {
    if (typeof t4 == "string")
      return ab(t4, e);
    var n = Object.prototype.toString.call(t4).slice(8, -1);
    if (n === "Object" && t4.constructor && (n = t4.constructor.name), n === "Map" || n === "Set")
      return Array.from(t4);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return ab(t4, e);
  }
}
function zM() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function i2(t4, e) {
  return ZM(t4) || WM(t4, e) || VM(t4, e) || zM();
}
function LM() {
  var t4 = Vf({}, q);
  return t4.useId;
}
var lb = 0;
var cb = LM();
var XM = cb ? (
  // Use React `useId`
  function(e) {
    var n = cb();
    return e || (false ? "test-id" : n);
  }
) : (
  // Use compatible of `useId`
  function(e) {
    var n = q.useState("ssr-id"), r = i2(n, 2), i = r[0], o = r[1];
    return q.useEffect(function() {
      var s = lb;
      lb += 1, o("rc_unique_".concat(s));
    }, []), e || (false ? "test-id" : i);
  }
);
var GM = function() {
  if (typeof navigator > "u" || typeof window > "u")
    return false;
  var t4 = navigator.userAgent || navigator.vendor || window.opera;
  return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(t4) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(t4 == null ? void 0 : t4.substr(0, 4));
};
var YM = /* @__PURE__ */ q.createContext({});
var qM = /* @__PURE__ */ function(t4) {
  Hd(n, t4);
  var e = Jd(n);
  function n() {
    return qd(this, n), e.apply(this, arguments);
  }
  return Ud(n, [{
    key: "render",
    value: function() {
      return this.props.children;
    }
  }]), n;
}(q.Component);
function af(t4) {
  var e = q.useRef(false), n = q.useState(t4), r = i2(n, 2), i = r[0], o = r[1];
  q.useEffect(function() {
    return e.current = false, function() {
      e.current = true;
    };
  }, []);
  function s(a, l) {
    l && e.current || o(a);
  }
  return [i, s];
}
var Ko = "none";
var Ou = "appear";
var xu = "enter";
var vu = "leave";
var ub = "none";
var Xr = "prepare";
var Gs = "start";
var Ys = "active";
var dx = "end";
var o2 = "prepared";
function fb(t4, e) {
  var n = {};
  return n[t4.toLowerCase()] = e.toLowerCase(), n["Webkit".concat(t4)] = "webkit".concat(e), n["Moz".concat(t4)] = "moz".concat(e), n["ms".concat(t4)] = "MS".concat(e), n["O".concat(t4)] = "o".concat(e.toLowerCase()), n;
}
function UM(t4, e) {
  var n = {
    animationend: fb("Animation", "AnimationEnd"),
    transitionend: fb("Transition", "TransitionEnd")
  };
  return t4 && ("AnimationEvent" in e || delete n.animationend.animation, "TransitionEvent" in e || delete n.transitionend.transition), n;
}
var HM = UM(Si(), typeof window < "u" ? window : {});
var s2 = {};
if (Si()) {
  JM = document.createElement("div");
  s2 = JM.style;
}
var JM;
var yu = {};
function a2(t4) {
  if (yu[t4])
    return yu[t4];
  var e = HM[t4];
  if (e)
    for (var n = Object.keys(e), r = n.length, i = 0; i < r; i += 1) {
      var o = n[i];
      if (Object.prototype.hasOwnProperty.call(e, o) && o in s2)
        return yu[t4] = e[o], yu[t4];
    }
  return "";
}
var l2 = a2("animationend");
var c2 = a2("transitionend");
var u2 = !!(l2 && c2);
var db = l2 || "animationend";
var hb = c2 || "transitionend";
function pb(t4, e) {
  if (!t4)
    return null;
  if (Hr(t4) === "object") {
    var n = e.replace(/-\w/g, function(r) {
      return r[1].toUpperCase();
    });
    return t4[n];
  }
  return "".concat(t4, "-").concat(e);
}
var KM = function(t4) {
  var e = Ke(), n = Ke(t4);
  n.current = t4;
  var r = q.useCallback(function(s) {
    n.current(s);
  }, []);
  function i(s) {
    s && (s.removeEventListener(hb, r), s.removeEventListener(db, r));
  }
  function o(s) {
    e.current && e.current !== s && i(e.current), s && s !== e.current && (s.addEventListener(hb, r), s.addEventListener(db, r), e.current = s);
  }
  return q.useEffect(function() {
    return function() {
      i(e.current);
    };
  }, []), [o, i];
};
var f2 = Si() ? qk : _e;
var d2 = function(e) {
  return +setTimeout(e, 16);
};
var h2 = function(e) {
  return clearTimeout(e);
};
typeof window < "u" && "requestAnimationFrame" in window && (d2 = function(e) {
  return window.requestAnimationFrame(e);
}, h2 = function(e) {
  return window.cancelAnimationFrame(e);
});
var gb = 0;
var fh = /* @__PURE__ */ new Map();
function p2(t4) {
  fh.delete(t4);
}
var Yf = function(e) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
  gb += 1;
  var r = gb;
  function i(o) {
    if (o === 0)
      p2(r), e();
    else {
      var s = d2(function() {
        i(o - 1);
      });
      fh.set(r, s);
    }
  }
  return i(n), r;
};
Yf.cancel = function(t4) {
  var e = fh.get(t4);
  return p2(t4), h2(e);
};
Yf.ids = function() {
  return fh;
};
var e8 = function() {
  var t4 = q.useRef(null);
  function e() {
    Yf.cancel(t4.current);
  }
  function n(r) {
    var i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2;
    e();
    var o = Yf(function() {
      i <= 1 ? r({
        isCanceled: function() {
          return o !== t4.current;
        }
      }) : n(r, i - 1);
    });
    t4.current = o;
  }
  return q.useEffect(function() {
    return function() {
      e();
    };
  }, []), [n, e];
};
var t8 = [Xr, Gs, Ys, dx];
var n8 = [Xr, o2];
var g2 = false;
var r8 = true;
function m2(t4) {
  return t4 === Ys || t4 === dx;
}
var i8 = function(t4, e, n) {
  var r = af(ub), i = Le(r, 2), o = i[0], s = i[1], a = e8(), l = Le(a, 2), c = l[0], u = l[1];
  function f() {
    s(Xr, true);
  }
  var d = e ? n8 : t8;
  return f2(function() {
    if (o !== ub && o !== dx) {
      var h = d.indexOf(o), p = d[h + 1], O = n(o);
      O === g2 ? s(p, true) : p && c(function(m) {
        function x() {
          m.isCanceled() || s(p, true);
        }
        O === true ? x() : Promise.resolve(O).then(x);
      });
    }
  }, [t4, o]), q.useEffect(function() {
    return function() {
      u();
    };
  }, []), [f, o];
};
function o8(t4, e, n, r) {
  var i = r.motionEnter, o = i === void 0 ? true : i, s = r.motionAppear, a = s === void 0 ? true : s, l = r.motionLeave, c = l === void 0 ? true : l, u = r.motionDeadline, f = r.motionLeaveImmediately, d = r.onAppearPrepare, h = r.onEnterPrepare, p = r.onLeavePrepare, O = r.onAppearStart, m = r.onEnterStart, x = r.onLeaveStart, v = r.onAppearActive, y = r.onEnterActive, S = r.onLeaveActive, b = r.onAppearEnd, w = r.onEnterEnd, C = r.onLeaveEnd, k = r.onVisibleChanged, T = af(), A = Le(T, 2), E = A[0], $ = A[1], j = af(Ko), B = Le(j, 2), D = B[0], N = B[1], z = af(null), Z = Le(z, 2), J = Z[0], L = Z[1], W = Ke(false), R = Ke(null);
  function Q() {
    return n();
  }
  var _ = Ke(false);
  function G() {
    N(Ko, true), L(null, true);
  }
  function M(ye) {
    var Ee = Q();
    if (!(ye && !ye.deadline && ye.target !== Ee)) {
      var $e = _.current, Ge;
      D === Ou && $e ? Ge = b == null ? void 0 : b(Ee, ye) : D === xu && $e ? Ge = w == null ? void 0 : w(Ee, ye) : D === vu && $e && (Ge = C == null ? void 0 : C(Ee, ye)), D !== Ko && $e && Ge !== false && G();
    }
  }
  var K = KM(M), V = Le(K, 1), ae = V[0], te = function(Ee) {
    var $e, Ge, Je;
    switch (Ee) {
      case Ou:
        return $e = {}, cn($e, Xr, d), cn($e, Gs, O), cn($e, Ys, v), $e;
      case xu:
        return Ge = {}, cn(Ge, Xr, h), cn(Ge, Gs, m), cn(Ge, Ys, y), Ge;
      case vu:
        return Je = {}, cn(Je, Xr, p), cn(Je, Gs, x), cn(Je, Ys, S), Je;
      default:
        return {};
    }
  }, oe = q.useMemo(function() {
    return te(D);
  }, [D]), Y = i8(D, !t4, function(ye) {
    if (ye === Xr) {
      var Ee = oe[Xr];
      return Ee ? Ee(Q()) : g2;
    }
    if (ee in oe) {
      var $e;
      L((($e = oe[ee]) === null || $e === void 0 ? void 0 : $e.call(oe, Q(), null)) || null);
    }
    return ee === Ys && (ae(Q()), u > 0 && (clearTimeout(R.current), R.current = setTimeout(function() {
      M({
        deadline: true
      });
    }, u))), ee === o2 && G(), r8;
  }), he = Le(Y, 2), X = he[0], ee = he[1], de = m2(ee);
  _.current = de, f2(function() {
    $(e);
    var ye = W.current;
    W.current = true;
    var Ee;
    !ye && e && a && (Ee = Ou), ye && e && o && (Ee = xu), (ye && !e && c || !ye && f && !e && c) && (Ee = vu);
    var $e = te(Ee);
    Ee && (t4 || $e[Xr]) ? (N(Ee), X()) : N(Ko);
  }, [e]), _e(function() {
    (D === Ou && !a || // Cancel enter
    D === xu && !o || // Cancel leave
    D === vu && !c) && N(Ko);
  }, [a, o, c]), _e(function() {
    return function() {
      W.current = false, clearTimeout(R.current);
    };
  }, []);
  var ve = q.useRef(false);
  _e(function() {
    E && (ve.current = true), E !== void 0 && D === Ko && ((ve.current || E) && (k == null || k(E)), ve.current = true);
  }, [E, D]);
  var Re = J;
  return oe[Xr] && ee === Gs && (Re = se({
    transition: "none"
  }, Re)), [D, ee, Re, E ?? e];
}
function s8(t4) {
  var e = t4;
  Hr(t4) === "object" && (e = t4.transitionSupport);
  function n(i, o) {
    return !!(i.motionName && e && o !== false);
  }
  var r = /* @__PURE__ */ q.forwardRef(function(i, o) {
    var s = i.visible, a = s === void 0 ? true : s, l = i.removeOnLeave, c = l === void 0 ? true : l, u = i.forceRender, f = i.children, d = i.motionName, h = i.leavedClassName, p = i.eventProps, O = q.useContext(YM), m = O.motion, x = n(i, m), v = Ke(), y = Ke();
    function S() {
      try {
        return v.current instanceof HTMLElement ? v.current : sf(y.current);
      } catch {
        return null;
      }
    }
    var b = o8(x, a, S, i), w = Le(b, 4), C = w[0], k = w[1], T = w[2], A = w[3], E = q.useRef(A);
    A && (E.current = true);
    var $ = q.useCallback(function(L) {
      v.current = L, lx(o, L);
    }, [o]), j, B = se(se({}, p), {}, {
      visible: a
    });
    if (!f)
      j = null;
    else if (C === Ko)
      A ? j = f(se({}, B), $) : !c && E.current && h ? j = f(se(se({}, B), {}, {
        className: h
      }), $) : u || !c && !h ? j = f(se(se({}, B), {}, {
        style: {
          display: "none"
        }
      }), $) : j = null;
    else {
      var D, N;
      k === Xr ? N = "prepare" : m2(k) ? N = "active" : k === Gs && (N = "start");
      var z = pb(d, "".concat(C, "-").concat(N));
      j = f(se(se({}, B), {}, {
        className: So(pb(d, C), (D = {}, cn(D, z, z && N), cn(D, d, typeof d == "string"), D)),
        style: T
      }), $);
    }
    if (/* @__PURE__ */ q.isValidElement(j) && ah(j)) {
      var Z = j, J = Z.ref;
      J || (j = /* @__PURE__ */ q.cloneElement(j, {
        ref: $
      }));
    }
    return /* @__PURE__ */ q.createElement(qM, {
      ref: y
    }, j);
  });
  return r.displayName = "CSSMotion", r;
}
var hx = s8(u2);
var _g = "add";
var Mg = "keep";
var Ng = "remove";
var gp = "removed";
function a8(t4) {
  var e;
  return t4 && Hr(t4) === "object" && "key" in t4 ? e = t4 : e = {
    key: t4
  }, se(se({}, e), {}, {
    key: String(e.key)
  });
}
function Fg() {
  var t4 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  return t4.map(a8);
}
function l8() {
  var t4 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], n = [], r = 0, i = e.length, o = Fg(t4), s = Fg(e);
  o.forEach(function(c) {
    for (var u = false, f = r; f < i; f += 1) {
      var d = s[f];
      if (d.key === c.key) {
        r < f && (n = n.concat(s.slice(r, f).map(function(h) {
          return se(se({}, h), {}, {
            status: _g
          });
        })), r = f), n.push(se(se({}, d), {}, {
          status: Mg
        })), r += 1, u = true;
        break;
      }
    }
    u || n.push(se(se({}, c), {}, {
      status: Ng
    }));
  }), r < i && (n = n.concat(s.slice(r).map(function(c) {
    return se(se({}, c), {}, {
      status: _g
    });
  })));
  var a = {};
  n.forEach(function(c) {
    var u = c.key;
    a[u] = (a[u] || 0) + 1;
  });
  var l = Object.keys(a).filter(function(c) {
    return a[c] > 1;
  });
  return l.forEach(function(c) {
    n = n.filter(function(u) {
      var f = u.key, d = u.status;
      return f !== c || d !== Ng;
    }), n.forEach(function(u) {
      u.key === c && (u.status = Mg);
    });
  }), n;
}
var c8 = ["component", "children", "onVisibleChanged", "onAllRemoved"];
var u8 = ["status"];
var f8 = ["eventProps", "visible", "children", "motionName", "motionAppear", "motionEnter", "motionLeave", "motionLeaveImmediately", "motionDeadline", "removeOnLeave", "leavedClassName", "onAppearPrepare", "onAppearStart", "onAppearActive", "onAppearEnd", "onEnterStart", "onEnterActive", "onEnterEnd", "onLeaveStart", "onLeaveActive", "onLeaveEnd"];
function d8(t4) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : hx, n = /* @__PURE__ */ function(r) {
    Hd(o, r);
    var i = Jd(o);
    function o() {
      var s;
      qd(this, o);
      for (var a = arguments.length, l = new Array(a), c = 0; c < a; c++)
        l[c] = arguments[c];
      return s = i.call.apply(i, [this].concat(l)), cn(xg(s), "state", {
        keyEntities: []
      }), cn(xg(s), "removeKey", function(u) {
        var f = s.state.keyEntities, d = f.map(function(h) {
          return h.key !== u ? h : se(se({}, h), {}, {
            status: gp
          });
        });
        return s.setState({
          keyEntities: d
        }), d.filter(function(h) {
          var p = h.status;
          return p !== gp;
        }).length;
      }), s;
    }
    return Ud(o, [{
      key: "render",
      value: function() {
        var a = this, l = this.state.keyEntities, c = this.props, u = c.component, f = c.children, d = c.onVisibleChanged, h = c.onAllRemoved, p = Mr(c, c8), O = u || q.Fragment, m = {};
        return f8.forEach(function(x) {
          m[x] = p[x], delete p[x];
        }), delete p.keys, /* @__PURE__ */ q.createElement(O, p, l.map(function(x, v) {
          var y = x.status, S = Mr(x, u8), b = y === _g || y === Mg;
          return /* @__PURE__ */ q.createElement(e, Ae({}, m, {
            key: S.key,
            visible: b,
            eventProps: S,
            onVisibleChanged: function(C) {
              if (d == null || d(C, {
                key: S.key
              }), !C) {
                var k = a.removeKey(S.key);
                k === 0 && h && h();
              }
            }
          }), function(w, C) {
            return f(se(se({}, w), {}, {
              index: v
            }), C);
          });
        }));
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function(a, l) {
        var c = a.keys, u = l.keyEntities, f = Fg(c), d = l8(u, f);
        return {
          keyEntities: d.filter(function(h) {
            var p = u.find(function(O) {
              var m = O.key;
              return h.key === m;
            });
            return !(p && p.status === gp && h.status === Ng);
          })
        };
      }
    }]), o;
  }(q.Component);
  return cn(n, "defaultProps", {
    component: "div"
  }), n;
}
d8(u2);
function h8(t4) {
  var e = t4.prefixCls, n = t4.align, r = t4.arrow, i = t4.arrowPos, o = r || {}, s = o.className, a = o.content, l = i.x, c = l === void 0 ? 0 : l, u = i.y, f = u === void 0 ? 0 : u, d = q.useRef();
  if (!n || !n.points)
    return null;
  var h = {
    position: "absolute"
  };
  if (n.autoArrow !== false) {
    var p = n.points[0], O = n.points[1], m = p[0], x = p[1], v = O[0], y = O[1];
    m === v || !["t", "b"].includes(m) ? h.top = f : m === "t" ? h.top = 0 : h.bottom = 0, x === y || !["l", "r"].includes(x) ? h.left = c : x === "l" ? h.left = 0 : h.right = 0;
  }
  return /* @__PURE__ */ q.createElement("div", {
    ref: d,
    className: So("".concat(e, "-arrow"), s),
    style: h
  }, a);
}
function p8(t4) {
  var e = t4.prefixCls, n = t4.open, r = t4.zIndex, i = t4.mask, o = t4.motion;
  return i ? /* @__PURE__ */ q.createElement(hx, Ae({}, o, {
    motionAppear: true,
    visible: n,
    removeOnLeave: true
  }), function(s) {
    var a = s.className;
    return /* @__PURE__ */ q.createElement("div", {
      style: {
        zIndex: r
      },
      className: So("".concat(e, "-mask"), a)
    });
  }) : null;
}
var O2 = /* @__PURE__ */ q.memo(function(t4) {
  var e = t4.children;
  return e;
}, function(t4, e) {
  return e.cache;
});
O2.displayName = "PopupContent";
var x2 = /* @__PURE__ */ q.forwardRef(function(t4, e) {
  var n = t4.popup, r = t4.className, i = t4.prefixCls, o = t4.style, s = t4.target, a = t4.onVisibleChanged, l = t4.open, c = t4.keepDom, u = t4.fresh, f = t4.onClick, d = t4.mask, h = t4.arrow, p = t4.arrowPos, O = t4.align, m = t4.motion, x = t4.maskMotion, v = t4.forceRender, y = t4.getPopupContainer, S = t4.autoDestroy, b = t4.portal, w = t4.zIndex, C = t4.onMouseEnter, k = t4.onMouseLeave, T = t4.onPointerEnter, A = t4.ready, E = t4.offsetX, $ = t4.offsetY, j = t4.offsetR, B = t4.offsetB, D = t4.onAlign, N = t4.onPrepare, z = t4.stretch, Z = t4.targetWidth, J = t4.targetHeight, L = typeof n == "function" ? n() : n, W = l || c, R = (y == null ? void 0 : y.length) > 0, Q = q.useState(!y || !R), _ = Le(Q, 2), G = _[0], M = _[1];
  if (yr(function() {
    !G && R && s && M(true);
  }, [G, R, s]), !G)
    return null;
  var K = "auto", V = {
    left: "-1000vw",
    top: "-1000vh",
    right: K,
    bottom: K
  };
  if (A || !l) {
    var ae, te = O.points, oe = O.dynamicInset || ((ae = O._experimental) === null || ae === void 0 ? void 0 : ae.dynamicInset), Y = oe && te[0][1] === "r", he = oe && te[0][0] === "b";
    Y ? (V.right = j, V.left = K) : (V.left = E, V.right = K), he ? (V.bottom = B, V.top = K) : (V.top = $, V.bottom = K);
  }
  var X = {};
  return z && (z.includes("height") && J ? X.height = J : z.includes("minHeight") && J && (X.minHeight = J), z.includes("width") && Z ? X.width = Z : z.includes("minWidth") && Z && (X.minWidth = Z)), l || (X.pointerEvents = "none"), /* @__PURE__ */ q.createElement(b, {
    open: v || W,
    getContainer: y && function() {
      return y(s);
    },
    autoDestroy: S
  }, /* @__PURE__ */ q.createElement(p8, {
    prefixCls: i,
    open: l,
    zIndex: w,
    mask: d,
    motion: x
  }), /* @__PURE__ */ q.createElement(uh, {
    onResize: D,
    disabled: !l
  }, function(ee) {
    return /* @__PURE__ */ q.createElement(hx, Ae({
      motionAppear: true,
      motionEnter: true,
      motionLeave: true,
      removeOnLeave: false,
      forceRender: v,
      leavedClassName: "".concat(i, "-hidden")
    }, m, {
      onAppearPrepare: N,
      onEnterPrepare: N,
      visible: l,
      onVisibleChanged: function(ve) {
        var Re;
        m == null || (Re = m.onVisibleChanged) === null || Re === void 0 || Re.call(m, ve), a(ve);
      }
    }), function(de, ve) {
      var Re = de.className, ye = de.style, Ee = So(i, Re, r);
      return /* @__PURE__ */ q.createElement("div", {
        ref: VP(ee, e, ve),
        className: Ee,
        style: se(se(se(se({
          "--arrow-x": "".concat(p.x || 0, "px"),
          "--arrow-y": "".concat(p.y || 0, "px")
        }, V), X), ye), {}, {
          boxSizing: "border-box",
          zIndex: w
        }, o),
        onMouseEnter: C,
        onMouseLeave: k,
        onPointerEnter: T,
        onClick: f
      }, h && /* @__PURE__ */ q.createElement(h8, {
        prefixCls: i,
        arrow: h,
        arrowPos: p,
        align: O
      }), /* @__PURE__ */ q.createElement(O2, {
        cache: !l && !u
      }, L));
    });
  }));
});
x2.displayName = "Popup";
var v2 = /* @__PURE__ */ q.forwardRef(function(t4, e) {
  var n = t4.children, r = t4.getTriggerDOMNode, i = ah(n), o = q.useCallback(function(a) {
    lx(e, r ? r(a) : a);
  }, [r]), s = cx(o, n.ref);
  return i ? /* @__PURE__ */ q.cloneElement(n, {
    ref: s
  }) : n;
});
v2.displayName = "TriggerWrapper";
var mb = /* @__PURE__ */ q.createContext(null);
function Ob(t4) {
  return t4 ? Array.isArray(t4) ? t4 : [t4] : [];
}
function g8(t4, e, n, r) {
  return q.useMemo(function() {
    var i = Ob(n ?? e), o = Ob(r ?? e), s = new Set(i), a = new Set(o);
    return t4 && (s.has("hover") && (s.delete("hover"), s.add("click")), a.has("hover") && (a.delete("hover"), a.add("click"))), [s, a];
  }, [t4, e, n, r]);
}
var m8 = function(t4) {
  if (!t4)
    return false;
  if (t4 instanceof Element) {
    if (t4.offsetParent)
      return true;
    if (t4.getBBox) {
      var e = t4.getBBox(), n = e.width, r = e.height;
      if (n || r)
        return true;
    }
    if (t4.getBoundingClientRect) {
      var i = t4.getBoundingClientRect(), o = i.width, s = i.height;
      if (o || s)
        return true;
    }
  }
  return false;
};
function O8() {
  var t4 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], n = arguments.length > 2 ? arguments[2] : void 0;
  return n ? t4[0] === e[0] : t4[0] === e[0] && t4[1] === e[1];
}
function x8(t4, e, n, r) {
  for (var i = n.points, o = Object.keys(t4), s = 0; s < o.length; s += 1) {
    var a, l = o[s];
    if (O8((a = t4[l]) === null || a === void 0 ? void 0 : a.points, i, r))
      return "".concat(e, "-placement-").concat(l);
  }
  return "";
}
function xb(t4, e, n, r) {
  return e || (n ? {
    motionName: "".concat(t4, "-").concat(n)
  } : r ? {
    motionName: r
  } : null);
}
function $c(t4) {
  return t4.ownerDocument.defaultView;
}
function Zg(t4) {
  for (var e = [], n = t4 == null ? void 0 : t4.parentElement, r = ["hidden", "scroll", "clip", "auto"]; n; ) {
    var i = $c(n).getComputedStyle(n), o = i.overflowX, s = i.overflowY, a = i.overflow;
    [o, s, a].some(function(l) {
      return r.includes(l);
    }) && e.push(n), n = n.parentElement;
  }
  return e;
}
function ec(t4) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
  return Number.isNaN(t4) ? e : t4;
}
function hl(t4) {
  return ec(parseFloat(t4), 0);
}
function vb(t4, e) {
  var n = se({}, t4);
  return (e || []).forEach(function(r) {
    if (!(r instanceof HTMLBodyElement || r instanceof HTMLHtmlElement)) {
      var i = $c(r).getComputedStyle(r), o = i.overflow, s = i.overflowClipMargin, a = i.borderTopWidth, l = i.borderBottomWidth, c = i.borderLeftWidth, u = i.borderRightWidth, f = r.getBoundingClientRect(), d = r.offsetHeight, h = r.clientHeight, p = r.offsetWidth, O = r.clientWidth, m = hl(a), x = hl(l), v = hl(c), y = hl(u), S = ec(Math.round(f.width / p * 1e3) / 1e3), b = ec(Math.round(f.height / d * 1e3) / 1e3), w = (p - O - v - y) * S, C = (d - h - m - x) * b, k = m * b, T = x * b, A = v * S, E = y * S, $ = 0, j = 0;
      if (o === "clip") {
        var B = hl(s);
        $ = B * S, j = B * b;
      }
      var D = f.x + A - $, N = f.y + k - j, z = D + f.width + 2 * $ - A - E - w, Z = N + f.height + 2 * j - k - T - C;
      n.left = Math.max(n.left, D), n.top = Math.max(n.top, N), n.right = Math.min(n.right, z), n.bottom = Math.min(n.bottom, Z);
    }
  }), n;
}
function yb(t4) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n = "".concat(e), r = n.match(/^(.*)\%$/);
  return r ? t4 * (parseFloat(r[1]) / 100) : parseFloat(n);
}
function bb(t4, e) {
  var n = e || [], r = Le(n, 2), i = r[0], o = r[1];
  return [yb(t4.width, i), yb(t4.height, o)];
}
function Sb() {
  var t4 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
  return [t4[0], t4[1]];
}
function Ds(t4, e) {
  var n = e[0], r = e[1], i, o;
  return n === "t" ? o = t4.y : n === "b" ? o = t4.y + t4.height : o = t4.y + t4.height / 2, r === "l" ? i = t4.x : r === "r" ? i = t4.x + t4.width : i = t4.x + t4.width / 2, {
    x: i,
    y: o
  };
}
function ao(t4, e) {
  var n = {
    t: "b",
    b: "t",
    l: "r",
    r: "l"
  };
  return t4.map(function(r, i) {
    return i === e ? n[r] || "c" : r;
  }).join("");
}
function v8(t4, e, n, r, i, o, s) {
  var a = q.useState({
    ready: false,
    offsetX: 0,
    offsetY: 0,
    offsetR: 0,
    offsetB: 0,
    arrowX: 0,
    arrowY: 0,
    scaleX: 1,
    scaleY: 1,
    align: i[r] || {}
  }), l = Le(a, 2), c = l[0], u = l[1], f = q.useRef(0), d = q.useMemo(function() {
    return e ? Zg(e) : [];
  }, [e]), h = q.useRef({}), p = function() {
    h.current = {};
  };
  t4 || p();
  var O = Jo(function() {
    if (e && n && t4) {
      let kr = function(eu, Ar) {
        var Ts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Ee, tu = L.x + eu, Is = L.y + Ar, nu = tu + ae, al = Is + V, ru = Math.max(tu, Ts.left), Hh = Math.max(Is, Ts.top), Jh = Math.min(nu, Ts.right), Kh = Math.min(al, Ts.bottom);
        return Math.max(0, (Jh - ru) * (Kh - Hh));
      }, Kc = function() {
        re = L.y + Qt, le = re + V, Ce = L.x + Dt, Ye = Ce + ae;
      };
      var v, y, S = e, b = S.ownerDocument, w = $c(S), C = w.getComputedStyle(S), k = C.width, T = C.height, A = C.position, E = S.style.left, $ = S.style.top, j = S.style.right, B = S.style.bottom, D = S.style.overflow, N = se(se({}, i[r]), o), z = b.createElement("div");
      (v = S.parentElement) === null || v === void 0 || v.appendChild(z), z.style.left = "".concat(S.offsetLeft, "px"), z.style.top = "".concat(S.offsetTop, "px"), z.style.position = A, z.style.height = "".concat(S.offsetHeight, "px"), z.style.width = "".concat(S.offsetWidth, "px"), S.style.left = "0", S.style.top = "0", S.style.right = "auto", S.style.bottom = "auto", S.style.overflow = "hidden";
      var Z;
      if (Array.isArray(n))
        Z = {
          x: n[0],
          y: n[1],
          width: 0,
          height: 0
        };
      else {
        var J = n.getBoundingClientRect();
        Z = {
          x: J.x,
          y: J.y,
          width: J.width,
          height: J.height
        };
      }
      var L = S.getBoundingClientRect(), W = b.documentElement, R = W.clientWidth, Q = W.clientHeight, _ = W.scrollWidth, G = W.scrollHeight, M = W.scrollTop, K = W.scrollLeft, V = L.height, ae = L.width, te = Z.height, oe = Z.width, Y = {
        left: 0,
        top: 0,
        right: R,
        bottom: Q
      }, he = {
        left: -K,
        top: -M,
        right: _ - K,
        bottom: G - M
      }, X = N.htmlRegion, ee = "visible", de = "visibleFirst";
      X !== "scroll" && X !== de && (X = ee);
      var ve = X === de, Re = vb(he, d), ye = vb(Y, d), Ee = X === ee ? ye : Re, $e = ve ? ye : Ee;
      S.style.left = "auto", S.style.top = "auto", S.style.right = "0", S.style.bottom = "0";
      var Ge = S.getBoundingClientRect();
      S.style.left = E, S.style.top = $, S.style.right = j, S.style.bottom = B, S.style.overflow = D, (y = S.parentElement) === null || y === void 0 || y.removeChild(z);
      var Je = ec(Math.round(ae / parseFloat(k) * 1e3) / 1e3), be = ec(Math.round(V / parseFloat(T) * 1e3) / 1e3);
      if (Je === 0 || be === 0 || Lf(n) && !m8(n))
        return;
      var lt = N.offset, wt = N.targetOffset, nn = bb(L, lt), gn = Le(nn, 2), xn = gn[0], vn = gn[1], Wn = bb(Z, wt), rn = Le(Wn, 2), zo = rn[0], _i = rn[1];
      Z.x -= zo, Z.y -= _i;
      var ro = N.points || [], Wr = Le(ro, 2), Rn = Wr[0], lr = Wr[1], Vn = Sb(lr), on = Sb(Rn), cr = Ds(Z, Vn), Vr = Ds(L, on), zn = se({}, N), Dt = cr.x - Vr.x + xn, Qt = cr.y - Vr.y + vn, At = kr(Dt, Qt), ri = kr(Dt, Qt, ye), ur = Ds(Z, ["t", "l"]), fr = Ds(L, ["t", "l"]), Mi = Ds(Z, ["b", "r"]), ii = Ds(L, ["b", "r"]), Mt = N.overflow || {}, Vt = Mt.adjustX, io = Mt.adjustY, Ni = Mt.shiftX, oo = Mt.shiftY, F = function(Ar) {
        return typeof Ar == "boolean" ? Ar : Ar >= 0;
      }, re, le, Ce, Ye;
      Kc();
      var ct = F(io), Ve = on[0] === Vn[0];
      if (ct && on[0] === "t" && (le > $e.bottom || h.current.bt)) {
        var Be = Qt;
        Ve ? Be -= V - te : Be = ur.y - ii.y - vn;
        var Ht = kr(Dt, Be), Ct = kr(Dt, Be, ye);
        Ht > At || Ht === At && (!ve || // Choose recommend one
        Ct >= ri) ? (h.current.bt = true, Qt = Be, vn = -vn, zn.points = [ao(on, 0), ao(Vn, 0)]) : h.current.bt = false;
      }
      if (ct && on[0] === "b" && (re < $e.top || h.current.tb)) {
        var kt = Qt;
        Ve ? kt += V - te : kt = Mi.y - fr.y - vn;
        var Pt = kr(Dt, kt), oi = kr(Dt, kt, ye);
        Pt > At || Pt === At && (!ve || // Choose recommend one
        oi >= ri) ? (h.current.tb = true, Qt = kt, vn = -vn, zn.points = [ao(on, 0), ao(Vn, 0)]) : h.current.tb = false;
      }
      var Lo = F(Vt), Jn = on[1] === Vn[1];
      if (Lo && on[1] === "l" && (Ye > $e.right || h.current.rl)) {
        var Xo = Dt;
        Jn ? Xo -= ae - oe : Xo = ur.x - ii.x - xn;
        var Gc = kr(Xo, Qt), Zh = kr(Xo, Qt, ye);
        Gc > At || Gc === At && (!ve || // Choose recommend one
        Zh >= ri) ? (h.current.rl = true, Dt = Xo, xn = -xn, zn.points = [ao(on, 1), ao(Vn, 1)]) : h.current.rl = false;
      }
      if (Lo && on[1] === "r" && (Ce < $e.left || h.current.lr)) {
        var Go = Dt;
        Jn ? Go += ae - oe : Go = Mi.x - fr.x - xn;
        var Yc = kr(Go, Qt), Wh = kr(Go, Qt, ye);
        Yc > At || Yc === At && (!ve || // Choose recommend one
        Wh >= ri) ? (h.current.lr = true, Dt = Go, xn = -xn, zn.points = [ao(on, 1), ao(Vn, 1)]) : h.current.lr = false;
      }
      Kc();
      var si = Ni === true ? 0 : Ni;
      typeof si == "number" && (Ce < ye.left && (Dt -= Ce - ye.left - xn, Z.x + oe < ye.left + si && (Dt += Z.x - ye.left + oe - si)), Ye > ye.right && (Dt -= Ye - ye.right - xn, Z.x > ye.right - si && (Dt += Z.x - ye.right + si)));
      var Fi = oo === true ? 0 : oo;
      typeof Fi == "number" && (re < ye.top && (Qt -= re - ye.top - vn, Z.y + te < ye.top + Fi && (Qt += Z.y - ye.top + te - Fi)), le > ye.bottom && (Qt -= le - ye.bottom - vn, Z.y > ye.bottom - Fi && (Qt += Z.y - ye.bottom + Fi)));
      var ol = L.x + Dt, qc = ol + ae, so = L.y + Qt, Yo = so + V, sl = Z.x, Es = sl + oe, Zi = Z.y, Vh = Zi + te, zh = Math.max(ol, sl), Lh = Math.min(qc, Es), Uc = (zh + Lh) / 2, Xh = Uc - ol, Gh = Math.max(so, Zi), Yh = Math.min(Yo, Vh), Hc = (Gh + Yh) / 2, qh = Hc - so;
      s == null || s(e, zn);
      var Uh = Ge.right - L.x - (Dt + L.width), Jc = Ge.bottom - L.y - (Qt + L.height);
      u({
        ready: true,
        offsetX: Dt / Je,
        offsetY: Qt / be,
        offsetR: Uh / Je,
        offsetB: Jc / be,
        arrowX: Xh / Je,
        arrowY: qh / be,
        scaleX: Je,
        scaleY: be,
        align: zn
      });
    }
  }), m = function() {
    f.current += 1;
    var y = f.current;
    Promise.resolve().then(function() {
      f.current === y && O();
    });
  }, x = function() {
    u(function(y) {
      return se(se({}, y), {}, {
        ready: false
      });
    });
  };
  return yr(x, [r]), yr(function() {
    t4 || x();
  }, [t4]), [c.ready, c.offsetX, c.offsetY, c.offsetR, c.offsetB, c.arrowX, c.arrowY, c.scaleX, c.scaleY, c.align, m];
}
function y8(t4, e, n, r, i) {
  yr(function() {
    if (t4 && e && n) {
      let f = function() {
        r(), i();
      };
      var o = e, s = n, a = Zg(o), l = Zg(s), c = $c(s), u = new Set([c].concat(xa(a), xa(l)));
      return u.forEach(function(d) {
        d.addEventListener("scroll", f, {
          passive: true
        });
      }), c.addEventListener("resize", f, {
        passive: true
      }), r(), function() {
        u.forEach(function(d) {
          d.removeEventListener("scroll", f), c.removeEventListener("resize", f);
        });
      };
    }
  }, [t4, e, n]);
}
function b8(t4, e, n, r, i, o, s, a) {
  var l = q.useRef(t4);
  l.current = t4, q.useEffect(function() {
    if (e && r && (!i || o)) {
      var c = function(x) {
        var v = x.target;
        l.current && !s(v) && a(false);
      }, u = $c(r);
      u.addEventListener("mousedown", c, true), u.addEventListener("contextmenu", c, true);
      var f = Bg(n);
      if (f && (f.addEventListener("mousedown", c, true), f.addEventListener("contextmenu", c, true)), true) {
        var d, h, p = n == null || (d = n.getRootNode) === null || d === void 0 ? void 0 : d.call(n), O = (h = r.getRootNode) === null || h === void 0 ? void 0 : h.call(r);
        zf(p === O, "trigger element and popup element should in same shadow root.");
      }
      return function() {
        u.removeEventListener("mousedown", c, true), u.removeEventListener("contextmenu", c, true), f && (f.removeEventListener("mousedown", c, true), f.removeEventListener("contextmenu", c, true));
      };
    }
  }, [e, n, r, i, o]);
}
var S8 = ["prefixCls", "children", "action", "showAction", "hideAction", "popupVisible", "defaultPopupVisible", "onPopupVisibleChange", "afterPopupVisibleChange", "mouseEnterDelay", "mouseLeaveDelay", "focusDelay", "blurDelay", "mask", "maskClosable", "getPopupContainer", "forceRender", "autoDestroy", "destroyPopupOnHide", "popup", "popupClassName", "popupStyle", "popupPlacement", "builtinPlacements", "popupAlign", "zIndex", "stretch", "getPopupClassNameFromAlign", "fresh", "alignPoint", "onPopupClick", "onPopupAlign", "arrow", "popupMotion", "maskMotion", "popupTransitionName", "popupAnimation", "maskTransitionName", "maskAnimation", "className", "getTriggerDOMNode"];
function w8() {
  var t4 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : fx, e = /* @__PURE__ */ q.forwardRef(function(n, r) {
    var i = n.prefixCls, o = i === void 0 ? "rc-trigger-popup" : i, s = n.children, a = n.action, l = a === void 0 ? "hover" : a, c = n.showAction, u = n.hideAction, f = n.popupVisible, d = n.defaultPopupVisible, h = n.onPopupVisibleChange, p = n.afterPopupVisibleChange, O = n.mouseEnterDelay, m = n.mouseLeaveDelay, x = m === void 0 ? 0.1 : m, v = n.focusDelay, y = n.blurDelay, S = n.mask, b = n.maskClosable, w = b === void 0 ? true : b, C = n.getPopupContainer, k = n.forceRender, T = n.autoDestroy, A = n.destroyPopupOnHide, E = n.popup, $ = n.popupClassName, j = n.popupStyle, B = n.popupPlacement, D = n.builtinPlacements, N = D === void 0 ? {} : D, z = n.popupAlign, Z = n.zIndex, J = n.stretch, L = n.getPopupClassNameFromAlign, W = n.fresh, R = n.alignPoint, Q = n.onPopupClick, _ = n.onPopupAlign, G = n.arrow, M = n.popupMotion, K = n.maskMotion, V = n.popupTransitionName, ae = n.popupAnimation, te = n.maskTransitionName, oe = n.maskAnimation, Y = n.className, he = n.getTriggerDOMNode, X = Mr(n, S8), ee = T || A || false, de = q.useState(false), ve = Le(de, 2), Re = ve[0], ye = ve[1];
    yr(function() {
      ye(GM());
    }, []);
    var Ee = q.useRef({}), $e = q.useContext(mb), Ge = q.useMemo(function() {
      return {
        registerSubPopup: function(De, zt) {
          Ee.current[De] = zt, $e == null || $e.registerSubPopup(De, zt);
        }
      };
    }, [$e]), Je = XM(), be = q.useState(null), lt = Le(be, 2), wt = lt[0], nn = lt[1], gn = q.useRef(null), xn = Jo(function(xe) {
      gn.current = xe, Lf(xe) && wt !== xe && nn(xe), $e == null || $e.registerSubPopup(Je, xe);
    }), vn = q.useState(null), Wn = Le(vn, 2), rn = Wn[0], zo = Wn[1], _i = q.useRef(null), ro = Jo(function(xe) {
      Lf(xe) && rn !== xe && (zo(xe), _i.current = xe);
    }), Wr = q.Children.only(s), Rn = (Wr == null ? void 0 : Wr.props) || {}, lr = {}, Vn = Jo(function(xe) {
      var De, zt, sn = rn;
      return (sn == null ? void 0 : sn.contains(xe)) || ((De = Bg(sn)) === null || De === void 0 ? void 0 : De.host) === xe || xe === sn || (wt == null ? void 0 : wt.contains(xe)) || ((zt = Bg(wt)) === null || zt === void 0 ? void 0 : zt.host) === xe || xe === wt || Object.values(Ee.current).some(function(Lt) {
        return (Lt == null ? void 0 : Lt.contains(xe)) || xe === Lt;
      });
    }), on = xb(o, M, ae, V), cr = xb(o, K, oe, te), Vr = q.useState(d || false), zn = Le(Vr, 2), Dt = zn[0], Qt = zn[1], At = f ?? Dt, ri = Jo(function(xe) {
      f === void 0 && Qt(xe);
    });
    yr(function() {
      Qt(f || false);
    }, [f]);
    var ur = q.useRef(At);
    ur.current = At;
    var fr = q.useRef([]);
    fr.current = [];
    var Mi = Jo(function(xe) {
      var De;
      ri(xe), ((De = fr.current[fr.current.length - 1]) !== null && De !== void 0 ? De : At) !== xe && (fr.current.push(xe), h == null || h(xe));
    }), ii = q.useRef(), Mt = function() {
      clearTimeout(ii.current);
    }, Vt = function(De) {
      var zt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      Mt(), zt === 0 ? Mi(De) : ii.current = setTimeout(function() {
        Mi(De);
      }, zt * 1e3);
    };
    q.useEffect(function() {
      return Mt;
    }, []);
    var io = q.useState(false), Ni = Le(io, 2), oo = Ni[0], F = Ni[1];
    yr(function(xe) {
      (!xe || At) && F(true);
    }, [At]);
    var re = q.useState(null), le = Le(re, 2), Ce = le[0], Ye = le[1], ct = q.useState([0, 0]), Ve = Le(ct, 2), Be = Ve[0], Ht = Ve[1], Ct = function(De) {
      Ht([De.clientX, De.clientY]);
    }, kt = v8(At, wt, R ? Be : rn, B, N, z, _), Pt = Le(kt, 11), oi = Pt[0], Lo = Pt[1], Jn = Pt[2], Xo = Pt[3], Gc = Pt[4], Zh = Pt[5], Go = Pt[6], Yc = Pt[7], Wh = Pt[8], si = Pt[9], Fi = Pt[10], ol = g8(Re, l, c, u), qc = Le(ol, 2), so = qc[0], Yo = qc[1], sl = so.has("click"), Es = Yo.has("click") || Yo.has("contextMenu"), Zi = Jo(function() {
      oo || Fi();
    }), Vh = function() {
      ur.current && R && Es && Vt(false);
    };
    y8(At, rn, wt, Zi, Vh), yr(function() {
      Zi();
    }, [Be, B]), yr(function() {
      At && !(N != null && N[B]) && Zi();
    }, [JSON.stringify(z)]);
    var zh = q.useMemo(function() {
      var xe = x8(N, o, si, R);
      return So(xe, L == null ? void 0 : L(si));
    }, [si, L, N, o, R]);
    q.useImperativeHandle(r, function() {
      return {
        nativeElement: _i.current,
        popupElement: gn.current,
        forceAlign: Zi
      };
    });
    var Lh = q.useState(0), Uc = Le(Lh, 2), Xh = Uc[0], Gh = Uc[1], Yh = q.useState(0), Hc = Le(Yh, 2), qh = Hc[0], Uh = Hc[1], Jc = function() {
      if (J && rn) {
        var De = rn.getBoundingClientRect();
        Gh(De.width), Uh(De.height);
      }
    }, kr = function() {
      Jc(), Zi();
    }, Kc = function(De) {
      F(false), Fi(), p == null || p(De);
    }, eu = function() {
      return new Promise(function(De) {
        Jc(), Ye(function() {
          return De;
        });
      });
    };
    yr(function() {
      Ce && (Fi(), Ce(), Ye(null));
    }, [Ce]);
    function Ar(xe, De, zt, sn) {
      lr[xe] = function(Lt) {
        var iu;
        sn == null || sn(Lt), Vt(De, zt);
        for (var ep = arguments.length, _v = new Array(ep > 1 ? ep - 1 : 0), ou = 1; ou < ep; ou++)
          _v[ou - 1] = arguments[ou];
        (iu = Rn[xe]) === null || iu === void 0 || iu.call.apply(iu, [Rn, Lt].concat(_v));
      };
    }
    (sl || Es) && (lr.onClick = function(xe) {
      var De;
      ur.current && Es ? Vt(false) : !ur.current && sl && (Ct(xe), Vt(true));
      for (var zt = arguments.length, sn = new Array(zt > 1 ? zt - 1 : 0), Lt = 1; Lt < zt; Lt++)
        sn[Lt - 1] = arguments[Lt];
      (De = Rn.onClick) === null || De === void 0 || De.call.apply(De, [Rn, xe].concat(sn));
    }), b8(At, Es, rn, wt, S, w, Vn, Vt);
    var Ts = so.has("hover"), tu = Yo.has("hover"), Is, nu;
    Ts && (Ar("onMouseEnter", true, O, function(xe) {
      Ct(xe);
    }), Ar("onPointerEnter", true, O, function(xe) {
      Ct(xe);
    }), Is = function(De) {
      (At || oo) && wt !== null && wt !== void 0 && wt.contains(De.target) && Vt(true, O);
    }, R && (lr.onMouseMove = function(xe) {
      var De;
      (De = Rn.onMouseMove) === null || De === void 0 || De.call(Rn, xe);
    })), tu && (Ar("onMouseLeave", false, x), Ar("onPointerLeave", false, x), nu = function() {
      Vt(false, x);
    }), so.has("focus") && Ar("onFocus", true, v), Yo.has("focus") && Ar("onBlur", false, y), so.has("contextMenu") && (lr.onContextMenu = function(xe) {
      var De;
      ur.current && Yo.has("contextMenu") ? Vt(false) : (Ct(xe), Vt(true)), xe.preventDefault();
      for (var zt = arguments.length, sn = new Array(zt > 1 ? zt - 1 : 0), Lt = 1; Lt < zt; Lt++)
        sn[Lt - 1] = arguments[Lt];
      (De = Rn.onContextMenu) === null || De === void 0 || De.call.apply(De, [Rn, xe].concat(sn));
    }), Y && (lr.className = So(Rn.className, Y));
    var al = se(se({}, Rn), lr), ru = {}, Hh = ["onContextMenu", "onClick", "onMouseDown", "onTouchStart", "onMouseEnter", "onMouseLeave", "onFocus", "onBlur"];
    Hh.forEach(function(xe) {
      X[xe] && (ru[xe] = function() {
        for (var De, zt = arguments.length, sn = new Array(zt), Lt = 0; Lt < zt; Lt++)
          sn[Lt] = arguments[Lt];
        (De = al[xe]) === null || De === void 0 || De.call.apply(De, [al].concat(sn)), X[xe].apply(X, sn);
      });
    });
    var Jh = /* @__PURE__ */ q.cloneElement(Wr, se(se({}, al), ru)), Kh = {
      x: Zh,
      y: Go
    }, t42 = G ? se({}, G !== true ? G : {}) : null;
    return /* @__PURE__ */ q.createElement(q.Fragment, null, /* @__PURE__ */ q.createElement(uh, {
      disabled: !At,
      ref: ro,
      onResize: kr
    }, /* @__PURE__ */ q.createElement(v2, {
      getTriggerDOMNode: he
    }, Jh)), /* @__PURE__ */ q.createElement(mb.Provider, {
      value: Ge
    }, /* @__PURE__ */ q.createElement(x2, {
      portal: t4,
      ref: xn,
      prefixCls: o,
      popup: E,
      className: So($, zh),
      style: j,
      target: rn,
      onMouseEnter: Is,
      onMouseLeave: nu,
      onPointerEnter: Is,
      zIndex: Z,
      open: At,
      keepDom: oo,
      fresh: W,
      onClick: Q,
      mask: S,
      motion: on,
      maskMotion: cr,
      onVisibleChanged: Kc,
      onPrepare: eu,
      forceRender: k,
      autoDestroy: ee,
      getPopupContainer: C,
      align: si,
      arrow: t42,
      arrowPos: Kh,
      ready: oi,
      offsetX: Lo,
      offsetY: Jn,
      offsetR: Xo,
      offsetB: Gc,
      onAlign: Zi,
      stretch: J,
      targetWidth: Xh / Yc,
      targetHeight: qh / Wh
    })));
  });
  return e.displayName = "Trigger", e;
}
var C8 = w8(fx);
var Qs = {
  shiftX: 64,
  adjustY: 1
};
var Bs = {
  adjustX: 1,
  shiftY: true
};
var Pr = [0, 0];
var k8 = {
  left: {
    points: ["cr", "cl"],
    overflow: Bs,
    offset: [-4, 0],
    targetOffset: Pr
  },
  right: {
    points: ["cl", "cr"],
    overflow: Bs,
    offset: [4, 0],
    targetOffset: Pr
  },
  top: {
    points: ["bc", "tc"],
    overflow: Qs,
    offset: [0, -4],
    targetOffset: Pr
  },
  bottom: {
    points: ["tc", "bc"],
    overflow: Qs,
    offset: [0, 4],
    targetOffset: Pr
  },
  topLeft: {
    points: ["bl", "tl"],
    overflow: Qs,
    offset: [0, -4],
    targetOffset: Pr
  },
  leftTop: {
    points: ["tr", "tl"],
    overflow: Bs,
    offset: [-4, 0],
    targetOffset: Pr
  },
  topRight: {
    points: ["br", "tr"],
    overflow: Qs,
    offset: [0, -4],
    targetOffset: Pr
  },
  rightTop: {
    points: ["tl", "tr"],
    overflow: Bs,
    offset: [4, 0],
    targetOffset: Pr
  },
  bottomRight: {
    points: ["tr", "br"],
    overflow: Qs,
    offset: [0, 4],
    targetOffset: Pr
  },
  rightBottom: {
    points: ["bl", "br"],
    overflow: Bs,
    offset: [4, 0],
    targetOffset: Pr
  },
  bottomLeft: {
    points: ["tl", "bl"],
    overflow: Qs,
    offset: [0, 4],
    targetOffset: Pr
  },
  leftBottom: {
    points: ["br", "bl"],
    overflow: Bs,
    offset: [-4, 0],
    targetOffset: Pr
  }
};
var A8 = ["overlayClassName", "trigger", "mouseEnterDelay", "mouseLeaveDelay", "overlayStyle", "prefixCls", "children", "onVisibleChange", "afterVisibleChange", "transitionName", "animation", "motion", "placement", "align", "destroyTooltipOnHide", "defaultVisible", "getTooltipContainer", "overlayInnerStyle", "arrowContent", "overlay", "id", "showArrow"];
var P8 = function(e, n) {
  var r = e.overlayClassName, i = e.trigger, o = i === void 0 ? ["hover"] : i, s = e.mouseEnterDelay, a = s === void 0 ? 0 : s, l = e.mouseLeaveDelay, c = l === void 0 ? 0.1 : l, u = e.overlayStyle, f = e.prefixCls, d = f === void 0 ? "rc-tooltip" : f, h = e.children, p = e.onVisibleChange, O = e.afterVisibleChange, m = e.transitionName, x = e.animation, v = e.motion, y = e.placement, S = y === void 0 ? "right" : y, b = e.align, w = b === void 0 ? {} : b, C = e.destroyTooltipOnHide, k = C === void 0 ? false : C, T = e.defaultVisible, A = e.getTooltipContainer, E = e.overlayInnerStyle;
  e.arrowContent;
  var $ = e.overlay, j = e.id, B = e.showArrow, D = B === void 0 ? true : B, N = H9(e, A8), z = Ke(null);
  $O(n, function() {
    return z.current;
  });
  var Z = Vf({}, N);
  "visible" in e && (Z.popupVisible = e.visible);
  var J = function() {
    return /* @__PURE__ */ q.createElement(X9, {
      key: "content",
      prefixCls: d,
      id: j,
      overlayInnerStyle: E
    }, $);
  };
  return /* @__PURE__ */ q.createElement(C8, Tg({
    popupClassName: r,
    prefixCls: d,
    popup: J,
    action: o,
    builtinPlacements: k8,
    popupPlacement: S,
    ref: z,
    popupAlign: w,
    getPopupContainer: A,
    onPopupVisibleChange: p,
    afterPopupVisibleChange: O,
    popupTransitionName: m,
    popupAnimation: x,
    popupMotion: v,
    defaultPopupVisible: T,
    autoDestroy: k,
    mouseLeaveDelay: c,
    popupStyle: u,
    mouseEnterDelay: a,
    arrow: D
  }, Z), h);
};
var Ga = /* @__PURE__ */ xs(P8);
var ia = I.div`
  color: var(--text-color-secondary);
  font-size: var(--font-size-sm);
  font-style: normal;
  font-weight: var(--font-weight-regular);
  line-height: 16px;

  span {
    color: var(--text-color-secondary);
  }
`;
var E8 = xs(
  ({ className: t4, ...e }, n) => /* @__PURE__ */ g.jsx(T8, { className: t4, ...e, ref: n })
);
var us = no(E8);
var T8 = I.input`
  color: var(--input-content-color-active);
  text-indent: var(--input-padding);
  background-color: var(--input-bg-color);
  border: 1px solid var(--border-color-secondary);
  border-radius: var(--border-radius);
  padding-left: 0;
  height: 24px;
  width: 100%;

  &:focus {
    outline: var(--input-border-focus);
  }
`;
function I8({ value: t4, disabled: e = false, onChange: n, title: r }) {
  return /* @__PURE__ */ g.jsxs($8, { children: [
    /* @__PURE__ */ g.jsx(Switch, { value: t4, onChange: n, disabled: e }),
    r && /* @__PURE__ */ g.jsx(j8, { children: r })
  ] });
}
var $8 = I.div`
  display: flex;
  flex-direction: row;
  align-items: center;
  gap: var(--spacing-xs);
`;
var j8 = I.div`
  font-color: var(--text-color-primary);
  font-size: var(--font-size-base);
  font-weight: var(--font-weight-regular);
  line-height: var(--line-height-base);
`;
function jc({
  variable: t4,
  onSave: e,
  onCancel: n,
  className: r,
  readonlyName: i,
  readonlyValue: o,
  isNew: s
}) {
  const [a, l] = fe(t4.name), [c, u] = fe(t4.value), [f, d] = fe(!!t4.isSecret), h = () => {
    e({
      ...t4,
      name: a,
      value: c,
      isSecret: f
    });
  };
  return /* @__PURE__ */ g.jsxs(R8, { className: r, children: [
    /* @__PURE__ */ g.jsxs(D8, { children: [
      s ? "New" : "Edit",
      " variable"
    ] }),
    /* @__PURE__ */ g.jsx(ia, { children: "Name" }),
    /* @__PURE__ */ g.jsx(
      us,
      {
        "data-testid": "variable-name-input",
        type: "text",
        placeholder: "Enter name",
        value: a,
        readOnly: i,
        onChange: (p) => l(p.target.value)
      }
    ),
    /* @__PURE__ */ g.jsx(ia, { children: "Value" }),
    /* @__PURE__ */ g.jsx(
      us,
      {
        "data-testid": "variable-value-input",
        type: "text",
        placeholder: "Enter value",
        value: c,
        readOnly: o,
        onChange: (p) => u(p.target.value)
      }
    ),
    /* @__PURE__ */ g.jsx(I8, { value: f, onChange: (p) => d(p), title: "Make it secret" }),
    /* @__PURE__ */ g.jsxs(Q8, { children: [
      /* @__PURE__ */ g.jsx(Button, { size: "small", variant: "text", onClick: n, children: "Cancel" }),
      /* @__PURE__ */ g.jsx(
        Button,
        {
          size: "small",
          variant: "primary",
          onClick: h,
          disabled: !a.trim(),
          "data-testid": "variable-save-button",
          children: "Save"
        }
      )
    ] })
  ] });
}
var R8 = I.div`
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  gap: var(--spacing-xs);
  padding: var(--spacing-sm) var(--spacing-base) var(--spacing-base) var(--spacing-base);
  align-self: stretch;
  background-color: var(--layer-color);
`;
var D8 = I.div`
  color: var(--text-color-primary);
  font-size: var(--font-size-base);
  font-style: normal;
  font-weight: var(--font-weight-semibold);
  line-height: var(--line-height-base);
`;
var Q8 = I.div`
  display: flex;
  flex-direction: row;
  align-self: flex-end;
  padding-top: var(--spacing-xxs);
  gap: var(--spacing-xs);
`;
var No = ({
  children: t4,
  className: e,
  ...n
}) => /* @__PURE__ */ g.jsx(
  B8,
  {
    className: e,
    onFocus: (r) => r.stopPropagation(),
    onKeyDown: (r) => r.stopPropagation(),
    onSelect: (r) => r.stopPropagation(),
    onPaste: (r) => r.stopPropagation(),
    onCut: (r) => r.stopPropagation(),
    onClick: (r) => r.stopPropagation(),
    ...n,
    children: t4
  }
);
var B8 = I.div`
  border-radius: var(--border-radius);
  border: 2px solid var(--border-color-secondary);
  background-color: var(--layer-color);
  box-shadow:
    0 8px 24px 8px rgba(0, 0, 0, 0.04),
    0 4px 12px 0 rgba(0, 0, 0, 0.08);
`;
var px = "server";
var mp = "replay-history";
var Op = "replay-collections";
var xp = "replay-draft-requests";
var vp = "replay-environments";
var yp = "replay-user-id";
function _8() {
  const [t4] = fe(localStorage.getItem(yp) || crypto.randomUUID());
  return _e(() => {
    localStorage.getItem(yp) || localStorage.setItem(yp, t4);
  }, []), t4;
}
function gt() {
  const { useTelemetry: t4 } = useThemeHooks(), e = _8(), n = t4();
  return {
    sendEvent: (i, o) => {
      var s;
      (s = n == null ? void 0 : n.send) == null || s.call(n, "replay", {
        ...o,
        eventType: i,
        replayUserId: e,
        url: window.location.href
      });
    }
  };
}
function dh({
  children: t4,
  controls: e,
  icon: n,
  title: r,
  defaultExpanded: i = false,
  dataTestId: o,
  size: s = "large",
  ...a
}) {
  const [l, c] = fe(i);
  _e(() => c(i), [i]);
  const u = (d) => {
    (d.key === " " || d.key === "Enter") && (d.preventDefault(), c(!l));
  }, f = () => {
    const d = !l;
    c(d), a.onToggle && a.onToggle(d);
  };
  return /* @__PURE__ */ g.jsxs(M8, { ...a, "data-testid": o, $size: s, children: [
    /* @__PURE__ */ g.jsxs(Z8, { $size: s, onKeyDown: u, tabIndex: 0, onClick: f, children: [
      /* @__PURE__ */ g.jsxs(V8, { children: [
        /* @__PURE__ */ g.jsx(W8, { children: n || (l ? /* @__PURE__ */ g.jsx(ChevronDownIcon, { size: "14px", color: "--text-color-secondary" }) : /* @__PURE__ */ g.jsx(ChevronRightIcon, { size: "14px", color: "--text-color-secondary" })) }),
        /* @__PURE__ */ g.jsx(N8, { children: r })
      ] }),
      e && /* @__PURE__ */ g.jsx(y2, { children: e })
    ] }),
    /* @__PURE__ */ g.jsx(F8, { $isExpanded: l, children: t4 })
  ] });
}
var M8 = I.div`
  display: flex;
  width: 100%;
  flex-direction: column;
  flex-shrink: 0;
  color: var(--text-color-secondary);
  font-size: ${({ $size: t4 }) => t4 === "small" ? "var(--font-size-sm)" : "var(--font-size-base)"};
  line-height: ${({ $size: t4 }) => t4 === "small" ? "var(--line-height-sm)" : "var(--line-height-base)"};
  cursor: pointer;
`;
var N8 = I.span`
  display: -webkit-box;
  -webkit-line-clamp: 2; /* Limit the text to 2 lines */
  -webkit-box-orient: vertical;
  overflow: hidden;
  max-height: 3em;
  text-overflow: ellipsis;
`;
var F8 = I.div`
  display: flex;
  flex-direction: column;
  margin-left: 23px;
  height: ${({ $isExpanded: t4 }) => t4 ? "auto" : "0"};
  overflow-y: clip;
  overflow-x: visible;
`;
var y2 = I.div`
  display: none;
`;
var Z8 = I.div`
  width: 100%;
  display: flex;
  flex-direction: row;
  justify-content: space-between;
  align-items: center;
  flex-grow: 1;
  height: ${({ $size: t4 }) => t4 === "small" ? "auto" : "40px"};
  padding: ${({ $size: t4 }) => t4 === "small" ? "0" : "0 var(--spacing-base)"};

  &:hover,
  &:focus,
  &:focus-within {
    ${y2} {
      display: flex;
    }
  }
`;
var W8 = I.div`
  display: flex;
  align-items: center;
  min-width: 14px;
`;
var V8 = I.div`
  display: flex;
  flex-direction: row;
  align-items: center;
  gap: var(--spacing-xs);
`;
var Nr = I(Button).attrs({
  variant: "text",
  size: "small",
  tone: "danger"
})`
  border: none;
  margin: 0;

  &:hover {
    background-color: var(--color-error-bg);
    border: none;
  }

  &:focus {
    border: 1px solid var(--button-border-color-focused);
  }
`;
var z8 = I(Button).attrs({
  variant: "text",
  size: "small",
  tone: "default"
})`
  border: none;
  margin: 0;
  box-sizing: content-box;
  color: var(--button-content-color-disabled);

  &:hover {
    background-color: var(--button-bg-color-secondary);
    border: none;
  }
`;
var b2 = I.div`
  position: relative;
  background-color: var(--bg-color-active);
  text-align: left;
  transform: rotate(-60deg) skewX(-30deg) scale(1, 0.866);
  top: -4px;

  &:before,
  &:after {
    content: '';
    position: absolute;
    background-color: var(--bg-color-active);
  }

  &,
  &:before,
  &:after {
    width: 4px;
    height: 4px;
    border-top-right-radius: 50%;
  }

  &:before {
    transform: rotate(-135deg) skewX(-45deg) scale(1.414, 0.707) translate(0, -50%);
  }
  &:after {
    transform: rotate(135deg) skewY(-45deg) scale(0.707, 1.414) translate(50%);
  }
`;
var oa = I(Button)`
  border: none;
  margin: 0;

  &:hover {
    border: none;
  }

  & + & {
    margin-left: 0;
  }
`;
function L8({
  variable: t4,
  variables: e,
  name: n,
  withPopover: r,
  inputId: i,
  onNewVariable: o
}) {
  const [s, a] = fe(false), [l, c] = fe({}), u = n === px, f = !(t4 != null && t4.value), { sendEvent: d } = gt(), h = t4 ? S2(t4, e) : [], p = () => {
    a(true), d("variable_editor_opened", { name: n, isUndefined: f });
  }, O = () => {
    d("variable_value_copied", { name: n });
  }, m = (j) => {
    a(false), o(j), d("variable_saved", { name: n, isUndefined: f });
  }, x = () => {
    a(false), d("variable_editor_closed", { name: n, isUndefined: f });
  }, v = (j) => {
    d("variable_nested_variables_toggled", { name: n, isExpanded: j });
  }, y = (j, B) => {
    c((D) => ({ ...D, [j]: B }));
  }, S = (j) => {
    const [B, D] = fe(false), N = () => {
      D((z) => !z);
    };
    return /* @__PURE__ */ g.jsx(J8, { children: l[j.id] ? /* @__PURE__ */ g.jsx(
      H8,
      {
        variable: j || { ...qf(), name: n },
        onSave: m,
        onCancel: () => y(j.id, false),
        isNew: !j,
        readonlyName: true
      }
    ) : /* @__PURE__ */ g.jsxs(g.Fragment, { children: [
      /* @__PURE__ */ g.jsx(bp, { children: j.name }),
      /* @__PURE__ */ g.jsxs(Y8, { children: [
        /* @__PURE__ */ g.jsx(Sp, { $isEmpty: !(j != null && j.value), children: j.isSecret && !B ? "\u2022\u2022\u2022\u2022\u2022" : Nl((j == null ? void 0 : j.value) || "", e, { withPopover: false }) || "No value" }),
        /* @__PURE__ */ g.jsxs(q8, { children: [
          j.isSecret && /* @__PURE__ */ g.jsx(
            oa,
            {
              onClick: N,
              variant: "text",
              size: "small",
              icon: B ? /* @__PURE__ */ g.jsx(ViewOffIcon, {}) : /* @__PURE__ */ g.jsx(ViewIcon, {})
            }
          ),
          (j == null ? void 0 : j.value) && /* @__PURE__ */ g.jsx(CopyButton, { data: j == null ? void 0 : j.value, onCopyClick: O, toasterPlacement: "left" })
        ] })
      ] }),
      (j == null ? void 0 : j.canBeEdited) && /* @__PURE__ */ g.jsxs(g.Fragment, { children: [
        /* @__PURE__ */ g.jsx(Fe, {}),
        /* @__PURE__ */ g.jsx(
          Button,
          {
            size: "small",
            icon: /* @__PURE__ */ g.jsx(EditIcon, {}),
            onClick: () => {
              y(j.id, true);
            },
            children: "Edit"
          }
        )
      ] })
    ] }) });
  }, b = () => {
    const [j, B] = fe(false), D = h.some(
      (N) => !!l[N.id]
    );
    return /* @__PURE__ */ g.jsxs(g.Fragment, { children: [
      t4 ? S(t4) : null,
      h.length ? /* @__PURE__ */ g.jsx(
        dh,
        {
          title: `${j ? "Hide" : "Show"} nested variables`,
          size: "small",
          defaultExpanded: D,
          onToggle: (N) => {
            B(N), v(N);
          },
          children: /* @__PURE__ */ g.jsx(K8, { children: h.map((N, z) => /* @__PURE__ */ g.jsxs(it.Fragment, { children: [
            S(N),
            h.length - 1 !== z && /* @__PURE__ */ g.jsx(eN, {})
          ] }, N.id)) })
        }
      ) : null
    ] });
  }, w = /* @__PURE__ */ g.jsxs(g.Fragment, { children: [
    /* @__PURE__ */ g.jsxs(bp, { children: [
      /* @__PURE__ */ g.jsx(wp, {}),
      /* @__PURE__ */ g.jsx("span", { children: "Undefined variable" })
    ] }),
    /* @__PURE__ */ g.jsx(Sp, { children: "Make sure the variable is defined and enabled in the active environment." }),
    /* @__PURE__ */ g.jsx(Fe, {}),
    /* @__PURE__ */ g.jsx(Button, { onClick: p, children: "Add new variable" })
  ] }), C = /* @__PURE__ */ g.jsxs(g.Fragment, { children: [
    /* @__PURE__ */ g.jsxs(bp, { children: [
      /* @__PURE__ */ g.jsx(wp, {}),
      /* @__PURE__ */ g.jsx("span", { children: "Undefined variable value" })
    ] }),
    /* @__PURE__ */ g.jsx(Sp, { children: "This variable needs a value assigned before you can use it." }),
    /* @__PURE__ */ g.jsx(Fe, {}),
    /* @__PURE__ */ g.jsx(Button, { onClick: p, children: "Set value" })
  ] }), k = /* @__PURE__ */ g.jsxs(
    X8,
    {
      "data-testid": "variable-input-name",
      $isServerVariable: u,
      $isUndefined: f,
      children: [
        bs + n + Ss,
        f && /* @__PURE__ */ g.jsx(wp, { $size: "var(--spacing-sm)" })
      ]
    }
  ), T = /* @__PURE__ */ g.jsx(
    U8,
    {
      variable: t4 || { ...qf(), name: n },
      onSave: m,
      onCancel: x,
      isNew: !t4,
      readonlyName: true
    }
  ), A = () => s ? T : f ? t4 ? C : w : /* @__PURE__ */ g.jsx(b, {}), E = We(() => s ? "variable-editor" : f ? t4 ? "variable-undefined-value" : "variable-undefined-variable" : "variable-info", [f, s, t4]), $ = !!Object.values(l).filter(Boolean).length;
  return r ? /* @__PURE__ */ g.jsx(
    Ga,
    {
      trigger: s || $ ? "click" : ["click", "hover"],
      placement: "bottomLeft",
      overlay: /* @__PURE__ */ g.jsx(
        G8,
        {
          "data-testid": E,
          "data-input-id": i,
          $addPadding: !s,
          children: A()
        }
      ),
      overlayStyle: { zIndex: "1000", position: "absolute", maxWidth: "424px" },
      onVisibleChange: (j) => {
        j || (a(false), c({}));
      },
      destroyTooltipOnHide: true,
      mouseEnterDelay: 0.1,
      showArrow: false,
      children: k
    }
  ) : k;
}
var X8 = I.span`
  display: inline-flex;
  align-items: center;
  width: fit-content;
  border-radius: var(--border-radius);
  gap: 2px;
  padding: 0 ${({ $isUndefined: t4 }) => t4 ? "var(--spacing-xxs)" : "2px"};
  color: ${({ $isServerVariable: t4, $isUndefined: e }) => `var(--replay-${t4 ? "server" : e ? "undefined" : "defined"}-variable-color)`};
  background-color: ${({ $isServerVariable: t4, $isUndefined: e }) => `var(--replay-${t4 ? "server" : e ? "undefined" : "defined"}-variable-bg-color)`};

  &:hover {
    background-color: ${({ $isServerVariable: t4, $isUndefined: e }) => `var(--replay-${t4 ? "server" : e ? "undefined" : "defined"}-variable-bg-color-hover)`};
  }
`;
var G8 = I(No)`
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  gap: var(--spacing-xs);
  padding: ${({ $addPadding: t4 }) => t4 ? "var(--spacing-xs) var(--spacing-sm);" : "0"};
  min-width: 230px;
  max-width: 424px;
  max-height: 500px;
  overflow: auto;
`;
var bp = I.div`
  display: flex;
  align-items: center;
  gap: var(--spacing-xs);
  color: var(--text-color-primary);
  font-size: var(--font-size-base);
  font-style: normal;
  font-weight: var(--font-weight-semibold);
  line-height: var(--line-height-base);
`;
var Y8 = I.div`
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: space-between;
  gap: var(--spacing-xs);
  min-width: 100%;
`;
var q8 = I.div`
  display: flex;
  flex-direction: row;
  align-items: center;
  gap: var(--spacing-xs);
`;
var Sp = I.div`
  color: ${({ $isEmpty: t4 }) => t4 ? "var(--color-warm-grey-5)" : "var(--text-color-secondary)"};
  font-size: var(--font-size-sm);
  font-style: normal;
  font-weight: var(--font-weight-regular);
  word-wrap: break-word;
  max-width: 360px;
`;
var wp = I(WarningFilledIcon)`
  width: ${({ $size: t4 }) => t4 || "var(--spacing-base)"};
  height: ${({ $size: t4 }) => t4 || "var(--spacing-base)"};
  color: var(--color-raspberry-6);
`;
var U8 = I(jc)`
  width: 364px;
`;
var H8 = I(jc)`
  padding: 0;
`;
var J8 = I.div`
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  gap: var(--spacing-xs);
  width: calc(100% + 16.5px);
  margin-left: -16.5px;
  padding-left: 15.5px;
  border-left: 1px solid var(--border-color-secondary);
`;
var K8 = I.div`
  display: flex;
  flex-direction: column;
  gap: var(--spacing-xs);
  padding-top: var(--spacing-xs);
`;
var eN = I(Fe)`
  margin-left: -16.5px;
  width: calc(100% + 16.5px);
`;
var Nl = (t4, e, n = { withPopover: true }) => {
  const r = Va(t4), i = (a) => {
    e.set((l) => [
      ...l.filter((c) => c.id !== a.id),
      a
    ]);
  };
  if (!r.length)
    return t4;
  let o = 0;
  const s = r.flatMap(({ start: a, end: l, content: c }) => {
    const u = e.get().findLast((d) => d.name === c), f = t4.slice(o, a);
    return o = l, [
      f.length ? /* @__PURE__ */ g.jsx(_r, { children: f }, o) : null,
      /* @__PURE__ */ g.jsx(
        L8,
        {
          inputId: n.inputId,
          variable: u,
          variables: e,
          name: c,
          withPopover: n.withPopover ?? true,
          onNewVariable: i
        },
        crypto.randomUUID()
      )
    ];
  });
  return t4.slice(o).length && s.push(/* @__PURE__ */ g.jsx(_r, { children: t4.slice(o) }, o + 1)), s;
};
var qf = () => ({
  id: crypto.randomUUID(),
  name: "",
  value: "",
  type: Tr.UserCreated,
  canBeRemoved: true,
  canBeEdited: true
});
var Jt = (t4) => bs + t4 + Ss;
var tN = (t4, e) => e.variables.find(
  (n) => {
    var r;
    return n.get().name === ((r = t4.match(`^${yA}$`)) == null ? void 0 : r[1]);
  }
);
var S2 = (t4, e, n = /* @__PURE__ */ new Set()) => {
  const i = Va((t4 == null ? void 0 : t4.value) || "").map(({ content: a }) => e.get().find((l) => l.name === a)).filter(Boolean), s = ((a) => {
    let l = [];
    for (const c of a) {
      if (n.has(c.name))
        continue;
      n.add(c.name);
      const u = S2(c, e, n);
      l = l.concat(u);
    }
    return l;
  })(i);
  return [.../* @__PURE__ */ new Set([...i, ...s])];
};
function nN(t4) {
  const { environments: e, selectedEnvironmentId: n } = t4;
  return (e.find((i) => i.id === n) || e[0]).variables || [];
}
var Fo = ({ children: t4, className: e, onClickOutside: n }) => {
  const r = Ke(null);
  _e(() => (document.addEventListener("mouseup", i), () => {
    document.removeEventListener("mouseup", i);
  }));
  const i = (o) => {
    r.current && !r.current.contains(o.target) && (n == null || n(o));
  };
  return /* @__PURE__ */ g.jsx(rN, { ref: r, className: e, children: t4 });
};
var rN = I.div`
  width: 100%;
`;
function iN({
  range: t4,
  value: e,
  inputId: n,
  onClose: r,
  onNewVariable: i
}) {
  const { sendEvent: o } = gt(), [s, a] = fe(false), l = window.pageXOffset || document.documentElement.scrollTop, c = t4.getBoundingClientRect(), u = () => {
    a(true), o("vi_new_variable_creation_started", { name: e });
  }, f = /* @__PURE__ */ g.jsx(Fo, { onClickOutside: r, children: /* @__PURE__ */ g.jsx(sN, { "data-input-id": n, children: s ? /* @__PURE__ */ g.jsx(
    jc,
    {
      variable: { ...qf(), value: e },
      onSave: (d) => i(d),
      onCancel: r,
      readonlyValue: true,
      isNew: true
    }
  ) : /* @__PURE__ */ g.jsx(
    Button,
    {
      icon: /* @__PURE__ */ g.jsx(ValueVariableIcon, {}),
      onClick: u,
      iconPosition: "left",
      size: "small",
      variant: "text",
      children: "Set as variable"
    }
  ) }) });
  return /* @__PURE__ */ g.jsx(Portal, { children: /* @__PURE__ */ g.jsx(
    Ga,
    {
      trigger: "click",
      placement: "bottom",
      showArrow: false,
      visible: true,
      zIndex: 1e3,
      overlay: f,
      overlayStyle: { position: "absolute" },
      children: /* @__PURE__ */ g.jsx(
        oN,
        {
          $rect: {
            ...c,
            width: c.width,
            height: c.height,
            left: c.left,
            top: c.top + l
          }
        }
      )
    }
  ) });
}
var oN = I.div`
  position: absolute;
  top: ${({ $rect: t4 }) => t4.top}px;
  left: ${({ $rect: t4 }) => t4.left}px;
  height: ${({ $rect: t4 }) => t4.height}px;
  width: ${({ $rect: t4 }) => t4.width}px;
`;
var sN = I(No)`
  padding: var(--spacing-xs) var(--spacing-sm);
`;
var wb = (t4, e) => {
  const n = w2(t4, e);
  return e.innerText.substring(n.start, n.end);
};
var w2 = (t4, e) => {
  const n = t4.cloneRange();
  n.selectNodeContents(e), n.setEnd(t4.startContainer, t4.startOffset);
  const r = n.toString().length;
  n.setEnd(t4.endContainer, t4.endOffset);
  const i = n.toString().length;
  return { start: r, end: i };
};
function aN(t4, e) {
  var r;
  let n = 0;
  for (let i = 0; i < t4.length; i++) {
    const o = t4[i];
    let s = 0;
    if (o.nodeType === Node.TEXT_NODE ? s = ((r = o.textContent) == null ? void 0 : r.length) || 0 : o.nodeType === Node.ELEMENT_NODE ? s = o.innerText.length : console.log("unknown node type", o), n + s >= e)
      return {
        node: o.nodeType === Node.TEXT_NODE ? o : o.childNodes[0] || o,
        offset: e - n
      };
    n += s;
  }
  return { node: t4[0], offset: e };
}
var lN = (t4, e) => {
  if (!t4 || !e)
    return 0;
  const n = e.cloneRange();
  return n.selectNodeContents(t4), n.setEnd(e.endContainer, e.endOffset), n.toString().length;
};
var cN = (t4, e) => {
  var n, r, i;
  if ((n = t4.current) != null && n.childNodes.length) {
    const o = aN((r = t4.current) == null ? void 0 : r.childNodes, e), s = document.createRange(), a = window.getSelection();
    s.setStart(
      o.node,
      Math.min(o.offset, ((i = o.node) == null ? void 0 : i.length) || 0)
    ), s.collapse(true), a == null || a.removeAllRanges(), a == null || a.addRange(s);
  }
};
var C2 = (t4) => t4 ? t4.dataset.inputId ? t4.dataset.inputId : C2(t4.parentElement) : null;
var k2 = (t4) => t4.lastIndexOf(bs);
var gx = (t4) => {
  const e = k2(t4);
  return t4.substring(e + 2);
};
var uN = (t4, e, n) => {
  const r = k2(t4), i = n.some((o) => {
    const s = gx(t4);
    return o.name.startsWith(s);
  });
  return r !== -1 && e >= r + 2 && i;
};
var fN = (t4, e) => {
  const n = gx(t4);
  return dN(
    e.filter((r) => r.name.startsWith(n))
  );
};
function dN(t4) {
  const e = t4.reduce((r, i) => (r[i.name] = i, r), {});
  return Object.values(e);
}
var hN = (t4, e) => {
  const n = gx(t4);
  return `${e.substring(n.length)}${Ss}`;
};
var pN = (t4) => t4.replace(/(\r\n|\n|\r)/gm, "");
function gN(t4, e) {
  const [n, r] = fe(t4), i = Ke([{ value: n, cursorPosition: e }]), [o, s] = fe(0), a = () => {
    const u = Math.max(o - 1, 0);
    return s(u), i.current[u];
  }, l = () => {
    const u = Math.min(o + 1, i.current.length - 1);
    return s(u), i.current[u];
  }, c = (u, f) => {
    if (u !== i.current[o].value) {
      const d = o + 1;
      i.current = i.current.slice(0, d), i.current[d] = { value: u, cursorPosition: f }, s(d), r(u);
    }
  };
  return [i.current[o].value, c, a, l];
}
function mN(t4, e) {
  let n;
  return function(...r) {
    clearTimeout(n), n = setTimeout(() => t4.apply(this, r), e);
  };
}
function ON({
  onClose: t4,
  onSelect: e,
  variables: n,
  selectedIndex: r,
  inputId: i
}) {
  return /* @__PURE__ */ g.jsx(Fo, { onClickOutside: t4, children: /* @__PURE__ */ g.jsx(yN, { "data-input-id": i, children: n.map((o, s) => /* @__PURE__ */ g.jsxs(
    bN,
    {
      role: "button",
      onClick: () => e(o),
      active: s === r,
      children: [
        /* @__PURE__ */ g.jsx(SN, { children: o.name }),
        /* @__PURE__ */ g.jsx(wN, { children: o.value || "No value" })
      ]
    },
    o.id
  )) }) });
}
function xN({
  range: t4,
  onClose: e,
  variables: n,
  onSelect: r,
  inputId: i
}) {
  const [o, s] = fe(0), a = window.scrollX || document.documentElement.scrollTop, l = t4.getBoundingClientRect();
  return _e(() => {
    const c = (u) => {
      u.key === "ArrowDown" ? s((f) => o < n.length - 1 ? f + 1 : 0) : u.key === "ArrowUp" ? s((f) => o > 0 ? f - 1 : n.length - 1) : u.key === "Enter" && r(n[o]);
    };
    return document.addEventListener("keydown", c), () => {
      document.removeEventListener("keydown", c);
    };
  }, [r, o, n, n.length]), /* @__PURE__ */ g.jsx(Portal, { children: /* @__PURE__ */ g.jsx(
    Ga,
    {
      trigger: "click",
      placement: "bottomLeft",
      showArrow: false,
      visible: true,
      zIndex: 1e3,
      overlay: /* @__PURE__ */ g.jsx(
        ON,
        {
          inputId: i,
          onClose: e,
          onSelect: r,
          variables: n,
          selectedIndex: o
        }
      ),
      overlayStyle: { position: "absolute" },
      children: /* @__PURE__ */ g.jsx(
        vN,
        {
          $rect: {
            ...l,
            width: l.width,
            height: l.height,
            left: l.left,
            top: l.top + a
          }
        }
      )
    }
  ) });
}
var vN = I.div`
  position: absolute;
  top: ${({ $rect: t4 }) => t4.top}px;
  left: ${({ $rect: t4 }) => t4.left}px;
  height: ${({ $rect: t4 }) => t4.height}px;
  width: ${({ $rect: t4 }) => t4.width}px;
`;
var yN = I(No)`
  max-height: 320px;
  overflow-y: auto;
  padding: var(--spacing-xxs);
  border-radius: var(--border-radius-lg);
`;
var bN = I.div`
  display: flex;
  flex-direction: column;
  justify-content: flex-start;
  min-width: 224px;
  padding: var(--spacing-xs) var(--spacing-md);
  cursor: pointer;
  border-radius: var(--border-radius-md);
  background-color: ${({ active: t4 }) => t4 ? "var(--bg-color-hover)" : "initial"};

  &:hover {
    background-color: var(--bg-color-hover);
  }
`;
var SN = I.span`
  display: flex;
  align-items: center;
  gap: var(--spacing-xxs);
  overflow: hidden;
  color: var(--text-color-primary);
  text-overflow: ellipsis;
  white-space: nowrap;
  font-size: var(--font-size-base);
  font-weight: var(--font-weight-regular);
  line-height: var(--line-height-base);
`;
var wN = I.span`
  color: var(--text-color-secondary);
  font-size: var(--font-size-sm);
  font-weight: var(--font-weight-regular);
  line-height: var(--line-height-sm);
  word-wrap: break-word;
`;
function rt({
  value: t4,
  environment: { variables: e },
  placeholder: n,
  className: r,
  onChange: i,
  dataTestId: o,
  editable: s = true,
  ...a
}) {
  const [l] = fe(crypto.randomUUID()), c = Ke(null), [u, f] = fe(false), [d, h] = fe(t4.length), [p, O] = fe(false), [m, x] = fe(
    Nl(t4, e, { inputId: l })
  ), [v, y, S, b] = gN(
    t4,
    d
  ), [w, C] = fe(null), [k, T] = fe(null), [A, E] = fe(false), $ = c.current && A && k && u && !w, j = We(
    () => fN(v, [...e.get({ noproxy: true })]),
    [v, e]
  ), { sendEvent: B } = gt(), D = Ue(
    (X, ee, de = true) => {
      i && X !== v && c.current && i(X, c.current), de && y(X, ee), x(Nl(X, e, { inputId: l })), h(ee);
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [i, v, e, l]
  );
  _e(() => {
    D(v, d);
  }, [e]), _e(() => {
    y(t4, t4.length > d ? d : t4.length), x(Nl(t4, e, { inputId: l })), h(t4.length > d ? d : t4.length);
  }, [t4]), _e(() => {
    u && cN(c, d);
  }, [d, u, m]), _e(() => {
    s || M(false, c.current);
  }, [s]), _e(() => {
    u && E(
      uN(v, d, [
        ...e.get({ noproxy: true })
      ])
    );
  }, [d, v, u, e]);
  const N = mN(() => {
    const X = window.getSelection();
    if (X && X.rangeCount > 0) {
      const ee = X == null ? void 0 : X.getRangeAt(0);
      if (ee.startOffset === ee.endOffset && ee.startContainer === ee.endContainer) {
        const de = lN(c.current, ee);
        h(de), T(X.getRangeAt(0).cloneRange()), C(null);
      } else
        C(X.getRangeAt(0).cloneRange());
    }
  }, 0), z = (X) => {
    s && (X.preventDefault(), Y(pN(X.clipboardData.getData("text"))));
  }, Z = (X) => {
    if (s && (X.preventDefault(), w && c.current)) {
      const ee = wb(w, c.current);
      p_.copyCustom(ee), Y("");
    }
  }, J = (X) => {
    if (!s)
      return;
    const ee = X.key, de = X.metaKey || X.ctrlKey;
    if (ee === "Tab" && O(true), ee === "ArrowUp" && $) {
      X.preventDefault();
      return;
    }
    if (ee === "Enter") {
      X.preventDefault();
      return;
    }
    if (de && ee === "Backspace") {
      X.preventDefault(), D("", 0);
      return;
    }
    if (ee === "Backspace") {
      if (X.preventDefault(), w) {
        Y("");
        return;
      }
      if (d === 0)
        return;
      D(
        v.slice(0, d - 1) + v.slice(d),
        d - 1
      );
    }
    if (ee === "Delete") {
      if (X.preventDefault(), w) {
        Y("");
        return;
      }
      if (d === v.length)
        return;
      D(
        v.slice(0, d) + v.slice(d + 1),
        d
      );
    }
    de && ee === "z" && (X.preventDefault(), X.shiftKey ? W() : L()), !de && ee.length === 1 && (X.preventDefault(), Y(ee));
  }, L = () => {
    const { value: X, cursorPosition: ee } = S();
    D(X, ee, false);
  }, W = () => {
    const { value: X, cursorPosition: ee } = b();
    D(X, ee, false);
  }, R = (X) => {
    const ee = X.target, de = C2(ee);
    (!de || de !== l) && (f(false), M(false, c.current));
  }, Q = (X) => {
    Y(`${bs}${X.name}${Ss}`), e.set((ee) => [...ee, X]), B("vi_new_variable_created", { name: X.name });
  }, _ = () => {
    C(null), B("vi_new_variable_creation_cancelled", {});
  }, G = () => {
    C(null);
  }, M = (X, ee) => {
    ee && (ee.contentEditable = X ? "true" : "false");
  }, K = () => {
    s && M(true, c.current);
  }, V = () => {
    u || M(false, c.current);
  }, ae = () => {
    K(), f(true);
  }, te = () => {
    p && (V(), f(false)), O(false);
  }, oe = () => {
    C(null);
  }, Y = (X) => {
    if (w && c.current) {
      const ee = w2(w, c.current), de = v.slice(0, ee.start) + X + v.slice(ee.end);
      D(de, ee.start + X.length), C(null);
    } else
      D(
        v.slice(0, d) + X + v.slice(d),
        d + X.length
      );
  }, he = (X) => {
    const ee = hN(v, X.name);
    Y(ee), E(false);
  };
  return /* @__PURE__ */ g.jsxs(CN, { "data-testid": o, children: [
    c.current && w && /* @__PURE__ */ g.jsx(
      iN,
      {
        range: w,
        value: wb(w, c.current) || "",
        inputId: l,
        onNewVariable: Q,
        onClose: _
      }
    ),
    $ && !!j.length && /* @__PURE__ */ g.jsx(
      xN,
      {
        range: k,
        onClose: G,
        onSelect: he,
        variables: j,
        inputId: l
      }
    ),
    /* @__PURE__ */ g.jsx(Fo, { onClickOutside: R, children: /* @__PURE__ */ g.jsx(
      kN,
      {
        ref: c,
        className: r,
        onFocus: ae,
        onBlur: te,
        $focused: u,
        onPaste: z,
        onCut: Z,
        onKeyDown: J,
        onSelect: N,
        onMouseDown: oe,
        onMouseLeave: V,
        onMouseEnter: K,
        onDragStart: (X) => X.preventDefault(),
        suppressContentEditableWarning: true,
        $placeholder: n,
        role: "input",
        tabIndex: 0,
        "data-gramm": "false",
        "data-gramm_editor": "false",
        "data-enable-grammarly": "false",
        ...a,
        children: s ? m : bA(
          t4,
          e.get({ noproxy: true })
        )
      }
    ) })
  ] });
}
var CN = I.div`
  position: relative;
  display: flex;
  flex-grow: 1;
  height: 100%;
  min-height: 40px;
`;
var kN = I.div`
  position: absolute;
  font-size: var(--font-size-base);
  width: 100%;
  padding: var(--input-padding) var(--spacing-sm);
  line-height: var(--line-height-lg);
  background-color: var(--bg-color);
  outline: none;
  overflow-wrap: break-word;
  -webkit-line-break: after-white-space;

  overflow: ${({ $focused: t4 }) => t4 ? "auto" : "hidden"};
  text-overflow: ${({ $focused: t4 }) => t4 ? "clip" : "ellipsis"};
  white-space: ${({ $focused: t4 }) => t4 ? "normal" : "nowrap"};

  &:empty:before {
    content: ${({ $placeholder: t4 }) => t4 ? `'${t4}'` : ""};
    pointer-events: none;
    display: block;
    color: var(--input-content-placeholder-color);
  }

  ${({ $focused: t4 }) => t4 && `
      background-color: var(--layer-color-raised);
      box-shadow: 0 8px 24px 8px rgba(0, 0, 0, 0.04), 0 4px 12px 0 rgba(0, 0, 0, 0.08);
      z-index: 1;
  `}
`;
function AN({ security: t4 }) {
  const {
    [H.APIKey]: { name: e, key: n }
  } = t4, { isRequestEditable: r } = je(), i = hn(), o = (s, a) => {
    a.dataset.name === "name" ? e.set(s) : n.set(s);
  };
  return /* @__PURE__ */ g.jsxs($i, { withBorder: true, children: [
    /* @__PURE__ */ g.jsxs(st, { children: [
      /* @__PURE__ */ g.jsx(He, { children: "Name" }),
      /* @__PURE__ */ g.jsx(Qe, {}),
      /* @__PURE__ */ g.jsx(
        rt,
        {
          dataTestId: "api-key-name",
          "data-name": "name",
          placeholder: "Name",
          value: e.get(),
          environment: i,
          editable: r.get(),
          onChange: o
        }
      )
    ] }),
    /* @__PURE__ */ g.jsx(Fe, {}),
    /* @__PURE__ */ g.jsxs(st, { children: [
      /* @__PURE__ */ g.jsx(He, { children: "API key" }),
      /* @__PURE__ */ g.jsx(Qe, {}),
      /* @__PURE__ */ g.jsx(
        rt,
        {
          dataTestId: "api-key-value",
          "data-name": "key",
          placeholder: "Enter API key",
          value: n.get(),
          environment: i,
          editable: r.get(),
          onChange: o
        }
      )
    ] })
  ] });
}
function PN({ security: t4 }) {
  const {
    [H.BasicAuth]: { username: e, password: n }
  } = t4, { isRequestEditable: r } = je(), i = hn(), o = (s, a) => {
    a.dataset.name === "username" ? e.set(s) : n.set(s);
  };
  return /* @__PURE__ */ g.jsxs($i, { children: [
    /* @__PURE__ */ g.jsxs(st, { children: [
      /* @__PURE__ */ g.jsx(He, { children: "Username" }),
      /* @__PURE__ */ g.jsx(Qe, {}),
      /* @__PURE__ */ g.jsx(
        rt,
        {
          "data-name": "username",
          placeholder: "Username",
          value: e.get(),
          environment: i,
          editable: r.get(),
          onChange: o
        }
      )
    ] }),
    /* @__PURE__ */ g.jsx(Fe, {}),
    /* @__PURE__ */ g.jsxs(st, { children: [
      /* @__PURE__ */ g.jsx(He, { children: "Password" }),
      /* @__PURE__ */ g.jsx(Qe, {}),
      /* @__PURE__ */ g.jsx(
        rt,
        {
          "data-name": "password",
          placeholder: "Password",
          value: n.get(),
          environment: i,
          editable: r.get(),
          onChange: o
        }
      )
    ] }),
    /* @__PURE__ */ g.jsx(Fe, {})
  ] });
}
function EN({ security: t4 }) {
  const {
    [H.JWT]: { token: e }
  } = t4, { isRequestEditable: n } = je(), r = hn(), i = (o) => {
    e.set(o);
  };
  return /* @__PURE__ */ g.jsxs($i, { direction: "row", withBorder: true, children: [
    /* @__PURE__ */ g.jsx(He, { children: "Bearer Token" }),
    /* @__PURE__ */ g.jsx(Qe, {}),
    /* @__PURE__ */ g.jsx(
      rt,
      {
        placeholder: "Token",
        value: e.get(),
        environment: r,
        editable: n.get(),
        onChange: i
      }
    )
  ] });
}
function Wg() {
  const [t4, e] = fe(false), n = Ue(() => {
    e(true);
  }, []), r = Ue(() => {
    e(false);
  }, []);
  return {
    isOpen: t4,
    handleOpen: n,
    handleClose: r
  };
}
function A2({
  title: t4,
  expanded: e = false,
  children: n
}) {
  const [r, i] = fe(e);
  return /* @__PURE__ */ g.jsxs(TN, { children: [
    /* @__PURE__ */ g.jsxs(IN, { onClick: () => i(!r), children: [
      /* @__PURE__ */ g.jsx($N, { children: t4 }),
      r ? /* @__PURE__ */ g.jsx(ChevronDownIcon, { size: "14px", color: "--text-color-secondary" }) : /* @__PURE__ */ g.jsx(ChevronRightIcon, { size: "14px", color: "--text-color-secondary" })
    ] }),
    r && n
  ] });
}
var TN = I.div`
  display: flex;
  flex-direction: column;
  color: var(--text-color-secondary);
  min-height: 40px;
`;
var IN = I.div`
  display: flex;
  flex-direction: row;
  align-items: center;
  gap: var(--spacing-xs);
  cursor: pointer;
  height: 40px;
`;
var $N = I.span`
  font-size: var(--font-size-base);
  font-weight: var(--font-weight-medium);
`;
function P2({ children: t4, onClick: e, className: n }) {
  const r = Ke(false), i = (o) => {
    o.target === o.currentTarget && (e == null || e(o));
  };
  return /* @__PURE__ */ g.jsx(
    jN,
    {
      className: n,
      onMouseDown: () => r.current = false,
      onMouseMove: () => r.current = true,
      onMouseUp: (o) => {
        r.current || i(o);
      },
      children: t4
    }
  );
}
var jN = I.div`
  display: flex;
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  justify-content: flex-end;
  background-color: rgba(0, 0, 0, 0.3);
  z-index: var(--z-index-overlay);
`;
function RN({ isOpen: t4, title: e, content: n, onClose: r, mountId: i, className: o }) {
  const s = Ke(null);
  return useModalScrollLock(t4), _e(() => {
    s.current && s.current.focus();
  }, []), t4 ? /* @__PURE__ */ g.jsx(Portal, { mountId: i, children: /* @__PURE__ */ g.jsx(P2, { className: o, children: /* @__PURE__ */ g.jsxs(E2, { children: [
    /* @__PURE__ */ g.jsxs(DN, { className: "modal-header", children: [
      /* @__PURE__ */ g.jsx(H4, { children: e }),
      /* @__PURE__ */ g.jsx(Button, { variant: "ghost", onClick: r, icon: /* @__PURE__ */ g.jsx(CloseIcon, { size: "18px" }), autoFocus: true })
    ] }),
    /* @__PURE__ */ g.jsx(T2, { className: "modal-content", children: n })
  ] }) }) }) : null;
}
var Uf = no(RN);
var E2 = I.div`
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background-color: var(--bg-color-raised);
  border-radius: var(--border-radius-lg);
  min-width: 720px;
`;
var DN = I.header`
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: var(--spacing-lg);

  ${H4} {
    margin: 0;
  }

  ${CloseIcon} {
    cursor: pointer;
  }
`;
var T2 = I.div`
  padding: var(--spacing-xxl) var(--spacing-lg) var(--spacing-lg);
`;
function QN(t4 = 32) {
  let e = "";
  for (; e.length < t4; )
    e += Math.random().toString(32).substring(2);
  return e.substring(0, t4);
}
async function BN(t4) {
  const e = new TextEncoder().encode(t4);
  return crypto == null ? void 0 : crypto.subtle.digest("SHA-256", e);
}
function _N(t4) {
  if (t4)
    return btoa(String.fromCharCode.apply(null, new Uint8Array(t4))).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
}
function An(t4) {
  const e = /* @__PURE__ */ new WeakMap();
  function n(r) {
    if (typeof r != "object" || r === null)
      return r;
    if (e.has(r))
      return e.get(r);
    const i = Array.isArray(r) ? [] : {};
    e.set(r, i);
    for (const o in r)
      Object.prototype.hasOwnProperty.call(r, o) && (i[o] = n(r[o]));
    return i;
  }
  return n(t4);
}
function Vg(t4, e) {
  if (t4 === e)
    return true;
  if (t4 && e && typeof t4 == "object" && typeof e == "object") {
    if (Array.isArray(t4) && Array.isArray(e)) {
      if (t4.length !== e.length)
        return false;
      for (let i = 0; i < t4.length; i++)
        if (!Vg(t4[i], e[i]))
          return false;
      return true;
    }
    const n = Object.keys(t4), r = Object.keys(e);
    if (n.length !== r.length)
      return false;
    for (let i = 0; i < n.length; i++) {
      const o = n[i];
      if (!Object.prototype.hasOwnProperty.call(e, o) || !Vg(t4[o], e[o]))
        return false;
    }
    return true;
  }
  return t4 !== t4 && e !== e;
}
function Hf(t4) {
  if (typeof t4 != "object" || t4 === null)
    return t4;
  if (Array.isArray(t4))
    return t4.map(Hf);
  const e = {};
  for (const n in t4)
    Object.prototype.hasOwnProperty.call(t4, n) && n !== "id" && (e[n] = Hf(t4[n]));
  return e;
}
function Cb(t4) {
  return Object.keys(t4).forEach((e) => {
    t4[e] === void 0 && delete t4[e];
  }), t4;
}
var Yk;
var as = ((Yk = window.__TAURI__) == null ? void 0 : Yk.http.fetch) ?? globalThis.fetch;
var kb = "/_auth/oauth2-redirect.html";
var hh = class Al {
  static authorizeImplicit({
    authorizationUrl: e,
    clientId: n,
    scopes: r,
    extraAuthParams: i = {},
    routingBasePath: o = "/",
    redirectUri: s,
    successCallback: a,
    errorCallback: l
  }) {
    const c = Ab({
      date: (/* @__PURE__ */ new Date()).toString()
    });
    try {
      const u = new URL(e), f = o === "/" ? "" : o, d = `${window.location.origin}${f}${kb}`;
      u.searchParams.set("client_id", n), u.searchParams.set("redirect_uri", s || d), u.searchParams.set("response_type", "token"), u.searchParams.set("state", c), Array.isArray(r) && u.searchParams.set("scope", r.join(" "));
      for (const h in i)
        u.searchParams.set(h, i[h]);
      window.redirectOAuth2 = {
        flow: "implicit",
        data: { authorizationUrl: e, clientId: n, scopes: r },
        state: c,
        successCallback: (h) => {
          a(h), Al.clearRedirectData("implicit");
        },
        errorCallback: (h) => {
          l(h), Al.clearRedirectData("implicit");
        }
      }, window.open(u.toString());
    } catch (u) {
      l(u);
    }
  }
  static async authorizeAuthorizationCode({
    authorizationUrl: e,
    tokenUrl: n,
    clientId: r,
    clientSecret: i,
    codeVerifier: o,
    codeChallenge: s,
    scopes: a,
    extraAuthParams: l = {},
    extraTokenHeaders: c = {},
    extraTokenBody: u = {},
    extraTokenParams: f = {},
    routingBasePath: d = "/",
    redirectUri: h,
    successCallback: p,
    errorCallback: O
  }) {
    try {
      const m = new URL(e), x = new URL(n), v = d === "/" ? "" : d, y = `${window.location.origin}${v}${kb}`, S = Ab({
        date: (/* @__PURE__ */ new Date()).toString()
      });
      m.searchParams.set("client_id", r), m.searchParams.set("redirect_uri", h || y), m.searchParams.set("response_type", "code"), m.searchParams.set("state", S), Array.isArray(a) && m.searchParams.set("scope", a.join(" ")), !s && !o && (o = FN(), s = await MN(o)), s && (m.searchParams.set("code_challenge", s), m.searchParams.set("code_challenge_method", "S256"));
      for (const b in l)
        m.searchParams.set(b, l[b]);
      for (const b in f)
        x.searchParams.set(b, f[b]);
      window.redirectOAuth2 = {
        flow: "authorizationCode",
        data: { authorizationUrl: e, clientId: r, scopes: a },
        state: S,
        successCallback: async ({ auth_code: b }) => {
          const w = An({
            client_id: r,
            client_secret: i,
            ...o && { code_verifier: o },
            code: b,
            grant_type: "authorization_code",
            redirect_uri: h || y,
            ...u
          });
          try {
            const C = await as(x, {
              method: "POST",
              headers: {
                "Content-Type": "application/x-www-form-urlencoded;charset=UTF-8",
                ...c
              },
              body: new URLSearchParams(w).toString()
            });
            await Cp(C, p, O);
          } catch (C) {
            O(C);
          }
          Al.clearRedirectData("authorizationCode");
        },
        errorCallback: (b) => {
          O(b), Al.clearRedirectData("authorizationCode");
        }
      }, window.open(m.toString());
    } catch (m) {
      O(m);
    }
  }
  static clearRedirectData(e) {
    window.redirectOAuth2 = {
      flow: e,
      data: { authorizationUrl: "", clientId: "", scopes: [] },
      state: "",
      successCallback: () => {
      },
      errorCallback: () => {
      }
    };
  }
  static async authorizeClientCredentials({
    tokenUrl: e,
    clientId: n,
    clientSecret: r,
    scopes: i = [],
    extraTokenParams: o = {},
    extraTokenHeaders: s = {},
    extraTokenBody: a = {},
    corsProxyUrl: l,
    assertionType: c,
    clientAssertion: u,
    successCallback: f,
    errorCallback: d
  }) {
    try {
      const h = {
        client_id: n,
        client_secret: r,
        grant_type: "client_credentials",
        scope: Array.isArray(i) && i.length ? i.join(" ") : void 0,
        client_assertion_type: c,
        client_assertion: u,
        ...a
      }, p = l ? `${l}${e}` : e, O = new URL(p);
      for (const x in o)
        O.searchParams.set(x, o[x]);
      const m = await as(p, {
        method: "POST",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded;charset=UTF-8",
          ...s
        },
        body: new URLSearchParams(Cb(h)).toString()
      });
      await Cp(m, f, d);
    } catch (h) {
      d(h);
    }
  }
  static async authorizePasswordGrant({
    username: e,
    password: n,
    tokenUrl: r,
    clientId: i,
    clientSecret: o,
    scopes: s = [],
    extraTokenParams: a = {},
    extraTokenHeaders: l = {},
    extraTokenBody: c = {},
    corsProxyUrl: u,
    successCallback: f,
    errorCallback: d
  }) {
    try {
      const h = {
        client_id: i,
        client_secret: o,
        grant_type: "password",
        username: e,
        password: n,
        scope: Array.isArray(s) && s.length ? s.join(" ") : void 0,
        ...c
      }, p = u ? `${u}${r}` : r, O = new URL(p);
      for (const x in a)
        O.searchParams.set(x, a[x]);
      const m = await as(p, {
        method: "POST",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded;charset=UTF-8",
          ...l
        },
        body: new URLSearchParams(Cb(h)).toString()
      });
      await Cp(m, f, d);
    } catch (h) {
      d(h);
    }
  }
};
function Ab(t4) {
  const e = {
    randomStr: QN(),
    ...t4
  };
  return btoa(JSON.stringify(e));
}
async function Cp(t4, e, n) {
  if (t4.ok) {
    const r = await t4.json();
    e(r);
  } else
    n(
      new Error(
        (t4.headers.get("Content-Type") || "").indexOf("json") > -1 ? JSON.stringify(await t4.json()) : await t4.text()
      )
    );
}
async function MN(t4) {
  return _N(await BN(t4));
}
function NN(t4) {
  return ("0" + t4.toString(16)).substring(-2);
}
function FN() {
  const t4 = new Uint32Array(28);
  return crypto.getRandomValues(t4), Array.from(t4, NN).join("");
}
function Sa({
  title: t4,
  onParameterChange: e,
  actions: n,
  elements: r,
  keyName: i,
  environment: o,
  renderDescription: s,
  singleValue: a = false,
  hideOuterBorders: l,
  valuePlaceholder: c = "Value",
  editable: u = true,
  additionalParameters: f
}) {
  return /* @__PURE__ */ g.jsxs(ZN, { children: [
    t4 && /* @__PURE__ */ g.jsx(WN, { children: t4 }),
    /* @__PURE__ */ g.jsx(VN, { $hideBorder: !!l, children: r.map((d, h) => {
      const p = h === r.length - 1, { value: O, key: m, active: x, id: v } = d.get(), y = a ? O : true;
      return /* @__PURE__ */ g.jsxs(zN, { $hideBorder: !!(l && p), children: [
        y && /* @__PURE__ */ g.jsx(LN, { children: (O || !p) && /* @__PURE__ */ g.jsxs(g.Fragment, { children: [
          /* @__PURE__ */ g.jsx(
            XN,
            {
              "data-testid": `parameter-checkbox-${h}`,
              type: "checkbox",
              checked: x,
              onChange: ({ target: S }) => {
                d.active.set(S.checked), e(d, p);
              }
            }
          ),
          /* @__PURE__ */ g.jsx(GN, { checked: x })
        ] }) }),
        !a && /* @__PURE__ */ g.jsxs(g.Fragment, { children: [
          /* @__PURE__ */ g.jsx(Qe, {}),
          /* @__PURE__ */ g.jsxs(qN, { children: [
            /* @__PURE__ */ g.jsx(
              rt,
              {
                "data-testid": `parameter-name-${h}`,
                placeholder: `${p ? "New " : ""}${i}`,
                value: m,
                environment: o,
                editable: u,
                onChange: (S) => {
                  d.nested("key").set(S), e(d, p);
                }
              }
            ),
            s == null ? void 0 : s(m)
          ] }),
          /* @__PURE__ */ g.jsx(Qe, {})
        ] }),
        /* @__PURE__ */ g.jsx(
          rt,
          {
            "data-testid": `parameter-value-${h}`,
            placeholder: c,
            value: O,
            environment: o,
            editable: u,
            onChange: (S) => {
              d.get().value === "" && S !== "" && d.active.set(true), d.nested("value").set(S), e(d, p);
            }
          }
        ),
        /* @__PURE__ */ g.jsx(Qe, {}),
        f == null ? void 0 : f(d),
        /* @__PURE__ */ g.jsx(YN, { children: (O || !p) && n(h) })
      ] }, v);
    }) })
  ] });
}
var ZN = I.div`
  display: flex;
  flex-direction: column;
  gap: var(--spacing-xs);
  min-width: 450px;
  width: 100%;
`;
var WN = I.div`
  font-size: var(--font-size-base);
  line-height: var(--line-height-base);
`;
var VN = I.div`
  display: flex;
  flex-direction: column;
  border-top: ${({ $hideBorder: t4 }) => t4 ? "none" : "1px solid var(--border-color-secondary)"};
`;
var zN = I.div`
  display: flex;
  flex-direction: row;
  border-bottom: ${({ $hideBorder: t4 }) => t4 ? "none" : "1px solid var(--border-color-secondary)"};
  align-items: center;
  flex-wrap: nowrap;
`;
var LN = I.div`
  display: flex;
  justify-content: center;
  min-width: 28px;
  align-items: center;
  position: relative;
`;
var XN = I.input`
  opacity: 0;
  width: 16px;
  height: 16px;

  position: absolute;
  margin: auto;

  &:checked {
    accent-color: black;
  }
`;
var GN = I(CheckboxIcon)`
  left: 0;
  top: 0;
  right: 0;
  width: 16px;
  height: 16px;

  svg {
    fill: ${({ checked: t4 }) => t4 ? "var(--color-primary-hover)" : "var(--bg-color)"};
    --checkbox-border-color: var(--border-color-secondary);
    --checkbox-mark-color: var(--bg-color);
  }
`;
var YN = I.div`
  display: flex;
  justify-content: center;
  min-width: 28px;
`;
var qN = I.div`
  display: flex;
  flex: 1;
`;
function mx({ scopes: t4, environment: e, editable: n }) {
  const r = (o, s) => {
    s && t4.merge([mn()]);
  }, i = (o) => {
    t4[o].set(pt);
  };
  return /* @__PURE__ */ g.jsx(UN, { children: /* @__PURE__ */ g.jsx(
    Sa,
    {
      keyName: "Scopes",
      elements: t4,
      onParameterChange: r,
      environment: e,
      actions: (o) => /* @__PURE__ */ g.jsx(
        Nr,
        {
          onClick: () => i(o),
          variant: "text",
          icon: /* @__PURE__ */ g.jsx(TrashCanIcon, {})
        }
      ),
      singleValue: true,
      hideOuterBorders: true,
      valuePlaceholder: "New scope item",
      editable: n
    }
  ) });
}
var UN = I.div`
  width: 100%;
`;
function bn(t4, e, n) {
  const r = tN(e.get(), n);
  r ? r.nested("value").set(t4) : e.set(t4);
}
var Pb = Object.values(Qr).map((t4) => ({
  label: /* @__PURE__ */ g.jsx("div", { children: t4 }),
  value: t4
}));
function HN({ param: t4 }) {
  const e = ({ value: n }) => {
    t4.set({ ...t4.get(), sendIn: n });
  };
  return /* @__PURE__ */ g.jsx(JN, { children: /* @__PURE__ */ g.jsx(
    Mo,
    {
      dataTestId: "send-in-select",
      options: Pb,
      value: Pb.find(({ value: n }) => n == t4.get().sendIn),
      onChange: e
    }
  ) });
}
function ph({
  environment: t4,
  isRequestEditable: e,
  authRequestExtraParameters: n,
  tokenRequestExtraParameters: r,
  hideAuthRequestExtraParameters: i,
  hideTokenRequestExtraParameters: o
}) {
  const s = (u, f) => {
    f && n.merge([mn()]);
  }, a = (u) => {
    n[u].set(pt);
  }, l = (u, f) => {
    f && r.merge([wA()]);
  }, c = (u) => {
    r[u].set(pt);
  };
  return /* @__PURE__ */ g.jsxs(A2, { title: "Advanced options", expanded: true, children: [
    /* @__PURE__ */ g.jsx(Fe, {}),
    !i && /* @__PURE__ */ g.jsx(Eb, { children: /* @__PURE__ */ g.jsx(
      Sa,
      {
        title: "Auth Request Extra Parameters",
        elements: n,
        onParameterChange: s,
        keyName: "Key",
        environment: t4,
        editable: e,
        actions: (u) => /* @__PURE__ */ g.jsx(
          Nr,
          {
            onClick: () => a(u),
            variant: "text",
            icon: /* @__PURE__ */ g.jsx(TrashCanIcon, {})
          }
        )
      }
    ) }),
    !o && /* @__PURE__ */ g.jsx(Eb, { children: /* @__PURE__ */ g.jsx(
      Sa,
      {
        title: "Token Request Extra Parameters",
        elements: r,
        onParameterChange: l,
        keyName: "Key",
        environment: t4,
        editable: e,
        actions: (u) => /* @__PURE__ */ g.jsx(
          Nr,
          {
            onClick: () => c(u),
            variant: "text",
            icon: /* @__PURE__ */ g.jsx(TrashCanIcon, {})
          }
        ),
        additionalParameters: (u) => /* @__PURE__ */ g.jsx(
          HN,
          {
            param: u
          }
        )
      }
    ) })
  ] });
}
var Eb = I.div`
  margin-top: var(--spacing-base);
`;
var JN = I.div`
  width: 124px;
  padding: 0 var(--spacing-xs);
`;
function qr(t4, e, n) {
  return t4.filter(
    (r) => r.active && r.key && r.value && (Tb(r) && n === r.sendIn || !Tb(r))
  ).reduce(
    (r, i) => (r[qe(i.key, e)] = i.value, r),
    {}
  );
}
function Tb(t4) {
  return t4.sendIn !== void 0;
}
var ft = class {
  /**
  Get the line description around the given position.
  */
  lineAt(e) {
    if (e < 0 || e > this.length)
      throw new RangeError(`Invalid position ${e} in document of length ${this.length}`);
    return this.lineInner(e, false, 1, 0);
  }
  /**
  Get the description for the given (1-based) line number.
  */
  line(e) {
    if (e < 1 || e > this.lines)
      throw new RangeError(`Invalid line number ${e} in ${this.lines}-line document`);
    return this.lineInner(e, true, 1, 0);
  }
  /**
  Replace a range of the text with the given content.
  */
  replace(e, n, r) {
    [e, n] = wa(this, e, n);
    let i = [];
    return this.decompose(
      0,
      e,
      i,
      2
      /* Open.To */
    ), r.length && r.decompose(
      0,
      r.length,
      i,
      3
      /* Open.To */
    ), this.decompose(
      n,
      this.length,
      i,
      1
      /* Open.From */
    ), pi.from(i, this.length - (n - e) + r.length);
  }
  /**
  Append another document to this one.
  */
  append(e) {
    return this.replace(this.length, this.length, e);
  }
  /**
  Retrieve the text between the given points.
  */
  slice(e, n = this.length) {
    [e, n] = wa(this, e, n);
    let r = [];
    return this.decompose(e, n, r, 0), pi.from(r, n - e);
  }
  /**
  Test whether this text is equal to another instance.
  */
  eq(e) {
    if (e == this)
      return true;
    if (e.length != this.length || e.lines != this.lines)
      return false;
    let n = this.scanIdentical(e, 1), r = this.length - this.scanIdentical(e, -1), i = new Fl(this), o = new Fl(e);
    for (let s = n, a = n; ; ) {
      if (i.next(s), o.next(s), s = 0, i.lineBreak != o.lineBreak || i.done != o.done || i.value != o.value)
        return false;
      if (a += i.value.length, i.done || a >= r)
        return true;
    }
  }
  /**
  Iterate over the text. When `dir` is `-1`, iteration happens
  from end to start. This will return lines and the breaks between
  them as separate strings.
  */
  iter(e = 1) {
    return new Fl(this, e);
  }
  /**
  Iterate over a range of the text. When `from` > `to`, the
  iterator will run in reverse.
  */
  iterRange(e, n = this.length) {
    return new I2(this, e, n);
  }
  /**
  Return a cursor that iterates over the given range of lines,
  _without_ returning the line breaks between, and yielding empty
  strings for empty lines.
  
  When `from` and `to` are given, they should be 1-based line numbers.
  */
  iterLines(e, n) {
    let r;
    if (e == null)
      r = this.iter();
    else {
      n == null && (n = this.lines + 1);
      let i = this.line(e).from;
      r = this.iterRange(i, Math.max(i, n == this.lines + 1 ? this.length : n <= 1 ? 0 : this.line(n - 1).to));
    }
    return new $2(r);
  }
  /**
  Return the document as a string, using newline characters to
  separate lines.
  */
  toString() {
    return this.sliceString(0);
  }
  /**
  Convert the document to an array of lines (which can be
  deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).
  */
  toJSON() {
    let e = [];
    return this.flatten(e), e;
  }
  /**
  @internal
  */
  constructor() {
  }
  /**
  Create a `Text` instance for the given array of lines.
  */
  static of(e) {
    if (e.length == 0)
      throw new RangeError("A document must have at least one line");
    return e.length == 1 && !e[0] ? ft.empty : e.length <= 32 ? new Ut(e) : pi.from(Ut.split(e, []));
  }
};
var Ut = class extends ft {
  constructor(e, n = KN(e)) {
    super(), this.text = e, this.length = n;
  }
  get lines() {
    return this.text.length;
  }
  get children() {
    return null;
  }
  lineInner(e, n, r, i) {
    for (let o = 0; ; o++) {
      let s = this.text[o], a = i + s.length;
      if ((n ? r : a) >= e)
        return new eF(i, a, r, s);
      i = a + 1, r++;
    }
  }
  decompose(e, n, r, i) {
    let o = e <= 0 && n >= this.length ? this : new Ut(Ib(this.text, e, n), Math.min(n, this.length) - Math.max(0, e));
    if (i & 1) {
      let s = r.pop(), a = lf(o.text, s.text.slice(), 0, o.length);
      if (a.length <= 32)
        r.push(new Ut(a, s.length + o.length));
      else {
        let l = a.length >> 1;
        r.push(new Ut(a.slice(0, l)), new Ut(a.slice(l)));
      }
    } else
      r.push(o);
  }
  replace(e, n, r) {
    if (!(r instanceof Ut))
      return super.replace(e, n, r);
    [e, n] = wa(this, e, n);
    let i = lf(this.text, lf(r.text, Ib(this.text, 0, e)), n), o = this.length + r.length - (n - e);
    return i.length <= 32 ? new Ut(i, o) : pi.from(Ut.split(i, []), o);
  }
  sliceString(e, n = this.length, r = `
`) {
    [e, n] = wa(this, e, n);
    let i = "";
    for (let o = 0, s = 0; o <= n && s < this.text.length; s++) {
      let a = this.text[s], l = o + a.length;
      o > e && s && (i += r), e < l && n > o && (i += a.slice(Math.max(0, e - o), n - o)), o = l + 1;
    }
    return i;
  }
  flatten(e) {
    for (let n of this.text)
      e.push(n);
  }
  scanIdentical() {
    return 0;
  }
  static split(e, n) {
    let r = [], i = -1;
    for (let o of e)
      r.push(o), i += o.length + 1, r.length == 32 && (n.push(new Ut(r, i)), r = [], i = -1);
    return i > -1 && n.push(new Ut(r, i)), n;
  }
};
var pi = class extends ft {
  constructor(e, n) {
    super(), this.children = e, this.length = n, this.lines = 0;
    for (let r of e)
      this.lines += r.lines;
  }
  lineInner(e, n, r, i) {
    for (let o = 0; ; o++) {
      let s = this.children[o], a = i + s.length, l = r + s.lines - 1;
      if ((n ? l : a) >= e)
        return s.lineInner(e, n, r, i);
      i = a + 1, r = l + 1;
    }
  }
  decompose(e, n, r, i) {
    for (let o = 0, s = 0; s <= n && o < this.children.length; o++) {
      let a = this.children[o], l = s + a.length;
      if (e <= l && n >= s) {
        let c = i & ((s <= e ? 1 : 0) | (l >= n ? 2 : 0));
        s >= e && l <= n && !c ? r.push(a) : a.decompose(e - s, n - s, r, c);
      }
      s = l + 1;
    }
  }
  replace(e, n, r) {
    if ([e, n] = wa(this, e, n), r.lines < this.lines)
      for (let i = 0, o = 0; i < this.children.length; i++) {
        let s = this.children[i], a = o + s.length;
        if (e >= o && n <= a) {
          let l = s.replace(e - o, n - o, r), c = this.lines - s.lines + l.lines;
          if (l.lines < c >> 4 && l.lines > c >> 6) {
            let u = this.children.slice();
            return u[i] = l, new pi(u, this.length - (n - e) + r.length);
          }
          return super.replace(o, a, l);
        }
        o = a + 1;
      }
    return super.replace(e, n, r);
  }
  sliceString(e, n = this.length, r = `
`) {
    [e, n] = wa(this, e, n);
    let i = "";
    for (let o = 0, s = 0; o < this.children.length && s <= n; o++) {
      let a = this.children[o], l = s + a.length;
      s > e && o && (i += r), e < l && n > s && (i += a.sliceString(e - s, n - s, r)), s = l + 1;
    }
    return i;
  }
  flatten(e) {
    for (let n of this.children)
      n.flatten(e);
  }
  scanIdentical(e, n) {
    if (!(e instanceof pi))
      return 0;
    let r = 0, [i, o, s, a] = n > 0 ? [0, 0, this.children.length, e.children.length] : [this.children.length - 1, e.children.length - 1, -1, -1];
    for (; ; i += n, o += n) {
      if (i == s || o == a)
        return r;
      let l = this.children[i], c = e.children[o];
      if (l != c)
        return r + l.scanIdentical(c, n);
      r += l.length + 1;
    }
  }
  static from(e, n = e.reduce((r, i) => r + i.length + 1, -1)) {
    let r = 0;
    for (let h of e)
      r += h.lines;
    if (r < 32) {
      let h = [];
      for (let p of e)
        p.flatten(h);
      return new Ut(h, n);
    }
    let i = Math.max(
      32,
      r >> 5
      /* Tree.BranchShift */
    ), o = i << 1, s = i >> 1, a = [], l = 0, c = -1, u = [];
    function f(h) {
      let p;
      if (h.lines > o && h instanceof pi)
        for (let O of h.children)
          f(O);
      else
        h.lines > s && (l > s || !l) ? (d(), a.push(h)) : h instanceof Ut && l && (p = u[u.length - 1]) instanceof Ut && h.lines + p.lines <= 32 ? (l += h.lines, c += h.length + 1, u[u.length - 1] = new Ut(p.text.concat(h.text), p.length + 1 + h.length)) : (l + h.lines > i && d(), l += h.lines, c += h.length + 1, u.push(h));
    }
    function d() {
      l != 0 && (a.push(u.length == 1 ? u[0] : pi.from(u, c)), c = -1, l = u.length = 0);
    }
    for (let h of e)
      f(h);
    return d(), a.length == 1 ? a[0] : new pi(a, n);
  }
};
ft.empty = /* @__PURE__ */ new Ut([""], 0);
function KN(t4) {
  let e = -1;
  for (let n of t4)
    e += n.length + 1;
  return e;
}
function lf(t4, e, n = 0, r = 1e9) {
  for (let i = 0, o = 0, s = true; o < t4.length && i <= r; o++) {
    let a = t4[o], l = i + a.length;
    l >= n && (l > r && (a = a.slice(0, r - i)), i < n && (a = a.slice(n - i)), s ? (e[e.length - 1] += a, s = false) : e.push(a)), i = l + 1;
  }
  return e;
}
function Ib(t4, e, n) {
  return lf(t4, [""], e, n);
}
var Fl = class {
  constructor(e, n = 1) {
    this.dir = n, this.done = false, this.lineBreak = false, this.value = "", this.nodes = [e], this.offsets = [n > 0 ? 1 : (e instanceof Ut ? e.text.length : e.children.length) << 1];
  }
  nextInner(e, n) {
    for (this.done = this.lineBreak = false; ; ) {
      let r = this.nodes.length - 1, i = this.nodes[r], o = this.offsets[r], s = o >> 1, a = i instanceof Ut ? i.text.length : i.children.length;
      if (s == (n > 0 ? a : 0)) {
        if (r == 0)
          return this.done = true, this.value = "", this;
        n > 0 && this.offsets[r - 1]++, this.nodes.pop(), this.offsets.pop();
      } else if ((o & 1) == (n > 0 ? 0 : 1)) {
        if (this.offsets[r] += n, e == 0)
          return this.lineBreak = true, this.value = `
`, this;
        e--;
      } else if (i instanceof Ut) {
        let l = i.text[s + (n < 0 ? -1 : 0)];
        if (this.offsets[r] += n, l.length > Math.max(0, e))
          return this.value = e == 0 ? l : n > 0 ? l.slice(e) : l.slice(0, l.length - e), this;
        e -= l.length;
      } else {
        let l = i.children[s + (n < 0 ? -1 : 0)];
        e > l.length ? (e -= l.length, this.offsets[r] += n) : (n < 0 && this.offsets[r]--, this.nodes.push(l), this.offsets.push(n > 0 ? 1 : (l instanceof Ut ? l.text.length : l.children.length) << 1));
      }
    }
  }
  next(e = 0) {
    return e < 0 && (this.nextInner(-e, -this.dir), e = this.value.length), this.nextInner(e, this.dir);
  }
};
var I2 = class {
  constructor(e, n, r) {
    this.value = "", this.done = false, this.cursor = new Fl(e, n > r ? -1 : 1), this.pos = n > r ? e.length : 0, this.from = Math.min(n, r), this.to = Math.max(n, r);
  }
  nextInner(e, n) {
    if (n < 0 ? this.pos <= this.from : this.pos >= this.to)
      return this.value = "", this.done = true, this;
    e += Math.max(0, n < 0 ? this.pos - this.to : this.from - this.pos);
    let r = n < 0 ? this.pos - this.from : this.to - this.pos;
    e > r && (e = r), r -= e;
    let { value: i } = this.cursor.next(e);
    return this.pos += (i.length + e) * n, this.value = i.length <= r ? i : n < 0 ? i.slice(i.length - r) : i.slice(0, r), this.done = !this.value, this;
  }
  next(e = 0) {
    return e < 0 ? e = Math.max(e, this.from - this.pos) : e > 0 && (e = Math.min(e, this.to - this.pos)), this.nextInner(e, this.cursor.dir);
  }
  get lineBreak() {
    return this.cursor.lineBreak && this.value != "";
  }
};
var $2 = class {
  constructor(e) {
    this.inner = e, this.afterBreak = true, this.value = "", this.done = false;
  }
  next(e = 0) {
    let { done: n, lineBreak: r, value: i } = this.inner.next(e);
    return n && this.afterBreak ? (this.value = "", this.afterBreak = false) : n ? (this.done = true, this.value = "") : r ? this.afterBreak ? this.value = "" : (this.afterBreak = true, this.next()) : (this.value = i, this.afterBreak = false), this;
  }
  get lineBreak() {
    return false;
  }
};
typeof Symbol < "u" && (ft.prototype[Symbol.iterator] = function() {
  return this.iter();
}, Fl.prototype[Symbol.iterator] = I2.prototype[Symbol.iterator] = $2.prototype[Symbol.iterator] = function() {
  return this;
});
var eF = class {
  /**
  @internal
  */
  constructor(e, n, r, i) {
    this.from = e, this.to = n, this.number = r, this.text = i;
  }
  /**
  The length of the line (not including any line break after it).
  */
  get length() {
    return this.to - this.from;
  }
};
function wa(t4, e, n) {
  return e = Math.max(0, Math.min(t4.length, e)), [e, Math.max(e, Math.min(t4.length, n))];
}
var sa = /* @__PURE__ */ "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((t4) => t4 ? parseInt(t4, 36) : 1);
for (let t4 = 1; t4 < sa.length; t4++)
  sa[t4] += sa[t4 - 1];
function tF(t4) {
  for (let e = 1; e < sa.length; e += 2)
    if (sa[e] > t4)
      return sa[e - 1] <= t4;
  return false;
}
function $b(t4) {
  return t4 >= 127462 && t4 <= 127487;
}
var jb = 8205;
function $n(t4, e, n = true, r = true) {
  return (n ? j2 : nF)(t4, e, r);
}
function j2(t4, e, n) {
  if (e == t4.length)
    return e;
  e && R2(t4.charCodeAt(e)) && D2(t4.charCodeAt(e - 1)) && e--;
  let r = Pn(t4, e);
  for (e += jr(r); e < t4.length; ) {
    let i = Pn(t4, e);
    if (r == jb || i == jb || n && tF(i))
      e += jr(i), r = i;
    else if ($b(i)) {
      let o = 0, s = e - 2;
      for (; s >= 0 && $b(Pn(t4, s)); )
        o++, s -= 2;
      if (o % 2 == 0)
        break;
      e += 2;
    } else
      break;
  }
  return e;
}
function nF(t4, e, n) {
  for (; e > 0; ) {
    let r = j2(t4, e - 2, n);
    if (r < e)
      return r;
    e--;
  }
  return 0;
}
function R2(t4) {
  return t4 >= 56320 && t4 < 57344;
}
function D2(t4) {
  return t4 >= 55296 && t4 < 56320;
}
function Pn(t4, e) {
  let n = t4.charCodeAt(e);
  if (!D2(n) || e + 1 == t4.length)
    return n;
  let r = t4.charCodeAt(e + 1);
  return R2(r) ? (n - 55296 << 10) + (r - 56320) + 65536 : n;
}
function Ox(t4) {
  return t4 <= 65535 ? String.fromCharCode(t4) : (t4 -= 65536, String.fromCharCode((t4 >> 10) + 55296, (t4 & 1023) + 56320));
}
function jr(t4) {
  return t4 < 65536 ? 1 : 2;
}
var zg = /\r\n?|\n/;
var Tn = /* @__PURE__ */ function(t4) {
  return t4[t4.Simple = 0] = "Simple", t4[t4.TrackDel = 1] = "TrackDel", t4[t4.TrackBefore = 2] = "TrackBefore", t4[t4.TrackAfter = 3] = "TrackAfter", t4;
}(Tn || (Tn = {}));
var wi = class {
  // Sections are encoded as pairs of integers. The first is the
  // length in the current document, and the second is -1 for
  // unaffected sections, and the length of the replacement content
  // otherwise. So an insertion would be (0, n>0), a deletion (n>0,
  // 0), and a replacement two positive numbers.
  /**
  @internal
  */
  constructor(e) {
    this.sections = e;
  }
  /**
  The length of the document before the change.
  */
  get length() {
    let e = 0;
    for (let n = 0; n < this.sections.length; n += 2)
      e += this.sections[n];
    return e;
  }
  /**
  The length of the document after the change.
  */
  get newLength() {
    let e = 0;
    for (let n = 0; n < this.sections.length; n += 2) {
      let r = this.sections[n + 1];
      e += r < 0 ? this.sections[n] : r;
    }
    return e;
  }
  /**
  False when there are actual changes in this set.
  */
  get empty() {
    return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
  }
  /**
  Iterate over the unchanged parts left by these changes. `posA`
  provides the position of the range in the old document, `posB`
  the new position in the changed document.
  */
  iterGaps(e) {
    for (let n = 0, r = 0, i = 0; n < this.sections.length; ) {
      let o = this.sections[n++], s = this.sections[n++];
      s < 0 ? (e(r, i, o), i += o) : i += s, r += o;
    }
  }
  /**
  Iterate over the ranges changed by these changes. (See
  [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a
  variant that also provides you with the inserted text.)
  `fromA`/`toA` provides the extent of the change in the starting
  document, `fromB`/`toB` the extent of the replacement in the
  changed document.
  
  When `individual` is true, adjacent changes (which are kept
  separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are
  reported separately.
  */
  iterChangedRanges(e, n = false) {
    Lg(this, e, n);
  }
  /**
  Get a description of the inverted form of these changes.
  */
  get invertedDesc() {
    let e = [];
    for (let n = 0; n < this.sections.length; ) {
      let r = this.sections[n++], i = this.sections[n++];
      i < 0 ? e.push(r, i) : e.push(i, r);
    }
    return new wi(e);
  }
  /**
  Compute the combined effect of applying another set of changes
  after this one. The length of the document after this set should
  match the length before `other`.
  */
  composeDesc(e) {
    return this.empty ? e : e.empty ? this : Q2(this, e);
  }
  /**
  Map this description, which should start with the same document
  as `other`, over another set of changes, so that it can be
  applied after it. When `before` is true, map as if the changes
  in `other` happened before the ones in `this`.
  */
  mapDesc(e, n = false) {
    return e.empty ? this : Xg(this, e, n);
  }
  mapPos(e, n = -1, r = Tn.Simple) {
    let i = 0, o = 0;
    for (let s = 0; s < this.sections.length; ) {
      let a = this.sections[s++], l = this.sections[s++], c = i + a;
      if (l < 0) {
        if (c > e)
          return o + (e - i);
        o += a;
      } else {
        if (r != Tn.Simple && c >= e && (r == Tn.TrackDel && i < e && c > e || r == Tn.TrackBefore && i < e || r == Tn.TrackAfter && c > e))
          return null;
        if (c > e || c == e && n < 0 && !a)
          return e == i || n < 0 ? o : o + l;
        o += l;
      }
      i = c;
    }
    if (e > i)
      throw new RangeError(`Position ${e} is out of range for changeset of length ${i}`);
    return o;
  }
  /**
  Check whether these changes touch a given range. When one of the
  changes entirely covers the range, the string `"cover"` is
  returned.
  */
  touchesRange(e, n = e) {
    for (let r = 0, i = 0; r < this.sections.length && i <= n; ) {
      let o = this.sections[r++], s = this.sections[r++], a = i + o;
      if (s >= 0 && i <= n && a >= e)
        return i < e && a > n ? "cover" : true;
      i = a;
    }
    return false;
  }
  /**
  @internal
  */
  toString() {
    let e = "";
    for (let n = 0; n < this.sections.length; ) {
      let r = this.sections[n++], i = this.sections[n++];
      e += (e ? " " : "") + r + (i >= 0 ? ":" + i : "");
    }
    return e;
  }
  /**
  Serialize this change desc to a JSON-representable value.
  */
  toJSON() {
    return this.sections;
  }
  /**
  Create a change desc from its JSON representation (as produced
  by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).
  */
  static fromJSON(e) {
    if (!Array.isArray(e) || e.length % 2 || e.some((n) => typeof n != "number"))
      throw new RangeError("Invalid JSON representation of ChangeDesc");
    return new wi(e);
  }
  /**
  @internal
  */
  static create(e) {
    return new wi(e);
  }
};
var un = class extends wi {
  constructor(e, n) {
    super(e), this.inserted = n;
  }
  /**
  Apply the changes to a document, returning the modified
  document.
  */
  apply(e) {
    if (this.length != e.length)
      throw new RangeError("Applying change set to a document with the wrong length");
    return Lg(this, (n, r, i, o, s) => e = e.replace(i, i + (r - n), s), false), e;
  }
  mapDesc(e, n = false) {
    return Xg(this, e, n, true);
  }
  /**
  Given the document as it existed _before_ the changes, return a
  change set that represents the inverse of this set, which could
  be used to go from the document created by the changes back to
  the document as it existed before the changes.
  */
  invert(e) {
    let n = this.sections.slice(), r = [];
    for (let i = 0, o = 0; i < n.length; i += 2) {
      let s = n[i], a = n[i + 1];
      if (a >= 0) {
        n[i] = a, n[i + 1] = s;
        let l = i >> 1;
        for (; r.length < l; )
          r.push(ft.empty);
        r.push(s ? e.slice(o, o + s) : ft.empty);
      }
      o += s;
    }
    return new un(n, r);
  }
  /**
  Combine two subsequent change sets into a single set. `other`
  must start in the document produced by `this`. If `this` goes
  `docA` → `docB` and `other` represents `docB` → `docC`, the
  returned value will represent the change `docA` → `docC`.
  */
  compose(e) {
    return this.empty ? e : e.empty ? this : Q2(this, e, true);
  }
  /**
  Given another change set starting in the same document, maps this
  change set over the other, producing a new change set that can be
  applied to the document produced by applying `other`. When
  `before` is `true`, order changes as if `this` comes before
  `other`, otherwise (the default) treat `other` as coming first.
  
  Given two changes `A` and `B`, `A.compose(B.map(A))` and
  `B.compose(A.map(B, true))` will produce the same document. This
  provides a basic form of [operational
  transformation](https://en.wikipedia.org/wiki/Operational_transformation),
  and can be used for collaborative editing.
  */
  map(e, n = false) {
    return e.empty ? this : Xg(this, e, n, true);
  }
  /**
  Iterate over the changed ranges in the document, calling `f` for
  each, with the range in the original document (`fromA`-`toA`)
  and the range that replaces it in the new document
  (`fromB`-`toB`).
  
  When `individual` is true, adjacent changes are reported
  separately.
  */
  iterChanges(e, n = false) {
    Lg(this, e, n);
  }
  /**
  Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change
  set.
  */
  get desc() {
    return wi.create(this.sections);
  }
  /**
  @internal
  */
  filter(e) {
    let n = [], r = [], i = [], o = new tc(this);
    e:
      for (let s = 0, a = 0; ; ) {
        let l = s == e.length ? 1e9 : e[s++];
        for (; a < l || a == l && o.len == 0; ) {
          if (o.done)
            break e;
          let u = Math.min(o.len, l - a);
          Bn(i, u, -1);
          let f = o.ins == -1 ? -1 : o.off == 0 ? o.ins : 0;
          Bn(n, u, f), f > 0 && Oo(r, n, o.text), o.forward(u), a += u;
        }
        let c = e[s++];
        for (; a < c; ) {
          if (o.done)
            break e;
          let u = Math.min(o.len, c - a);
          Bn(n, u, -1), Bn(i, u, o.ins == -1 ? -1 : o.off == 0 ? o.ins : 0), o.forward(u), a += u;
        }
      }
    return {
      changes: new un(n, r),
      filtered: wi.create(i)
    };
  }
  /**
  Serialize this change set to a JSON-representable value.
  */
  toJSON() {
    let e = [];
    for (let n = 0; n < this.sections.length; n += 2) {
      let r = this.sections[n], i = this.sections[n + 1];
      i < 0 ? e.push(r) : i == 0 ? e.push([r]) : e.push([r].concat(this.inserted[n >> 1].toJSON()));
    }
    return e;
  }
  /**
  Create a change set for the given changes, for a document of the
  given length, using `lineSep` as line separator.
  */
  static of(e, n, r) {
    let i = [], o = [], s = 0, a = null;
    function l(u = false) {
      if (!u && !i.length)
        return;
      s < n && Bn(i, n - s, -1);
      let f = new un(i, o);
      a = a ? a.compose(f.map(a)) : f, i = [], o = [], s = 0;
    }
    function c(u) {
      if (Array.isArray(u))
        for (let f of u)
          c(f);
      else if (u instanceof un) {
        if (u.length != n)
          throw new RangeError(`Mismatched change set length (got ${u.length}, expected ${n})`);
        l(), a = a ? a.compose(u.map(a)) : u;
      } else {
        let { from: f, to: d = f, insert: h } = u;
        if (f > d || f < 0 || d > n)
          throw new RangeError(`Invalid change range ${f} to ${d} (in doc of length ${n})`);
        let p = h ? typeof h == "string" ? ft.of(h.split(r || zg)) : h : ft.empty, O = p.length;
        if (f == d && O == 0)
          return;
        f < s && l(), f > s && Bn(i, f - s, -1), Bn(i, d - f, O), Oo(o, i, p), s = d;
      }
    }
    return c(e), l(!a), a;
  }
  /**
  Create an empty changeset of the given length.
  */
  static empty(e) {
    return new un(e ? [e, -1] : [], []);
  }
  /**
  Create a changeset from its JSON representation (as produced by
  [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).
  */
  static fromJSON(e) {
    if (!Array.isArray(e))
      throw new RangeError("Invalid JSON representation of ChangeSet");
    let n = [], r = [];
    for (let i = 0; i < e.length; i++) {
      let o = e[i];
      if (typeof o == "number")
        n.push(o, -1);
      else {
        if (!Array.isArray(o) || typeof o[0] != "number" || o.some((s, a) => a && typeof s != "string"))
          throw new RangeError("Invalid JSON representation of ChangeSet");
        if (o.length == 1)
          n.push(o[0], 0);
        else {
          for (; r.length < i; )
            r.push(ft.empty);
          r[i] = ft.of(o.slice(1)), n.push(o[0], r[i].length);
        }
      }
    }
    return new un(n, r);
  }
  /**
  @internal
  */
  static createSet(e, n) {
    return new un(e, n);
  }
};
function Bn(t4, e, n, r = false) {
  if (e == 0 && n <= 0)
    return;
  let i = t4.length - 2;
  i >= 0 && n <= 0 && n == t4[i + 1] ? t4[i] += e : e == 0 && t4[i] == 0 ? t4[i + 1] += n : r ? (t4[i] += e, t4[i + 1] += n) : t4.push(e, n);
}
function Oo(t4, e, n) {
  if (n.length == 0)
    return;
  let r = e.length - 2 >> 1;
  if (r < t4.length)
    t4[t4.length - 1] = t4[t4.length - 1].append(n);
  else {
    for (; t4.length < r; )
      t4.push(ft.empty);
    t4.push(n);
  }
}
function Lg(t4, e, n) {
  let r = t4.inserted;
  for (let i = 0, o = 0, s = 0; s < t4.sections.length; ) {
    let a = t4.sections[s++], l = t4.sections[s++];
    if (l < 0)
      i += a, o += a;
    else {
      let c = i, u = o, f = ft.empty;
      for (; c += a, u += l, l && r && (f = f.append(r[s - 2 >> 1])), !(n || s == t4.sections.length || t4.sections[s + 1] < 0); )
        a = t4.sections[s++], l = t4.sections[s++];
      e(i, c, o, u, f), i = c, o = u;
    }
  }
}
function Xg(t4, e, n, r = false) {
  let i = [], o = r ? [] : null, s = new tc(t4), a = new tc(e);
  for (let l = -1; ; )
    if (s.ins == -1 && a.ins == -1) {
      let c = Math.min(s.len, a.len);
      Bn(i, c, -1), s.forward(c), a.forward(c);
    } else if (a.ins >= 0 && (s.ins < 0 || l == s.i || s.off == 0 && (a.len < s.len || a.len == s.len && !n))) {
      let c = a.len;
      for (Bn(i, a.ins, -1); c; ) {
        let u = Math.min(s.len, c);
        s.ins >= 0 && l < s.i && s.len <= u && (Bn(i, 0, s.ins), o && Oo(o, i, s.text), l = s.i), s.forward(u), c -= u;
      }
      a.next();
    } else if (s.ins >= 0) {
      let c = 0, u = s.len;
      for (; u; )
        if (a.ins == -1) {
          let f = Math.min(u, a.len);
          c += f, u -= f, a.forward(f);
        } else if (a.ins == 0 && a.len < u)
          u -= a.len, a.next();
        else
          break;
      Bn(i, c, l < s.i ? s.ins : 0), o && l < s.i && Oo(o, i, s.text), l = s.i, s.forward(s.len - u);
    } else {
      if (s.done && a.done)
        return o ? un.createSet(i, o) : wi.create(i);
      throw new Error("Mismatched change set lengths");
    }
}
function Q2(t4, e, n = false) {
  let r = [], i = n ? [] : null, o = new tc(t4), s = new tc(e);
  for (let a = false; ; ) {
    if (o.done && s.done)
      return i ? un.createSet(r, i) : wi.create(r);
    if (o.ins == 0)
      Bn(r, o.len, 0, a), o.next();
    else if (s.len == 0 && !s.done)
      Bn(r, 0, s.ins, a), i && Oo(i, r, s.text), s.next();
    else {
      if (o.done || s.done)
        throw new Error("Mismatched change set lengths");
      {
        let l = Math.min(o.len2, s.len), c = r.length;
        if (o.ins == -1) {
          let u = s.ins == -1 ? -1 : s.off ? 0 : s.ins;
          Bn(r, l, u, a), i && u && Oo(i, r, s.text);
        } else
          s.ins == -1 ? (Bn(r, o.off ? 0 : o.len, l, a), i && Oo(i, r, o.textBit(l))) : (Bn(r, o.off ? 0 : o.len, s.off ? 0 : s.ins, a), i && !s.off && Oo(i, r, s.text));
        a = (o.ins > l || s.ins >= 0 && s.len > l) && (a || r.length > c), o.forward2(l), s.forward(l);
      }
    }
  }
}
var tc = class {
  constructor(e) {
    this.set = e, this.i = 0, this.next();
  }
  next() {
    let { sections: e } = this.set;
    this.i < e.length ? (this.len = e[this.i++], this.ins = e[this.i++]) : (this.len = 0, this.ins = -2), this.off = 0;
  }
  get done() {
    return this.ins == -2;
  }
  get len2() {
    return this.ins < 0 ? this.len : this.ins;
  }
  get text() {
    let { inserted: e } = this.set, n = this.i - 2 >> 1;
    return n >= e.length ? ft.empty : e[n];
  }
  textBit(e) {
    let { inserted: n } = this.set, r = this.i - 2 >> 1;
    return r >= n.length && !e ? ft.empty : n[r].slice(this.off, e == null ? void 0 : this.off + e);
  }
  forward(e) {
    e == this.len ? this.next() : (this.len -= e, this.off += e);
  }
  forward2(e) {
    this.ins == -1 ? this.forward(e) : e == this.ins ? this.next() : (this.ins -= e, this.off += e);
  }
};
var bu = class Gg {
  constructor(e, n, r) {
    this.from = e, this.to = n, this.flags = r;
  }
  /**
  The anchor of the range—the side that doesn't move when you
  extend it.
  */
  get anchor() {
    return this.flags & 32 ? this.to : this.from;
  }
  /**
  The head of the range, which is moved when the range is
  [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).
  */
  get head() {
    return this.flags & 32 ? this.from : this.to;
  }
  /**
  True when `anchor` and `head` are at the same position.
  */
  get empty() {
    return this.from == this.to;
  }
  /**
  If this is a cursor that is explicitly associated with the
  character on one of its sides, this returns the side. -1 means
  the character before its position, 1 the character after, and 0
  means no association.
  */
  get assoc() {
    return this.flags & 8 ? -1 : this.flags & 16 ? 1 : 0;
  }
  /**
  The bidirectional text level associated with this cursor, if
  any.
  */
  get bidiLevel() {
    let e = this.flags & 7;
    return e == 7 ? null : e;
  }
  /**
  The goal column (stored vertical offset) associated with a
  cursor. This is used to preserve the vertical position when
  [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across
  lines of different length.
  */
  get goalColumn() {
    let e = this.flags >> 6;
    return e == 16777215 ? void 0 : e;
  }
  /**
  Map this range through a change, producing a valid range in the
  updated document.
  */
  map(e, n = -1) {
    let r, i;
    return this.empty ? r = i = e.mapPos(this.from, n) : (r = e.mapPos(this.from, 1), i = e.mapPos(this.to, -1)), r == this.from && i == this.to ? this : new Gg(r, i, this.flags);
  }
  /**
  Extend this range to cover at least `from` to `to`.
  */
  extend(e, n = e) {
    if (e <= this.anchor && n >= this.anchor)
      return ne.range(e, n);
    let r = Math.abs(e - this.anchor) > Math.abs(n - this.anchor) ? e : n;
    return ne.range(this.anchor, r);
  }
  /**
  Compare this range to another range.
  */
  eq(e, n = false) {
    return this.anchor == e.anchor && this.head == e.head && (!n || !this.empty || this.assoc == e.assoc);
  }
  /**
  Return a JSON-serializable object representing the range.
  */
  toJSON() {
    return { anchor: this.anchor, head: this.head };
  }
  /**
  Convert a JSON representation of a range to a `SelectionRange`
  instance.
  */
  static fromJSON(e) {
    if (!e || typeof e.anchor != "number" || typeof e.head != "number")
      throw new RangeError("Invalid JSON representation for SelectionRange");
    return ne.range(e.anchor, e.head);
  }
  /**
  @internal
  */
  static create(e, n, r) {
    return new Gg(e, n, r);
  }
};
var ne = class {
  constructor(e, n) {
    this.ranges = e, this.mainIndex = n;
  }
  /**
  Map a selection through a change. Used to adjust the selection
  position for changes.
  */
  map(e, n = -1) {
    return e.empty ? this : ne.create(this.ranges.map((r) => r.map(e, n)), this.mainIndex);
  }
  /**
  Compare this selection to another selection. By default, ranges
  are compared only by position. When `includeAssoc` is true,
  cursor ranges must also have the same
  [`assoc`](https://codemirror.net/6/docs/ref/#state.SelectionRange.assoc) value.
  */
  eq(e, n = false) {
    if (this.ranges.length != e.ranges.length || this.mainIndex != e.mainIndex)
      return false;
    for (let r = 0; r < this.ranges.length; r++)
      if (!this.ranges[r].eq(e.ranges[r], n))
        return false;
    return true;
  }
  /**
  Get the primary selection range. Usually, you should make sure
  your code applies to _all_ ranges, by using methods like
  [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).
  */
  get main() {
    return this.ranges[this.mainIndex];
  }
  /**
  Make sure the selection only has one range. Returns a selection
  holding only the main range from this selection.
  */
  asSingle() {
    return this.ranges.length == 1 ? this : new ne([this.main], 0);
  }
  /**
  Extend this selection with an extra range.
  */
  addRange(e, n = true) {
    return ne.create([e].concat(this.ranges), n ? 0 : this.mainIndex + 1);
  }
  /**
  Replace a given range with another range, and then normalize the
  selection to merge and sort ranges if necessary.
  */
  replaceRange(e, n = this.mainIndex) {
    let r = this.ranges.slice();
    return r[n] = e, ne.create(r, this.mainIndex);
  }
  /**
  Convert this selection to an object that can be serialized to
  JSON.
  */
  toJSON() {
    return { ranges: this.ranges.map((e) => e.toJSON()), main: this.mainIndex };
  }
  /**
  Create a selection from a JSON representation.
  */
  static fromJSON(e) {
    if (!e || !Array.isArray(e.ranges) || typeof e.main != "number" || e.main >= e.ranges.length)
      throw new RangeError("Invalid JSON representation for EditorSelection");
    return new ne(e.ranges.map((n) => bu.fromJSON(n)), e.main);
  }
  /**
  Create a selection holding a single range.
  */
  static single(e, n = e) {
    return new ne([ne.range(e, n)], 0);
  }
  /**
  Sort and merge the given set of ranges, creating a valid
  selection.
  */
  static create(e, n = 0) {
    if (e.length == 0)
      throw new RangeError("A selection needs at least one range");
    for (let r = 0, i = 0; i < e.length; i++) {
      let o = e[i];
      if (o.empty ? o.from <= r : o.from < r)
        return ne.normalized(e.slice(), n);
      r = o.to;
    }
    return new ne(e, n);
  }
  /**
  Create a cursor selection range at the given position. You can
  safely ignore the optional arguments in most situations.
  */
  static cursor(e, n = 0, r, i) {
    return bu.create(e, e, (n == 0 ? 0 : n < 0 ? 8 : 16) | (r == null ? 7 : Math.min(6, r)) | (i ?? 16777215) << 6);
  }
  /**
  Create a selection range.
  */
  static range(e, n, r, i) {
    let o = (r ?? 16777215) << 6 | (i == null ? 7 : Math.min(6, i));
    return n < e ? bu.create(n, e, 48 | o) : bu.create(e, n, (n > e ? 8 : 0) | o);
  }
  /**
  @internal
  */
  static normalized(e, n = 0) {
    let r = e[n];
    e.sort((i, o) => i.from - o.from), n = e.indexOf(r);
    for (let i = 1; i < e.length; i++) {
      let o = e[i], s = e[i - 1];
      if (o.empty ? o.from <= s.to : o.from < s.to) {
        let a = s.from, l = Math.max(o.to, s.to);
        i <= n && n--, e.splice(--i, 2, o.anchor > o.head ? ne.range(l, a) : ne.range(a, l));
      }
    }
    return new ne(e, n);
  }
};
function B2(t4, e) {
  for (let n of t4.ranges)
    if (n.to > e)
      throw new RangeError("Selection points outside of document");
}
var xx = 0;
var ge = class {
  constructor(e, n, r, i, o) {
    this.combine = e, this.compareInput = n, this.compare = r, this.isStatic = i, this.id = xx++, this.default = e([]), this.extensions = typeof o == "function" ? o(this) : o;
  }
  /**
  Returns a facet reader for this facet, which can be used to
  [read](https://codemirror.net/6/docs/ref/#state.EditorState.facet) it but not to define values for it.
  */
  get reader() {
    return this;
  }
  /**
  Define a new facet.
  */
  static define(e = {}) {
    return new ge(e.combine || ((n) => n), e.compareInput || ((n, r) => n === r), e.compare || (e.combine ? (n, r) => n === r : vx), !!e.static, e.enables);
  }
  /**
  Returns an extension that adds the given value to this facet.
  */
  of(e) {
    return new cf([], this, 0, e);
  }
  /**
  Create an extension that computes a value for the facet from a
  state. You must take care to declare the parts of the state that
  this value depends on, since your function is only called again
  for a new state when one of those parts changed.
  
  In cases where your value depends only on a single field, you'll
  want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.
  */
  compute(e, n) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new cf(e, this, 1, n);
  }
  /**
  Create an extension that computes zero or more values for this
  facet from a state.
  */
  computeN(e, n) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new cf(e, this, 2, n);
  }
  from(e, n) {
    return n || (n = (r) => r), this.compute([e], (r) => n(r.field(e)));
  }
};
function vx(t4, e) {
  return t4 == e || t4.length == e.length && t4.every((n, r) => n === e[r]);
}
var cf = class {
  constructor(e, n, r, i) {
    this.dependencies = e, this.facet = n, this.type = r, this.value = i, this.id = xx++;
  }
  dynamicSlot(e) {
    var n;
    let r = this.value, i = this.facet.compareInput, o = this.id, s = e[o] >> 1, a = this.type == 2, l = false, c = false, u = [];
    for (let f of this.dependencies)
      f == "doc" ? l = true : f == "selection" ? c = true : ((n = e[f.id]) !== null && n !== void 0 ? n : 1) & 1 || u.push(e[f.id]);
    return {
      create(f) {
        return f.values[s] = r(f), 1;
      },
      update(f, d) {
        if (l && d.docChanged || c && (d.docChanged || d.selection) || Yg(f, u)) {
          let h = r(f);
          if (a ? !Rb(h, f.values[s], i) : !i(h, f.values[s]))
            return f.values[s] = h, 1;
        }
        return 0;
      },
      reconfigure: (f, d) => {
        let h, p = d.config.address[o];
        if (p != null) {
          let O = Kf(d, p);
          if (this.dependencies.every((m) => m instanceof ge ? d.facet(m) === f.facet(m) : m instanceof pn ? d.field(m, false) == f.field(m, false) : true) || (a ? Rb(h = r(f), O, i) : i(h = r(f), O)))
            return f.values[s] = O, 0;
        } else
          h = r(f);
        return f.values[s] = h, 1;
      }
    };
  }
};
function Rb(t4, e, n) {
  if (t4.length != e.length)
    return false;
  for (let r = 0; r < t4.length; r++)
    if (!n(t4[r], e[r]))
      return false;
  return true;
}
function Yg(t4, e) {
  let n = false;
  for (let r of e)
    Zl(t4, r) & 1 && (n = true);
  return n;
}
function rF(t4, e, n) {
  let r = n.map((l) => t4[l.id]), i = n.map((l) => l.type), o = r.filter((l) => !(l & 1)), s = t4[e.id] >> 1;
  function a(l) {
    let c = [];
    for (let u = 0; u < r.length; u++) {
      let f = Kf(l, r[u]);
      if (i[u] == 2)
        for (let d of f)
          c.push(d);
      else
        c.push(f);
    }
    return e.combine(c);
  }
  return {
    create(l) {
      for (let c of r)
        Zl(l, c);
      return l.values[s] = a(l), 1;
    },
    update(l, c) {
      if (!Yg(l, o))
        return 0;
      let u = a(l);
      return e.compare(u, l.values[s]) ? 0 : (l.values[s] = u, 1);
    },
    reconfigure(l, c) {
      let u = Yg(l, r), f = c.config.facets[e.id], d = c.facet(e);
      if (f && !u && vx(n, f))
        return l.values[s] = d, 0;
      let h = a(l);
      return e.compare(h, d) ? (l.values[s] = d, 0) : (l.values[s] = h, 1);
    }
  };
}
var Db = /* @__PURE__ */ ge.define({ static: true });
var pn = class {
  constructor(e, n, r, i, o) {
    this.id = e, this.createF = n, this.updateF = r, this.compareF = i, this.spec = o, this.provides = void 0;
  }
  /**
  Define a state field.
  */
  static define(e) {
    let n = new pn(xx++, e.create, e.update, e.compare || ((r, i) => r === i), e);
    return e.provide && (n.provides = e.provide(n)), n;
  }
  create(e) {
    let n = e.facet(Db).find((r) => r.field == this);
    return ((n == null ? void 0 : n.create) || this.createF)(e);
  }
  /**
  @internal
  */
  slot(e) {
    let n = e[this.id] >> 1;
    return {
      create: (r) => (r.values[n] = this.create(r), 1),
      update: (r, i) => {
        let o = r.values[n], s = this.updateF(o, i);
        return this.compareF(o, s) ? 0 : (r.values[n] = s, 1);
      },
      reconfigure: (r, i) => i.config.address[this.id] != null ? (r.values[n] = i.field(this), 0) : (r.values[n] = this.create(r), 1)
    };
  }
  /**
  Returns an extension that enables this field and overrides the
  way it is initialized. Can be useful when you need to provide a
  non-default starting value for the field.
  */
  init(e) {
    return [this, Db.of({ field: this, create: e })];
  }
  /**
  State field instances can be used as
  [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a
  given state.
  */
  get extension() {
    return this;
  }
};
var ns = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
function pl(t4) {
  return (e) => new _2(e, t4);
}
var ji = {
  /**
  The highest precedence level, for extensions that should end up
  near the start of the precedence ordering.
  */
  highest: /* @__PURE__ */ pl(ns.highest),
  /**
  A higher-than-default precedence, for extensions that should
  come before those with default precedence.
  */
  high: /* @__PURE__ */ pl(ns.high),
  /**
  The default precedence, which is also used for extensions
  without an explicit precedence.
  */
  default: /* @__PURE__ */ pl(ns.default),
  /**
  A lower-than-default precedence.
  */
  low: /* @__PURE__ */ pl(ns.low),
  /**
  The lowest precedence level. Meant for things that should end up
  near the end of the extension order.
  */
  lowest: /* @__PURE__ */ pl(ns.lowest)
};
var _2 = class {
  constructor(e, n) {
    this.inner = e, this.prec = n;
  }
};
var gh = class {
  /**
  Create an instance of this compartment to add to your [state
  configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).
  */
  of(e) {
    return new qg(this, e);
  }
  /**
  Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that
  reconfigures this compartment.
  */
  reconfigure(e) {
    return gh.reconfigure.of({ compartment: this, extension: e });
  }
  /**
  Get the current content of the compartment in the state, or
  `undefined` if it isn't present.
  */
  get(e) {
    return e.config.compartments.get(this);
  }
};
var qg = class {
  constructor(e, n) {
    this.compartment = e, this.inner = n;
  }
};
var Jf = class {
  constructor(e, n, r, i, o, s) {
    for (this.base = e, this.compartments = n, this.dynamicSlots = r, this.address = i, this.staticValues = o, this.facets = s, this.statusTemplate = []; this.statusTemplate.length < r.length; )
      this.statusTemplate.push(
        0
        /* SlotStatus.Unresolved */
      );
  }
  staticFacet(e) {
    let n = this.address[e.id];
    return n == null ? e.default : this.staticValues[n >> 1];
  }
  static resolve(e, n, r) {
    let i = [], o = /* @__PURE__ */ Object.create(null), s = /* @__PURE__ */ new Map();
    for (let d of iF(e, n, s))
      d instanceof pn ? i.push(d) : (o[d.facet.id] || (o[d.facet.id] = [])).push(d);
    let a = /* @__PURE__ */ Object.create(null), l = [], c = [];
    for (let d of i)
      a[d.id] = c.length << 1, c.push((h) => d.slot(h));
    let u = r == null ? void 0 : r.config.facets;
    for (let d in o) {
      let h = o[d], p = h[0].facet, O = u && u[d] || [];
      if (h.every(
        (m) => m.type == 0
        /* Provider.Static */
      ))
        if (a[p.id] = l.length << 1 | 1, vx(O, h))
          l.push(r.facet(p));
        else {
          let m = p.combine(h.map((x) => x.value));
          l.push(r && p.compare(m, r.facet(p)) ? r.facet(p) : m);
        }
      else {
        for (let m of h)
          m.type == 0 ? (a[m.id] = l.length << 1 | 1, l.push(m.value)) : (a[m.id] = c.length << 1, c.push((x) => m.dynamicSlot(x)));
        a[p.id] = c.length << 1, c.push((m) => rF(m, p, h));
      }
    }
    let f = c.map((d) => d(a));
    return new Jf(e, s, f, a, l, o);
  }
};
function iF(t4, e, n) {
  let r = [[], [], [], [], []], i = /* @__PURE__ */ new Map();
  function o(s, a) {
    let l = i.get(s);
    if (l != null) {
      if (l <= a)
        return;
      let c = r[l].indexOf(s);
      c > -1 && r[l].splice(c, 1), s instanceof qg && n.delete(s.compartment);
    }
    if (i.set(s, a), Array.isArray(s))
      for (let c of s)
        o(c, a);
    else if (s instanceof qg) {
      if (n.has(s.compartment))
        throw new RangeError("Duplicate use of compartment in extensions");
      let c = e.get(s.compartment) || s.inner;
      n.set(s.compartment, c), o(c, a);
    } else if (s instanceof _2)
      o(s.inner, s.prec);
    else if (s instanceof pn)
      r[a].push(s), s.provides && o(s.provides, a);
    else if (s instanceof cf)
      r[a].push(s), s.facet.extensions && o(s.facet.extensions, ns.default);
    else {
      let c = s.extension;
      if (!c)
        throw new Error(`Unrecognized extension value in extension set (${s}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
      o(c, a);
    }
  }
  return o(t4, ns.default), r.reduce((s, a) => s.concat(a));
}
function Zl(t4, e) {
  if (e & 1)
    return 2;
  let n = e >> 1, r = t4.status[n];
  if (r == 4)
    throw new Error("Cyclic dependency between fields and/or facets");
  if (r & 2)
    return r;
  t4.status[n] = 4;
  let i = t4.computeSlot(t4, t4.config.dynamicSlots[n]);
  return t4.status[n] = 2 | i;
}
function Kf(t4, e) {
  return e & 1 ? t4.config.staticValues[e >> 1] : t4.values[e >> 1];
}
var M2 = /* @__PURE__ */ ge.define();
var Ug = /* @__PURE__ */ ge.define({
  combine: (t4) => t4.some((e) => e),
  static: true
});
var N2 = /* @__PURE__ */ ge.define({
  combine: (t4) => t4.length ? t4[0] : void 0,
  static: true
});
var F2 = /* @__PURE__ */ ge.define();
var Z2 = /* @__PURE__ */ ge.define();
var W2 = /* @__PURE__ */ ge.define();
var V2 = /* @__PURE__ */ ge.define({
  combine: (t4) => t4.length ? t4[0] : false
});
var Ri = class {
  /**
  @internal
  */
  constructor(e, n) {
    this.type = e, this.value = n;
  }
  /**
  Define a new type of annotation.
  */
  static define() {
    return new oF();
  }
};
var oF = class {
  /**
  Create an instance of this annotation.
  */
  of(e) {
    return new Ri(this, e);
  }
};
var sF = class {
  /**
  @internal
  */
  constructor(e) {
    this.map = e;
  }
  /**
  Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this
  type.
  */
  of(e) {
    return new Me(this, e);
  }
};
var Me = class {
  /**
  @internal
  */
  constructor(e, n) {
    this.type = e, this.value = n;
  }
  /**
  Map this effect through a position mapping. Will return
  `undefined` when that ends up deleting the effect.
  */
  map(e) {
    let n = this.type.map(this.value, e);
    return n === void 0 ? void 0 : n == this.value ? this : new Me(this.type, n);
  }
  /**
  Tells you whether this effect object is of a given
  [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).
  */
  is(e) {
    return this.type == e;
  }
  /**
  Define a new effect type. The type parameter indicates the type
  of values that his effect holds. It should be a type that
  doesn't include `undefined`, since that is used in
  [mapping](https://codemirror.net/6/docs/ref/#state.StateEffect.map) to indicate that an effect is
  removed.
  */
  static define(e = {}) {
    return new sF(e.map || ((n) => n));
  }
  /**
  Map an array of effects through a change set.
  */
  static mapEffects(e, n) {
    if (!e.length)
      return e;
    let r = [];
    for (let i of e) {
      let o = i.map(n);
      o && r.push(o);
    }
    return r;
  }
};
Me.reconfigure = /* @__PURE__ */ Me.define();
Me.appendConfig = /* @__PURE__ */ Me.define();
var tn = class {
  constructor(e, n, r, i, o, s) {
    this.startState = e, this.changes = n, this.selection = r, this.effects = i, this.annotations = o, this.scrollIntoView = s, this._doc = null, this._state = null, r && B2(r, n.newLength), o.some((a) => a.type == tn.time) || (this.annotations = o.concat(tn.time.of(Date.now())));
  }
  /**
  @internal
  */
  static create(e, n, r, i, o, s) {
    return new tn(e, n, r, i, o, s);
  }
  /**
  The new document produced by the transaction. Contrary to
  [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't
  force the entire new state to be computed right away, so it is
  recommended that [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter
  when they need to look at the new document.
  */
  get newDoc() {
    return this._doc || (this._doc = this.changes.apply(this.startState.doc));
  }
  /**
  The new selection produced by the transaction. If
  [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,
  this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's
  current selection through the changes made by the transaction.
  */
  get newSelection() {
    return this.selection || this.startState.selection.map(this.changes);
  }
  /**
  The new state created by the transaction. Computed on demand
  (but retained for subsequent access), so it is recommended not to
  access it in [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.
  */
  get state() {
    return this._state || this.startState.applyTransaction(this), this._state;
  }
  /**
  Get the value of the given annotation type, if any.
  */
  annotation(e) {
    for (let n of this.annotations)
      if (n.type == e)
        return n.value;
  }
  /**
  Indicates whether the transaction changed the document.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Indicates whether this transaction reconfigures the state
  (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or
  with a top-level configuration
  [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).
  */
  get reconfigured() {
    return this.startState.config != this.state.config;
  }
  /**
  Returns true if the transaction has a [user
  event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to
  or more specific than `event`. For example, if the transaction
  has `"select.pointer"` as user event, `"select"` and
  `"select.pointer"` will match it.
  */
  isUserEvent(e) {
    let n = this.annotation(tn.userEvent);
    return !!(n && (n == e || n.length > e.length && n.slice(0, e.length) == e && n[e.length] == "."));
  }
};
tn.time = /* @__PURE__ */ Ri.define();
tn.userEvent = /* @__PURE__ */ Ri.define();
tn.addToHistory = /* @__PURE__ */ Ri.define();
tn.remote = /* @__PURE__ */ Ri.define();
function aF(t4, e) {
  let n = [];
  for (let r = 0, i = 0; ; ) {
    let o, s;
    if (r < t4.length && (i == e.length || e[i] >= t4[r]))
      o = t4[r++], s = t4[r++];
    else if (i < e.length)
      o = e[i++], s = e[i++];
    else
      return n;
    !n.length || n[n.length - 1] < o ? n.push(o, s) : n[n.length - 1] < s && (n[n.length - 1] = s);
  }
}
function z2(t4, e, n) {
  var r;
  let i, o, s;
  return n ? (i = e.changes, o = un.empty(e.changes.length), s = t4.changes.compose(e.changes)) : (i = e.changes.map(t4.changes), o = t4.changes.mapDesc(e.changes, true), s = t4.changes.compose(i)), {
    changes: s,
    selection: e.selection ? e.selection.map(o) : (r = t4.selection) === null || r === void 0 ? void 0 : r.map(i),
    effects: Me.mapEffects(t4.effects, i).concat(Me.mapEffects(e.effects, o)),
    annotations: t4.annotations.length ? t4.annotations.concat(e.annotations) : e.annotations,
    scrollIntoView: t4.scrollIntoView || e.scrollIntoView
  };
}
function Hg(t4, e, n) {
  let r = e.selection, i = aa(e.annotations);
  return e.userEvent && (i = i.concat(tn.userEvent.of(e.userEvent))), {
    changes: e.changes instanceof un ? e.changes : un.of(e.changes || [], n, t4.facet(N2)),
    selection: r && (r instanceof ne ? r : ne.single(r.anchor, r.head)),
    effects: aa(e.effects),
    annotations: i,
    scrollIntoView: !!e.scrollIntoView
  };
}
function L2(t4, e, n) {
  let r = Hg(t4, e.length ? e[0] : {}, t4.doc.length);
  e.length && e[0].filter === false && (n = false);
  for (let o = 1; o < e.length; o++) {
    e[o].filter === false && (n = false);
    let s = !!e[o].sequential;
    r = z2(r, Hg(t4, e[o], s ? r.changes.newLength : t4.doc.length), s);
  }
  let i = tn.create(t4, r.changes, r.selection, r.effects, r.annotations, r.scrollIntoView);
  return cF(n ? lF(i) : i);
}
function lF(t4) {
  let e = t4.startState, n = true;
  for (let i of e.facet(F2)) {
    let o = i(t4);
    if (o === false) {
      n = false;
      break;
    }
    Array.isArray(o) && (n = n === true ? o : aF(n, o));
  }
  if (n !== true) {
    let i, o;
    if (n === false)
      o = t4.changes.invertedDesc, i = un.empty(e.doc.length);
    else {
      let s = t4.changes.filter(n);
      i = s.changes, o = s.filtered.mapDesc(s.changes).invertedDesc;
    }
    t4 = tn.create(e, i, t4.selection && t4.selection.map(o), Me.mapEffects(t4.effects, o), t4.annotations, t4.scrollIntoView);
  }
  let r = e.facet(Z2);
  for (let i = r.length - 1; i >= 0; i--) {
    let o = r[i](t4);
    o instanceof tn ? t4 = o : Array.isArray(o) && o.length == 1 && o[0] instanceof tn ? t4 = o[0] : t4 = L2(e, aa(o), false);
  }
  return t4;
}
function cF(t4) {
  let e = t4.startState, n = e.facet(W2), r = t4;
  for (let i = n.length - 1; i >= 0; i--) {
    let o = n[i](t4);
    o && Object.keys(o).length && (r = z2(r, Hg(e, o, t4.changes.newLength), true));
  }
  return r == t4 ? t4 : tn.create(e, t4.changes, t4.selection, r.effects, r.annotations, r.scrollIntoView);
}
var uF = [];
function aa(t4) {
  return t4 == null ? uF : Array.isArray(t4) ? t4 : [t4];
}
var Nt = /* @__PURE__ */ function(t4) {
  return t4[t4.Word = 0] = "Word", t4[t4.Space = 1] = "Space", t4[t4.Other = 2] = "Other", t4;
}(Nt || (Nt = {}));
var fF = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
var Jg;
try {
  Jg = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
} catch {
}
function dF(t4) {
  if (Jg)
    return Jg.test(t4);
  for (let e = 0; e < t4.length; e++) {
    let n = t4[e];
    if (/\w/.test(n) || n > "\x80" && (n.toUpperCase() != n.toLowerCase() || fF.test(n)))
      return true;
  }
  return false;
}
function hF(t4) {
  return (e) => {
    if (!/\S/.test(e))
      return Nt.Space;
    if (dF(e))
      return Nt.Word;
    for (let n = 0; n < t4.length; n++)
      if (e.indexOf(t4[n]) > -1)
        return Nt.Word;
    return Nt.Other;
  };
}
var et = class {
  constructor(e, n, r, i, o, s) {
    this.config = e, this.doc = n, this.selection = r, this.values = i, this.status = e.statusTemplate.slice(), this.computeSlot = o, s && (s._state = this);
    for (let a = 0; a < this.config.dynamicSlots.length; a++)
      Zl(this, a << 1);
    this.computeSlot = null;
  }
  field(e, n = true) {
    let r = this.config.address[e.id];
    if (r == null) {
      if (n)
        throw new RangeError("Field is not present in this state");
      return;
    }
    return Zl(this, r), Kf(this, r);
  }
  /**
  Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this
  state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)
  can be passed. Unless
  [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the
  [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec
  are assumed to start in the _current_ document (not the document
  produced by previous specs), and its
  [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and
  [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer
  to the document created by its _own_ changes. The resulting
  transaction contains the combined effect of all the different
  specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later
  specs take precedence over earlier ones.
  */
  update(...e) {
    return L2(this, e, true);
  }
  /**
  @internal
  */
  applyTransaction(e) {
    let n = this.config, { base: r, compartments: i } = n;
    for (let a of e.effects)
      a.is(gh.reconfigure) ? (n && (i = /* @__PURE__ */ new Map(), n.compartments.forEach((l, c) => i.set(c, l)), n = null), i.set(a.value.compartment, a.value.extension)) : a.is(Me.reconfigure) ? (n = null, r = a.value) : a.is(Me.appendConfig) && (n = null, r = aa(r).concat(a.value));
    let o;
    n ? o = e.startState.values.slice() : (n = Jf.resolve(r, i, this), o = new et(n, this.doc, this.selection, n.dynamicSlots.map(() => null), (l, c) => c.reconfigure(l, this), null).values);
    let s = e.startState.facet(Ug) ? e.newSelection : e.newSelection.asSingle();
    new et(n, e.newDoc, s, o, (a, l) => l.update(a, e), e);
  }
  /**
  Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that
  replaces every selection range with the given content.
  */
  replaceSelection(e) {
    return typeof e == "string" && (e = this.toText(e)), this.changeByRange((n) => ({
      changes: { from: n.from, to: n.to, insert: e },
      range: ne.cursor(n.from + e.length)
    }));
  }
  /**
  Create a set of changes and a new selection by running the given
  function for each range in the active selection. The function
  can return an optional set of changes (in the coordinate space
  of the start document), plus an updated range (in the coordinate
  space of the document produced by the call's own changes). This
  method will merge all the changes and ranges into a single
  changeset and selection, and return it as a [transaction
  spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to
  [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).
  */
  changeByRange(e) {
    let n = this.selection, r = e(n.ranges[0]), i = this.changes(r.changes), o = [r.range], s = aa(r.effects);
    for (let a = 1; a < n.ranges.length; a++) {
      let l = e(n.ranges[a]), c = this.changes(l.changes), u = c.map(i);
      for (let d = 0; d < a; d++)
        o[d] = o[d].map(u);
      let f = i.mapDesc(c, true);
      o.push(l.range.map(f)), i = i.compose(u), s = Me.mapEffects(s, u).concat(Me.mapEffects(aa(l.effects), f));
    }
    return {
      changes: i,
      selection: ne.create(o, n.mainIndex),
      effects: s
    };
  }
  /**
  Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change
  description, taking the state's document length and line
  separator into account.
  */
  changes(e = []) {
    return e instanceof un ? e : un.of(e, this.doc.length, this.facet(et.lineSeparator));
  }
  /**
  Using the state's [line
  separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a
  [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.
  */
  toText(e) {
    return ft.of(e.split(this.facet(et.lineSeparator) || zg));
  }
  /**
  Return the given range of the document as a string.
  */
  sliceDoc(e = 0, n = this.doc.length) {
    return this.doc.sliceString(e, n, this.lineBreak);
  }
  /**
  Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).
  */
  facet(e) {
    let n = this.config.address[e.id];
    return n == null ? e.default : (Zl(this, n), Kf(this, n));
  }
  /**
  Convert this state to a JSON-serializable object. When custom
  fields should be serialized, you can pass them in as an object
  mapping property names (in the resulting object, which should
  not use `doc` or `selection`) to fields.
  */
  toJSON(e) {
    let n = {
      doc: this.sliceDoc(),
      selection: this.selection.toJSON()
    };
    if (e)
      for (let r in e) {
        let i = e[r];
        i instanceof pn && this.config.address[i.id] != null && (n[r] = i.spec.toJSON(this.field(e[r]), this));
      }
    return n;
  }
  /**
  Deserialize a state from its JSON representation. When custom
  fields should be deserialized, pass the same object you passed
  to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as
  third argument.
  */
  static fromJSON(e, n = {}, r) {
    if (!e || typeof e.doc != "string")
      throw new RangeError("Invalid JSON representation for EditorState");
    let i = [];
    if (r) {
      for (let o in r)
        if (Object.prototype.hasOwnProperty.call(e, o)) {
          let s = r[o], a = e[o];
          i.push(s.init((l) => s.spec.fromJSON(a, l)));
        }
    }
    return et.create({
      doc: e.doc,
      selection: ne.fromJSON(e.selection),
      extensions: n.extensions ? i.concat([n.extensions]) : i
    });
  }
  /**
  Create a new state. You'll usually only need this when
  initializing an editor—updated states are created by applying
  transactions.
  */
  static create(e = {}) {
    let n = Jf.resolve(e.extensions || [], /* @__PURE__ */ new Map()), r = e.doc instanceof ft ? e.doc : ft.of((e.doc || "").split(n.staticFacet(et.lineSeparator) || zg)), i = e.selection ? e.selection instanceof ne ? e.selection : ne.single(e.selection.anchor, e.selection.head) : ne.single(0);
    return B2(i, r.length), n.staticFacet(Ug) || (i = i.asSingle()), new et(n, r, i, n.dynamicSlots.map(() => null), (o, s) => s.create(o), null);
  }
  /**
  The size (in columns) of a tab in the document, determined by
  the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.
  */
  get tabSize() {
    return this.facet(et.tabSize);
  }
  /**
  Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)
  string for this state.
  */
  get lineBreak() {
    return this.facet(et.lineSeparator) || `
`;
  }
  /**
  Returns true when the editor is
  [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.
  */
  get readOnly() {
    return this.facet(V2);
  }
  /**
  Look up a translation for the given phrase (via the
  [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the
  original string if no translation is found.
  
  If additional arguments are passed, they will be inserted in
  place of markers like `$1` (for the first value) and `$2`, etc.
  A single `$` is equivalent to `$1`, and `$$` will produce a
  literal dollar sign.
  */
  phrase(e, ...n) {
    for (let r of this.facet(et.phrases))
      if (Object.prototype.hasOwnProperty.call(r, e)) {
        e = r[e];
        break;
      }
    return n.length && (e = e.replace(/\$(\$|\d*)/g, (r, i) => {
      if (i == "$")
        return "$";
      let o = +(i || 1);
      return !o || o > n.length ? r : n[o - 1];
    })), e;
  }
  /**
  Find the values for a given language data field, provided by the
  the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.
  
  Examples of language data fields are...
  
  - [`"commentTokens"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying
    comment syntax.
  - [`"autocomplete"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)
    for providing language-specific completion sources.
  - [`"wordChars"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding
    characters that should be considered part of words in this
    language.
  - [`"closeBrackets"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls
    bracket closing behavior.
  */
  languageDataAt(e, n, r = -1) {
    let i = [];
    for (let o of this.facet(M2))
      for (let s of o(this, n, r))
        Object.prototype.hasOwnProperty.call(s, e) && i.push(s[e]);
    return i;
  }
  /**
  Return a function that can categorize strings (expected to
  represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))
  into one of:
  
   - Word (contains an alphanumeric character or a character
     explicitly listed in the local language's `"wordChars"`
     language data, which should be a string)
   - Space (contains only whitespace)
   - Other (anything else)
  */
  charCategorizer(e) {
    return hF(this.languageDataAt("wordChars", e).join(""));
  }
  /**
  Find the word at the given position, meaning the range
  containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters
  around it. If no word characters are adjacent to the position,
  this returns null.
  */
  wordAt(e) {
    let { text: n, from: r, length: i } = this.doc.lineAt(e), o = this.charCategorizer(e), s = e - r, a = e - r;
    for (; s > 0; ) {
      let l = $n(n, s, false);
      if (o(n.slice(l, s)) != Nt.Word)
        break;
      s = l;
    }
    for (; a < i; ) {
      let l = $n(n, a);
      if (o(n.slice(a, l)) != Nt.Word)
        break;
      a = l;
    }
    return s == a ? null : ne.range(s + r, a + r);
  }
};
et.allowMultipleSelections = Ug;
et.tabSize = /* @__PURE__ */ ge.define({
  combine: (t4) => t4.length ? t4[0] : 4
});
et.lineSeparator = N2;
et.readOnly = V2;
et.phrases = /* @__PURE__ */ ge.define({
  compare(t4, e) {
    let n = Object.keys(t4), r = Object.keys(e);
    return n.length == r.length && n.every((i) => t4[i] == e[i]);
  }
});
et.languageData = M2;
et.changeFilter = F2;
et.transactionFilter = Z2;
et.transactionExtender = W2;
gh.reconfigure = /* @__PURE__ */ Me.define();
function Di(t4, e, n = {}) {
  let r = {};
  for (let i of t4)
    for (let o of Object.keys(i)) {
      let s = i[o], a = r[o];
      if (a === void 0)
        r[o] = s;
      else if (!(a === s || s === void 0))
        if (Object.hasOwnProperty.call(n, o))
          r[o] = n[o](a, s);
        else
          throw new Error("Config merge conflict for field " + o);
    }
  for (let i in e)
    r[i] === void 0 && (r[i] = e[i]);
  return r;
}
var fs = class {
  /**
  Compare this value with another value. Used when comparing
  rangesets. The default implementation compares by identity.
  Unless you are only creating a fixed number of unique instances
  of your value type, it is a good idea to implement this
  properly.
  */
  eq(e) {
    return this == e;
  }
  /**
  Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.
  */
  range(e, n = e) {
    return Kg.create(e, n, this);
  }
};
fs.prototype.startSide = fs.prototype.endSide = 0;
fs.prototype.point = false;
fs.prototype.mapMode = Tn.TrackDel;
var Kg = class X2 {
  constructor(e, n, r) {
    this.from = e, this.to = n, this.value = r;
  }
  /**
  @internal
  */
  static create(e, n, r) {
    return new X2(e, n, r);
  }
};
function em(t4, e) {
  return t4.from - e.from || t4.value.startSide - e.value.startSide;
}
var yx = class {
  constructor(e, n, r, i) {
    this.from = e, this.to = n, this.value = r, this.maxPoint = i;
  }
  get length() {
    return this.to[this.to.length - 1];
  }
  // Find the index of the given position and side. Use the ranges'
  // `from` pos when `end == false`, `to` when `end == true`.
  findIndex(e, n, r, i = 0) {
    let o = r ? this.to : this.from;
    for (let s = i, a = o.length; ; ) {
      if (s == a)
        return s;
      let l = s + a >> 1, c = o[l] - e || (r ? this.value[l].endSide : this.value[l].startSide) - n;
      if (l == s)
        return c >= 0 ? s : a;
      c >= 0 ? a = l : s = l + 1;
    }
  }
  between(e, n, r, i) {
    for (let o = this.findIndex(n, -1e9, true), s = this.findIndex(r, 1e9, false, o); o < s; o++)
      if (i(this.from[o] + e, this.to[o] + e, this.value[o]) === false)
        return false;
  }
  map(e, n) {
    let r = [], i = [], o = [], s = -1, a = -1;
    for (let l = 0; l < this.value.length; l++) {
      let c = this.value[l], u = this.from[l] + e, f = this.to[l] + e, d, h;
      if (u == f) {
        let p = n.mapPos(u, c.startSide, c.mapMode);
        if (p == null || (d = h = p, c.startSide != c.endSide && (h = n.mapPos(u, c.endSide), h < d)))
          continue;
      } else if (d = n.mapPos(u, c.startSide), h = n.mapPos(f, c.endSide), d > h || d == h && c.startSide > 0 && c.endSide <= 0)
        continue;
      (h - d || c.endSide - c.startSide) < 0 || (s < 0 && (s = d), c.point && (a = Math.max(a, h - d)), r.push(c), i.push(d - s), o.push(h - s));
    }
    return { mapped: r.length ? new yx(i, o, r, a) : null, pos: s };
  }
};
var ot = class {
  constructor(e, n, r, i) {
    this.chunkPos = e, this.chunk = n, this.nextLayer = r, this.maxPoint = i;
  }
  /**
  @internal
  */
  static create(e, n, r, i) {
    return new ot(e, n, r, i);
  }
  /**
  @internal
  */
  get length() {
    let e = this.chunk.length - 1;
    return e < 0 ? 0 : Math.max(this.chunkEnd(e), this.nextLayer.length);
  }
  /**
  The number of ranges in the set.
  */
  get size() {
    if (this.isEmpty)
      return 0;
    let e = this.nextLayer.size;
    for (let n of this.chunk)
      e += n.value.length;
    return e;
  }
  /**
  @internal
  */
  chunkEnd(e) {
    return this.chunkPos[e] + this.chunk[e].length;
  }
  /**
  Update the range set, optionally adding new ranges or filtering
  out existing ones.
  
  (Note: The type parameter is just there as a kludge to work
  around TypeScript variance issues that prevented `RangeSet<X>`
  from being a subtype of `RangeSet<Y>` when `X` is a subtype of
  `Y`.)
  */
  update(e) {
    let { add: n = [], sort: r = false, filterFrom: i = 0, filterTo: o = this.length } = e, s = e.filter;
    if (n.length == 0 && !s)
      return this;
    if (r && (n = n.slice().sort(em)), this.isEmpty)
      return n.length ? ot.of(n) : this;
    let a = new G2(this, null, -1).goto(0), l = 0, c = [], u = new To();
    for (; a.value || l < n.length; )
      if (l < n.length && (a.from - n[l].from || a.startSide - n[l].value.startSide) >= 0) {
        let f = n[l++];
        u.addInner(f.from, f.to, f.value) || c.push(f);
      } else
        a.rangeIndex == 1 && a.chunkIndex < this.chunk.length && (l == n.length || this.chunkEnd(a.chunkIndex) < n[l].from) && (!s || i > this.chunkEnd(a.chunkIndex) || o < this.chunkPos[a.chunkIndex]) && u.addChunk(this.chunkPos[a.chunkIndex], this.chunk[a.chunkIndex]) ? a.nextChunk() : ((!s || i > a.to || o < a.from || s(a.from, a.to, a.value)) && (u.addInner(a.from, a.to, a.value) || c.push(Kg.create(a.from, a.to, a.value))), a.next());
    return u.finishInner(this.nextLayer.isEmpty && !c.length ? ot.empty : this.nextLayer.update({ add: c, filter: s, filterFrom: i, filterTo: o }));
  }
  /**
  Map this range set through a set of changes, return the new set.
  */
  map(e) {
    if (e.empty || this.isEmpty)
      return this;
    let n = [], r = [], i = -1;
    for (let s = 0; s < this.chunk.length; s++) {
      let a = this.chunkPos[s], l = this.chunk[s], c = e.touchesRange(a, a + l.length);
      if (c === false)
        i = Math.max(i, l.maxPoint), n.push(l), r.push(e.mapPos(a));
      else if (c === true) {
        let { mapped: u, pos: f } = l.map(a, e);
        u && (i = Math.max(i, u.maxPoint), n.push(u), r.push(f));
      }
    }
    let o = this.nextLayer.map(e);
    return n.length == 0 ? o : new ot(r, n, o || ot.empty, i);
  }
  /**
  Iterate over the ranges that touch the region `from` to `to`,
  calling `f` for each. There is no guarantee that the ranges will
  be reported in any specific order. When the callback returns
  `false`, iteration stops.
  */
  between(e, n, r) {
    if (!this.isEmpty) {
      for (let i = 0; i < this.chunk.length; i++) {
        let o = this.chunkPos[i], s = this.chunk[i];
        if (n >= o && e <= o + s.length && s.between(o, e - o, n - o, r) === false)
          return;
      }
      this.nextLayer.between(e, n, r);
    }
  }
  /**
  Iterate over the ranges in this set, in order, including all
  ranges that end at or after `from`.
  */
  iter(e = 0) {
    return nc.from([this]).goto(e);
  }
  /**
  @internal
  */
  get isEmpty() {
    return this.nextLayer == this;
  }
  /**
  Iterate over the ranges in a collection of sets, in order,
  starting from `from`.
  */
  static iter(e, n = 0) {
    return nc.from(e).goto(n);
  }
  /**
  Iterate over two groups of sets, calling methods on `comparator`
  to notify it of possible differences.
  */
  static compare(e, n, r, i, o = -1) {
    let s = e.filter((f) => f.maxPoint > 0 || !f.isEmpty && f.maxPoint >= o), a = n.filter((f) => f.maxPoint > 0 || !f.isEmpty && f.maxPoint >= o), l = Qb(s, a, r), c = new gl(s, l, o), u = new gl(a, l, o);
    r.iterGaps((f, d, h) => Bb(c, f, u, d, h, i)), r.empty && r.length == 0 && Bb(c, 0, u, 0, 0, i);
  }
  /**
  Compare the contents of two groups of range sets, returning true
  if they are equivalent in the given range.
  */
  static eq(e, n, r = 0, i) {
    i == null && (i = 999999999);
    let o = e.filter((u) => !u.isEmpty && n.indexOf(u) < 0), s = n.filter((u) => !u.isEmpty && e.indexOf(u) < 0);
    if (o.length != s.length)
      return false;
    if (!o.length)
      return true;
    let a = Qb(o, s), l = new gl(o, a, 0).goto(r), c = new gl(s, a, 0).goto(r);
    for (; ; ) {
      if (l.to != c.to || !tm(l.active, c.active) || l.point && (!c.point || !l.point.eq(c.point)))
        return false;
      if (l.to > i)
        return true;
      l.next(), c.next();
    }
  }
  /**
  Iterate over a group of range sets at the same time, notifying
  the iterator about the ranges covering every given piece of
  content. Returns the open count (see
  [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end
  of the iteration.
  */
  static spans(e, n, r, i, o = -1) {
    let s = new gl(e, null, o).goto(n), a = n, l = s.openStart;
    for (; ; ) {
      let c = Math.min(s.to, r);
      if (s.point) {
        let u = s.activeForPoint(s.to), f = s.pointFrom < n ? u.length + 1 : s.point.startSide < 0 ? u.length : Math.min(u.length, l);
        i.point(a, c, s.point, u, f, s.pointRank), l = Math.min(s.openEnd(c), u.length);
      } else
        c > a && (i.span(a, c, s.active, l), l = s.openEnd(c));
      if (s.to > r)
        return l + (s.point && s.to > r ? 1 : 0);
      a = s.to, s.next();
    }
  }
  /**
  Create a range set for the given range or array of ranges. By
  default, this expects the ranges to be _sorted_ (by start
  position and, if two start at the same position,
  `value.startSide`). You can pass `true` as second argument to
  cause the method to sort them.
  */
  static of(e, n = false) {
    let r = new To();
    for (let i of e instanceof Kg ? [e] : n ? pF(e) : e)
      r.add(i.from, i.to, i.value);
    return r.finish();
  }
  /**
  Join an array of range sets into a single set.
  */
  static join(e) {
    if (!e.length)
      return ot.empty;
    let n = e[e.length - 1];
    for (let r = e.length - 2; r >= 0; r--)
      for (let i = e[r]; i != ot.empty; i = i.nextLayer)
        n = new ot(i.chunkPos, i.chunk, n, Math.max(i.maxPoint, n.maxPoint));
    return n;
  }
};
ot.empty = /* @__PURE__ */ new ot([], [], null, -1);
function pF(t4) {
  if (t4.length > 1)
    for (let e = t4[0], n = 1; n < t4.length; n++) {
      let r = t4[n];
      if (em(e, r) > 0)
        return t4.slice().sort(em);
      e = r;
    }
  return t4;
}
ot.empty.nextLayer = ot.empty;
var To = class {
  finishChunk(e) {
    this.chunks.push(new yx(this.from, this.to, this.value, this.maxPoint)), this.chunkPos.push(this.chunkStart), this.chunkStart = -1, this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint), this.maxPoint = -1, e && (this.from = [], this.to = [], this.value = []);
  }
  /**
  Create an empty builder.
  */
  constructor() {
    this.chunks = [], this.chunkPos = [], this.chunkStart = -1, this.last = null, this.lastFrom = -1e9, this.lastTo = -1e9, this.from = [], this.to = [], this.value = [], this.maxPoint = -1, this.setMaxPoint = -1, this.nextLayer = null;
  }
  /**
  Add a range. Ranges should be added in sorted (by `from` and
  `value.startSide`) order.
  */
  add(e, n, r) {
    this.addInner(e, n, r) || (this.nextLayer || (this.nextLayer = new To())).add(e, n, r);
  }
  /**
  @internal
  */
  addInner(e, n, r) {
    let i = e - this.lastTo || r.startSide - this.last.endSide;
    if (i <= 0 && (e - this.lastFrom || r.startSide - this.last.startSide) < 0)
      throw new Error("Ranges must be added sorted by `from` position and `startSide`");
    return i < 0 ? false : (this.from.length == 250 && this.finishChunk(true), this.chunkStart < 0 && (this.chunkStart = e), this.from.push(e - this.chunkStart), this.to.push(n - this.chunkStart), this.last = r, this.lastFrom = e, this.lastTo = n, this.value.push(r), r.point && (this.maxPoint = Math.max(this.maxPoint, n - e)), true);
  }
  /**
  @internal
  */
  addChunk(e, n) {
    if ((e - this.lastTo || n.value[0].startSide - this.last.endSide) < 0)
      return false;
    this.from.length && this.finishChunk(true), this.setMaxPoint = Math.max(this.setMaxPoint, n.maxPoint), this.chunks.push(n), this.chunkPos.push(e);
    let r = n.value.length - 1;
    return this.last = n.value[r], this.lastFrom = n.from[r] + e, this.lastTo = n.to[r] + e, true;
  }
  /**
  Finish the range set. Returns the new set. The builder can't be
  used anymore after this has been called.
  */
  finish() {
    return this.finishInner(ot.empty);
  }
  /**
  @internal
  */
  finishInner(e) {
    if (this.from.length && this.finishChunk(false), this.chunks.length == 0)
      return e;
    let n = ot.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(e) : e, this.setMaxPoint);
    return this.from = null, n;
  }
};
function Qb(t4, e, n) {
  let r = /* @__PURE__ */ new Map();
  for (let o of t4)
    for (let s = 0; s < o.chunk.length; s++)
      o.chunk[s].maxPoint <= 0 && r.set(o.chunk[s], o.chunkPos[s]);
  let i = /* @__PURE__ */ new Set();
  for (let o of e)
    for (let s = 0; s < o.chunk.length; s++) {
      let a = r.get(o.chunk[s]);
      a != null && (n ? n.mapPos(a) : a) == o.chunkPos[s] && !(n != null && n.touchesRange(a, a + o.chunk[s].length)) && i.add(o.chunk[s]);
    }
  return i;
}
var G2 = class {
  constructor(e, n, r, i = 0) {
    this.layer = e, this.skip = n, this.minPoint = r, this.rank = i;
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  get endSide() {
    return this.value ? this.value.endSide : 0;
  }
  goto(e, n = -1e9) {
    return this.chunkIndex = this.rangeIndex = 0, this.gotoInner(e, n, false), this;
  }
  gotoInner(e, n, r) {
    for (; this.chunkIndex < this.layer.chunk.length; ) {
      let i = this.layer.chunk[this.chunkIndex];
      if (!(this.skip && this.skip.has(i) || this.layer.chunkEnd(this.chunkIndex) < e || i.maxPoint < this.minPoint))
        break;
      this.chunkIndex++, r = false;
    }
    if (this.chunkIndex < this.layer.chunk.length) {
      let i = this.layer.chunk[this.chunkIndex].findIndex(e - this.layer.chunkPos[this.chunkIndex], n, true);
      (!r || this.rangeIndex < i) && this.setRangeIndex(i);
    }
    this.next();
  }
  forward(e, n) {
    (this.to - e || this.endSide - n) < 0 && this.gotoInner(e, n, true);
  }
  next() {
    for (; ; )
      if (this.chunkIndex == this.layer.chunk.length) {
        this.from = this.to = 1e9, this.value = null;
        break;
      } else {
        let e = this.layer.chunkPos[this.chunkIndex], n = this.layer.chunk[this.chunkIndex], r = e + n.from[this.rangeIndex];
        if (this.from = r, this.to = e + n.to[this.rangeIndex], this.value = n.value[this.rangeIndex], this.setRangeIndex(this.rangeIndex + 1), this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
          break;
      }
  }
  setRangeIndex(e) {
    if (e == this.layer.chunk[this.chunkIndex].value.length) {
      if (this.chunkIndex++, this.skip)
        for (; this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]); )
          this.chunkIndex++;
      this.rangeIndex = 0;
    } else
      this.rangeIndex = e;
  }
  nextChunk() {
    this.chunkIndex++, this.rangeIndex = 0, this.next();
  }
  compare(e) {
    return this.from - e.from || this.startSide - e.startSide || this.rank - e.rank || this.to - e.to || this.endSide - e.endSide;
  }
};
var nc = class {
  constructor(e) {
    this.heap = e;
  }
  static from(e, n = null, r = -1) {
    let i = [];
    for (let o = 0; o < e.length; o++)
      for (let s = e[o]; !s.isEmpty; s = s.nextLayer)
        s.maxPoint >= r && i.push(new G2(s, n, r, o));
    return i.length == 1 ? i[0] : new nc(i);
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  goto(e, n = -1e9) {
    for (let r of this.heap)
      r.goto(e, n);
    for (let r = this.heap.length >> 1; r >= 0; r--)
      kp(this.heap, r);
    return this.next(), this;
  }
  forward(e, n) {
    for (let r of this.heap)
      r.forward(e, n);
    for (let r = this.heap.length >> 1; r >= 0; r--)
      kp(this.heap, r);
    (this.to - e || this.value.endSide - n) < 0 && this.next();
  }
  next() {
    if (this.heap.length == 0)
      this.from = this.to = 1e9, this.value = null, this.rank = -1;
    else {
      let e = this.heap[0];
      this.from = e.from, this.to = e.to, this.value = e.value, this.rank = e.rank, e.value && e.next(), kp(this.heap, 0);
    }
  }
};
function kp(t4, e) {
  for (let n = t4[e]; ; ) {
    let r = (e << 1) + 1;
    if (r >= t4.length)
      break;
    let i = t4[r];
    if (r + 1 < t4.length && i.compare(t4[r + 1]) >= 0 && (i = t4[r + 1], r++), n.compare(i) < 0)
      break;
    t4[r] = n, t4[e] = i, e = r;
  }
}
var gl = class {
  constructor(e, n, r) {
    this.minPoint = r, this.active = [], this.activeTo = [], this.activeRank = [], this.minActive = -1, this.point = null, this.pointFrom = 0, this.pointRank = 0, this.to = -1e9, this.endSide = 0, this.openStart = -1, this.cursor = nc.from(e, n, r);
  }
  goto(e, n = -1e9) {
    return this.cursor.goto(e, n), this.active.length = this.activeTo.length = this.activeRank.length = 0, this.minActive = -1, this.to = e, this.endSide = n, this.openStart = -1, this.next(), this;
  }
  forward(e, n) {
    for (; this.minActive > -1 && (this.activeTo[this.minActive] - e || this.active[this.minActive].endSide - n) < 0; )
      this.removeActive(this.minActive);
    this.cursor.forward(e, n);
  }
  removeActive(e) {
    Su(this.active, e), Su(this.activeTo, e), Su(this.activeRank, e), this.minActive = _b(this.active, this.activeTo);
  }
  addActive(e) {
    let n = 0, { value: r, to: i, rank: o } = this.cursor;
    for (; n < this.activeRank.length && (o - this.activeRank[n] || i - this.activeTo[n]) > 0; )
      n++;
    wu(this.active, n, r), wu(this.activeTo, n, i), wu(this.activeRank, n, o), e && wu(e, n, this.cursor.from), this.minActive = _b(this.active, this.activeTo);
  }
  // After calling this, if `this.point` != null, the next range is a
  // point. Otherwise, it's a regular range, covered by `this.active`.
  next() {
    let e = this.to, n = this.point;
    this.point = null;
    let r = this.openStart < 0 ? [] : null;
    for (; ; ) {
      let i = this.minActive;
      if (i > -1 && (this.activeTo[i] - this.cursor.from || this.active[i].endSide - this.cursor.startSide) < 0) {
        if (this.activeTo[i] > e) {
          this.to = this.activeTo[i], this.endSide = this.active[i].endSide;
          break;
        }
        this.removeActive(i), r && Su(r, i);
      } else if (this.cursor.value)
        if (this.cursor.from > e) {
          this.to = this.cursor.from, this.endSide = this.cursor.startSide;
          break;
        } else {
          let o = this.cursor.value;
          if (!o.point)
            this.addActive(r), this.cursor.next();
          else if (n && this.cursor.to == this.to && this.cursor.from < this.cursor.to)
            this.cursor.next();
          else {
            this.point = o, this.pointFrom = this.cursor.from, this.pointRank = this.cursor.rank, this.to = this.cursor.to, this.endSide = o.endSide, this.cursor.next(), this.forward(this.to, this.endSide);
            break;
          }
        }
      else {
        this.to = this.endSide = 1e9;
        break;
      }
    }
    if (r) {
      this.openStart = 0;
      for (let i = r.length - 1; i >= 0 && r[i] < e; i--)
        this.openStart++;
    }
  }
  activeForPoint(e) {
    if (!this.active.length)
      return this.active;
    let n = [];
    for (let r = this.active.length - 1; r >= 0 && !(this.activeRank[r] < this.pointRank); r--)
      (this.activeTo[r] > e || this.activeTo[r] == e && this.active[r].endSide >= this.point.endSide) && n.push(this.active[r]);
    return n.reverse();
  }
  openEnd(e) {
    let n = 0;
    for (let r = this.activeTo.length - 1; r >= 0 && this.activeTo[r] > e; r--)
      n++;
    return n;
  }
};
function Bb(t4, e, n, r, i, o) {
  t4.goto(e), n.goto(r);
  let s = r + i, a = r, l = r - e;
  for (; ; ) {
    let c = t4.to + l - n.to || t4.endSide - n.endSide, u = c < 0 ? t4.to + l : n.to, f = Math.min(u, s);
    if (t4.point || n.point ? t4.point && n.point && (t4.point == n.point || t4.point.eq(n.point)) && tm(t4.activeForPoint(t4.to), n.activeForPoint(n.to)) || o.comparePoint(a, f, t4.point, n.point) : f > a && !tm(t4.active, n.active) && o.compareRange(a, f, t4.active, n.active), u > s)
      break;
    a = u, c <= 0 && t4.next(), c >= 0 && n.next();
  }
}
function tm(t4, e) {
  if (t4.length != e.length)
    return false;
  for (let n = 0; n < t4.length; n++)
    if (t4[n] != e[n] && !t4[n].eq(e[n]))
      return false;
  return true;
}
function Su(t4, e) {
  for (let n = e, r = t4.length - 1; n < r; n++)
    t4[n] = t4[n + 1];
  t4.pop();
}
function wu(t4, e, n) {
  for (let r = t4.length - 1; r >= e; r--)
    t4[r + 1] = t4[r];
  t4[e] = n;
}
function _b(t4, e) {
  let n = -1, r = 1e9;
  for (let i = 0; i < e.length; i++)
    (e[i] - r || t4[i].endSide - t4[n].endSide) < 0 && (n = i, r = e[i]);
  return n;
}
function Ya(t4, e, n = t4.length) {
  let r = 0;
  for (let i = 0; i < n; )
    t4.charCodeAt(i) == 9 ? (r += e - r % e, i++) : (r++, i = $n(t4, i));
  return r;
}
function nm(t4, e, n, r) {
  for (let i = 0, o = 0; ; ) {
    if (o >= e)
      return i;
    if (i == t4.length)
      break;
    o += t4.charCodeAt(i) == 9 ? n - o % n : 1, i = $n(t4, i);
  }
  return r === true ? -1 : t4.length;
}
var rm = "\u037C";
var Mb = typeof Symbol > "u" ? "__" + rm : Symbol.for(rm);
var im = typeof Symbol > "u" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet");
var Nb = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : {};
var Io = class {
  // :: (Object<Style>, ?{finish: ?(string) → string})
  // Create a style module from the given spec.
  //
  // When `finish` is given, it is called on regular (non-`@`)
  // selectors (after `&` expansion) to compute the final selector.
  constructor(e, n) {
    this.rules = [];
    let { finish: r } = n || {};
    function i(s) {
      return /^@/.test(s) ? [s] : s.split(/,\s*/);
    }
    function o(s, a, l, c) {
      let u = [], f = /^@(\w+)\b/.exec(s[0]), d = f && f[1] == "keyframes";
      if (f && a == null)
        return l.push(s[0] + ";");
      for (let h in a) {
        let p = a[h];
        if (/&/.test(h))
          o(
            h.split(/,\s*/).map((O) => s.map((m) => O.replace(/&/, m))).reduce((O, m) => O.concat(m)),
            p,
            l
          );
        else if (p && typeof p == "object") {
          if (!f)
            throw new RangeError("The value of a property (" + h + ") should be a primitive value.");
          o(i(h), p, u, d);
        } else
          p != null && u.push(h.replace(/_.*/, "").replace(/[A-Z]/g, (O) => "-" + O.toLowerCase()) + ": " + p + ";");
      }
      (u.length || d) && l.push((r && !f && !c ? s.map(r) : s).join(", ") + " {" + u.join(" ") + "}");
    }
    for (let s in e)
      o(i(s), e[s], this.rules);
  }
  // :: () → string
  // Returns a string containing the module's CSS rules.
  getRules() {
    return this.rules.join(`
`);
  }
  // :: () → string
  // Generate a new unique CSS class name.
  static newName() {
    let e = Nb[Mb] || 1;
    return Nb[Mb] = e + 1, rm + e.toString(36);
  }
  // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>, ?{nonce: ?string})
  //
  // Mount the given set of modules in the given DOM root, which ensures
  // that the CSS rules defined by the module are available in that
  // context.
  //
  // Rules are only added to the document once per root.
  //
  // Rule order will follow the order of the modules, so that rules from
  // modules later in the array take precedence of those from earlier
  // modules. If you call this function multiple times for the same root
  // in a way that changes the order of already mounted modules, the old
  // order will be changed.
  //
  // If a Content Security Policy nonce is provided, it is added to
  // the `<style>` tag generated by the library.
  static mount(e, n, r) {
    let i = e[im], o = r && r.nonce;
    i ? o && i.setNonce(o) : i = new gF(e, o), i.mount(Array.isArray(n) ? n : [n], e);
  }
};
var Fb = /* @__PURE__ */ new Map();
var gF = class {
  constructor(e, n) {
    let r = e.ownerDocument || e, i = r.defaultView;
    if (!e.head && e.adoptedStyleSheets && i.CSSStyleSheet) {
      let o = Fb.get(r);
      if (o)
        return e[im] = o;
      this.sheet = new i.CSSStyleSheet(), Fb.set(r, this);
    } else
      this.styleTag = r.createElement("style"), n && this.styleTag.setAttribute("nonce", n);
    this.modules = [], e[im] = this;
  }
  mount(e, n) {
    let r = this.sheet, i = 0, o = 0;
    for (let s = 0; s < e.length; s++) {
      let a = e[s], l = this.modules.indexOf(a);
      if (l < o && l > -1 && (this.modules.splice(l, 1), o--, l = -1), l == -1) {
        if (this.modules.splice(o++, 0, a), r)
          for (let c = 0; c < a.rules.length; c++)
            r.insertRule(a.rules[c], i++);
      } else {
        for (; o < l; )
          i += this.modules[o++].rules.length;
        i += a.rules.length, o++;
      }
    }
    if (r)
      n.adoptedStyleSheets.indexOf(this.sheet) < 0 && (n.adoptedStyleSheets = [this.sheet, ...n.adoptedStyleSheets]);
    else {
      let s = "";
      for (let l = 0; l < this.modules.length; l++)
        s += this.modules[l].getRules() + `
`;
      this.styleTag.textContent = s;
      let a = n.head || n;
      this.styleTag.parentNode != a && a.insertBefore(this.styleTag, a.firstChild);
    }
  }
  setNonce(e) {
    this.styleTag && this.styleTag.getAttribute("nonce") != e && this.styleTag.setAttribute("nonce", e);
  }
};
var $o = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
};
var rc = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
};
var mF = typeof navigator < "u" && /Mac/.test(navigator.platform);
var OF = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (En = 0; En < 10; En++)
  $o[48 + En] = $o[96 + En] = String(En);
var En;
for (En = 1; En <= 24; En++)
  $o[En + 111] = "F" + En;
var En;
for (En = 65; En <= 90; En++)
  $o[En] = String.fromCharCode(En + 32), rc[En] = String.fromCharCode(En);
var En;
for (Ap in $o)
  rc.hasOwnProperty(Ap) || (rc[Ap] = $o[Ap]);
var Ap;
function xF(t4) {
  var e = mF && t4.metaKey && t4.shiftKey && !t4.ctrlKey && !t4.altKey || OF && t4.shiftKey && t4.key && t4.key.length == 1 || t4.key == "Unidentified", n = !e && t4.key || (t4.shiftKey ? rc : $o)[t4.keyCode] || t4.key || "Unidentified";
  return n == "Esc" && (n = "Escape"), n == "Del" && (n = "Delete"), n == "Left" && (n = "ArrowLeft"), n == "Up" && (n = "ArrowUp"), n == "Right" && (n = "ArrowRight"), n == "Down" && (n = "ArrowDown"), n;
}
function ed(t4) {
  let e;
  return t4.nodeType == 11 ? e = t4.getSelection ? t4 : t4.ownerDocument : e = t4, e.getSelection();
}
function om(t4, e) {
  return e ? t4 == e || t4.contains(e.nodeType != 1 ? e.parentNode : e) : false;
}
function vF(t4) {
  let e = t4.activeElement;
  for (; e && e.shadowRoot; )
    e = e.shadowRoot.activeElement;
  return e;
}
function uf(t4, e) {
  if (!e.anchorNode)
    return false;
  try {
    return om(t4, e.anchorNode);
  } catch {
    return false;
  }
}
function Ca(t4) {
  return t4.nodeType == 3 ? hs(t4, 0, t4.nodeValue.length).getClientRects() : t4.nodeType == 1 ? t4.getClientRects() : [];
}
function Wl(t4, e, n, r) {
  return n ? Zb(t4, e, n, r, -1) || Zb(t4, e, n, r, 1) : false;
}
function ds(t4) {
  for (var e = 0; ; e++)
    if (t4 = t4.previousSibling, !t4)
      return e;
}
function td(t4) {
  return t4.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(t4.nodeName);
}
function Zb(t4, e, n, r, i) {
  for (; ; ) {
    if (t4 == n && e == r)
      return true;
    if (e == (i < 0 ? 0 : Ui(t4))) {
      if (t4.nodeName == "DIV")
        return false;
      let o = t4.parentNode;
      if (!o || o.nodeType != 1)
        return false;
      e = ds(t4) + (i < 0 ? 0 : 1), t4 = o;
    } else if (t4.nodeType == 1) {
      if (t4 = t4.childNodes[e + (i < 0 ? -1 : 0)], t4.nodeType == 1 && t4.contentEditable == "false")
        return false;
      e = i < 0 ? Ui(t4) : 0;
    } else
      return false;
  }
}
function Ui(t4) {
  return t4.nodeType == 3 ? t4.nodeValue.length : t4.childNodes.length;
}
function mh(t4, e) {
  let n = e ? t4.left : t4.right;
  return { left: n, right: n, top: t4.top, bottom: t4.bottom };
}
function yF(t4) {
  let e = t4.visualViewport;
  return e ? {
    left: 0,
    right: e.width,
    top: 0,
    bottom: e.height
  } : {
    left: 0,
    right: t4.innerWidth,
    top: 0,
    bottom: t4.innerHeight
  };
}
function Y2(t4, e) {
  let n = e.width / t4.offsetWidth, r = e.height / t4.offsetHeight;
  return (n > 0.995 && n < 1.005 || !isFinite(n) || Math.abs(e.width - t4.offsetWidth) < 1) && (n = 1), (r > 0.995 && r < 1.005 || !isFinite(r) || Math.abs(e.height - t4.offsetHeight) < 1) && (r = 1), { scaleX: n, scaleY: r };
}
function bF(t4, e, n, r, i, o, s, a) {
  let l = t4.ownerDocument, c = l.defaultView || window;
  for (let u = t4, f = false; u && !f; )
    if (u.nodeType == 1) {
      let d, h = u == l.body, p = 1, O = 1;
      if (h)
        d = yF(c);
      else {
        if (/^(fixed|sticky)$/.test(getComputedStyle(u).position) && (f = true), u.scrollHeight <= u.clientHeight && u.scrollWidth <= u.clientWidth) {
          u = u.assignedSlot || u.parentNode;
          continue;
        }
        let v = u.getBoundingClientRect();
        ({ scaleX: p, scaleY: O } = Y2(u, v)), d = {
          left: v.left,
          right: v.left + u.clientWidth * p,
          top: v.top,
          bottom: v.top + u.clientHeight * O
        };
      }
      let m = 0, x = 0;
      if (i == "nearest")
        e.top < d.top ? (x = -(d.top - e.top + s), n > 0 && e.bottom > d.bottom + x && (x = e.bottom - d.bottom + x + s)) : e.bottom > d.bottom && (x = e.bottom - d.bottom + s, n < 0 && e.top - x < d.top && (x = -(d.top + x - e.top + s)));
      else {
        let v = e.bottom - e.top, y = d.bottom - d.top;
        x = (i == "center" && v <= y ? e.top + v / 2 - y / 2 : i == "start" || i == "center" && n < 0 ? e.top - s : e.bottom - y + s) - d.top;
      }
      if (r == "nearest" ? e.left < d.left ? (m = -(d.left - e.left + o), n > 0 && e.right > d.right + m && (m = e.right - d.right + m + o)) : e.right > d.right && (m = e.right - d.right + o, n < 0 && e.left < d.left + m && (m = -(d.left + m - e.left + o))) : m = (r == "center" ? e.left + (e.right - e.left) / 2 - (d.right - d.left) / 2 : r == "start" == a ? e.left - o : e.right - (d.right - d.left) + o) - d.left, m || x)
        if (h)
          c.scrollBy(m, x);
        else {
          let v = 0, y = 0;
          if (x) {
            let S = u.scrollTop;
            u.scrollTop += x / O, y = (u.scrollTop - S) * O;
          }
          if (m) {
            let S = u.scrollLeft;
            u.scrollLeft += m / p, v = (u.scrollLeft - S) * p;
          }
          e = {
            left: e.left - v,
            top: e.top - y,
            right: e.right - v,
            bottom: e.bottom - y
          }, v && Math.abs(v - m) < 1 && (r = "nearest"), y && Math.abs(y - x) < 1 && (i = "nearest");
        }
      if (h)
        break;
      u = u.assignedSlot || u.parentNode;
    } else if (u.nodeType == 11)
      u = u.host;
    else
      break;
}
function SF(t4) {
  let e = t4.ownerDocument;
  for (let n = t4.parentNode; n && n != e.body; )
    if (n.nodeType == 1) {
      if (n.scrollHeight > n.clientHeight || n.scrollWidth > n.clientWidth)
        return n;
      n = n.assignedSlot || n.parentNode;
    } else if (n.nodeType == 11)
      n = n.host;
    else
      break;
  return null;
}
var wF = class {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  eq(e) {
    return this.anchorNode == e.anchorNode && this.anchorOffset == e.anchorOffset && this.focusNode == e.focusNode && this.focusOffset == e.focusOffset;
  }
  setRange(e) {
    let { anchorNode: n, focusNode: r } = e;
    this.set(n, Math.min(e.anchorOffset, n ? Ui(n) : 0), r, Math.min(e.focusOffset, r ? Ui(r) : 0));
  }
  set(e, n, r, i) {
    this.anchorNode = e, this.anchorOffset = n, this.focusNode = r, this.focusOffset = i;
  }
};
var _s = null;
function q2(t4) {
  if (t4.setActive)
    return t4.setActive();
  if (_s)
    return t4.focus(_s);
  let e = [];
  for (let n = t4; n && (e.push(n, n.scrollTop, n.scrollLeft), n != n.ownerDocument); n = n.parentNode)
    ;
  if (t4.focus(_s == null ? {
    get preventScroll() {
      return _s = { preventScroll: true }, true;
    }
  } : void 0), !_s) {
    _s = false;
    for (let n = 0; n < e.length; ) {
      let r = e[n++], i = e[n++], o = e[n++];
      r.scrollTop != i && (r.scrollTop = i), r.scrollLeft != o && (r.scrollLeft = o);
    }
  }
}
var Wb;
function hs(t4, e, n = e) {
  let r = Wb || (Wb = document.createRange());
  return r.setEnd(t4, n), r.setStart(t4, e), r;
}
function la(t4, e, n, r) {
  let i = { key: e, code: e, keyCode: n, which: n, cancelable: true };
  r && ({ altKey: i.altKey, ctrlKey: i.ctrlKey, shiftKey: i.shiftKey, metaKey: i.metaKey } = r);
  let o = new KeyboardEvent("keydown", i);
  o.synthetic = true, t4.dispatchEvent(o);
  let s = new KeyboardEvent("keyup", i);
  return s.synthetic = true, t4.dispatchEvent(s), o.defaultPrevented || s.defaultPrevented;
}
function CF(t4) {
  for (; t4; ) {
    if (t4 && (t4.nodeType == 9 || t4.nodeType == 11 && t4.host))
      return t4;
    t4 = t4.assignedSlot || t4.parentNode;
  }
  return null;
}
function U2(t4) {
  for (; t4.attributes.length; )
    t4.removeAttributeNode(t4.attributes[0]);
}
function kF(t4, e) {
  let n = e.focusNode, r = e.focusOffset;
  if (!n || e.anchorNode != n || e.anchorOffset != r)
    return false;
  for (r = Math.min(r, Ui(n)); ; )
    if (r) {
      if (n.nodeType != 1)
        return false;
      let i = n.childNodes[r - 1];
      i.contentEditable == "false" ? r-- : (n = i, r = Ui(n));
    } else {
      if (n == t4)
        return true;
      r = ds(n), n = n.parentNode;
    }
}
function H2(t4) {
  return t4.scrollTop > Math.max(1, t4.scrollHeight - t4.clientHeight - 4);
}
function J2(t4, e) {
  for (let n = t4, r = e; ; ) {
    if (n.nodeType == 3 && r > 0)
      return { node: n, offset: r };
    if (n.nodeType == 1 && r > 0) {
      if (n.contentEditable == "false")
        return null;
      n = n.childNodes[r - 1], r = Ui(n);
    } else if (n.parentNode && !td(n))
      r = ds(n), n = n.parentNode;
    else
      return null;
  }
}
function K2(t4, e) {
  for (let n = t4, r = e; ; ) {
    if (n.nodeType == 3 && r < n.nodeValue.length)
      return { node: n, offset: r };
    if (n.nodeType == 1 && r < n.childNodes.length) {
      if (n.contentEditable == "false")
        return null;
      n = n.childNodes[r], r = 0;
    } else if (n.parentNode && !td(n))
      r = ds(n) + 1, n = n.parentNode;
    else
      return null;
  }
}
var _n = class {
  constructor(e, n, r = true) {
    this.node = e, this.offset = n, this.precise = r;
  }
  static before(e, n) {
    return new _n(e.parentNode, ds(e), n);
  }
  static after(e, n) {
    return new _n(e.parentNode, ds(e) + 1, n);
  }
};
var bx = [];
var It = class {
  constructor() {
    this.parent = null, this.dom = null, this.flags = 2;
  }
  get overrideDOMText() {
    return null;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(e) {
    let n = this.posAtStart;
    for (let r of this.children) {
      if (r == e)
        return n;
      n += r.length + r.breakAfter;
    }
    throw new RangeError("Invalid child in posBefore");
  }
  posAfter(e) {
    return this.posBefore(e) + e.length;
  }
  sync(e, n) {
    if (this.flags & 2) {
      let r = this.dom, i = null, o;
      for (let s of this.children) {
        if (s.flags & 7) {
          if (!s.dom && (o = i ? i.nextSibling : r.firstChild)) {
            let a = It.get(o);
            (!a || !a.parent && a.canReuseDOM(s)) && s.reuseDOM(o);
          }
          s.sync(e, n), s.flags &= -8;
        }
        if (o = i ? i.nextSibling : r.firstChild, n && !n.written && n.node == r && o != s.dom && (n.written = true), s.dom.parentNode == r)
          for (; o && o != s.dom; )
            o = Vb(o);
        else
          r.insertBefore(s.dom, o);
        i = s.dom;
      }
      for (o = i ? i.nextSibling : r.firstChild, o && n && n.node == r && (n.written = true); o; )
        o = Vb(o);
    } else if (this.flags & 1)
      for (let r of this.children)
        r.flags & 7 && (r.sync(e, n), r.flags &= -8);
  }
  reuseDOM(e) {
  }
  localPosFromDOM(e, n) {
    let r;
    if (e == this.dom)
      r = this.dom.childNodes[n];
    else {
      let i = Ui(e) == 0 ? 0 : n == 0 ? -1 : 1;
      for (; ; ) {
        let o = e.parentNode;
        if (o == this.dom)
          break;
        i == 0 && o.firstChild != o.lastChild && (e == o.firstChild ? i = -1 : i = 1), e = o;
      }
      i < 0 ? r = e : r = e.nextSibling;
    }
    if (r == this.dom.firstChild)
      return 0;
    for (; r && !It.get(r); )
      r = r.nextSibling;
    if (!r)
      return this.length;
    for (let i = 0, o = 0; ; i++) {
      let s = this.children[i];
      if (s.dom == r)
        return o;
      o += s.length + s.breakAfter;
    }
  }
  domBoundsAround(e, n, r = 0) {
    let i = -1, o = -1, s = -1, a = -1;
    for (let l = 0, c = r, u = r; l < this.children.length; l++) {
      let f = this.children[l], d = c + f.length;
      if (c < e && d > n)
        return f.domBoundsAround(e, n, c);
      if (d >= e && i == -1 && (i = l, o = c), c > n && f.dom.parentNode == this.dom) {
        s = l, a = u;
        break;
      }
      u = d, c = d + f.breakAfter;
    }
    return {
      from: o,
      to: a < 0 ? r + this.length : a,
      startDOM: (i ? this.children[i - 1].dom.nextSibling : null) || this.dom.firstChild,
      endDOM: s < this.children.length && s >= 0 ? this.children[s].dom : null
    };
  }
  markDirty(e = false) {
    this.flags |= 2, this.markParentsDirty(e);
  }
  markParentsDirty(e) {
    for (let n = this.parent; n; n = n.parent) {
      if (e && (n.flags |= 2), n.flags & 1)
        return;
      n.flags |= 1, e = false;
    }
  }
  setParent(e) {
    this.parent != e && (this.parent = e, this.flags & 7 && this.markParentsDirty(true));
  }
  setDOM(e) {
    this.dom != e && (this.dom && (this.dom.cmView = null), this.dom = e, e.cmView = this);
  }
  get rootView() {
    for (let e = this; ; ) {
      let n = e.parent;
      if (!n)
        return e;
      e = n;
    }
  }
  replaceChildren(e, n, r = bx) {
    this.markDirty();
    for (let i = e; i < n; i++) {
      let o = this.children[i];
      o.parent == this && r.indexOf(o) < 0 && o.destroy();
    }
    this.children.splice(e, n - e, ...r);
    for (let i = 0; i < r.length; i++)
      r[i].setParent(this);
  }
  ignoreMutation(e) {
    return false;
  }
  ignoreEvent(e) {
    return false;
  }
  childCursor(e = this.length) {
    return new eE(this.children, e, this.children.length);
  }
  childPos(e, n = 1) {
    return this.childCursor().findPos(e, n);
  }
  toString() {
    let e = this.constructor.name.replace("View", "");
    return e + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (e == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
  }
  static get(e) {
    return e.cmView;
  }
  get isEditable() {
    return true;
  }
  get isWidget() {
    return false;
  }
  get isHidden() {
    return false;
  }
  merge(e, n, r, i, o, s) {
    return false;
  }
  become(e) {
    return false;
  }
  canReuseDOM(e) {
    return e.constructor == this.constructor && !((this.flags | e.flags) & 8);
  }
  // When this is a zero-length view with a side, this should return a
  // number <= 0 to indicate it is before its position, or a
  // number > 0 when after its position.
  getSide() {
    return 0;
  }
  destroy() {
    for (let e of this.children)
      e.parent == this && e.destroy();
    this.parent = null;
  }
};
It.prototype.breakAfter = 0;
function Vb(t4) {
  let e = t4.nextSibling;
  return t4.parentNode.removeChild(t4), e;
}
var eE = class {
  constructor(e, n, r) {
    this.children = e, this.pos = n, this.i = r, this.off = 0;
  }
  findPos(e, n = 1) {
    for (; ; ) {
      if (e > this.pos || e == this.pos && (n > 0 || this.i == 0 || this.children[this.i - 1].breakAfter))
        return this.off = e - this.pos, this;
      let r = this.children[--this.i];
      this.pos -= r.length + r.breakAfter;
    }
  }
};
function tE(t4, e, n, r, i, o, s, a, l) {
  let { children: c } = t4, u = c.length ? c[e] : null, f = o.length ? o[o.length - 1] : null, d = f ? f.breakAfter : s;
  if (!(e == r && u && !s && !d && o.length < 2 && u.merge(n, i, o.length ? f : null, n == 0, a, l))) {
    if (r < c.length) {
      let h = c[r];
      h && (i < h.length || h.breakAfter && (f != null && f.breakAfter)) ? (e == r && (h = h.split(i), i = 0), !d && f && h.merge(0, i, f, true, 0, l) ? o[o.length - 1] = h : ((i || h.children.length && !h.children[0].length) && h.merge(0, i, null, false, 0, l), o.push(h))) : h != null && h.breakAfter && (f ? f.breakAfter = 1 : s = 1), r++;
    }
    for (u && (u.breakAfter = s, n > 0 && (!s && o.length && u.merge(n, u.length, o[0], false, a, 0) ? u.breakAfter = o.shift().breakAfter : (n < u.length || u.children.length && u.children[u.children.length - 1].length == 0) && u.merge(n, u.length, null, false, a, 0), e++)); e < r && o.length; )
      if (c[r - 1].become(o[o.length - 1]))
        r--, o.pop(), l = o.length ? 0 : a;
      else if (c[e].become(o[0]))
        e++, o.shift(), a = o.length ? 0 : l;
      else
        break;
    !o.length && e && r < c.length && !c[e - 1].breakAfter && c[r].merge(0, 0, c[e - 1], false, a, l) && e--, (e < r || o.length) && t4.replaceChildren(e, r, o);
  }
}
function nE(t4, e, n, r, i, o) {
  let s = t4.childCursor(), { i: a, off: l } = s.findPos(n, 1), { i: c, off: u } = s.findPos(e, -1), f = e - n;
  for (let d of r)
    f += d.length;
  t4.length += f, tE(t4, c, u, a, l, r, 0, i, o);
}
var br = typeof navigator < "u" ? navigator : { userAgent: "", vendor: "", platform: "" };
var sm = typeof document < "u" ? document : { documentElement: { style: {} } };
var am = /* @__PURE__ */ /Edge\/(\d+)/.exec(br.userAgent);
var rE = /* @__PURE__ */ /MSIE \d/.test(br.userAgent);
var lm = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(br.userAgent);
var Oh = !!(rE || lm || am);
var zb = !Oh && /* @__PURE__ */ /gecko\/(\d+)/i.test(br.userAgent);
var Pp = !Oh && /* @__PURE__ */ /Chrome\/(\d+)/.exec(br.userAgent);
var Lb = "webkitFontSmoothing" in sm.documentElement.style;
var iE = !Oh && /* @__PURE__ */ /Apple Computer/.test(br.vendor);
var Xb = iE && (/* @__PURE__ */ /Mobile\/\w+/.test(br.userAgent) || br.maxTouchPoints > 2);
var me = {
  mac: Xb || /* @__PURE__ */ /Mac/.test(br.platform),
  windows: /* @__PURE__ */ /Win/.test(br.platform),
  linux: /* @__PURE__ */ /Linux|X11/.test(br.platform),
  ie: Oh,
  ie_version: rE ? sm.documentMode || 6 : lm ? +lm[1] : am ? +am[1] : 0,
  gecko: zb,
  gecko_version: zb ? +(/* @__PURE__ */ /Firefox\/(\d+)/.exec(br.userAgent) || [0, 0])[1] : 0,
  chrome: !!Pp,
  chrome_version: Pp ? +Pp[1] : 0,
  ios: Xb,
  android: /* @__PURE__ */ /Android\b/.test(br.userAgent),
  webkit: Lb,
  safari: iE,
  webkit_version: Lb ? +(/* @__PURE__ */ /\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0,
  tabSize: sm.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};
var AF = 256;
var Jr = class extends It {
  constructor(e) {
    super(), this.text = e;
  }
  get length() {
    return this.text.length;
  }
  createDOM(e) {
    this.setDOM(e || document.createTextNode(this.text));
  }
  sync(e, n) {
    this.dom || this.createDOM(), this.dom.nodeValue != this.text && (n && n.node == this.dom && (n.written = true), this.dom.nodeValue = this.text);
  }
  reuseDOM(e) {
    e.nodeType == 3 && this.createDOM(e);
  }
  merge(e, n, r) {
    return this.flags & 8 || r && (!(r instanceof Jr) || this.length - (n - e) + r.length > AF || r.flags & 8) ? false : (this.text = this.text.slice(0, e) + (r ? r.text : "") + this.text.slice(n), this.markDirty(), true);
  }
  split(e) {
    let n = new Jr(this.text.slice(e));
    return this.text = this.text.slice(0, e), this.markDirty(), n.flags |= this.flags & 8, n;
  }
  localPosFromDOM(e, n) {
    return e == this.dom ? n : n ? this.text.length : 0;
  }
  domAtPos(e) {
    return new _n(this.dom, e);
  }
  domBoundsAround(e, n, r) {
    return { from: r, to: r + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
  }
  coordsAt(e, n) {
    return PF(this.dom, e, n);
  }
};
var Hi = class extends It {
  constructor(e, n = [], r = 0) {
    super(), this.mark = e, this.children = n, this.length = r;
    for (let i of n)
      i.setParent(this);
  }
  setAttrs(e) {
    if (U2(e), this.mark.class && (e.className = this.mark.class), this.mark.attrs)
      for (let n in this.mark.attrs)
        e.setAttribute(n, this.mark.attrs[n]);
    return e;
  }
  canReuseDOM(e) {
    return super.canReuseDOM(e) && !((this.flags | e.flags) & 8);
  }
  reuseDOM(e) {
    e.nodeName == this.mark.tagName.toUpperCase() && (this.setDOM(e), this.flags |= 6);
  }
  sync(e, n) {
    this.dom ? this.flags & 4 && this.setAttrs(this.dom) : this.setDOM(this.setAttrs(document.createElement(this.mark.tagName))), super.sync(e, n);
  }
  merge(e, n, r, i, o, s) {
    return r && (!(r instanceof Hi && r.mark.eq(this.mark)) || e && o <= 0 || n < this.length && s <= 0) ? false : (nE(this, e, n, r ? r.children.slice() : [], o - 1, s - 1), this.markDirty(), true);
  }
  split(e) {
    let n = [], r = 0, i = -1, o = 0;
    for (let a of this.children) {
      let l = r + a.length;
      l > e && n.push(r < e ? a.split(e - r) : a), i < 0 && r >= e && (i = o), r = l, o++;
    }
    let s = this.length - e;
    return this.length = e, i > -1 && (this.children.length = i, this.markDirty()), new Hi(this.mark, n, s);
  }
  domAtPos(e) {
    return oE(this, e);
  }
  coordsAt(e, n) {
    return aE(this, e, n);
  }
};
function PF(t4, e, n) {
  let r = t4.nodeValue.length;
  e > r && (e = r);
  let i = e, o = e, s = 0;
  e == 0 && n < 0 || e == r && n >= 0 ? me.chrome || me.gecko || (e ? (i--, s = 1) : o < r && (o++, s = -1)) : n < 0 ? i-- : o < r && o++;
  let a = hs(t4, i, o).getClientRects();
  if (!a.length)
    return null;
  let l = a[(s ? s < 0 : n >= 0) ? 0 : a.length - 1];
  return me.safari && !s && l.width == 0 && (l = Array.prototype.find.call(a, (c) => c.width) || l), s ? mh(l, s < 0) : l || null;
}
var xo = class extends It {
  static create(e, n, r) {
    return new xo(e, n, r);
  }
  constructor(e, n, r) {
    super(), this.widget = e, this.length = n, this.side = r, this.prevWidget = null;
  }
  split(e) {
    let n = xo.create(this.widget, this.length - e, this.side);
    return this.length -= e, n;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  getSide() {
    return this.side;
  }
  merge(e, n, r, i, o, s) {
    return r && (!(r instanceof xo) || !this.widget.compare(r.widget) || e > 0 && o <= 0 || n < this.length && s <= 0) ? false : (this.length = e + (r ? r.length : 0) + (this.length - n), true);
  }
  become(e) {
    return e instanceof xo && e.side == this.side && this.widget.constructor == e.widget.constructor ? (this.widget.compare(e.widget) || this.markDirty(true), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, true) : false;
  }
  ignoreMutation() {
    return true;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get overrideDOMText() {
    if (this.length == 0)
      return ft.empty;
    let e = this;
    for (; e.parent; )
      e = e.parent;
    let { view: n } = e, r = n && n.state.doc, i = this.posAtStart;
    return r ? r.slice(i, i + this.length) : ft.empty;
  }
  domAtPos(e) {
    return (this.length ? e == 0 : this.side > 0) ? _n.before(this.dom) : _n.after(this.dom, e == this.length);
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e, n) {
    let r = this.widget.coordsAt(this.dom, e, n);
    if (r)
      return r;
    let i = this.dom.getClientRects(), o = null;
    if (!i.length)
      return null;
    let s = this.side ? this.side < 0 : e > 0;
    for (let a = s ? i.length - 1 : 0; o = i[a], !(e > 0 ? a == 0 : a == i.length - 1 || o.top < o.bottom); a += s ? -1 : 1)
      ;
    return mh(o, !s);
  }
  get isEditable() {
    return false;
  }
  get isWidget() {
    return true;
  }
  get isHidden() {
    return this.widget.isHidden;
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
};
var ka = class extends It {
  constructor(e) {
    super(), this.side = e;
  }
  get length() {
    return 0;
  }
  merge() {
    return false;
  }
  become(e) {
    return e instanceof ka && e.side == this.side;
  }
  split() {
    return new ka(this.side);
  }
  sync() {
    if (!this.dom) {
      let e = document.createElement("img");
      e.className = "cm-widgetBuffer", e.setAttribute("aria-hidden", "true"), this.setDOM(e);
    }
  }
  getSide() {
    return this.side;
  }
  domAtPos(e) {
    return this.side > 0 ? _n.before(this.dom) : _n.after(this.dom);
  }
  localPosFromDOM() {
    return 0;
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e) {
    return this.dom.getBoundingClientRect();
  }
  get overrideDOMText() {
    return ft.empty;
  }
  get isHidden() {
    return true;
  }
};
Jr.prototype.children = xo.prototype.children = ka.prototype.children = bx;
function oE(t4, e) {
  let n = t4.dom, { children: r } = t4, i = 0;
  for (let o = 0; i < r.length; i++) {
    let s = r[i], a = o + s.length;
    if (!(a == o && s.getSide() <= 0)) {
      if (e > o && e < a && s.dom.parentNode == n)
        return s.domAtPos(e - o);
      if (e <= o)
        break;
      o = a;
    }
  }
  for (let o = i; o > 0; o--) {
    let s = r[o - 1];
    if (s.dom.parentNode == n)
      return s.domAtPos(s.length);
  }
  for (let o = i; o < r.length; o++) {
    let s = r[o];
    if (s.dom.parentNode == n)
      return s.domAtPos(0);
  }
  return new _n(n, 0);
}
function sE(t4, e, n) {
  let r, { children: i } = t4;
  n > 0 && e instanceof Hi && i.length && (r = i[i.length - 1]) instanceof Hi && r.mark.eq(e.mark) ? sE(r, e.children[0], n - 1) : (i.push(e), e.setParent(t4)), t4.length += e.length;
}
function aE(t4, e, n) {
  let r = null, i = -1, o = null, s = -1;
  function a(c, u) {
    for (let f = 0, d = 0; f < c.children.length && d <= u; f++) {
      let h = c.children[f], p = d + h.length;
      p >= u && (h.children.length ? a(h, u - d) : (!o || o.isHidden && n > 0) && (p > u || d == p && h.getSide() > 0) ? (o = h, s = u - d) : (d < u || d == p && h.getSide() < 0 && !h.isHidden) && (r = h, i = u - d)), d = p;
    }
  }
  a(t4, e);
  let l = (n < 0 ? r : o) || r || o;
  return l ? l.coordsAt(Math.max(0, l == r ? i : s), n) : EF(t4);
}
function EF(t4) {
  let e = t4.dom.lastChild;
  if (!e)
    return t4.dom.getBoundingClientRect();
  let n = Ca(e);
  return n[n.length - 1] || null;
}
function cm(t4, e) {
  for (let n in t4)
    n == "class" && e.class ? e.class += " " + t4.class : n == "style" && e.style ? e.style += ";" + t4.style : e[n] = t4[n];
  return e;
}
var Gb = /* @__PURE__ */ Object.create(null);
function Sx(t4, e, n) {
  if (t4 == e)
    return true;
  t4 || (t4 = Gb), e || (e = Gb);
  let r = Object.keys(t4), i = Object.keys(e);
  if (r.length - (n && r.indexOf(n) > -1 ? 1 : 0) != i.length - (n && i.indexOf(n) > -1 ? 1 : 0))
    return false;
  for (let o of r)
    if (o != n && (i.indexOf(o) == -1 || t4[o] !== e[o]))
      return false;
  return true;
}
function um(t4, e, n) {
  let r = false;
  if (e)
    for (let i in e)
      n && i in n || (r = true, i == "style" ? t4.style.cssText = "" : t4.removeAttribute(i));
  if (n)
    for (let i in n)
      e && e[i] == n[i] || (r = true, i == "style" ? t4.style.cssText = n[i] : t4.setAttribute(i, n[i]));
  return r;
}
function TF(t4) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let n = 0; n < t4.attributes.length; n++) {
    let r = t4.attributes[n];
    e[r.name] = r.value;
  }
  return e;
}
var ln = class extends It {
  constructor() {
    super(...arguments), this.children = [], this.length = 0, this.prevAttrs = void 0, this.attrs = null, this.breakAfter = 0;
  }
  // Consumes source
  merge(e, n, r, i, o, s) {
    if (r) {
      if (!(r instanceof ln))
        return false;
      this.dom || r.transferDOM(this);
    }
    return i && this.setDeco(r ? r.attrs : null), nE(this, e, n, r ? r.children.slice() : [], o, s), true;
  }
  split(e) {
    let n = new ln();
    if (n.breakAfter = this.breakAfter, this.length == 0)
      return n;
    let { i: r, off: i } = this.childPos(e);
    i && (n.append(this.children[r].split(i), 0), this.children[r].merge(i, this.children[r].length, null, false, 0, 0), r++);
    for (let o = r; o < this.children.length; o++)
      n.append(this.children[o], 0);
    for (; r > 0 && this.children[r - 1].length == 0; )
      this.children[--r].destroy();
    return this.children.length = r, this.markDirty(), this.length = e, n;
  }
  transferDOM(e) {
    this.dom && (this.markDirty(), e.setDOM(this.dom), e.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs, this.prevAttrs = void 0, this.dom = null);
  }
  setDeco(e) {
    Sx(this.attrs, e) || (this.dom && (this.prevAttrs = this.attrs, this.markDirty()), this.attrs = e);
  }
  append(e, n) {
    sE(this, e, n);
  }
  // Only called when building a line view in ContentBuilder
  addLineDeco(e) {
    let n = e.spec.attributes, r = e.spec.class;
    n && (this.attrs = cm(n, this.attrs || {})), r && (this.attrs = cm({ class: r }, this.attrs || {}));
  }
  domAtPos(e) {
    return oE(this, e);
  }
  reuseDOM(e) {
    e.nodeName == "DIV" && (this.setDOM(e), this.flags |= 6);
  }
  sync(e, n) {
    var r;
    this.dom ? this.flags & 4 && (U2(this.dom), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0) : (this.setDOM(document.createElement("div")), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0), this.prevAttrs !== void 0 && (um(this.dom, this.prevAttrs, this.attrs), this.dom.classList.add("cm-line"), this.prevAttrs = void 0), super.sync(e, n);
    let i = this.dom.lastChild;
    for (; i && It.get(i) instanceof Hi; )
      i = i.lastChild;
    if (!i || !this.length || i.nodeName != "BR" && ((r = It.get(i)) === null || r === void 0 ? void 0 : r.isEditable) == false && (!me.ios || !this.children.some((o) => o instanceof Jr))) {
      let o = document.createElement("BR");
      o.cmIgnore = true, this.dom.appendChild(o);
    }
  }
  measureTextSize() {
    if (this.children.length == 0 || this.length > 20)
      return null;
    let e = 0, n;
    for (let r of this.children) {
      if (!(r instanceof Jr) || /[^ -~]/.test(r.text))
        return null;
      let i = Ca(r.dom);
      if (i.length != 1)
        return null;
      e += i[0].width, n = i[0].height;
    }
    return e ? {
      lineHeight: this.dom.getBoundingClientRect().height,
      charWidth: e / this.length,
      textHeight: n
    } : null;
  }
  coordsAt(e, n) {
    let r = aE(this, e, n);
    if (!this.children.length && r && this.parent) {
      let { heightOracle: i } = this.parent.view.viewState, o = r.bottom - r.top;
      if (Math.abs(o - i.lineHeight) < 2 && i.textHeight < o) {
        let s = (o - i.textHeight) / 2;
        return { top: r.top + s, bottom: r.bottom - s, left: r.left, right: r.left };
      }
    }
    return r;
  }
  become(e) {
    return false;
  }
  covers() {
    return true;
  }
  static find(e, n) {
    for (let r = 0, i = 0; r < e.children.length; r++) {
      let o = e.children[r], s = i + o.length;
      if (s >= n) {
        if (o instanceof ln)
          return o;
        if (s > n)
          break;
      }
      i = s + o.breakAfter;
    }
    return null;
  }
};
var wo = class extends It {
  constructor(e, n, r) {
    super(), this.widget = e, this.length = n, this.deco = r, this.breakAfter = 0, this.prevWidget = null;
  }
  merge(e, n, r, i, o, s) {
    return r && (!(r instanceof wo) || !this.widget.compare(r.widget) || e > 0 && o <= 0 || n < this.length && s <= 0) ? false : (this.length = e + (r ? r.length : 0) + (this.length - n), true);
  }
  domAtPos(e) {
    return e == 0 ? _n.before(this.dom) : _n.after(this.dom, e == this.length);
  }
  split(e) {
    let n = this.length - e;
    this.length = e;
    let r = new wo(this.widget, n, this.deco);
    return r.breakAfter = this.breakAfter, r;
  }
  get children() {
    return bx;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  get overrideDOMText() {
    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : ft.empty;
  }
  domBoundsAround() {
    return null;
  }
  become(e) {
    return e instanceof wo && e.widget.constructor == this.widget.constructor ? (e.widget.compare(this.widget) || this.markDirty(true), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, this.deco = e.deco, this.breakAfter = e.breakAfter, true) : false;
  }
  ignoreMutation() {
    return true;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get isEditable() {
    return false;
  }
  get isWidget() {
    return true;
  }
  coordsAt(e, n) {
    return this.widget.coordsAt(this.dom, e, n);
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
  covers(e) {
    let { startSide: n, endSide: r } = this.deco;
    return n == r ? false : e < 0 ? n < 0 : r > 0;
  }
};
var Qi = class {
  /**
  Compare this instance to another instance of the same type.
  (TypeScript can't express this, but only instances of the same
  specific class will be passed to this method.) This is used to
  avoid redrawing widgets when they are replaced by a new
  decoration of the same type. The default implementation just
  returns `false`, which will cause new instances of the widget to
  always be redrawn.
  */
  eq(e) {
    return false;
  }
  /**
  Update a DOM element created by a widget of the same type (but
  different, non-`eq` content) to reflect this widget. May return
  true to indicate that it could update, false to indicate it
  couldn't (in which case the widget will be redrawn). The default
  implementation just returns false.
  */
  updateDOM(e, n) {
    return false;
  }
  /**
  @internal
  */
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  /**
  The estimated height this widget will have, to be used when
  estimating the height of content that hasn't been drawn. May
  return -1 to indicate you don't know. The default implementation
  returns -1.
  */
  get estimatedHeight() {
    return -1;
  }
  /**
  For inline widgets that are displayed inline (as opposed to
  `inline-block`) and introduce line breaks (through `<br>` tags
  or textual newlines), this must indicate the amount of line
  breaks they introduce. Defaults to 0.
  */
  get lineBreaks() {
    return 0;
  }
  /**
  Can be used to configure which kinds of events inside the widget
  should be ignored by the editor. The default is to ignore all
  events.
  */
  ignoreEvent(e) {
    return true;
  }
  /**
  Override the way screen coordinates for positions at/in the
  widget are found. `pos` will be the offset into the widget, and
  `side` the side of the position that is being queried—less than
  zero for before, greater than zero for after, and zero for
  directly at that position.
  */
  coordsAt(e, n, r) {
    return null;
  }
  /**
  @internal
  */
  get isHidden() {
    return false;
  }
  /**
  @internal
  */
  get editable() {
    return false;
  }
  /**
  This is called when the an instance of the widget is removed
  from the editor view.
  */
  destroy(e) {
  }
};
var Yn = /* @__PURE__ */ function(t4) {
  return t4[t4.Text = 0] = "Text", t4[t4.WidgetBefore = 1] = "WidgetBefore", t4[t4.WidgetAfter = 2] = "WidgetAfter", t4[t4.WidgetRange = 3] = "WidgetRange", t4;
}(Yn || (Yn = {}));
var we = class extends fs {
  constructor(e, n, r, i) {
    super(), this.startSide = e, this.endSide = n, this.widget = r, this.spec = i;
  }
  /**
  @internal
  */
  get heightRelevant() {
    return false;
  }
  /**
  Create a mark decoration, which influences the styling of the
  content in its range. Nested mark decorations will cause nested
  DOM elements to be created. Nesting order is determined by
  precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with
  the higher-precedence decorations creating the inner DOM nodes.
  Such elements are split on line boundaries and on the boundaries
  of lower-precedence decorations.
  */
  static mark(e) {
    return new Rc(e);
  }
  /**
  Create a widget decoration, which displays a DOM element at the
  given position.
  */
  static widget(e) {
    let n = Math.max(-1e4, Math.min(1e4, e.side || 0)), r = !!e.block;
    return n += r && !e.inlineOrder ? n > 0 ? 3e8 : -4e8 : n > 0 ? 1e8 : -1e8, new jo(e, n, n, r, e.widget || null, false);
  }
  /**
  Create a replace decoration which replaces the given range with
  a widget, or simply hides it.
  */
  static replace(e) {
    let n = !!e.block, r, i;
    if (e.isBlockGap)
      r = -5e8, i = 4e8;
    else {
      let { start: o, end: s } = lE(e, n);
      r = (o ? n ? -3e8 : -1 : 5e8) - 1, i = (s ? n ? 2e8 : 1 : -6e8) + 1;
    }
    return new jo(e, r, i, n, e.widget || null, true);
  }
  /**
  Create a line decoration, which can add DOM attributes to the
  line starting at the given position.
  */
  static line(e) {
    return new Dc(e);
  }
  /**
  Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given
  decorated range or ranges. If the ranges aren't already sorted,
  pass `true` for `sort` to make the library sort them for you.
  */
  static set(e, n = false) {
    return ot.of(e, n);
  }
  /**
  @internal
  */
  hasHeight() {
    return this.widget ? this.widget.estimatedHeight > -1 : false;
  }
};
we.none = ot.empty;
var Rc = class extends we {
  constructor(e) {
    let { start: n, end: r } = lE(e);
    super(n ? -1 : 5e8, r ? 1 : -6e8, null, e), this.tagName = e.tagName || "span", this.class = e.class || "", this.attrs = e.attributes || null;
  }
  eq(e) {
    var n, r;
    return this == e || e instanceof Rc && this.tagName == e.tagName && (this.class || ((n = this.attrs) === null || n === void 0 ? void 0 : n.class)) == (e.class || ((r = e.attrs) === null || r === void 0 ? void 0 : r.class)) && Sx(this.attrs, e.attrs, "class");
  }
  range(e, n = e) {
    if (e >= n)
      throw new RangeError("Mark decorations may not be empty");
    return super.range(e, n);
  }
};
Rc.prototype.point = false;
var Dc = class extends we {
  constructor(e) {
    super(-2e8, -2e8, null, e);
  }
  eq(e) {
    return e instanceof Dc && this.spec.class == e.spec.class && Sx(this.spec.attributes, e.spec.attributes);
  }
  range(e, n = e) {
    if (n != e)
      throw new RangeError("Line decoration ranges must be zero-length");
    return super.range(e, n);
  }
};
Dc.prototype.mapMode = Tn.TrackBefore;
Dc.prototype.point = true;
var jo = class extends we {
  constructor(e, n, r, i, o, s) {
    super(n, r, o, e), this.block = i, this.isReplace = s, this.mapMode = i ? n <= 0 ? Tn.TrackBefore : Tn.TrackAfter : Tn.TrackDel;
  }
  // Only relevant when this.block == true
  get type() {
    return this.startSide != this.endSide ? Yn.WidgetRange : this.startSide <= 0 ? Yn.WidgetBefore : Yn.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
  }
  eq(e) {
    return e instanceof jo && IF(this.widget, e.widget) && this.block == e.block && this.startSide == e.startSide && this.endSide == e.endSide;
  }
  range(e, n = e) {
    if (this.isReplace && (e > n || e == n && this.startSide > 0 && this.endSide <= 0))
      throw new RangeError("Invalid range for replacement decoration");
    if (!this.isReplace && n != e)
      throw new RangeError("Widget decorations can only have zero-length ranges");
    return super.range(e, n);
  }
};
jo.prototype.point = true;
function lE(t4, e = false) {
  let { inclusiveStart: n, inclusiveEnd: r } = t4;
  return n == null && (n = t4.inclusive), r == null && (r = t4.inclusive), { start: n ?? e, end: r ?? e };
}
function IF(t4, e) {
  return t4 == e || !!(t4 && e && t4.compare(e));
}
function fm(t4, e, n, r = 0) {
  let i = n.length - 1;
  i >= 0 && n[i] + r >= t4 ? n[i] = Math.max(n[i], e) : n.push(t4, e);
}
var Vl = class {
  constructor(e, n, r, i) {
    this.doc = e, this.pos = n, this.end = r, this.disallowBlockEffectsFor = i, this.content = [], this.curLine = null, this.breakAtStart = 0, this.pendingBuffer = 0, this.bufferMarks = [], this.atCursorPos = true, this.openStart = -1, this.openEnd = -1, this.text = "", this.textOff = 0, this.cursor = e.iter(), this.skip = n;
  }
  posCovered() {
    if (this.content.length == 0)
      return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
    let e = this.content[this.content.length - 1];
    return !(e.breakAfter || e instanceof wo && e.deco.endSide < 0);
  }
  getLine() {
    return this.curLine || (this.content.push(this.curLine = new ln()), this.atCursorPos = true), this.curLine;
  }
  flushBuffer(e = this.bufferMarks) {
    this.pendingBuffer && (this.curLine.append(Cu(new ka(-1), e), e.length), this.pendingBuffer = 0);
  }
  addBlockWidget(e) {
    this.flushBuffer(), this.curLine = null, this.content.push(e);
  }
  finish(e) {
    this.pendingBuffer && e <= this.bufferMarks.length ? this.flushBuffer() : this.pendingBuffer = 0, !this.posCovered() && !(e && this.content.length && this.content[this.content.length - 1] instanceof wo) && this.getLine();
  }
  buildText(e, n, r) {
    for (; e > 0; ) {
      if (this.textOff == this.text.length) {
        let { value: o, lineBreak: s, done: a } = this.cursor.next(this.skip);
        if (this.skip = 0, a)
          throw new Error("Ran out of text content when drawing inline views");
        if (s) {
          this.posCovered() || this.getLine(), this.content.length ? this.content[this.content.length - 1].breakAfter = 1 : this.breakAtStart = 1, this.flushBuffer(), this.curLine = null, this.atCursorPos = true, e--;
          continue;
        } else
          this.text = o, this.textOff = 0;
      }
      let i = Math.min(
        this.text.length - this.textOff,
        e,
        512
        /* T.Chunk */
      );
      this.flushBuffer(n.slice(n.length - r)), this.getLine().append(Cu(new Jr(this.text.slice(this.textOff, this.textOff + i)), n), r), this.atCursorPos = true, this.textOff += i, e -= i, r = 0;
    }
  }
  span(e, n, r, i) {
    this.buildText(n - e, r, i), this.pos = n, this.openStart < 0 && (this.openStart = i);
  }
  point(e, n, r, i, o, s) {
    if (this.disallowBlockEffectsFor[s] && r instanceof jo) {
      if (r.block)
        throw new RangeError("Block decorations may not be specified via plugins");
      if (n > this.doc.lineAt(this.pos).to)
        throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
    }
    let a = n - e;
    if (r instanceof jo)
      if (r.block)
        r.startSide > 0 && !this.posCovered() && this.getLine(), this.addBlockWidget(new wo(r.widget || Aa.block, a, r));
      else {
        let l = xo.create(r.widget || Aa.inline, a, a ? 0 : r.startSide), c = this.atCursorPos && !l.isEditable && o <= i.length && (e < n || r.startSide > 0), u = !l.isEditable && (e < n || o > i.length || r.startSide <= 0), f = this.getLine();
        this.pendingBuffer == 2 && !c && !l.isEditable && (this.pendingBuffer = 0), this.flushBuffer(i), c && (f.append(Cu(new ka(1), i), o), o = i.length + Math.max(0, o - i.length)), f.append(Cu(l, i), o), this.atCursorPos = u, this.pendingBuffer = u ? e < n || o > i.length ? 1 : 2 : 0, this.pendingBuffer && (this.bufferMarks = i.slice());
      }
    else
      this.doc.lineAt(this.pos).from == this.pos && this.getLine().addLineDeco(r);
    a && (this.textOff + a <= this.text.length ? this.textOff += a : (this.skip += a - (this.text.length - this.textOff), this.text = "", this.textOff = 0), this.pos = n), this.openStart < 0 && (this.openStart = o);
  }
  static build(e, n, r, i, o) {
    let s = new Vl(e, n, r, o);
    return s.openEnd = ot.spans(i, n, r, s), s.openStart < 0 && (s.openStart = s.openEnd), s.finish(s.openEnd), s;
  }
};
function Cu(t4, e) {
  for (let n of e)
    t4 = new Hi(n, [t4], t4.length);
  return t4;
}
var Aa = class extends Qi {
  constructor(e) {
    super(), this.tag = e;
  }
  eq(e) {
    return e.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(e) {
    return e.nodeName.toLowerCase() == this.tag;
  }
  get isHidden() {
    return true;
  }
};
Aa.inline = /* @__PURE__ */ new Aa("span");
Aa.block = /* @__PURE__ */ new Aa("div");
var _t = /* @__PURE__ */ function(t4) {
  return t4[t4.LTR = 0] = "LTR", t4[t4.RTL = 1] = "RTL", t4;
}(_t || (_t = {}));
var ps = _t.LTR;
var wx = _t.RTL;
function cE(t4) {
  let e = [];
  for (let n = 0; n < t4.length; n++)
    e.push(1 << +t4[n]);
  return e;
}
var $F = /* @__PURE__ */ cE("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008");
var jF = /* @__PURE__ */ cE("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333");
var dm = /* @__PURE__ */ Object.create(null);
var ai = [];
for (let t4 of ["()", "[]", "{}"]) {
  let e = /* @__PURE__ */ t4.charCodeAt(0), n = /* @__PURE__ */ t4.charCodeAt(1);
  dm[e] = n, dm[n] = -e;
}
function uE(t4) {
  return t4 <= 247 ? $F[t4] : 1424 <= t4 && t4 <= 1524 ? 2 : 1536 <= t4 && t4 <= 1785 ? jF[t4 - 1536] : 1774 <= t4 && t4 <= 2220 ? 4 : 8192 <= t4 && t4 <= 8204 ? 256 : 64336 <= t4 && t4 <= 65023 ? 4 : 1;
}
var RF = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
var vo = class {
  /**
  The direction of this span.
  */
  get dir() {
    return this.level % 2 ? wx : ps;
  }
  /**
  @internal
  */
  constructor(e, n, r) {
    this.from = e, this.to = n, this.level = r;
  }
  /**
  @internal
  */
  side(e, n) {
    return this.dir == n == e ? this.to : this.from;
  }
  /**
  @internal
  */
  forward(e, n) {
    return e == (this.dir == n);
  }
  /**
  @internal
  */
  static find(e, n, r, i) {
    let o = -1;
    for (let s = 0; s < e.length; s++) {
      let a = e[s];
      if (a.from <= n && a.to >= n) {
        if (a.level == r)
          return s;
        (o < 0 || (i != 0 ? i < 0 ? a.from < n : a.to > n : e[o].level > a.level)) && (o = s);
      }
    }
    if (o < 0)
      throw new RangeError("Index out of range");
    return o;
  }
};
function fE(t4, e) {
  if (t4.length != e.length)
    return false;
  for (let n = 0; n < t4.length; n++) {
    let r = t4[n], i = e[n];
    if (r.from != i.from || r.to != i.to || r.direction != i.direction || !fE(r.inner, i.inner))
      return false;
  }
  return true;
}
var Tt = [];
function DF(t4, e, n, r, i) {
  for (let o = 0; o <= r.length; o++) {
    let s = o ? r[o - 1].to : e, a = o < r.length ? r[o].from : n, l = o ? 256 : i;
    for (let c = s, u = l, f = l; c < a; c++) {
      let d = uE(t4.charCodeAt(c));
      d == 512 ? d = u : d == 8 && f == 4 && (d = 16), Tt[c] = d == 4 ? 2 : d, d & 7 && (f = d), u = d;
    }
    for (let c = s, u = l, f = l; c < a; c++) {
      let d = Tt[c];
      if (d == 128)
        c < a - 1 && u == Tt[c + 1] && u & 24 ? d = Tt[c] = u : Tt[c] = 256;
      else if (d == 64) {
        let h = c + 1;
        for (; h < a && Tt[h] == 64; )
          h++;
        let p = c && u == 8 || h < n && Tt[h] == 8 ? f == 1 ? 1 : 8 : 256;
        for (let O = c; O < h; O++)
          Tt[O] = p;
        c = h - 1;
      } else
        d == 8 && f == 1 && (Tt[c] = 1);
      u = d, d & 7 && (f = d);
    }
  }
}
function QF(t4, e, n, r, i) {
  let o = i == 1 ? 2 : 1;
  for (let s = 0, a = 0, l = 0; s <= r.length; s++) {
    let c = s ? r[s - 1].to : e, u = s < r.length ? r[s].from : n;
    for (let f = c, d, h, p; f < u; f++)
      if (h = dm[d = t4.charCodeAt(f)])
        if (h < 0) {
          for (let O = a - 3; O >= 0; O -= 3)
            if (ai[O + 1] == -h) {
              let m = ai[O + 2], x = m & 2 ? i : m & 4 ? m & 1 ? o : i : 0;
              x && (Tt[f] = Tt[ai[O]] = x), a = O;
              break;
            }
        } else {
          if (ai.length == 189)
            break;
          ai[a++] = f, ai[a++] = d, ai[a++] = l;
        }
      else if ((p = Tt[f]) == 2 || p == 1) {
        let O = p == i;
        l = O ? 0 : 1;
        for (let m = a - 3; m >= 0; m -= 3) {
          let x = ai[m + 2];
          if (x & 2)
            break;
          if (O)
            ai[m + 2] |= 2;
          else {
            if (x & 4)
              break;
            ai[m + 2] |= 4;
          }
        }
      }
  }
}
function BF(t4, e, n, r) {
  for (let i = 0, o = r; i <= n.length; i++) {
    let s = i ? n[i - 1].to : t4, a = i < n.length ? n[i].from : e;
    for (let l = s; l < a; ) {
      let c = Tt[l];
      if (c == 256) {
        let u = l + 1;
        for (; ; )
          if (u == a) {
            if (i == n.length)
              break;
            u = n[i++].to, a = i < n.length ? n[i].from : e;
          } else if (Tt[u] == 256)
            u++;
          else
            break;
        let f = o == 1, d = (u < e ? Tt[u] : r) == 1, h = f == d ? f ? 1 : 2 : r;
        for (let p = u, O = i, m = O ? n[O - 1].to : t4; p > l; )
          p == m && (p = n[--O].from, m = O ? n[O - 1].to : t4), Tt[--p] = h;
        l = u;
      } else
        o = c, l++;
    }
  }
}
function hm(t4, e, n, r, i, o, s) {
  let a = r % 2 ? 2 : 1;
  if (r % 2 == i % 2)
    for (let l = e, c = 0; l < n; ) {
      let u = true, f = false;
      if (c == o.length || l < o[c].from) {
        let O = Tt[l];
        O != a && (u = false, f = O == 16);
      }
      let d = !u && a == 1 ? [] : null, h = u ? r : r + 1, p = l;
      e:
        for (; ; )
          if (c < o.length && p == o[c].from) {
            if (f)
              break e;
            let O = o[c];
            if (!u)
              for (let m = O.to, x = c + 1; ; ) {
                if (m == n)
                  break e;
                if (x < o.length && o[x].from == m)
                  m = o[x++].to;
                else {
                  if (Tt[m] == a)
                    break e;
                  break;
                }
              }
            if (c++, d)
              d.push(O);
            else {
              O.from > l && s.push(new vo(l, O.from, h));
              let m = O.direction == ps != !(h % 2);
              pm(t4, m ? r + 1 : r, i, O.inner, O.from, O.to, s), l = O.to;
            }
            p = O.to;
          } else {
            if (p == n || (u ? Tt[p] != a : Tt[p] == a))
              break;
            p++;
          }
      d ? hm(t4, l, p, r + 1, i, d, s) : l < p && s.push(new vo(l, p, h)), l = p;
    }
  else
    for (let l = n, c = o.length; l > e; ) {
      let u = true, f = false;
      if (!c || l > o[c - 1].to) {
        let O = Tt[l - 1];
        O != a && (u = false, f = O == 16);
      }
      let d = !u && a == 1 ? [] : null, h = u ? r : r + 1, p = l;
      e:
        for (; ; )
          if (c && p == o[c - 1].to) {
            if (f)
              break e;
            let O = o[--c];
            if (!u)
              for (let m = O.from, x = c; ; ) {
                if (m == e)
                  break e;
                if (x && o[x - 1].to == m)
                  m = o[--x].from;
                else {
                  if (Tt[m - 1] == a)
                    break e;
                  break;
                }
              }
            if (d)
              d.push(O);
            else {
              O.to < l && s.push(new vo(O.to, l, h));
              let m = O.direction == ps != !(h % 2);
              pm(t4, m ? r + 1 : r, i, O.inner, O.from, O.to, s), l = O.from;
            }
            p = O.from;
          } else {
            if (p == e || (u ? Tt[p - 1] != a : Tt[p - 1] == a))
              break;
            p--;
          }
      d ? hm(t4, p, l, r + 1, i, d, s) : p < l && s.push(new vo(p, l, h)), l = p;
    }
}
function pm(t4, e, n, r, i, o, s) {
  let a = e % 2 ? 2 : 1;
  DF(t4, i, o, r, a), QF(t4, i, o, r, a), BF(i, o, r, a), hm(t4, i, o, e, n, r, s);
}
function _F(t4, e, n) {
  if (!t4)
    return [new vo(0, 0, e == wx ? 1 : 0)];
  if (e == ps && !n.length && !RF.test(t4))
    return dE(t4.length);
  if (n.length)
    for (; t4.length > Tt.length; )
      Tt[Tt.length] = 256;
  let r = [], i = e == ps ? 0 : 1;
  return pm(t4, i, i, n, 0, t4.length, r), r;
}
function dE(t4) {
  return [new vo(0, t4, 0)];
}
var hE = "";
function MF(t4, e, n, r, i) {
  var o;
  let s = r.head - t4.from, a = vo.find(e, s, (o = r.bidiLevel) !== null && o !== void 0 ? o : -1, r.assoc), l = e[a], c = l.side(i, n);
  if (s == c) {
    let d = a += i ? 1 : -1;
    if (d < 0 || d >= e.length)
      return null;
    l = e[a = d], s = l.side(!i, n), c = l.side(i, n);
  }
  let u = $n(t4.text, s, l.forward(i, n));
  (u < l.from || u > l.to) && (u = c), hE = t4.text.slice(Math.min(s, u), Math.max(s, u));
  let f = a == (i ? e.length - 1 : 0) ? null : e[a + (i ? 1 : -1)];
  return f && u == c && f.level + (i ? 0 : 1) < l.level ? ne.cursor(f.side(!i, n) + t4.from, f.forward(i, n) ? 1 : -1, f.level) : ne.cursor(u + t4.from, l.forward(i, n) ? -1 : 1, l.level);
}
function NF(t4, e, n) {
  for (let r = e; r < n; r++) {
    let i = uE(t4.charCodeAt(r));
    if (i == 1)
      return ps;
    if (i == 2 || i == 4)
      return wx;
  }
  return ps;
}
var pE = /* @__PURE__ */ ge.define();
var gE = /* @__PURE__ */ ge.define();
var mE = /* @__PURE__ */ ge.define();
var OE = /* @__PURE__ */ ge.define();
var gm = /* @__PURE__ */ ge.define();
var xE = /* @__PURE__ */ ge.define();
var vE = /* @__PURE__ */ ge.define();
var yE = /* @__PURE__ */ ge.define({
  combine: (t4) => t4.some((e) => e)
});
var bE = /* @__PURE__ */ ge.define({
  combine: (t4) => t4.some((e) => e)
});
var SE = /* @__PURE__ */ ge.define();
var ca = class {
  constructor(e, n = "nearest", r = "nearest", i = 5, o = 5, s = false) {
    this.range = e, this.y = n, this.x = r, this.yMargin = i, this.xMargin = o, this.isSnapshot = s;
  }
  map(e) {
    return e.empty ? this : new ca(this.range.map(e), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
  clip(e) {
    return this.range.to <= e.doc.length ? this : new ca(ne.cursor(e.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
};
var ku = /* @__PURE__ */ Me.define({ map: (t4, e) => t4.map(e) });
function Gn(t4, e, n) {
  let r = t4.facet(OE);
  r.length ? r[0](e) : window.onerror ? window.onerror(String(e), n, void 0, void 0, e) : n ? console.error(n + ":", e) : console.error(e);
}
var xh = /* @__PURE__ */ ge.define({ combine: (t4) => t4.length ? t4[0] : true });
var FF = 0;
var Pl = /* @__PURE__ */ ge.define();
var Wt = class {
  constructor(e, n, r, i, o) {
    this.id = e, this.create = n, this.domEventHandlers = r, this.domEventObservers = i, this.extension = o(this);
  }
  /**
  Define a plugin from a constructor function that creates the
  plugin's value, given an editor view.
  */
  static define(e, n) {
    const { eventHandlers: r, eventObservers: i, provide: o, decorations: s } = n || {};
    return new Wt(FF++, e, r, i, (a) => {
      let l = [Pl.of(a)];
      return s && l.push(ic.of((c) => {
        let u = c.plugin(a);
        return u ? s(u) : we.none;
      })), o && l.push(o(a)), l;
    });
  }
  /**
  Create a plugin for a class whose constructor takes a single
  editor view as argument.
  */
  static fromClass(e, n) {
    return Wt.define((r) => new e(r), n);
  }
};
var Ep = class {
  constructor(e) {
    this.spec = e, this.mustUpdate = null, this.value = null;
  }
  update(e) {
    if (this.value) {
      if (this.mustUpdate) {
        let n = this.mustUpdate;
        if (this.mustUpdate = null, this.value.update)
          try {
            this.value.update(n);
          } catch (r) {
            if (Gn(n.state, r, "CodeMirror plugin crashed"), this.value.destroy)
              try {
                this.value.destroy();
              } catch {
              }
            this.deactivate();
          }
      }
    } else if (this.spec)
      try {
        this.value = this.spec.create(e);
      } catch (n) {
        Gn(e.state, n, "CodeMirror plugin crashed"), this.deactivate();
      }
    return this;
  }
  destroy(e) {
    var n;
    if (!((n = this.value) === null || n === void 0) && n.destroy)
      try {
        this.value.destroy();
      } catch (r) {
        Gn(e.state, r, "CodeMirror plugin crashed");
      }
  }
  deactivate() {
    this.spec = this.value = null;
  }
};
var wE = /* @__PURE__ */ ge.define();
var Cx = /* @__PURE__ */ ge.define();
var ic = /* @__PURE__ */ ge.define();
var CE = /* @__PURE__ */ ge.define();
var kx = /* @__PURE__ */ ge.define();
var kE = /* @__PURE__ */ ge.define();
function Yb(t4, e) {
  let n = t4.state.facet(kE);
  if (!n.length)
    return n;
  let r = n.map((o) => o instanceof Function ? o(t4) : o), i = [];
  return ot.spans(r, e.from, e.to, {
    point() {
    },
    span(o, s, a, l) {
      let c = o - e.from, u = s - e.from, f = i;
      for (let d = a.length - 1; d >= 0; d--, l--) {
        let h = a[d].spec.bidiIsolate, p;
        if (h == null && (h = NF(e.text, c, u)), l > 0 && f.length && (p = f[f.length - 1]).to == c && p.direction == h)
          p.to = u, f = p.inner;
        else {
          let O = { from: c, to: u, direction: h, inner: [] };
          f.push(O), f = O.inner;
        }
      }
    }
  }), i;
}
var AE = /* @__PURE__ */ ge.define();
function PE(t4) {
  let e = 0, n = 0, r = 0, i = 0;
  for (let o of t4.state.facet(AE)) {
    let s = o(t4);
    s && (s.left != null && (e = Math.max(e, s.left)), s.right != null && (n = Math.max(n, s.right)), s.top != null && (r = Math.max(r, s.top)), s.bottom != null && (i = Math.max(i, s.bottom)));
  }
  return { left: e, right: n, top: r, bottom: i };
}
var El = /* @__PURE__ */ ge.define();
var Br = class {
  constructor(e, n, r, i) {
    this.fromA = e, this.toA = n, this.fromB = r, this.toB = i;
  }
  join(e) {
    return new Br(Math.min(this.fromA, e.fromA), Math.max(this.toA, e.toA), Math.min(this.fromB, e.fromB), Math.max(this.toB, e.toB));
  }
  addToSet(e) {
    let n = e.length, r = this;
    for (; n > 0; n--) {
      let i = e[n - 1];
      if (!(i.fromA > r.toA)) {
        if (i.toA < r.fromA)
          break;
        r = r.join(i), e.splice(n - 1, 1);
      }
    }
    return e.splice(n, 0, r), e;
  }
  static extendWithRanges(e, n) {
    if (n.length == 0)
      return e;
    let r = [];
    for (let i = 0, o = 0, s = 0, a = 0; ; i++) {
      let l = i == e.length ? null : e[i], c = s - a, u = l ? l.fromB : 1e9;
      for (; o < n.length && n[o] < u; ) {
        let f = n[o], d = n[o + 1], h = Math.max(a, f), p = Math.min(u, d);
        if (h <= p && new Br(h + c, p + c, h, p).addToSet(r), d > u)
          break;
        o += 2;
      }
      if (!l)
        return r;
      new Br(l.fromA, l.toA, l.fromB, l.toB).addToSet(r), s = l.toA, a = l.toB;
    }
  }
};
var nd = class {
  constructor(e, n, r) {
    this.view = e, this.state = n, this.transactions = r, this.flags = 0, this.startState = e.state, this.changes = un.empty(this.startState.doc.length);
    for (let o of r)
      this.changes = this.changes.compose(o.changes);
    let i = [];
    this.changes.iterChangedRanges((o, s, a, l) => i.push(new Br(o, s, a, l))), this.changedRanges = i;
  }
  /**
  @internal
  */
  static create(e, n, r) {
    return new nd(e, n, r);
  }
  /**
  Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or
  [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this
  update.
  */
  get viewportChanged() {
    return (this.flags & 4) > 0;
  }
  /**
  Indicates whether the height of a block element in the editor
  changed in this update.
  */
  get heightChanged() {
    return (this.flags & 2) > 0;
  }
  /**
  Returns true when the document was modified or the size of the
  editor, or elements within the editor, changed.
  */
  get geometryChanged() {
    return this.docChanged || (this.flags & 10) > 0;
  }
  /**
  True when this update indicates a focus change.
  */
  get focusChanged() {
    return (this.flags & 1) > 0;
  }
  /**
  Whether the document changed in this update.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Whether the selection was explicitly set in this update.
  */
  get selectionSet() {
    return this.transactions.some((e) => e.selection);
  }
  /**
  @internal
  */
  get empty() {
    return this.flags == 0 && this.transactions.length == 0;
  }
};
var qb = class extends It {
  get length() {
    return this.view.state.doc.length;
  }
  constructor(e) {
    super(), this.view = e, this.decorations = [], this.dynamicDecorationMap = [], this.domChanged = null, this.hasComposition = null, this.markedForComposition = /* @__PURE__ */ new Set(), this.lastCompositionAfterCursor = false, this.minWidth = 0, this.minWidthFrom = 0, this.minWidthTo = 0, this.impreciseAnchor = null, this.impreciseHead = null, this.forceSelection = false, this.lastUpdate = Date.now(), this.setDOM(e.contentDOM), this.children = [new ln()], this.children[0].setParent(this), this.updateDeco(), this.updateInner([new Br(0, 0, 0, e.state.doc.length)], 0, null);
  }
  // Update the document view to a given state.
  update(e) {
    var n;
    let r = e.changedRanges;
    this.minWidth > 0 && r.length && (r.every(({ fromA: c, toA: u }) => u < this.minWidthFrom || c > this.minWidthTo) ? (this.minWidthFrom = e.changes.mapPos(this.minWidthFrom, 1), this.minWidthTo = e.changes.mapPos(this.minWidthTo, 1)) : this.minWidth = this.minWidthFrom = this.minWidthTo = 0);
    let i = -1;
    this.view.inputState.composing >= 0 && (!((n = this.domChanged) === null || n === void 0) && n.newSel ? i = this.domChanged.newSel.head : !GF(e.changes, this.hasComposition) && !e.selectionSet && (i = e.state.selection.main.head));
    let o = i > -1 ? WF(this.view, e.changes, i) : null;
    if (this.domChanged = null, this.hasComposition) {
      this.markedForComposition.clear();
      let { from: c, to: u } = this.hasComposition;
      r = new Br(c, u, e.changes.mapPos(c, -1), e.changes.mapPos(u, 1)).addToSet(r.slice());
    }
    this.hasComposition = o ? { from: o.range.fromB, to: o.range.toB } : null, (me.ie || me.chrome) && !o && e && e.state.doc.lines != e.startState.doc.lines && (this.forceSelection = true);
    let s = this.decorations, a = this.updateDeco(), l = LF(s, a, e.changes);
    return r = Br.extendWithRanges(r, l), !(this.flags & 7) && r.length == 0 ? false : (this.updateInner(r, e.startState.doc.length, o), e.transactions.length && (this.lastUpdate = Date.now()), true);
  }
  // Used by update and the constructor do perform the actual DOM
  // update
  updateInner(e, n, r) {
    this.view.viewState.mustMeasureContent = true, this.updateChildren(e, n, r);
    let { observer: i } = this.view;
    i.ignore(() => {
      this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px", this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
      let s = me.chrome || me.ios ? { node: i.selectionRange.focusNode, written: false } : void 0;
      this.sync(this.view, s), this.flags &= -8, s && (s.written || i.selectionRange.focusNode != s.node) && (this.forceSelection = true), this.dom.style.height = "";
    }), this.markedForComposition.forEach(
      (s) => s.flags &= -9
      /* ViewFlag.Composition */
    );
    let o = [];
    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length)
      for (let s of this.children)
        s instanceof wo && s.widget instanceof Ub && o.push(s.dom);
    i.updateGaps(o);
  }
  updateChildren(e, n, r) {
    let i = r ? r.range.addToSet(e.slice()) : e, o = this.childCursor(n);
    for (let s = i.length - 1; ; s--) {
      let a = s >= 0 ? i[s] : null;
      if (!a)
        break;
      let { fromA: l, toA: c, fromB: u, toB: f } = a, d, h, p, O;
      if (r && r.range.fromB < f && r.range.toB > u) {
        let S = Vl.build(this.view.state.doc, u, r.range.fromB, this.decorations, this.dynamicDecorationMap), b = Vl.build(this.view.state.doc, r.range.toB, f, this.decorations, this.dynamicDecorationMap);
        h = S.breakAtStart, p = S.openStart, O = b.openEnd;
        let w = this.compositionView(r);
        b.breakAtStart ? w.breakAfter = 1 : b.content.length && w.merge(w.length, w.length, b.content[0], false, b.openStart, 0) && (w.breakAfter = b.content[0].breakAfter, b.content.shift()), S.content.length && w.merge(0, 0, S.content[S.content.length - 1], true, 0, S.openEnd) && S.content.pop(), d = S.content.concat(w).concat(b.content);
      } else
        ({ content: d, breakAtStart: h, openStart: p, openEnd: O } = Vl.build(this.view.state.doc, u, f, this.decorations, this.dynamicDecorationMap));
      let { i: m, off: x } = o.findPos(c, 1), { i: v, off: y } = o.findPos(l, -1);
      tE(this, v, y, m, x, d, h, p, O);
    }
    r && this.fixCompositionDOM(r);
  }
  compositionView(e) {
    let n = new Jr(e.text.nodeValue);
    n.flags |= 8;
    for (let { deco: i } of e.marks)
      n = new Hi(i, [n], n.length);
    let r = new ln();
    return r.append(n, 0), r;
  }
  fixCompositionDOM(e) {
    let n = (o, s) => {
      s.flags |= 8 | (s.children.some(
        (l) => l.flags & 7
        /* ViewFlag.Dirty */
      ) ? 1 : 0), this.markedForComposition.add(s);
      let a = It.get(o);
      a && a != s && (a.dom = null), s.setDOM(o);
    }, r = this.childPos(e.range.fromB, 1), i = this.children[r.i];
    n(e.line, i);
    for (let o = e.marks.length - 1; o >= -1; o--)
      r = i.childPos(r.off, 1), i = i.children[r.i], n(o >= 0 ? e.marks[o].node : e.text, i);
  }
  // Sync the DOM selection to this.state.selection
  updateSelection(e = false, n = false) {
    (e || !this.view.observer.selectionRange.focusNode) && this.view.observer.readSelectionRange();
    let r = this.view.root.activeElement, i = r == this.dom, o = !i && uf(this.dom, this.view.observer.selectionRange) && !(r && this.dom.contains(r));
    if (!(i || n || o))
      return;
    let s = this.forceSelection;
    this.forceSelection = false;
    let a = this.view.state.selection.main, l = this.moveToLine(this.domAtPos(a.anchor)), c = a.empty ? l : this.moveToLine(this.domAtPos(a.head));
    if (me.gecko && a.empty && !this.hasComposition && ZF(l)) {
      let f = document.createTextNode("");
      this.view.observer.ignore(() => l.node.insertBefore(f, l.node.childNodes[l.offset] || null)), l = c = new _n(f, 0), s = true;
    }
    let u = this.view.observer.selectionRange;
    (s || !u.focusNode || (!Wl(l.node, l.offset, u.anchorNode, u.anchorOffset) || !Wl(c.node, c.offset, u.focusNode, u.focusOffset)) && !this.suppressWidgetCursorChange(u, a)) && (this.view.observer.ignore(() => {
      me.android && me.chrome && this.dom.contains(u.focusNode) && XF(u.focusNode, this.dom) && (this.dom.blur(), this.dom.focus({ preventScroll: true }));
      let f = ed(this.view.root);
      if (f)
        if (a.empty) {
          if (me.gecko) {
            let d = VF(l.node, l.offset);
            if (d && d != 3) {
              let h = (d == 1 ? J2 : K2)(l.node, l.offset);
              h && (l = new _n(h.node, h.offset));
            }
          }
          f.collapse(l.node, l.offset), a.bidiLevel != null && f.caretBidiLevel !== void 0 && (f.caretBidiLevel = a.bidiLevel);
        } else if (f.extend) {
          f.collapse(l.node, l.offset);
          try {
            f.extend(c.node, c.offset);
          } catch {
          }
        } else {
          let d = document.createRange();
          a.anchor > a.head && ([l, c] = [c, l]), d.setEnd(c.node, c.offset), d.setStart(l.node, l.offset), f.removeAllRanges(), f.addRange(d);
        }
      o && this.view.root.activeElement == this.dom && (this.dom.blur(), r && r.focus());
    }), this.view.observer.setSelectionRange(l, c)), this.impreciseAnchor = l.precise ? null : new _n(u.anchorNode, u.anchorOffset), this.impreciseHead = c.precise ? null : new _n(u.focusNode, u.focusOffset);
  }
  // If a zero-length widget is inserted next to the cursor during
  // composition, avoid moving it across it and disrupting the
  // composition.
  suppressWidgetCursorChange(e, n) {
    return this.hasComposition && n.empty && Wl(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset) && this.posFromDOM(e.focusNode, e.focusOffset) == n.head;
  }
  enforceCursorAssoc() {
    if (this.hasComposition)
      return;
    let { view: e } = this, n = e.state.selection.main, r = ed(e.root), { anchorNode: i, anchorOffset: o } = e.observer.selectionRange;
    if (!r || !n.empty || !n.assoc || !r.modify)
      return;
    let s = ln.find(this, n.head);
    if (!s)
      return;
    let a = s.posAtStart;
    if (n.head == a || n.head == a + s.length)
      return;
    let l = this.coordsAt(n.head, -1), c = this.coordsAt(n.head, 1);
    if (!l || !c || l.bottom > c.top)
      return;
    let u = this.domAtPos(n.head + n.assoc);
    r.collapse(u.node, u.offset), r.modify("move", n.assoc < 0 ? "forward" : "backward", "lineboundary"), e.observer.readSelectionRange();
    let f = e.observer.selectionRange;
    e.docView.posFromDOM(f.anchorNode, f.anchorOffset) != n.from && r.collapse(i, o);
  }
  // If a position is in/near a block widget, move it to a nearby text
  // line, since we don't want the cursor inside a block widget.
  moveToLine(e) {
    let n = this.dom, r;
    if (e.node != n)
      return e;
    for (let i = e.offset; !r && i < n.childNodes.length; i++) {
      let o = It.get(n.childNodes[i]);
      o instanceof ln && (r = o.domAtPos(0));
    }
    for (let i = e.offset - 1; !r && i >= 0; i--) {
      let o = It.get(n.childNodes[i]);
      o instanceof ln && (r = o.domAtPos(o.length));
    }
    return r ? new _n(r.node, r.offset, true) : e;
  }
  nearest(e) {
    for (let n = e; n; ) {
      let r = It.get(n);
      if (r && r.rootView == this)
        return r;
      n = n.parentNode;
    }
    return null;
  }
  posFromDOM(e, n) {
    let r = this.nearest(e);
    if (!r)
      throw new RangeError("Trying to find position for a DOM position outside of the document");
    return r.localPosFromDOM(e, n) + r.posAtStart;
  }
  domAtPos(e) {
    let { i: n, off: r } = this.childCursor().findPos(e, -1);
    for (; n < this.children.length - 1; ) {
      let i = this.children[n];
      if (r < i.length || i instanceof ln)
        break;
      n++, r = 0;
    }
    return this.children[n].domAtPos(r);
  }
  coordsAt(e, n) {
    let r = null, i = 0;
    for (let o = this.length, s = this.children.length - 1; s >= 0; s--) {
      let a = this.children[s], l = o - a.breakAfter, c = l - a.length;
      if (l < e)
        break;
      c <= e && (c < e || a.covers(-1)) && (l > e || a.covers(1)) && (!r || a instanceof ln && !(r instanceof ln && n >= 0)) && (r = a, i = c), o = c;
    }
    return r ? r.coordsAt(e - i, n) : null;
  }
  coordsForChar(e) {
    let { i: n, off: r } = this.childPos(e, 1), i = this.children[n];
    if (!(i instanceof ln))
      return null;
    for (; i.children.length; ) {
      let { i: a, off: l } = i.childPos(r, 1);
      for (; ; a++) {
        if (a == i.children.length)
          return null;
        if ((i = i.children[a]).length)
          break;
      }
      r = l;
    }
    if (!(i instanceof Jr))
      return null;
    let o = $n(i.text, r);
    if (o == r)
      return null;
    let s = hs(i.dom, r, o).getClientRects();
    for (let a = 0; a < s.length; a++) {
      let l = s[a];
      if (a == s.length - 1 || l.top < l.bottom && l.left < l.right)
        return l;
    }
    return null;
  }
  measureVisibleLineHeights(e) {
    let n = [], { from: r, to: i } = e, o = this.view.contentDOM.clientWidth, s = o > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1, a = -1, l = this.view.textDirection == _t.LTR;
    for (let c = 0, u = 0; u < this.children.length; u++) {
      let f = this.children[u], d = c + f.length;
      if (d > i)
        break;
      if (c >= r) {
        let h = f.dom.getBoundingClientRect();
        if (n.push(h.height), s) {
          let p = f.dom.lastChild, O = p ? Ca(p) : [];
          if (O.length) {
            let m = O[O.length - 1], x = l ? m.right - h.left : h.right - m.left;
            x > a && (a = x, this.minWidth = o, this.minWidthFrom = c, this.minWidthTo = d);
          }
        }
      }
      c = d + f.breakAfter;
    }
    return n;
  }
  textDirectionAt(e) {
    let { i: n } = this.childPos(e, 1);
    return getComputedStyle(this.children[n].dom).direction == "rtl" ? _t.RTL : _t.LTR;
  }
  measureTextSize() {
    for (let o of this.children)
      if (o instanceof ln) {
        let s = o.measureTextSize();
        if (s)
          return s;
      }
    let e = document.createElement("div"), n, r, i;
    return e.className = "cm-line", e.style.width = "99999px", e.style.position = "absolute", e.textContent = "abc def ghi jkl mno pqr stu", this.view.observer.ignore(() => {
      this.dom.appendChild(e);
      let o = Ca(e.firstChild)[0];
      n = e.getBoundingClientRect().height, r = o ? o.width / 27 : 7, i = o ? o.height : n, e.remove();
    }), { lineHeight: n, charWidth: r, textHeight: i };
  }
  childCursor(e = this.length) {
    let n = this.children.length;
    return n && (e -= this.children[--n].length), new eE(this.children, e, n);
  }
  computeBlockGapDeco() {
    let e = [], n = this.view.viewState;
    for (let r = 0, i = 0; ; i++) {
      let o = i == n.viewports.length ? null : n.viewports[i], s = o ? o.from - 1 : this.length;
      if (s > r) {
        let a = (n.lineBlockAt(s).bottom - n.lineBlockAt(r).top) / this.view.scaleY;
        e.push(we.replace({
          widget: new Ub(a),
          block: true,
          inclusive: true,
          isBlockGap: true
        }).range(r, s));
      }
      if (!o)
        break;
      r = o.to + 1;
    }
    return we.set(e);
  }
  updateDeco() {
    let e = 0, n = this.view.state.facet(ic).map((o) => (this.dynamicDecorationMap[e++] = typeof o == "function") ? o(this.view) : o), r = false, i = this.view.state.facet(CE).map((o, s) => {
      let a = typeof o == "function";
      return a && (r = true), a ? o(this.view) : o;
    });
    for (i.length && (this.dynamicDecorationMap[e++] = r, n.push(ot.join(i))), this.decorations = [
      ...n,
      this.computeBlockGapDeco(),
      this.view.viewState.lineGapDeco
    ]; e < this.decorations.length; )
      this.dynamicDecorationMap[e++] = false;
    return this.decorations;
  }
  scrollIntoView(e) {
    if (e.isSnapshot) {
      let c = this.view.viewState.lineBlockAt(e.range.head);
      this.view.scrollDOM.scrollTop = c.top - e.yMargin, this.view.scrollDOM.scrollLeft = e.xMargin;
      return;
    }
    for (let c of this.view.state.facet(SE))
      try {
        if (c(this.view, e.range, e))
          return true;
      } catch (u) {
        Gn(this.view.state, u, "scroll handler");
      }
    let { range: n } = e, r = this.coordsAt(n.head, n.empty ? n.assoc : n.head > n.anchor ? -1 : 1), i;
    if (!r)
      return;
    !n.empty && (i = this.coordsAt(n.anchor, n.anchor > n.head ? -1 : 1)) && (r = {
      left: Math.min(r.left, i.left),
      top: Math.min(r.top, i.top),
      right: Math.max(r.right, i.right),
      bottom: Math.max(r.bottom, i.bottom)
    });
    let o = PE(this.view), s = {
      left: r.left - o.left,
      top: r.top - o.top,
      right: r.right + o.right,
      bottom: r.bottom + o.bottom
    }, { offsetWidth: a, offsetHeight: l } = this.view.scrollDOM;
    bF(this.view.scrollDOM, s, n.head < n.anchor ? -1 : 1, e.x, e.y, Math.max(Math.min(e.xMargin, a), -a), Math.max(Math.min(e.yMargin, l), -l), this.view.textDirection == _t.LTR);
  }
};
function ZF(t4) {
  return t4.node.nodeType == 1 && t4.node.firstChild && (t4.offset == 0 || t4.node.childNodes[t4.offset - 1].contentEditable == "false") && (t4.offset == t4.node.childNodes.length || t4.node.childNodes[t4.offset].contentEditable == "false");
}
var Ub = class extends Qi {
  constructor(e) {
    super(), this.height = e;
  }
  toDOM() {
    let e = document.createElement("div");
    return e.className = "cm-gap", this.updateDOM(e), e;
  }
  eq(e) {
    return e.height == this.height;
  }
  updateDOM(e) {
    return e.style.height = this.height + "px", true;
  }
  get editable() {
    return true;
  }
  get estimatedHeight() {
    return this.height;
  }
  ignoreEvent() {
    return false;
  }
};
function EE(t4, e) {
  let n = t4.observer.selectionRange;
  if (!n.focusNode)
    return null;
  let r = J2(n.focusNode, n.focusOffset), i = K2(n.focusNode, n.focusOffset), o = r || i;
  if (i && r && i.node != r.node) {
    let a = It.get(i.node);
    if (!a || a instanceof Jr && a.text != i.node.nodeValue)
      o = i;
    else if (t4.docView.lastCompositionAfterCursor) {
      let l = It.get(r.node);
      !l || l instanceof Jr && l.text != r.node.nodeValue || (o = i);
    }
  }
  if (t4.docView.lastCompositionAfterCursor = o != r, !o)
    return null;
  let s = e - o.offset;
  return { from: s, to: s + o.node.nodeValue.length, node: o.node };
}
function WF(t4, e, n) {
  let r = EE(t4, n);
  if (!r)
    return null;
  let { node: i, from: o, to: s } = r, a = i.nodeValue;
  if (/[\n\r]/.test(a) || t4.state.doc.sliceString(r.from, r.to) != a)
    return null;
  let l = e.invertedDesc, c = new Br(l.mapPos(o), l.mapPos(s), o, s), u = [];
  for (let f = i.parentNode; ; f = f.parentNode) {
    let d = It.get(f);
    if (d instanceof Hi)
      u.push({ node: f, deco: d.mark });
    else {
      if (d instanceof ln || f.nodeName == "DIV" && f.parentNode == t4.contentDOM)
        return { range: c, text: i, marks: u, line: f };
      if (f != t4.contentDOM)
        u.push({ node: f, deco: new Rc({
          inclusive: true,
          attributes: TF(f),
          tagName: f.tagName.toLowerCase()
        }) });
      else
        return null;
    }
  }
}
function VF(t4, e) {
  return t4.nodeType != 1 ? 0 : (e && t4.childNodes[e - 1].contentEditable == "false" ? 1 : 0) | (e < t4.childNodes.length && t4.childNodes[e].contentEditable == "false" ? 2 : 0);
}
var zF = class {
  constructor() {
    this.changes = [];
  }
  compareRange(e, n) {
    fm(e, n, this.changes);
  }
  comparePoint(e, n) {
    fm(e, n, this.changes);
  }
};
function LF(t4, e, n) {
  let r = new zF();
  return ot.compare(t4, e, n, r), r.changes;
}
function XF(t4, e) {
  for (let n = t4; n && n != e; n = n.assignedSlot || n.parentNode)
    if (n.nodeType == 1 && n.contentEditable == "false")
      return true;
  return false;
}
function GF(t4, e) {
  let n = false;
  return e && t4.iterChangedRanges((r, i) => {
    r < e.to && i > e.from && (n = true);
  }), n;
}
function YF(t4, e, n = 1) {
  let r = t4.charCategorizer(e), i = t4.doc.lineAt(e), o = e - i.from;
  if (i.length == 0)
    return ne.cursor(e);
  o == 0 ? n = 1 : o == i.length && (n = -1);
  let s = o, a = o;
  n < 0 ? s = $n(i.text, o, false) : a = $n(i.text, o);
  let l = r(i.text.slice(s, a));
  for (; s > 0; ) {
    let c = $n(i.text, s, false);
    if (r(i.text.slice(c, s)) != l)
      break;
    s = c;
  }
  for (; a < i.length; ) {
    let c = $n(i.text, a);
    if (r(i.text.slice(a, c)) != l)
      break;
    a = c;
  }
  return ne.range(s + i.from, a + i.from);
}
function qF(t4, e) {
  return e.left > t4 ? e.left - t4 : Math.max(0, t4 - e.right);
}
function UF(t4, e) {
  return e.top > t4 ? e.top - t4 : Math.max(0, t4 - e.bottom);
}
function Tp(t4, e) {
  return t4.top < e.bottom - 1 && t4.bottom > e.top + 1;
}
function Hb(t4, e) {
  return e < t4.top ? { top: e, left: t4.left, right: t4.right, bottom: t4.bottom } : t4;
}
function Jb(t4, e) {
  return e > t4.bottom ? { top: t4.top, left: t4.left, right: t4.right, bottom: e } : t4;
}
function mm(t4, e, n) {
  let r, i, o, s, a = false, l, c, u, f;
  for (let p = t4.firstChild; p; p = p.nextSibling) {
    let O = Ca(p);
    for (let m = 0; m < O.length; m++) {
      let x = O[m];
      i && Tp(i, x) && (x = Hb(Jb(x, i.bottom), i.top));
      let v = qF(e, x), y = UF(n, x);
      if (v == 0 && y == 0)
        return p.nodeType == 3 ? Kb(p, e, n) : mm(p, e, n);
      if (!r || s > y || s == y && o > v) {
        r = p, i = x, o = v, s = y;
        let S = y ? n < x.top ? -1 : 1 : v ? e < x.left ? -1 : 1 : 0;
        a = !S || (S > 0 ? m < O.length - 1 : m > 0);
      }
      v == 0 ? n > x.bottom && (!u || u.bottom < x.bottom) ? (l = p, u = x) : n < x.top && (!f || f.top > x.top) && (c = p, f = x) : u && Tp(u, x) ? u = Jb(u, x.bottom) : f && Tp(f, x) && (f = Hb(f, x.top));
    }
  }
  if (u && u.bottom >= n ? (r = l, i = u) : f && f.top <= n && (r = c, i = f), !r)
    return { node: t4, offset: 0 };
  let d = Math.max(i.left, Math.min(i.right, e));
  if (r.nodeType == 3)
    return Kb(r, d, n);
  if (a && r.contentEditable != "false")
    return mm(r, d, n);
  let h = Array.prototype.indexOf.call(t4.childNodes, r) + (e >= (i.left + i.right) / 2 ? 1 : 0);
  return { node: t4, offset: h };
}
function Kb(t4, e, n) {
  let r = t4.nodeValue.length, i = -1, o = 1e9, s = 0;
  for (let a = 0; a < r; a++) {
    let l = hs(t4, a, a + 1).getClientRects();
    for (let c = 0; c < l.length; c++) {
      let u = l[c];
      if (u.top == u.bottom)
        continue;
      s || (s = e - u.left);
      let f = (u.top > n ? u.top - n : n - u.bottom) - 1;
      if (u.left - 1 <= e && u.right + 1 >= e && f < o) {
        let d = e >= (u.left + u.right) / 2, h = d;
        if ((me.chrome || me.gecko) && hs(t4, a).getBoundingClientRect().left == u.right && (h = !d), f <= 0)
          return { node: t4, offset: a + (h ? 1 : 0) };
        i = a + (h ? 1 : 0), o = f;
      }
    }
  }
  return { node: t4, offset: i > -1 ? i : s > 0 ? t4.nodeValue.length : 0 };
}
function TE(t4, e, n, r = -1) {
  var i, o;
  let s = t4.contentDOM.getBoundingClientRect(), a = s.top + t4.viewState.paddingTop, l, { docHeight: c } = t4.viewState, { x: u, y: f } = e, d = f - a;
  if (d < 0)
    return 0;
  if (d > c)
    return t4.state.doc.length;
  for (let S = t4.viewState.heightOracle.textHeight / 2, b = false; l = t4.elementAtHeight(d), l.type != Yn.Text; )
    for (; d = r > 0 ? l.bottom + S : l.top - S, !(d >= 0 && d <= c); ) {
      if (b)
        return n ? null : 0;
      b = true, r = -r;
    }
  f = a + d;
  let h = l.from;
  if (h < t4.viewport.from)
    return t4.viewport.from == 0 ? 0 : n ? null : e1(t4, s, l, u, f);
  if (h > t4.viewport.to)
    return t4.viewport.to == t4.state.doc.length ? t4.state.doc.length : n ? null : e1(t4, s, l, u, f);
  let p = t4.dom.ownerDocument, O = t4.root.elementFromPoint ? t4.root : p, m = O.elementFromPoint(u, f);
  m && !t4.contentDOM.contains(m) && (m = null), m || (u = Math.max(s.left + 1, Math.min(s.right - 1, u)), m = O.elementFromPoint(u, f), m && !t4.contentDOM.contains(m) && (m = null));
  let x, v = -1;
  if (m && ((i = t4.docView.nearest(m)) === null || i === void 0 ? void 0 : i.isEditable) != false) {
    if (p.caretPositionFromPoint) {
      let S = p.caretPositionFromPoint(u, f);
      S && ({ offsetNode: x, offset: v } = S);
    } else if (p.caretRangeFromPoint) {
      let S = p.caretRangeFromPoint(u, f);
      S && ({ startContainer: x, startOffset: v } = S, (!t4.contentDOM.contains(x) || me.safari && HF(x, v, u) || me.chrome && JF(x, v, u)) && (x = void 0));
    }
  }
  if (!x || !t4.docView.dom.contains(x)) {
    let S = ln.find(t4.docView, h);
    if (!S)
      return d > l.top + l.height / 2 ? l.to : l.from;
    ({ node: x, offset: v } = mm(S.dom, u, f));
  }
  let y = t4.docView.nearest(x);
  if (!y)
    return null;
  if (y.isWidget && ((o = y.dom) === null || o === void 0 ? void 0 : o.nodeType) == 1) {
    let S = y.dom.getBoundingClientRect();
    return e.y < S.top || e.y <= S.bottom && e.x <= (S.left + S.right) / 2 ? y.posAtStart : y.posAtEnd;
  } else
    return y.localPosFromDOM(x, v) + y.posAtStart;
}
function e1(t4, e, n, r, i) {
  let o = Math.round((r - e.left) * t4.defaultCharacterWidth);
  if (t4.lineWrapping && n.height > t4.defaultLineHeight * 1.5) {
    let a = t4.viewState.heightOracle.textHeight, l = Math.floor((i - n.top - (t4.defaultLineHeight - a) * 0.5) / a);
    o += l * t4.viewState.heightOracle.lineLength;
  }
  let s = t4.state.sliceDoc(n.from, n.to);
  return n.from + nm(s, o, t4.state.tabSize);
}
function HF(t4, e, n) {
  let r;
  if (t4.nodeType != 3 || e != (r = t4.nodeValue.length))
    return false;
  for (let i = t4.nextSibling; i; i = i.nextSibling)
    if (i.nodeType != 1 || i.nodeName != "BR")
      return false;
  return hs(t4, r - 1, r).getBoundingClientRect().left > n;
}
function JF(t4, e, n) {
  if (e != 0)
    return false;
  for (let i = t4; ; ) {
    let o = i.parentNode;
    if (!o || o.nodeType != 1 || o.firstChild != i)
      return false;
    if (o.classList.contains("cm-line"))
      break;
    i = o;
  }
  let r = t4.nodeType == 1 ? t4.getBoundingClientRect() : hs(t4, 0, Math.max(t4.nodeValue.length, 1)).getBoundingClientRect();
  return n - r.left > 5;
}
function Om(t4, e) {
  let n = t4.lineBlockAt(e);
  if (Array.isArray(n.type)) {
    for (let r of n.type)
      if (r.to > e || r.to == e && (r.to == n.to || r.type == Yn.Text))
        return r;
  }
  return n;
}
function KF(t4, e, n, r) {
  let i = Om(t4, e.head), o = !r || i.type != Yn.Text || !(t4.lineWrapping || i.widgetLineBreaks) ? null : t4.coordsAtPos(e.assoc < 0 && e.head > i.from ? e.head - 1 : e.head);
  if (o) {
    let s = t4.dom.getBoundingClientRect(), a = t4.textDirectionAt(i.from), l = t4.posAtCoords({
      x: n == (a == _t.LTR) ? s.right - 1 : s.left + 1,
      y: (o.top + o.bottom) / 2
    });
    if (l != null)
      return ne.cursor(l, n ? -1 : 1);
  }
  return ne.cursor(n ? i.to : i.from, n ? -1 : 1);
}
function t1(t4, e, n, r) {
  let i = t4.state.doc.lineAt(e.head), o = t4.bidiSpans(i), s = t4.textDirectionAt(i.from);
  for (let a = e, l = null; ; ) {
    let c = MF(i, o, s, a, n), u = hE;
    if (!c) {
      if (i.number == (n ? t4.state.doc.lines : 1))
        return a;
      u = `
`, i = t4.state.doc.line(i.number + (n ? 1 : -1)), o = t4.bidiSpans(i), c = t4.visualLineSide(i, !n);
    }
    if (l) {
      if (!l(u))
        return a;
    } else {
      if (!r)
        return c;
      l = r(u);
    }
    a = c;
  }
}
function eZ(t4, e, n) {
  let r = t4.state.charCategorizer(e), i = r(n);
  return (o) => {
    let s = r(o);
    return i == Nt.Space && (i = s), i == s;
  };
}
function tZ(t4, e, n, r) {
  let i = e.head, o = n ? 1 : -1;
  if (i == (n ? t4.state.doc.length : 0))
    return ne.cursor(i, e.assoc);
  let s = e.goalColumn, a, l = t4.contentDOM.getBoundingClientRect(), c = t4.coordsAtPos(i, e.assoc || -1), u = t4.documentTop;
  if (c)
    s == null && (s = c.left - l.left), a = o < 0 ? c.top : c.bottom;
  else {
    let h = t4.viewState.lineBlockAt(i);
    s == null && (s = Math.min(l.right - l.left, t4.defaultCharacterWidth * (i - h.from))), a = (o < 0 ? h.top : h.bottom) + u;
  }
  let f = l.left + s, d = r ?? t4.viewState.heightOracle.textHeight >> 1;
  for (let h = 0; ; h += 10) {
    let p = a + (d + h) * o, O = TE(t4, { x: f, y: p }, false, o);
    if (p < l.top || p > l.bottom || (o < 0 ? O < i : O > i)) {
      let m = t4.docView.coordsForChar(O), x = !m || p < m.top ? -1 : 1;
      return ne.cursor(O, x, void 0, s);
    }
  }
}
function ff(t4, e, n) {
  for (; ; ) {
    let r = 0;
    for (let i of t4)
      i.between(e - 1, e + 1, (o, s, a) => {
        if (e > o && e < s) {
          let l = r || n || (e - o < s - e ? -1 : 1);
          e = l < 0 ? o : s, r = l;
        }
      });
    if (!r)
      return e;
  }
}
function Ip(t4, e, n) {
  let r = ff(t4.state.facet(kx).map((i) => i(t4)), n.from, e.head > n.from ? -1 : 1);
  return r == n.from ? n : ne.cursor(r, r < n.from ? 1 : -1);
}
var nZ = class {
  setSelectionOrigin(e) {
    this.lastSelectionOrigin = e, this.lastSelectionTime = Date.now();
  }
  constructor(e) {
    this.view = e, this.lastKeyCode = 0, this.lastKeyTime = 0, this.lastTouchTime = 0, this.lastFocusTime = 0, this.lastScrollTop = 0, this.lastScrollLeft = 0, this.pendingIOSKey = void 0, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastEscPress = 0, this.lastContextMenu = 0, this.scrollHandlers = [], this.handlers = /* @__PURE__ */ Object.create(null), this.composing = -1, this.compositionFirstChange = null, this.compositionEndedAt = 0, this.compositionPendingKey = false, this.compositionPendingChange = false, this.mouseSelection = null, this.draggedContent = null, this.handleEvent = this.handleEvent.bind(this), this.notifiedFocused = e.hasFocus, me.safari && e.contentDOM.addEventListener("input", () => null), me.gecko && xZ(e.contentDOM.ownerDocument);
  }
  handleEvent(e) {
    !uZ(this.view, e) || this.ignoreDuringComposition(e) || e.type == "keydown" && this.keydown(e) || this.runHandlers(e.type, e);
  }
  runHandlers(e, n) {
    let r = this.handlers[e];
    if (r) {
      for (let i of r.observers)
        i(this.view, n);
      for (let i of r.handlers) {
        if (n.defaultPrevented)
          break;
        if (i(this.view, n)) {
          n.preventDefault();
          break;
        }
      }
    }
  }
  ensureHandlers(e) {
    let n = rZ(e), r = this.handlers, i = this.view.contentDOM;
    for (let o in n)
      if (o != "scroll") {
        let s = !n[o].handlers.length, a = r[o];
        a && s != !a.handlers.length && (i.removeEventListener(o, this.handleEvent), a = null), a || i.addEventListener(o, this.handleEvent, { passive: s });
      }
    for (let o in r)
      o != "scroll" && !n[o] && i.removeEventListener(o, this.handleEvent);
    this.handlers = n;
  }
  keydown(e) {
    if (this.lastKeyCode = e.keyCode, this.lastKeyTime = Date.now(), e.keyCode == 9 && Date.now() < this.lastEscPress + 2e3)
      return true;
    if (e.keyCode != 27 && $E.indexOf(e.keyCode) < 0 && (this.view.inputState.lastEscPress = 0), me.android && me.chrome && !e.synthetic && (e.keyCode == 13 || e.keyCode == 8))
      return this.view.observer.delayAndroidKey(e.key, e.keyCode), true;
    let n;
    return me.ios && !e.synthetic && !e.altKey && !e.metaKey && ((n = IE.find((r) => r.keyCode == e.keyCode)) && !e.ctrlKey || iZ.indexOf(e.key) > -1 && e.ctrlKey && !e.shiftKey) ? (this.pendingIOSKey = n || e, setTimeout(() => this.flushIOSKey(), 250), true) : (e.keyCode != 229 && this.view.observer.forceFlush(), false);
  }
  flushIOSKey(e) {
    let n = this.pendingIOSKey;
    return !n || n.key == "Enter" && e && e.from < e.to && /^\S+$/.test(e.insert.toString()) ? false : (this.pendingIOSKey = void 0, la(this.view.contentDOM, n.key, n.keyCode, n instanceof KeyboardEvent ? n : void 0));
  }
  ignoreDuringComposition(e) {
    return /^key/.test(e.type) ? this.composing > 0 ? true : me.safari && !me.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100 ? (this.compositionPendingKey = false, true) : false : false;
  }
  startMouseSelection(e) {
    this.mouseSelection && this.mouseSelection.destroy(), this.mouseSelection = e;
  }
  update(e) {
    this.mouseSelection && this.mouseSelection.update(e), this.draggedContent && e.docChanged && (this.draggedContent = this.draggedContent.map(e.changes)), e.transactions.length && (this.lastKeyCode = this.lastSelectionTime = 0);
  }
  destroy() {
    this.mouseSelection && this.mouseSelection.destroy();
  }
};
function n1(t4, e) {
  return (n, r) => {
    try {
      return e.call(t4, r, n);
    } catch (i) {
      Gn(n.state, i);
    }
  };
}
function rZ(t4) {
  let e = /* @__PURE__ */ Object.create(null);
  function n(r) {
    return e[r] || (e[r] = { observers: [], handlers: [] });
  }
  for (let r of t4) {
    let i = r.spec;
    if (i && i.domEventHandlers)
      for (let o in i.domEventHandlers) {
        let s = i.domEventHandlers[o];
        s && n(o).handlers.push(n1(r.value, s));
      }
    if (i && i.domEventObservers)
      for (let o in i.domEventObservers) {
        let s = i.domEventObservers[o];
        s && n(o).observers.push(n1(r.value, s));
      }
  }
  for (let r in Kr)
    n(r).handlers.push(Kr[r]);
  for (let r in Fr)
    n(r).observers.push(Fr[r]);
  return e;
}
var IE = [
  { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
  { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
  { key: "Enter", keyCode: 13, inputType: "insertLineBreak" },
  { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
];
var iZ = "dthko";
var $E = [16, 17, 18, 20, 91, 92, 224, 225];
var Au = 6;
function Pu(t4) {
  return Math.max(0, t4) * 0.7 + 8;
}
function oZ(t4, e) {
  return Math.max(Math.abs(t4.clientX - e.clientX), Math.abs(t4.clientY - e.clientY));
}
var sZ = class {
  constructor(e, n, r, i) {
    this.view = e, this.startEvent = n, this.style = r, this.mustSelect = i, this.scrollSpeed = { x: 0, y: 0 }, this.scrolling = -1, this.lastEvent = n, this.scrollParent = SF(e.contentDOM), this.atoms = e.state.facet(kx).map((s) => s(e));
    let o = e.contentDOM.ownerDocument;
    o.addEventListener("mousemove", this.move = this.move.bind(this)), o.addEventListener("mouseup", this.up = this.up.bind(this)), this.extend = n.shiftKey, this.multiple = e.state.facet(et.allowMultipleSelections) && aZ(e, n), this.dragging = cZ(e, n) && QE(n) == 1 ? null : false;
  }
  start(e) {
    this.dragging === false && this.select(e);
  }
  move(e) {
    var n;
    if (e.buttons == 0)
      return this.destroy();
    if (this.dragging || this.dragging == null && oZ(this.startEvent, e) < 10)
      return;
    this.select(this.lastEvent = e);
    let r = 0, i = 0, o = ((n = this.scrollParent) === null || n === void 0 ? void 0 : n.getBoundingClientRect()) || { left: 0, top: 0, right: this.view.win.innerWidth, bottom: this.view.win.innerHeight }, s = PE(this.view);
    e.clientX - s.left <= o.left + Au ? r = -Pu(o.left - e.clientX) : e.clientX + s.right >= o.right - Au && (r = Pu(e.clientX - o.right)), e.clientY - s.top <= o.top + Au ? i = -Pu(o.top - e.clientY) : e.clientY + s.bottom >= o.bottom - Au && (i = Pu(e.clientY - o.bottom)), this.setScrollSpeed(r, i);
  }
  up(e) {
    this.dragging == null && this.select(this.lastEvent), this.dragging || e.preventDefault(), this.destroy();
  }
  destroy() {
    this.setScrollSpeed(0, 0);
    let e = this.view.contentDOM.ownerDocument;
    e.removeEventListener("mousemove", this.move), e.removeEventListener("mouseup", this.up), this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;
  }
  setScrollSpeed(e, n) {
    this.scrollSpeed = { x: e, y: n }, e || n ? this.scrolling < 0 && (this.scrolling = setInterval(() => this.scroll(), 50)) : this.scrolling > -1 && (clearInterval(this.scrolling), this.scrolling = -1);
  }
  scroll() {
    this.scrollParent ? (this.scrollParent.scrollLeft += this.scrollSpeed.x, this.scrollParent.scrollTop += this.scrollSpeed.y) : this.view.win.scrollBy(this.scrollSpeed.x, this.scrollSpeed.y), this.dragging === false && this.select(this.lastEvent);
  }
  skipAtoms(e) {
    let n = null;
    for (let r = 0; r < e.ranges.length; r++) {
      let i = e.ranges[r], o = null;
      if (i.empty) {
        let s = ff(this.atoms, i.from, 0);
        s != i.from && (o = ne.cursor(s, -1));
      } else {
        let s = ff(this.atoms, i.from, -1), a = ff(this.atoms, i.to, 1);
        (s != i.from || a != i.to) && (o = ne.range(i.from == i.anchor ? s : a, i.from == i.head ? s : a));
      }
      o && (n || (n = e.ranges.slice()), n[r] = o);
    }
    return n ? ne.create(n, e.mainIndex) : e;
  }
  select(e) {
    let { view: n } = this, r = this.skipAtoms(this.style.get(e, this.extend, this.multiple));
    (this.mustSelect || !r.eq(n.state.selection, this.dragging === false)) && this.view.dispatch({
      selection: r,
      userEvent: "select.pointer"
    }), this.mustSelect = false;
  }
  update(e) {
    this.style.update(e) && setTimeout(() => this.select(this.lastEvent), 20);
  }
};
function aZ(t4, e) {
  let n = t4.state.facet(pE);
  return n.length ? n[0](e) : me.mac ? e.metaKey : e.ctrlKey;
}
function lZ(t4, e) {
  let n = t4.state.facet(gE);
  return n.length ? n[0](e) : me.mac ? !e.altKey : !e.ctrlKey;
}
function cZ(t4, e) {
  let { main: n } = t4.state.selection;
  if (n.empty)
    return false;
  let r = ed(t4.root);
  if (!r || r.rangeCount == 0)
    return true;
  let i = r.getRangeAt(0).getClientRects();
  for (let o = 0; o < i.length; o++) {
    let s = i[o];
    if (s.left <= e.clientX && s.right >= e.clientX && s.top <= e.clientY && s.bottom >= e.clientY)
      return true;
  }
  return false;
}
function uZ(t4, e) {
  if (!e.bubbles)
    return true;
  if (e.defaultPrevented)
    return false;
  for (let n = e.target, r; n != t4.contentDOM; n = n.parentNode)
    if (!n || n.nodeType == 11 || (r = It.get(n)) && r.ignoreEvent(e))
      return false;
  return true;
}
var Kr = /* @__PURE__ */ Object.create(null);
var Fr = /* @__PURE__ */ Object.create(null);
var jE = me.ie && me.ie_version < 15 || me.ios && me.webkit_version < 604;
function fZ(t4) {
  let e = t4.dom.parentNode;
  if (!e)
    return;
  let n = e.appendChild(document.createElement("textarea"));
  n.style.cssText = "position: fixed; left: -10000px; top: 10px", n.focus(), setTimeout(() => {
    t4.focus(), n.remove(), RE(t4, n.value);
  }, 50);
}
function RE(t4, e) {
  let { state: n } = t4, r, i = 1, o = n.toText(e), s = o.lines == n.selection.ranges.length;
  if (xm != null && n.selection.ranges.every((l) => l.empty) && xm == o.toString()) {
    let l = -1;
    r = n.changeByRange((c) => {
      let u = n.doc.lineAt(c.from);
      if (u.from == l)
        return { range: c };
      l = u.from;
      let f = n.toText((s ? o.line(i++).text : e) + n.lineBreak);
      return {
        changes: { from: u.from, insert: f },
        range: ne.cursor(c.from + f.length)
      };
    });
  } else
    s ? r = n.changeByRange((l) => {
      let c = o.line(i++);
      return {
        changes: { from: l.from, to: l.to, insert: c.text },
        range: ne.cursor(l.from + c.length)
      };
    }) : r = n.replaceSelection(o);
  t4.dispatch(r, {
    userEvent: "input.paste",
    scrollIntoView: true
  });
}
Fr.scroll = (t4) => {
  t4.inputState.lastScrollTop = t4.scrollDOM.scrollTop, t4.inputState.lastScrollLeft = t4.scrollDOM.scrollLeft;
};
Kr.keydown = (t4, e) => (t4.inputState.setSelectionOrigin("select"), e.keyCode == 27 && (t4.inputState.lastEscPress = Date.now()), false);
Fr.touchstart = (t4, e) => {
  t4.inputState.lastTouchTime = Date.now(), t4.inputState.setSelectionOrigin("select.pointer");
};
Fr.touchmove = (t4) => {
  t4.inputState.setSelectionOrigin("select.pointer");
};
Kr.mousedown = (t4, e) => {
  if (t4.observer.flush(), t4.inputState.lastTouchTime > Date.now() - 2e3)
    return false;
  let n = null;
  for (let r of t4.state.facet(mE))
    if (n = r(t4, e), n)
      break;
  if (!n && e.button == 0 && (n = pZ(t4, e)), n) {
    let r = !t4.hasFocus;
    t4.inputState.startMouseSelection(new sZ(t4, e, n, r)), r && t4.observer.ignore(() => q2(t4.contentDOM));
    let i = t4.inputState.mouseSelection;
    if (i)
      return i.start(e), i.dragging === false;
  }
  return false;
};
function r1(t4, e, n, r) {
  if (r == 1)
    return ne.cursor(e, n);
  if (r == 2)
    return YF(t4.state, e, n);
  {
    let i = ln.find(t4.docView, e), o = t4.state.doc.lineAt(i ? i.posAtEnd : e), s = i ? i.posAtStart : o.from, a = i ? i.posAtEnd : o.to;
    return a < t4.state.doc.length && a == o.to && a++, ne.range(s, a);
  }
}
var DE = (t4, e) => t4 >= e.top && t4 <= e.bottom;
var i1 = (t4, e, n) => DE(e, n) && t4 >= n.left && t4 <= n.right;
function dZ(t4, e, n, r) {
  let i = ln.find(t4.docView, e);
  if (!i)
    return 1;
  let o = e - i.posAtStart;
  if (o == 0)
    return 1;
  if (o == i.length)
    return -1;
  let s = i.coordsAt(o, -1);
  if (s && i1(n, r, s))
    return -1;
  let a = i.coordsAt(o, 1);
  return a && i1(n, r, a) ? 1 : s && DE(r, s) ? -1 : 1;
}
function o1(t4, e) {
  let n = t4.posAtCoords({ x: e.clientX, y: e.clientY }, false);
  return { pos: n, bias: dZ(t4, n, e.clientX, e.clientY) };
}
var hZ = me.ie && me.ie_version <= 11;
var s1 = null;
var a1 = 0;
var l1 = 0;
function QE(t4) {
  if (!hZ)
    return t4.detail;
  let e = s1, n = l1;
  return s1 = t4, l1 = Date.now(), a1 = !e || n > Date.now() - 400 && Math.abs(e.clientX - t4.clientX) < 2 && Math.abs(e.clientY - t4.clientY) < 2 ? (a1 + 1) % 3 : 1;
}
function pZ(t4, e) {
  let n = o1(t4, e), r = QE(e), i = t4.state.selection;
  return {
    update(o) {
      o.docChanged && (n.pos = o.changes.mapPos(n.pos), i = i.map(o.changes));
    },
    get(o, s, a) {
      let l = o1(t4, o), c, u = r1(t4, l.pos, l.bias, r);
      if (n.pos != l.pos && !s) {
        let f = r1(t4, n.pos, n.bias, r), d = Math.min(f.from, u.from), h = Math.max(f.to, u.to);
        u = d < u.from ? ne.range(d, h) : ne.range(h, d);
      }
      return s ? i.replaceRange(i.main.extend(u.from, u.to)) : a && r == 1 && i.ranges.length > 1 && (c = gZ(i, l.pos)) ? c : a ? i.addRange(u) : ne.create([u]);
    }
  };
}
function gZ(t4, e) {
  for (let n = 0; n < t4.ranges.length; n++) {
    let { from: r, to: i } = t4.ranges[n];
    if (r <= e && i >= e)
      return ne.create(t4.ranges.slice(0, n).concat(t4.ranges.slice(n + 1)), t4.mainIndex == n ? 0 : t4.mainIndex - (t4.mainIndex > n ? 1 : 0));
  }
  return null;
}
Kr.dragstart = (t4, e) => {
  let { selection: { main: n } } = t4.state;
  if (e.target.draggable) {
    let i = t4.docView.nearest(e.target);
    if (i && i.isWidget) {
      let o = i.posAtStart, s = o + i.length;
      (o >= n.to || s <= n.from) && (n = ne.range(o, s));
    }
  }
  let { inputState: r } = t4;
  return r.mouseSelection && (r.mouseSelection.dragging = true), r.draggedContent = n, e.dataTransfer && (e.dataTransfer.setData("Text", t4.state.sliceDoc(n.from, n.to)), e.dataTransfer.effectAllowed = "copyMove"), false;
};
Kr.dragend = (t4) => (t4.inputState.draggedContent = null, false);
function c1(t4, e, n, r) {
  if (!n)
    return;
  let i = t4.posAtCoords({ x: e.clientX, y: e.clientY }, false), { draggedContent: o } = t4.inputState, s = r && o && lZ(t4, e) ? { from: o.from, to: o.to } : null, a = { from: i, insert: n }, l = t4.state.changes(s ? [s, a] : a);
  t4.focus(), t4.dispatch({
    changes: l,
    selection: { anchor: l.mapPos(i, -1), head: l.mapPos(i, 1) },
    userEvent: s ? "move.drop" : "input.drop"
  }), t4.inputState.draggedContent = null;
}
Kr.drop = (t4, e) => {
  if (!e.dataTransfer)
    return false;
  if (t4.state.readOnly)
    return true;
  let n = e.dataTransfer.files;
  if (n && n.length) {
    let r = Array(n.length), i = 0, o = () => {
      ++i == n.length && c1(t4, e, r.filter((s) => s != null).join(t4.state.lineBreak), false);
    };
    for (let s = 0; s < n.length; s++) {
      let a = new FileReader();
      a.onerror = o, a.onload = () => {
        /[\x00-\x08\x0e-\x1f]{2}/.test(a.result) || (r[s] = a.result), o();
      }, a.readAsText(n[s]);
    }
    return true;
  } else {
    let r = e.dataTransfer.getData("Text");
    if (r)
      return c1(t4, e, r, true), true;
  }
  return false;
};
Kr.paste = (t4, e) => {
  if (t4.state.readOnly)
    return true;
  t4.observer.flush();
  let n = jE ? null : e.clipboardData;
  return n ? (RE(t4, n.getData("text/plain") || n.getData("text/uri-list")), true) : (fZ(t4), false);
};
function mZ(t4, e) {
  let n = t4.dom.parentNode;
  if (!n)
    return;
  let r = n.appendChild(document.createElement("textarea"));
  r.style.cssText = "position: fixed; left: -10000px; top: 10px", r.value = e, r.focus(), r.selectionEnd = e.length, r.selectionStart = 0, setTimeout(() => {
    r.remove(), t4.focus();
  }, 50);
}
function OZ(t4) {
  let e = [], n = [], r = false;
  for (let i of t4.selection.ranges)
    i.empty || (e.push(t4.sliceDoc(i.from, i.to)), n.push(i));
  if (!e.length) {
    let i = -1;
    for (let { from: o } of t4.selection.ranges) {
      let s = t4.doc.lineAt(o);
      s.number > i && (e.push(s.text), n.push({ from: s.from, to: Math.min(t4.doc.length, s.to + 1) })), i = s.number;
    }
    r = true;
  }
  return { text: e.join(t4.lineBreak), ranges: n, linewise: r };
}
var xm = null;
Kr.copy = Kr.cut = (t4, e) => {
  let { text: n, ranges: r, linewise: i } = OZ(t4.state);
  if (!n && !i)
    return false;
  xm = i ? n : null, e.type == "cut" && !t4.state.readOnly && t4.dispatch({
    changes: r,
    scrollIntoView: true,
    userEvent: "delete.cut"
  });
  let o = jE ? null : e.clipboardData;
  return o ? (o.clearData(), o.setData("text/plain", n), true) : (mZ(t4, n), false);
};
var BE = /* @__PURE__ */ Ri.define();
function _E(t4, e) {
  let n = [];
  for (let r of t4.facet(vE)) {
    let i = r(t4, e);
    i && n.push(i);
  }
  return n ? t4.update({ effects: n, annotations: BE.of(true) }) : null;
}
function ME(t4) {
  setTimeout(() => {
    let e = t4.hasFocus;
    if (e != t4.inputState.notifiedFocused) {
      let n = _E(t4.state, e);
      n ? t4.dispatch(n) : t4.update([]);
    }
  }, 10);
}
Fr.focus = (t4) => {
  t4.inputState.lastFocusTime = Date.now(), !t4.scrollDOM.scrollTop && (t4.inputState.lastScrollTop || t4.inputState.lastScrollLeft) && (t4.scrollDOM.scrollTop = t4.inputState.lastScrollTop, t4.scrollDOM.scrollLeft = t4.inputState.lastScrollLeft), ME(t4);
};
Fr.blur = (t4) => {
  t4.observer.clearSelectionRange(), ME(t4);
};
Fr.compositionstart = Fr.compositionupdate = (t4) => {
  t4.inputState.compositionFirstChange == null && (t4.inputState.compositionFirstChange = true), t4.inputState.composing < 0 && (t4.inputState.composing = 0);
};
Fr.compositionend = (t4) => {
  t4.inputState.composing = -1, t4.inputState.compositionEndedAt = Date.now(), t4.inputState.compositionPendingKey = true, t4.inputState.compositionPendingChange = t4.observer.pendingRecords().length > 0, t4.inputState.compositionFirstChange = null, me.chrome && me.android ? t4.observer.flushSoon() : t4.inputState.compositionPendingChange ? Promise.resolve().then(() => t4.observer.flush()) : setTimeout(() => {
    t4.inputState.composing < 0 && t4.docView.hasComposition && t4.update([]);
  }, 50);
};
Fr.contextmenu = (t4) => {
  t4.inputState.lastContextMenu = Date.now();
};
Kr.beforeinput = (t4, e) => {
  var n;
  let r;
  if (me.chrome && me.android && (r = IE.find((i) => i.inputType == e.inputType)) && (t4.observer.delayAndroidKey(r.key, r.keyCode), r.key == "Backspace" || r.key == "Delete")) {
    let i = ((n = window.visualViewport) === null || n === void 0 ? void 0 : n.height) || 0;
    setTimeout(() => {
      var o;
      (((o = window.visualViewport) === null || o === void 0 ? void 0 : o.height) || 0) > i + 10 && t4.hasFocus && (t4.contentDOM.blur(), t4.focus());
    }, 100);
  }
  return me.ios && e.inputType == "deleteContentForward" && t4.observer.flushSoon(), me.safari && e.inputType == "insertText" && t4.inputState.composing >= 0 && setTimeout(() => Fr.compositionend(t4, e), 20), false;
};
var u1 = /* @__PURE__ */ new Set();
function xZ(t4) {
  u1.has(t4) || (u1.add(t4), t4.addEventListener("copy", () => {
  }), t4.addEventListener("cut", () => {
  }));
}
var f1 = ["pre-wrap", "normal", "pre-line", "break-spaces"];
var vZ = class {
  constructor(e) {
    this.lineWrapping = e, this.doc = ft.empty, this.heightSamples = {}, this.lineHeight = 14, this.charWidth = 7, this.textHeight = 14, this.lineLength = 30, this.heightChanged = false;
  }
  heightForGap(e, n) {
    let r = this.doc.lineAt(n).number - this.doc.lineAt(e).number + 1;
    return this.lineWrapping && (r += Math.max(0, Math.ceil((n - e - r * this.lineLength * 0.5) / this.lineLength))), this.lineHeight * r;
  }
  heightForLine(e) {
    return this.lineWrapping ? (1 + Math.max(0, Math.ceil((e - this.lineLength) / (this.lineLength - 5)))) * this.lineHeight : this.lineHeight;
  }
  setDoc(e) {
    return this.doc = e, this;
  }
  mustRefreshForWrapping(e) {
    return f1.indexOf(e) > -1 != this.lineWrapping;
  }
  mustRefreshForHeights(e) {
    let n = false;
    for (let r = 0; r < e.length; r++) {
      let i = e[r];
      i < 0 ? r++ : this.heightSamples[Math.floor(i * 10)] || (n = true, this.heightSamples[Math.floor(i * 10)] = true);
    }
    return n;
  }
  refresh(e, n, r, i, o, s) {
    let a = f1.indexOf(e) > -1, l = Math.round(n) != Math.round(this.lineHeight) || this.lineWrapping != a;
    if (this.lineWrapping = a, this.lineHeight = n, this.charWidth = r, this.textHeight = i, this.lineLength = o, l) {
      this.heightSamples = {};
      for (let c = 0; c < s.length; c++) {
        let u = s[c];
        u < 0 ? c++ : this.heightSamples[Math.floor(u * 10)] = true;
      }
    }
    return l;
  }
};
var yZ = class {
  constructor(e, n) {
    this.from = e, this.heights = n, this.index = 0;
  }
  get more() {
    return this.index < this.heights.length;
  }
};
var gi = class {
  /**
  @internal
  */
  constructor(e, n, r, i, o) {
    this.from = e, this.length = n, this.top = r, this.height = i, this._content = o;
  }
  /**
  The type of element this is. When querying lines, this may be
  an array of all the blocks that make up the line.
  */
  get type() {
    return typeof this._content == "number" ? Yn.Text : Array.isArray(this._content) ? this._content : this._content.type;
  }
  /**
  The end of the element as a document position.
  */
  get to() {
    return this.from + this.length;
  }
  /**
  The bottom position of the element.
  */
  get bottom() {
    return this.top + this.height;
  }
  /**
  If this is a widget block, this will return the widget
  associated with it.
  */
  get widget() {
    return this._content instanceof jo ? this._content.widget : null;
  }
  /**
  If this is a textblock, this holds the number of line breaks
  that appear in widgets inside the block.
  */
  get widgetLineBreaks() {
    return typeof this._content == "number" ? this._content : 0;
  }
  /**
  @internal
  */
  join(e) {
    let n = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(e._content) ? e._content : [e]);
    return new gi(this.from, this.length + e.length, this.top, this.height + e.height, n);
  }
};
var Bt = /* @__PURE__ */ function(t4) {
  return t4[t4.ByPos = 0] = "ByPos", t4[t4.ByHeight = 1] = "ByHeight", t4[t4.ByPosNoHeight = 2] = "ByPosNoHeight", t4;
}(Bt || (Bt = {}));
var df = 1e-3;
var qn = class {
  constructor(e, n, r = 2) {
    this.length = e, this.height = n, this.flags = r;
  }
  get outdated() {
    return (this.flags & 2) > 0;
  }
  set outdated(e) {
    this.flags = (e ? 2 : 0) | this.flags & -3;
  }
  setHeight(e, n) {
    this.height != n && (Math.abs(this.height - n) > df && (e.heightChanged = true), this.height = n);
  }
  // Base case is to replace a leaf node, which simply builds a tree
  // from the new nodes and returns that (HeightMapBranch and
  // HeightMapGap override this to actually use from/to)
  replace(e, n, r) {
    return qn.of(r);
  }
  // Again, these are base cases, and are overridden for branch and gap nodes.
  decomposeLeft(e, n) {
    n.push(this);
  }
  decomposeRight(e, n) {
    n.push(this);
  }
  applyChanges(e, n, r, i) {
    let o = this, s = r.doc;
    for (let a = i.length - 1; a >= 0; a--) {
      let { fromA: l, toA: c, fromB: u, toB: f } = i[a], d = o.lineAt(l, Bt.ByPosNoHeight, r.setDoc(n), 0, 0), h = d.to >= c ? d : o.lineAt(c, Bt.ByPosNoHeight, r, 0, 0);
      for (f += h.to - c, c = h.to; a > 0 && d.from <= i[a - 1].toA; )
        l = i[a - 1].fromA, u = i[a - 1].fromB, a--, l < d.from && (d = o.lineAt(l, Bt.ByPosNoHeight, r, 0, 0));
      u += d.from - l, l = d.from;
      let p = Ax.build(r.setDoc(s), e, u, f);
      o = o.replace(l, c, p);
    }
    return o.updateHeight(r, 0);
  }
  static empty() {
    return new xr(0, 0);
  }
  // nodes uses null values to indicate the position of line breaks.
  // There are never line breaks at the start or end of the array, or
  // two line breaks next to each other, and the array isn't allowed
  // to be empty (same restrictions as return value from the builder).
  static of(e) {
    if (e.length == 1)
      return e[0];
    let n = 0, r = e.length, i = 0, o = 0;
    for (; ; )
      if (n == r)
        if (i > o * 2) {
          let a = e[n - 1];
          a.break ? e.splice(--n, 1, a.left, null, a.right) : e.splice(--n, 1, a.left, a.right), r += 1 + a.break, i -= a.size;
        } else if (o > i * 2) {
          let a = e[r];
          a.break ? e.splice(r, 1, a.left, null, a.right) : e.splice(r, 1, a.left, a.right), r += 2 + a.break, o -= a.size;
        } else
          break;
      else if (i < o) {
        let a = e[n++];
        a && (i += a.size);
      } else {
        let a = e[--r];
        a && (o += a.size);
      }
    let s = 0;
    return e[n - 1] == null ? (s = 1, n--) : e[n] == null && (s = 1, r++), new bZ(qn.of(e.slice(0, n)), s, qn.of(e.slice(r)));
  }
};
qn.prototype.size = 1;
var NE = class extends qn {
  constructor(e, n, r) {
    super(e, n), this.deco = r;
  }
  blockAt(e, n, r, i) {
    return new gi(i, this.length, r, this.height, this.deco || 0);
  }
  lineAt(e, n, r, i, o) {
    return this.blockAt(0, r, i, o);
  }
  forEachLine(e, n, r, i, o, s) {
    e <= o + this.length && n >= o && s(this.blockAt(0, r, i, o));
  }
  updateHeight(e, n = 0, r = false, i) {
    return i && i.from <= n && i.more && this.setHeight(e, i.heights[i.index++]), this.outdated = false, this;
  }
  toString() {
    return `block(${this.length})`;
  }
};
var xr = class extends NE {
  constructor(e, n) {
    super(e, n, null), this.collapsed = 0, this.widgetHeight = 0, this.breaks = 0;
  }
  blockAt(e, n, r, i) {
    return new gi(i, this.length, r, this.height, this.breaks);
  }
  replace(e, n, r) {
    let i = r[0];
    return r.length == 1 && (i instanceof xr || i instanceof Sn && i.flags & 4) && Math.abs(this.length - i.length) < 10 ? (i instanceof Sn ? i = new xr(i.length, this.height) : i.height = this.height, this.outdated || (i.outdated = false), i) : qn.of(r);
  }
  updateHeight(e, n = 0, r = false, i) {
    return i && i.from <= n && i.more ? this.setHeight(e, i.heights[i.index++]) : (r || this.outdated) && this.setHeight(e, Math.max(this.widgetHeight, e.heightForLine(this.length - this.collapsed)) + this.breaks * e.lineHeight), this.outdated = false, this;
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
  }
};
var Sn = class extends qn {
  constructor(e) {
    super(e, 0);
  }
  heightMetrics(e, n) {
    let r = e.doc.lineAt(n).number, i = e.doc.lineAt(n + this.length).number, o = i - r + 1, s, a = 0;
    if (e.lineWrapping) {
      let l = Math.min(this.height, e.lineHeight * o);
      s = l / o, this.length > o + 1 && (a = (this.height - l) / (this.length - o - 1));
    } else
      s = this.height / o;
    return { firstLine: r, lastLine: i, perLine: s, perChar: a };
  }
  blockAt(e, n, r, i) {
    let { firstLine: o, lastLine: s, perLine: a, perChar: l } = this.heightMetrics(n, i);
    if (n.lineWrapping) {
      let c = i + (e < n.lineHeight ? 0 : Math.round(Math.max(0, Math.min(1, (e - r) / this.height)) * this.length)), u = n.doc.lineAt(c), f = a + u.length * l, d = Math.max(r, e - f / 2);
      return new gi(u.from, u.length, d, f, 0);
    } else {
      let c = Math.max(0, Math.min(s - o, Math.floor((e - r) / a))), { from: u, length: f } = n.doc.line(o + c);
      return new gi(u, f, r + a * c, a, 0);
    }
  }
  lineAt(e, n, r, i, o) {
    if (n == Bt.ByHeight)
      return this.blockAt(e, r, i, o);
    if (n == Bt.ByPosNoHeight) {
      let { from: h, to: p } = r.doc.lineAt(e);
      return new gi(h, p - h, 0, 0, 0);
    }
    let { firstLine: s, perLine: a, perChar: l } = this.heightMetrics(r, o), c = r.doc.lineAt(e), u = a + c.length * l, f = c.number - s, d = i + a * f + l * (c.from - o - f);
    return new gi(c.from, c.length, Math.max(i, Math.min(d, i + this.height - u)), u, 0);
  }
  forEachLine(e, n, r, i, o, s) {
    e = Math.max(e, o), n = Math.min(n, o + this.length);
    let { firstLine: a, perLine: l, perChar: c } = this.heightMetrics(r, o);
    for (let u = e, f = i; u <= n; ) {
      let d = r.doc.lineAt(u);
      if (u == e) {
        let p = d.number - a;
        f += l * p + c * (e - o - p);
      }
      let h = l + c * d.length;
      s(new gi(d.from, d.length, f, h, 0)), f += h, u = d.to + 1;
    }
  }
  replace(e, n, r) {
    let i = this.length - n;
    if (i > 0) {
      let o = r[r.length - 1];
      o instanceof Sn ? r[r.length - 1] = new Sn(o.length + i) : r.push(null, new Sn(i - 1));
    }
    if (e > 0) {
      let o = r[0];
      o instanceof Sn ? r[0] = new Sn(e + o.length) : r.unshift(new Sn(e - 1), null);
    }
    return qn.of(r);
  }
  decomposeLeft(e, n) {
    n.push(new Sn(e - 1), null);
  }
  decomposeRight(e, n) {
    n.push(null, new Sn(this.length - e - 1));
  }
  updateHeight(e, n = 0, r = false, i) {
    let o = n + this.length;
    if (i && i.from <= n + this.length && i.more) {
      let s = [], a = Math.max(n, i.from), l = -1;
      for (i.from > n && s.push(new Sn(i.from - n - 1).updateHeight(e, n)); a <= o && i.more; ) {
        let u = e.doc.lineAt(a).length;
        s.length && s.push(null);
        let f = i.heights[i.index++];
        l == -1 ? l = f : Math.abs(f - l) >= df && (l = -2);
        let d = new xr(u, f);
        d.outdated = false, s.push(d), a += u + 1;
      }
      a <= o && s.push(null, new Sn(o - a).updateHeight(e, a));
      let c = qn.of(s);
      return (l < 0 || Math.abs(c.height - this.height) >= df || Math.abs(l - this.heightMetrics(e, n).perLine) >= df) && (e.heightChanged = true), c;
    } else
      (r || this.outdated) && (this.setHeight(e, e.heightForGap(n, n + this.length)), this.outdated = false);
    return this;
  }
  toString() {
    return `gap(${this.length})`;
  }
};
var bZ = class extends qn {
  constructor(e, n, r) {
    super(e.length + n + r.length, e.height + r.height, n | (e.outdated || r.outdated ? 2 : 0)), this.left = e, this.right = r, this.size = e.size + r.size;
  }
  get break() {
    return this.flags & 1;
  }
  blockAt(e, n, r, i) {
    let o = r + this.left.height;
    return e < o ? this.left.blockAt(e, n, r, i) : this.right.blockAt(e, n, o, i + this.left.length + this.break);
  }
  lineAt(e, n, r, i, o) {
    let s = i + this.left.height, a = o + this.left.length + this.break, l = n == Bt.ByHeight ? e < s : e < a, c = l ? this.left.lineAt(e, n, r, i, o) : this.right.lineAt(e, n, r, s, a);
    if (this.break || (l ? c.to < a : c.from > a))
      return c;
    let u = n == Bt.ByPosNoHeight ? Bt.ByPosNoHeight : Bt.ByPos;
    return l ? c.join(this.right.lineAt(a, u, r, s, a)) : this.left.lineAt(a, u, r, i, o).join(c);
  }
  forEachLine(e, n, r, i, o, s) {
    let a = i + this.left.height, l = o + this.left.length + this.break;
    if (this.break)
      e < l && this.left.forEachLine(e, n, r, i, o, s), n >= l && this.right.forEachLine(e, n, r, a, l, s);
    else {
      let c = this.lineAt(l, Bt.ByPos, r, i, o);
      e < c.from && this.left.forEachLine(e, c.from - 1, r, i, o, s), c.to >= e && c.from <= n && s(c), n > c.to && this.right.forEachLine(c.to + 1, n, r, a, l, s);
    }
  }
  replace(e, n, r) {
    let i = this.left.length + this.break;
    if (n < i)
      return this.balanced(this.left.replace(e, n, r), this.right);
    if (e > this.left.length)
      return this.balanced(this.left, this.right.replace(e - i, n - i, r));
    let o = [];
    e > 0 && this.decomposeLeft(e, o);
    let s = o.length;
    for (let a of r)
      o.push(a);
    if (e > 0 && d1(o, s - 1), n < this.length) {
      let a = o.length;
      this.decomposeRight(n, o), d1(o, a);
    }
    return qn.of(o);
  }
  decomposeLeft(e, n) {
    let r = this.left.length;
    if (e <= r)
      return this.left.decomposeLeft(e, n);
    n.push(this.left), this.break && (r++, e >= r && n.push(null)), e > r && this.right.decomposeLeft(e - r, n);
  }
  decomposeRight(e, n) {
    let r = this.left.length, i = r + this.break;
    if (e >= i)
      return this.right.decomposeRight(e - i, n);
    e < r && this.left.decomposeRight(e, n), this.break && e < i && n.push(null), n.push(this.right);
  }
  balanced(e, n) {
    return e.size > 2 * n.size || n.size > 2 * e.size ? qn.of(this.break ? [e, null, n] : [e, n]) : (this.left = e, this.right = n, this.height = e.height + n.height, this.outdated = e.outdated || n.outdated, this.size = e.size + n.size, this.length = e.length + this.break + n.length, this);
  }
  updateHeight(e, n = 0, r = false, i) {
    let { left: o, right: s } = this, a = n + o.length + this.break, l = null;
    return i && i.from <= n + o.length && i.more ? l = o = o.updateHeight(e, n, r, i) : o.updateHeight(e, n, r), i && i.from <= a + s.length && i.more ? l = s = s.updateHeight(e, a, r, i) : s.updateHeight(e, a, r), l ? this.balanced(o, s) : (this.height = this.left.height + this.right.height, this.outdated = false, this);
  }
  toString() {
    return this.left + (this.break ? " " : "-") + this.right;
  }
};
function d1(t4, e) {
  let n, r;
  t4[e] == null && (n = t4[e - 1]) instanceof Sn && (r = t4[e + 1]) instanceof Sn && t4.splice(e - 1, 3, new Sn(n.length + 1 + r.length));
}
var SZ = 5;
var Ax = class {
  constructor(e, n) {
    this.pos = e, this.oracle = n, this.nodes = [], this.lineStart = -1, this.lineEnd = -1, this.covering = null, this.writtenTo = e;
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(e, n) {
    if (this.lineStart > -1) {
      let r = Math.min(n, this.lineEnd), i = this.nodes[this.nodes.length - 1];
      i instanceof xr ? i.length += r - this.pos : (r > this.pos || !this.isCovered) && this.nodes.push(new xr(r - this.pos, -1)), this.writtenTo = r, n > r && (this.nodes.push(null), this.writtenTo++, this.lineStart = -1);
    }
    this.pos = n;
  }
  point(e, n, r) {
    if (e < n || r.heightRelevant) {
      let i = r.widget ? r.widget.estimatedHeight : 0, o = r.widget ? r.widget.lineBreaks : 0;
      i < 0 && (i = this.oracle.lineHeight);
      let s = n - e;
      r.block ? this.addBlock(new NE(s, i, r)) : (s || o || i >= SZ) && this.addLineDeco(i, o, s);
    } else
      n > e && this.span(e, n);
    this.lineEnd > -1 && this.lineEnd < this.pos && (this.lineEnd = this.oracle.doc.lineAt(this.pos).to);
  }
  enterLine() {
    if (this.lineStart > -1)
      return;
    let { from: e, to: n } = this.oracle.doc.lineAt(this.pos);
    this.lineStart = e, this.lineEnd = n, this.writtenTo < e && ((this.writtenTo < e - 1 || this.nodes[this.nodes.length - 1] == null) && this.nodes.push(this.blankContent(this.writtenTo, e - 1)), this.nodes.push(null)), this.pos > e && this.nodes.push(new xr(this.pos - e, -1)), this.writtenTo = this.pos;
  }
  blankContent(e, n) {
    let r = new Sn(n - e);
    return this.oracle.doc.lineAt(e).to == n && (r.flags |= 4), r;
  }
  ensureLine() {
    this.enterLine();
    let e = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (e instanceof xr)
      return e;
    let n = new xr(0, -1);
    return this.nodes.push(n), n;
  }
  addBlock(e) {
    this.enterLine();
    let n = e.deco;
    n && n.startSide > 0 && !this.isCovered && this.ensureLine(), this.nodes.push(e), this.writtenTo = this.pos = this.pos + e.length, n && n.endSide > 0 && (this.covering = e);
  }
  addLineDeco(e, n, r) {
    let i = this.ensureLine();
    i.length += r, i.collapsed += r, i.widgetHeight = Math.max(i.widgetHeight, e), i.breaks += n, this.writtenTo = this.pos = this.pos + r;
  }
  finish(e) {
    let n = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
    this.lineStart > -1 && !(n instanceof xr) && !this.isCovered ? this.nodes.push(new xr(0, -1)) : (this.writtenTo < this.pos || n == null) && this.nodes.push(this.blankContent(this.writtenTo, this.pos));
    let r = e;
    for (let i of this.nodes)
      i instanceof xr && i.updateHeight(this.oracle, r), r += i ? i.length : 1;
    return this.nodes;
  }
  // Always called with a region that on both sides either stretches
  // to a line break or the end of the document.
  // The returned array uses null to indicate line breaks, but never
  // starts or ends in a line break, or has multiple line breaks next
  // to each other.
  static build(e, n, r, i) {
    let o = new Ax(r, e);
    return ot.spans(n, r, i, o, 0), o.finish(r);
  }
};
function wZ(t4, e, n) {
  let r = new CZ();
  return ot.compare(t4, e, n, r, 0), r.changes;
}
var CZ = class {
  constructor() {
    this.changes = [];
  }
  compareRange() {
  }
  comparePoint(e, n, r, i) {
    (e < n || r && r.heightRelevant || i && i.heightRelevant) && fm(e, n, this.changes, 5);
  }
};
function kZ(t4, e) {
  let n = t4.getBoundingClientRect(), r = t4.ownerDocument, i = r.defaultView || window, o = Math.max(0, n.left), s = Math.min(i.innerWidth, n.right), a = Math.max(0, n.top), l = Math.min(i.innerHeight, n.bottom);
  for (let c = t4.parentNode; c && c != r.body; )
    if (c.nodeType == 1) {
      let u = c, f = window.getComputedStyle(u);
      if ((u.scrollHeight > u.clientHeight || u.scrollWidth > u.clientWidth) && f.overflow != "visible") {
        let d = u.getBoundingClientRect();
        o = Math.max(o, d.left), s = Math.min(s, d.right), a = Math.max(a, d.top), l = c == t4.parentNode ? d.bottom : Math.min(l, d.bottom);
      }
      c = f.position == "absolute" || f.position == "fixed" ? u.offsetParent : u.parentNode;
    } else if (c.nodeType == 11)
      c = c.host;
    else
      break;
  return {
    left: o - n.left,
    right: Math.max(o, s) - n.left,
    top: a - (n.top + e),
    bottom: Math.max(a, l) - (n.top + e)
  };
}
function AZ(t4, e) {
  let n = t4.getBoundingClientRect();
  return {
    left: 0,
    right: n.right - n.left,
    top: e,
    bottom: n.bottom - (n.top + e)
  };
}
var $p = class {
  constructor(e, n, r) {
    this.from = e, this.to = n, this.size = r;
  }
  static same(e, n) {
    if (e.length != n.length)
      return false;
    for (let r = 0; r < e.length; r++) {
      let i = e[r], o = n[r];
      if (i.from != o.from || i.to != o.to || i.size != o.size)
        return false;
    }
    return true;
  }
  draw(e, n) {
    return we.replace({
      widget: new PZ(this.size * (n ? e.scaleY : e.scaleX), n)
    }).range(this.from, this.to);
  }
};
var PZ = class extends Qi {
  constructor(e, n) {
    super(), this.size = e, this.vertical = n;
  }
  eq(e) {
    return e.size == this.size && e.vertical == this.vertical;
  }
  toDOM() {
    let e = document.createElement("div");
    return this.vertical ? e.style.height = this.size + "px" : (e.style.width = this.size + "px", e.style.height = "2px", e.style.display = "inline-block"), e;
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
};
var h1 = class {
  constructor(e) {
    this.state = e, this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 }, this.inView = true, this.paddingTop = 0, this.paddingBottom = 0, this.contentDOMWidth = 0, this.contentDOMHeight = 0, this.editorHeight = 0, this.editorWidth = 0, this.scrollTop = 0, this.scrolledToBottom = false, this.scaleX = 1, this.scaleY = 1, this.scrollAnchorPos = 0, this.scrollAnchorHeight = -1, this.scaler = p1, this.scrollTarget = null, this.printing = false, this.mustMeasureContent = true, this.defaultTextDirection = _t.LTR, this.visibleRanges = [], this.mustEnforceCursorAssoc = false;
    let n = e.facet(Cx).some((r) => typeof r != "function" && r.class == "cm-lineWrapping");
    this.heightOracle = new vZ(n), this.stateDeco = e.facet(ic).filter((r) => typeof r != "function"), this.heightMap = qn.empty().applyChanges(this.stateDeco, ft.empty, this.heightOracle.setDoc(e.doc), [new Br(0, 0, 0, e.doc.length)]), this.viewport = this.getViewport(0, null), this.updateViewportLines(), this.updateForViewport(), this.lineGaps = this.ensureLineGaps([]), this.lineGapDeco = we.set(this.lineGaps.map((r) => r.draw(this, false))), this.computeVisibleRanges();
  }
  updateForViewport() {
    let e = [this.viewport], { main: n } = this.state.selection;
    for (let r = 0; r <= 1; r++) {
      let i = r ? n.head : n.anchor;
      if (!e.some(({ from: o, to: s }) => i >= o && i <= s)) {
        let { from: o, to: s } = this.lineBlockAt(i);
        e.push(new Eu(o, s));
      }
    }
    this.viewports = e.sort((r, i) => r.from - i.from), this.scaler = this.heightMap.height <= 7e6 ? p1 : new IZ(this.heightOracle, this.heightMap, this.viewports);
  }
  updateViewportLines() {
    this.viewportLines = [], this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (e) => {
      this.viewportLines.push(this.scaler.scale == 1 ? e : Tl(e, this.scaler));
    });
  }
  update(e, n = null) {
    this.state = e.state;
    let r = this.stateDeco;
    this.stateDeco = this.state.facet(ic).filter((u) => typeof u != "function");
    let i = e.changedRanges, o = Br.extendWithRanges(i, wZ(r, this.stateDeco, e ? e.changes : un.empty(this.state.doc.length))), s = this.heightMap.height, a = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
    this.heightMap = this.heightMap.applyChanges(this.stateDeco, e.startState.doc, this.heightOracle.setDoc(this.state.doc), o), this.heightMap.height != s && (e.flags |= 2), a ? (this.scrollAnchorPos = e.changes.mapPos(a.from, -1), this.scrollAnchorHeight = a.top) : (this.scrollAnchorPos = -1, this.scrollAnchorHeight = this.heightMap.height);
    let l = o.length ? this.mapViewport(this.viewport, e.changes) : this.viewport;
    (n && (n.range.head < l.from || n.range.head > l.to) || !this.viewportIsAppropriate(l)) && (l = this.getViewport(0, n));
    let c = !e.changes.empty || e.flags & 2 || l.from != this.viewport.from || l.to != this.viewport.to;
    this.viewport = l, this.updateForViewport(), c && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, e.changes))), e.flags |= this.computeVisibleRanges(), n && (this.scrollTarget = n), !this.mustEnforceCursorAssoc && e.selectionSet && e.view.lineWrapping && e.state.selection.main.empty && e.state.selection.main.assoc && !e.state.facet(bE) && (this.mustEnforceCursorAssoc = true);
  }
  measure(e) {
    let n = e.contentDOM, r = window.getComputedStyle(n), i = this.heightOracle, o = r.whiteSpace;
    this.defaultTextDirection = r.direction == "rtl" ? _t.RTL : _t.LTR;
    let s = this.heightOracle.mustRefreshForWrapping(o), a = n.getBoundingClientRect(), l = s || this.mustMeasureContent || this.contentDOMHeight != a.height;
    this.contentDOMHeight = a.height, this.mustMeasureContent = false;
    let c = 0, u = 0;
    if (a.width && a.height) {
      let { scaleX: S, scaleY: b } = Y2(n, a);
      (S > 5e-3 && Math.abs(this.scaleX - S) > 5e-3 || b > 5e-3 && Math.abs(this.scaleY - b) > 5e-3) && (this.scaleX = S, this.scaleY = b, c |= 8, s = l = true);
    }
    let f = (parseInt(r.paddingTop) || 0) * this.scaleY, d = (parseInt(r.paddingBottom) || 0) * this.scaleY;
    (this.paddingTop != f || this.paddingBottom != d) && (this.paddingTop = f, this.paddingBottom = d, c |= 10), this.editorWidth != e.scrollDOM.clientWidth && (i.lineWrapping && (l = true), this.editorWidth = e.scrollDOM.clientWidth, c |= 8);
    let h = e.scrollDOM.scrollTop * this.scaleY;
    this.scrollTop != h && (this.scrollAnchorHeight = -1, this.scrollTop = h), this.scrolledToBottom = H2(e.scrollDOM);
    let p = (this.printing ? AZ : kZ)(n, this.paddingTop), O = p.top - this.pixelViewport.top, m = p.bottom - this.pixelViewport.bottom;
    this.pixelViewport = p;
    let x = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if (x != this.inView && (this.inView = x, x && (l = true)), !this.inView && !this.scrollTarget)
      return 0;
    let v = a.width;
    if ((this.contentDOMWidth != v || this.editorHeight != e.scrollDOM.clientHeight) && (this.contentDOMWidth = a.width, this.editorHeight = e.scrollDOM.clientHeight, c |= 8), l) {
      let S = e.docView.measureVisibleLineHeights(this.viewport);
      if (i.mustRefreshForHeights(S) && (s = true), s || i.lineWrapping && Math.abs(v - this.contentDOMWidth) > i.charWidth) {
        let { lineHeight: b, charWidth: w, textHeight: C } = e.docView.measureTextSize();
        s = b > 0 && i.refresh(o, b, w, C, v / w, S), s && (e.docView.minWidth = 0, c |= 8);
      }
      O > 0 && m > 0 ? u = Math.max(O, m) : O < 0 && m < 0 && (u = Math.min(O, m)), i.heightChanged = false;
      for (let b of this.viewports) {
        let w = b.from == this.viewport.from ? S : e.docView.measureVisibleLineHeights(b);
        this.heightMap = (s ? qn.empty().applyChanges(this.stateDeco, ft.empty, this.heightOracle, [new Br(0, 0, 0, e.state.doc.length)]) : this.heightMap).updateHeight(i, 0, s, new yZ(b.from, w));
      }
      i.heightChanged && (c |= 2);
    }
    let y = !this.viewportIsAppropriate(this.viewport, u) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
    return y && (this.viewport = this.getViewport(u, this.scrollTarget)), this.updateForViewport(), (c & 2 || y) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(s ? [] : this.lineGaps, e)), c |= this.computeVisibleRanges(), this.mustEnforceCursorAssoc && (this.mustEnforceCursorAssoc = false, e.docView.enforceCursorAssoc()), c;
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom);
  }
  getViewport(e, n) {
    let r = 0.5 - Math.max(-0.5, Math.min(0.5, e / 1e3 / 2)), i = this.heightMap, o = this.heightOracle, { visibleTop: s, visibleBottom: a } = this, l = new Eu(i.lineAt(s - r * 1e3, Bt.ByHeight, o, 0, 0).from, i.lineAt(a + (1 - r) * 1e3, Bt.ByHeight, o, 0, 0).to);
    if (n) {
      let { head: c } = n.range;
      if (c < l.from || c > l.to) {
        let u = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top), f = i.lineAt(c, Bt.ByPos, o, 0, 0), d;
        n.y == "center" ? d = (f.top + f.bottom) / 2 - u / 2 : n.y == "start" || n.y == "nearest" && c < l.from ? d = f.top : d = f.bottom - u, l = new Eu(i.lineAt(d - 1e3 / 2, Bt.ByHeight, o, 0, 0).from, i.lineAt(d + u + 1e3 / 2, Bt.ByHeight, o, 0, 0).to);
      }
    }
    return l;
  }
  mapViewport(e, n) {
    let r = n.mapPos(e.from, -1), i = n.mapPos(e.to, 1);
    return new Eu(this.heightMap.lineAt(r, Bt.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(i, Bt.ByPos, this.heightOracle, 0, 0).to);
  }
  // Checks if a given viewport covers the visible part of the
  // document and not too much beyond that.
  viewportIsAppropriate({ from: e, to: n }, r = 0) {
    if (!this.inView)
      return true;
    let { top: i } = this.heightMap.lineAt(e, Bt.ByPos, this.heightOracle, 0, 0), { bottom: o } = this.heightMap.lineAt(n, Bt.ByPos, this.heightOracle, 0, 0), { visibleTop: s, visibleBottom: a } = this;
    return (e == 0 || i <= s - Math.max(10, Math.min(
      -r,
      250
      /* VP.MaxCoverMargin */
    ))) && (n == this.state.doc.length || o >= a + Math.max(10, Math.min(
      r,
      250
      /* VP.MaxCoverMargin */
    ))) && i > s - 2 * 1e3 && o < a + 2 * 1e3;
  }
  mapLineGaps(e, n) {
    if (!e.length || n.empty)
      return e;
    let r = [];
    for (let i of e)
      n.touchesRange(i.from, i.to) || r.push(new $p(n.mapPos(i.from), n.mapPos(i.to), i.size));
    return r;
  }
  // Computes positions in the viewport where the start or end of a
  // line should be hidden, trying to reuse existing line gaps when
  // appropriate to avoid unneccesary redraws.
  // Uses crude character-counting for the positioning and sizing,
  // since actual DOM coordinates aren't always available and
  // predictable. Relies on generous margins (see LG.Margin) to hide
  // the artifacts this might produce from the user.
  ensureLineGaps(e, n) {
    let r = this.heightOracle.lineWrapping, i = r ? 1e4 : 2e3, o = i >> 1, s = i << 1;
    if (this.defaultTextDirection != _t.LTR && !r)
      return [];
    let a = [], l = (c, u, f, d) => {
      if (u - c < o)
        return;
      let h = this.state.selection.main, p = [h.from];
      h.empty || p.push(h.to);
      for (let m of p)
        if (m > c && m < u) {
          l(c, m - 10, f, d), l(m + 10, u, f, d);
          return;
        }
      let O = TZ(e, (m) => m.from >= f.from && m.to <= f.to && Math.abs(m.from - c) < o && Math.abs(m.to - u) < o && !p.some((x) => m.from < x && m.to > x));
      if (!O) {
        if (u < f.to && n && r && n.visibleRanges.some((m) => m.from <= u && m.to >= u)) {
          let m = n.moveToLineBoundary(ne.cursor(u), false, true).head;
          m > c && (u = m);
        }
        O = new $p(c, u, this.gapSize(f, c, u, d));
      }
      a.push(O);
    };
    for (let c of this.viewportLines) {
      if (c.length < s)
        continue;
      let u = EZ(c.from, c.to, this.stateDeco);
      if (u.total < s)
        continue;
      let f = this.scrollTarget ? this.scrollTarget.range.head : null, d, h;
      if (r) {
        let p = i / this.heightOracle.lineLength * this.heightOracle.lineHeight, O, m;
        if (f != null) {
          let x = Iu(u, f), v = ((this.visibleBottom - this.visibleTop) / 2 + p) / c.height;
          O = x - v, m = x + v;
        } else
          O = (this.visibleTop - c.top - p) / c.height, m = (this.visibleBottom - c.top + p) / c.height;
        d = Tu(u, O), h = Tu(u, m);
      } else {
        let p = u.total * this.heightOracle.charWidth, O = i * this.heightOracle.charWidth, m, x;
        if (f != null) {
          let v = Iu(u, f), y = ((this.pixelViewport.right - this.pixelViewport.left) / 2 + O) / p;
          m = v - y, x = v + y;
        } else
          m = (this.pixelViewport.left - O) / p, x = (this.pixelViewport.right + O) / p;
        d = Tu(u, m), h = Tu(u, x);
      }
      d > c.from && l(c.from, d, c, u), h < c.to && l(h, c.to, c, u);
    }
    return a;
  }
  gapSize(e, n, r, i) {
    let o = Iu(i, r) - Iu(i, n);
    return this.heightOracle.lineWrapping ? e.height * o : i.total * this.heightOracle.charWidth * o;
  }
  updateLineGaps(e) {
    $p.same(e, this.lineGaps) || (this.lineGaps = e, this.lineGapDeco = we.set(e.map((n) => n.draw(this, this.heightOracle.lineWrapping))));
  }
  computeVisibleRanges() {
    let e = this.stateDeco;
    this.lineGaps.length && (e = e.concat(this.lineGapDeco));
    let n = [];
    ot.spans(e, this.viewport.from, this.viewport.to, {
      span(i, o) {
        n.push({ from: i, to: o });
      },
      point() {
      }
    }, 20);
    let r = n.length != this.visibleRanges.length || this.visibleRanges.some((i, o) => i.from != n[o].from || i.to != n[o].to);
    return this.visibleRanges = n, r ? 4 : 0;
  }
  lineBlockAt(e) {
    return e >= this.viewport.from && e <= this.viewport.to && this.viewportLines.find((n) => n.from <= e && n.to >= e) || Tl(this.heightMap.lineAt(e, Bt.ByPos, this.heightOracle, 0, 0), this.scaler);
  }
  lineBlockAtHeight(e) {
    return Tl(this.heightMap.lineAt(this.scaler.fromDOM(e), Bt.ByHeight, this.heightOracle, 0, 0), this.scaler);
  }
  scrollAnchorAt(e) {
    let n = this.lineBlockAtHeight(e + 8);
    return n.from >= this.viewport.from || this.viewportLines[0].top - e > 200 ? n : this.viewportLines[0];
  }
  elementAtHeight(e) {
    return Tl(this.heightMap.blockAt(this.scaler.fromDOM(e), this.heightOracle, 0, 0), this.scaler);
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height);
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom;
  }
};
var Eu = class {
  constructor(e, n) {
    this.from = e, this.to = n;
  }
};
function EZ(t4, e, n) {
  let r = [], i = t4, o = 0;
  return ot.spans(n, t4, e, {
    span() {
    },
    point(s, a) {
      s > i && (r.push({ from: i, to: s }), o += s - i), i = a;
    }
  }, 20), i < e && (r.push({ from: i, to: e }), o += e - i), { total: o, ranges: r };
}
function Tu({ total: t4, ranges: e }, n) {
  if (n <= 0)
    return e[0].from;
  if (n >= 1)
    return e[e.length - 1].to;
  let r = Math.floor(t4 * n);
  for (let i = 0; ; i++) {
    let { from: o, to: s } = e[i], a = s - o;
    if (r <= a)
      return o + r;
    r -= a;
  }
}
function Iu(t4, e) {
  let n = 0;
  for (let { from: r, to: i } of t4.ranges) {
    if (e <= i) {
      n += e - r;
      break;
    }
    n += i - r;
  }
  return n / t4.total;
}
function TZ(t4, e) {
  for (let n of t4)
    if (e(n))
      return n;
}
var p1 = {
  toDOM(t4) {
    return t4;
  },
  fromDOM(t4) {
    return t4;
  },
  scale: 1
};
var IZ = class {
  constructor(e, n, r) {
    let i = 0, o = 0, s = 0;
    this.viewports = r.map(({ from: a, to: l }) => {
      let c = n.lineAt(a, Bt.ByPos, e, 0, 0).top, u = n.lineAt(l, Bt.ByPos, e, 0, 0).bottom;
      return i += u - c, { from: a, to: l, top: c, bottom: u, domTop: 0, domBottom: 0 };
    }), this.scale = (7e6 - i) / (n.height - i);
    for (let a of this.viewports)
      a.domTop = s + (a.top - o) * this.scale, s = a.domBottom = a.domTop + (a.bottom - a.top), o = a.bottom;
  }
  toDOM(e) {
    for (let n = 0, r = 0, i = 0; ; n++) {
      let o = n < this.viewports.length ? this.viewports[n] : null;
      if (!o || e < o.top)
        return i + (e - r) * this.scale;
      if (e <= o.bottom)
        return o.domTop + (e - o.top);
      r = o.bottom, i = o.domBottom;
    }
  }
  fromDOM(e) {
    for (let n = 0, r = 0, i = 0; ; n++) {
      let o = n < this.viewports.length ? this.viewports[n] : null;
      if (!o || e < o.domTop)
        return r + (e - i) / this.scale;
      if (e <= o.domBottom)
        return o.top + (e - o.domTop);
      r = o.bottom, i = o.domBottom;
    }
  }
};
function Tl(t4, e) {
  if (e.scale == 1)
    return t4;
  let n = e.toDOM(t4.top), r = e.toDOM(t4.bottom);
  return new gi(t4.from, t4.length, n, r - n, Array.isArray(t4._content) ? t4._content.map((i) => Tl(i, e)) : t4._content);
}
var $u = /* @__PURE__ */ ge.define({ combine: (t4) => t4.join(" ") });
var vm = /* @__PURE__ */ ge.define({ combine: (t4) => t4.indexOf(true) > -1 });
var ym = /* @__PURE__ */ Io.newName();
var FE = /* @__PURE__ */ Io.newName();
var ZE = /* @__PURE__ */ Io.newName();
var WE = { "&light": "." + FE, "&dark": "." + ZE };
function bm(t4, e, n) {
  return new Io(e, {
    finish(r) {
      return /&/.test(r) ? r.replace(/&\w*/, (i) => {
        if (i == "&")
          return t4;
        if (!n || !n[i])
          throw new RangeError(`Unsupported selector: ${i}`);
        return n[i];
      }) : t4 + " " + r;
    }
  });
}
var $Z = /* @__PURE__ */ bm("." + ym, {
  "&": {
    position: "relative !important",
    boxSizing: "border-box",
    "&.cm-focused": {
      // Provide a simple default outline to make sure a focused
      // editor is visually distinct. Can't leave the default behavior
      // because that will apply to the content element, which is
      // inside the scrollable container and doesn't include the
      // gutters. We also can't use an 'auto' outline, since those
      // are, for some reason, drawn behind the element content, which
      // will cause things like the active line background to cover
      // the outline (#297).
      outline: "1px dotted #212121"
    },
    display: "flex !important",
    flexDirection: "column"
  },
  ".cm-scroller": {
    display: "flex !important",
    alignItems: "flex-start !important",
    fontFamily: "monospace",
    lineHeight: 1.4,
    height: "100%",
    overflowX: "auto",
    position: "relative",
    zIndex: 0
  },
  ".cm-content": {
    margin: 0,
    flexGrow: 2,
    flexShrink: 0,
    display: "block",
    whiteSpace: "pre",
    wordWrap: "normal",
    // https://github.com/codemirror/dev/issues/456
    boxSizing: "border-box",
    minHeight: "100%",
    padding: "4px 0",
    outline: "none",
    "&[contenteditable=true]": {
      WebkitUserModify: "read-write-plaintext-only"
    }
  },
  ".cm-lineWrapping": {
    whiteSpace_fallback: "pre-wrap",
    // For IE
    whiteSpace: "break-spaces",
    wordBreak: "break-word",
    // For Safari, which doesn't support overflow-wrap: anywhere
    overflowWrap: "anywhere",
    flexShrink: 1
  },
  "&light .cm-content": { caretColor: "black" },
  "&dark .cm-content": { caretColor: "white" },
  ".cm-line": {
    display: "block",
    padding: "0 2px 0 6px"
  },
  ".cm-layer": {
    position: "absolute",
    left: 0,
    top: 0,
    contain: "size style",
    "& > *": {
      position: "absolute"
    }
  },
  "&light .cm-selectionBackground": {
    background: "#d9d9d9"
  },
  "&dark .cm-selectionBackground": {
    background: "#222"
  },
  "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#d7d4f0"
  },
  "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#233"
  },
  ".cm-cursorLayer": {
    pointerEvents: "none"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
    animation: "steps(1) cm-blink 1.2s infinite"
  },
  // Two animations defined so that we can switch between them to
  // restart the animation without forcing another style
  // recomputation.
  "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  ".cm-cursor, .cm-dropCursor": {
    borderLeft: "1.2px solid black",
    marginLeft: "-0.6px",
    pointerEvents: "none"
  },
  ".cm-cursor": {
    display: "none"
  },
  "&dark .cm-cursor": {
    borderLeftColor: "#444"
  },
  ".cm-dropCursor": {
    position: "absolute"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
    display: "block"
  },
  ".cm-iso": {
    unicodeBidi: "isolate"
  },
  ".cm-announced": {
    position: "fixed",
    top: "-10000px"
  },
  "@media print": {
    ".cm-announced": { display: "none" }
  },
  "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
  "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
  "&light .cm-specialChar": { color: "red" },
  "&dark .cm-specialChar": { color: "#f78" },
  ".cm-gutters": {
    flexShrink: 0,
    display: "flex",
    height: "100%",
    boxSizing: "border-box",
    insetInlineStart: 0,
    zIndex: 200
  },
  "&light .cm-gutters": {
    backgroundColor: "#f5f5f5",
    color: "#6c6c6c",
    borderRight: "1px solid #ddd"
  },
  "&dark .cm-gutters": {
    backgroundColor: "#333338",
    color: "#ccc"
  },
  ".cm-gutter": {
    display: "flex !important",
    // Necessary -- prevents margin collapsing
    flexDirection: "column",
    flexShrink: 0,
    boxSizing: "border-box",
    minHeight: "100%",
    overflow: "hidden"
  },
  ".cm-gutterElement": {
    boxSizing: "border-box"
  },
  ".cm-lineNumbers .cm-gutterElement": {
    padding: "0 3px 0 5px",
    minWidth: "20px",
    textAlign: "right",
    whiteSpace: "nowrap"
  },
  "&light .cm-activeLineGutter": {
    backgroundColor: "#e2f2ff"
  },
  "&dark .cm-activeLineGutter": {
    backgroundColor: "#222227"
  },
  ".cm-panels": {
    boxSizing: "border-box",
    position: "sticky",
    left: 0,
    right: 0
  },
  "&light .cm-panels": {
    backgroundColor: "#f5f5f5",
    color: "black"
  },
  "&light .cm-panels-top": {
    borderBottom: "1px solid #ddd"
  },
  "&light .cm-panels-bottom": {
    borderTop: "1px solid #ddd"
  },
  "&dark .cm-panels": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tab": {
    display: "inline-block",
    overflow: "hidden",
    verticalAlign: "bottom"
  },
  ".cm-widgetBuffer": {
    verticalAlign: "text-top",
    height: "1em",
    width: 0,
    display: "inline"
  },
  ".cm-placeholder": {
    color: "#888",
    display: "inline-block",
    verticalAlign: "top"
  },
  ".cm-highlightSpace:before": {
    content: "attr(data-display)",
    position: "absolute",
    pointerEvents: "none",
    color: "#888"
  },
  ".cm-highlightTab": {
    backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
    backgroundSize: "auto 100%",
    backgroundPosition: "right 90%",
    backgroundRepeat: "no-repeat"
  },
  ".cm-trailingSpace": {
    backgroundColor: "#ff332255"
  },
  ".cm-button": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    padding: ".2em 1em",
    borderRadius: "1px"
  },
  "&light .cm-button": {
    backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
    }
  },
  "&dark .cm-button": {
    backgroundImage: "linear-gradient(#393939, #111)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#111, #333)"
    }
  },
  ".cm-textfield": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    border: "1px solid silver",
    padding: ".2em .5em"
  },
  "&light .cm-textfield": {
    backgroundColor: "white"
  },
  "&dark .cm-textfield": {
    border: "1px solid #555",
    backgroundColor: "inherit"
  }
}, WE);
var Il = "\uFFFF";
var jZ = class {
  constructor(e, n) {
    this.points = e, this.text = "", this.lineSeparator = n.facet(et.lineSeparator);
  }
  append(e) {
    this.text += e;
  }
  lineBreak() {
    this.text += Il;
  }
  readRange(e, n) {
    if (!e)
      return this;
    let r = e.parentNode;
    for (let i = e; ; ) {
      this.findPointBefore(r, i);
      let o = this.text.length;
      this.readNode(i);
      let s = i.nextSibling;
      if (s == n)
        break;
      let a = It.get(i), l = It.get(s);
      (a && l ? a.breakAfter : (a ? a.breakAfter : td(i)) || td(s) && (i.nodeName != "BR" || i.cmIgnore) && this.text.length > o) && this.lineBreak(), i = s;
    }
    return this.findPointBefore(r, n), this;
  }
  readTextNode(e) {
    let n = e.nodeValue;
    for (let r of this.points)
      r.node == e && (r.pos = this.text.length + Math.min(r.offset, n.length));
    for (let r = 0, i = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
      let o = -1, s = 1, a;
      if (this.lineSeparator ? (o = n.indexOf(this.lineSeparator, r), s = this.lineSeparator.length) : (a = i.exec(n)) && (o = a.index, s = a[0].length), this.append(n.slice(r, o < 0 ? n.length : o)), o < 0)
        break;
      if (this.lineBreak(), s > 1)
        for (let l of this.points)
          l.node == e && l.pos > this.text.length && (l.pos -= s - 1);
      r = o + s;
    }
  }
  readNode(e) {
    if (e.cmIgnore)
      return;
    let n = It.get(e), r = n && n.overrideDOMText;
    if (r != null) {
      this.findPointInside(e, r.length);
      for (let i = r.iter(); !i.next().done; )
        i.lineBreak ? this.lineBreak() : this.append(i.value);
    } else
      e.nodeType == 3 ? this.readTextNode(e) : e.nodeName == "BR" ? e.nextSibling && this.lineBreak() : e.nodeType == 1 && this.readRange(e.firstChild, null);
  }
  findPointBefore(e, n) {
    for (let r of this.points)
      r.node == e && e.childNodes[r.offset] == n && (r.pos = this.text.length);
  }
  findPointInside(e, n) {
    for (let r of this.points)
      (e.nodeType == 3 ? r.node == e : e.contains(r.node)) && (r.pos = this.text.length + (RZ(e, r.node, r.offset) ? n : 0));
  }
};
function RZ(t4, e, n) {
  for (; ; ) {
    if (!e || n < Ui(e))
      return false;
    if (e == t4)
      return true;
    n = ds(e) + 1, e = e.parentNode;
  }
}
var g1 = class {
  constructor(e, n) {
    this.node = e, this.offset = n, this.pos = -1;
  }
};
var DZ = class {
  constructor(e, n, r, i) {
    this.typeOver = i, this.bounds = null, this.text = "";
    let { impreciseHead: o, impreciseAnchor: s } = e.docView;
    if (e.state.readOnly && n > -1)
      this.newSel = null;
    else if (n > -1 && (this.bounds = e.docView.domBoundsAround(n, r, 0))) {
      let a = o || s ? [] : _Z(e), l = new jZ(a, e.state);
      l.readRange(this.bounds.startDOM, this.bounds.endDOM), this.text = l.text, this.newSel = MZ(a, this.bounds.from);
    } else {
      let a = e.observer.selectionRange, l = o && o.node == a.focusNode && o.offset == a.focusOffset || !om(e.contentDOM, a.focusNode) ? e.state.selection.main.head : e.docView.posFromDOM(a.focusNode, a.focusOffset), c = s && s.node == a.anchorNode && s.offset == a.anchorOffset || !om(e.contentDOM, a.anchorNode) ? e.state.selection.main.anchor : e.docView.posFromDOM(a.anchorNode, a.anchorOffset), u = e.viewport;
      if ((me.ios || me.chrome) && e.state.selection.main.empty && l != c && (u.from > 0 || u.to < e.state.doc.length)) {
        let f = Math.min(l, c), d = Math.max(l, c), h = u.from - f, p = u.to - d;
        (h == 0 || h == 1 || f == 0) && (p == 0 || p == -1 || d == e.state.doc.length) && (l = 0, c = e.state.doc.length);
      }
      this.newSel = ne.single(c, l);
    }
  }
};
function VE(t4, e) {
  let n, { newSel: r } = e, i = t4.state.selection.main, o = t4.inputState.lastKeyTime > Date.now() - 100 ? t4.inputState.lastKeyCode : -1;
  if (e.bounds) {
    let { from: s, to: a } = e.bounds, l = i.from, c = null;
    (o === 8 || me.android && e.text.length < a - s) && (l = i.to, c = "end");
    let u = BZ(t4.state.doc.sliceString(s, a, Il), e.text, l - s, c);
    u && (me.chrome && o == 13 && u.toB == u.from + 2 && e.text.slice(u.from, u.toB) == Il + Il && u.toB--, n = {
      from: s + u.from,
      to: s + u.toA,
      insert: ft.of(e.text.slice(u.from, u.toB).split(Il))
    });
  } else
    r && (!t4.hasFocus && t4.state.facet(xh) || r.main.eq(i)) && (r = null);
  if (!n && !r)
    return false;
  if (!n && e.typeOver && !i.empty && r && r.main.empty ? n = { from: i.from, to: i.to, insert: t4.state.doc.slice(i.from, i.to) } : n && n.from >= i.from && n.to <= i.to && (n.from != i.from || n.to != i.to) && i.to - i.from - (n.to - n.from) <= 4 ? n = {
    from: i.from,
    to: i.to,
    insert: t4.state.doc.slice(i.from, n.from).append(n.insert).append(t4.state.doc.slice(n.to, i.to))
  } : (me.mac || me.android) && n && n.from == n.to && n.from == i.head - 1 && /^\. ?$/.test(n.insert.toString()) && t4.contentDOM.getAttribute("autocorrect") == "off" ? (r && n.insert.length == 2 && (r = ne.single(r.main.anchor - 1, r.main.head - 1)), n = { from: i.from, to: i.to, insert: ft.of([" "]) }) : me.chrome && n && n.from == n.to && n.from == i.head && n.insert.toString() == `
 ` && t4.lineWrapping && (r && (r = ne.single(r.main.anchor - 1, r.main.head - 1)), n = { from: i.from, to: i.to, insert: ft.of([" "]) }), n) {
    if (me.ios && t4.inputState.flushIOSKey(n) || me.android && (n.to == i.to && // GBoard will sometimes remove a space it just inserted
    // after a completion when you press enter
    (n.from == i.from || n.from == i.from - 1 && t4.state.sliceDoc(n.from, i.from) == " ") && n.insert.length == 1 && n.insert.lines == 2 && la(t4.contentDOM, "Enter", 13) || (n.from == i.from - 1 && n.to == i.to && n.insert.length == 0 || o == 8 && n.insert.length < n.to - n.from && n.to > i.head) && la(t4.contentDOM, "Backspace", 8) || n.from == i.from && n.to == i.to + 1 && n.insert.length == 0 && la(t4.contentDOM, "Delete", 46)))
      return true;
    let s = n.insert.toString();
    t4.inputState.composing >= 0 && t4.inputState.composing++;
    let a, l = () => a || (a = QZ(t4, n, r));
    return t4.state.facet(xE).some((c) => c(t4, n.from, n.to, s, l)) || t4.dispatch(l()), true;
  } else if (r && !r.main.eq(i)) {
    let s = false, a = "select";
    return t4.inputState.lastSelectionTime > Date.now() - 50 && (t4.inputState.lastSelectionOrigin == "select" && (s = true), a = t4.inputState.lastSelectionOrigin), t4.dispatch({ selection: r, scrollIntoView: s, userEvent: a }), true;
  } else
    return false;
}
function QZ(t4, e, n) {
  let r, i = t4.state, o = i.selection.main;
  if (e.from >= o.from && e.to <= o.to && e.to - e.from >= (o.to - o.from) / 3 && (!n || n.main.empty && n.main.from == e.from + e.insert.length) && t4.inputState.composing < 0) {
    let a = o.from < e.from ? i.sliceDoc(o.from, e.from) : "", l = o.to > e.to ? i.sliceDoc(e.to, o.to) : "";
    r = i.replaceSelection(t4.state.toText(a + e.insert.sliceString(0, void 0, t4.state.lineBreak) + l));
  } else {
    let a = i.changes(e), l = n && n.main.to <= a.newLength ? n.main : void 0;
    if (i.selection.ranges.length > 1 && t4.inputState.composing >= 0 && e.to <= o.to && e.to >= o.to - 10) {
      let c = t4.state.sliceDoc(e.from, e.to), u, f = n && EE(t4, n.main.head);
      if (f) {
        let p = e.insert.length - (e.to - e.from);
        u = { from: f.from, to: f.to - p };
      } else
        u = t4.state.doc.lineAt(o.head);
      let d = o.to - e.to, h = o.to - o.from;
      r = i.changeByRange((p) => {
        if (p.from == o.from && p.to == o.to)
          return { changes: a, range: l || p.map(a) };
        let O = p.to - d, m = O - c.length;
        if (p.to - p.from != h || t4.state.sliceDoc(m, O) != c || // Unfortunately, there's no way to make multiple
        // changes in the same node work without aborting
        // composition, so cursors in the composition range are
        // ignored.
        p.to >= u.from && p.from <= u.to)
          return { range: p };
        let x = i.changes({ from: m, to: O, insert: e.insert }), v = p.to - o.to;
        return {
          changes: x,
          range: l ? ne.range(Math.max(0, l.anchor + v), Math.max(0, l.head + v)) : p.map(x)
        };
      });
    } else
      r = {
        changes: a,
        selection: l && i.selection.replaceRange(l)
      };
  }
  let s = "input.type";
  return (t4.composing || t4.inputState.compositionPendingChange && t4.inputState.compositionEndedAt > Date.now() - 50) && (t4.inputState.compositionPendingChange = false, s += ".compose", t4.inputState.compositionFirstChange && (s += ".start", t4.inputState.compositionFirstChange = false)), i.update(r, { userEvent: s, scrollIntoView: true });
}
function BZ(t4, e, n, r) {
  let i = Math.min(t4.length, e.length), o = 0;
  for (; o < i && t4.charCodeAt(o) == e.charCodeAt(o); )
    o++;
  if (o == i && t4.length == e.length)
    return null;
  let s = t4.length, a = e.length;
  for (; s > 0 && a > 0 && t4.charCodeAt(s - 1) == e.charCodeAt(a - 1); )
    s--, a--;
  if (r == "end") {
    let l = Math.max(0, o - Math.min(s, a));
    n -= s + l - o;
  }
  if (s < o && t4.length < e.length) {
    let l = n <= o && n >= s ? o - n : 0;
    o -= l, a = o + (a - s), s = o;
  } else if (a < o) {
    let l = n <= o && n >= a ? o - n : 0;
    o -= l, s = o + (s - a), a = o;
  }
  return { from: o, toA: s, toB: a };
}
function _Z(t4) {
  let e = [];
  if (t4.root.activeElement != t4.contentDOM)
    return e;
  let { anchorNode: n, anchorOffset: r, focusNode: i, focusOffset: o } = t4.observer.selectionRange;
  return n && (e.push(new g1(n, r)), (i != n || o != r) && e.push(new g1(i, o))), e;
}
function MZ(t4, e) {
  if (t4.length == 0)
    return null;
  let n = t4[0].pos, r = t4.length == 2 ? t4[1].pos : n;
  return n > -1 && r > -1 ? ne.single(n + e, r + e) : null;
}
var NZ = {
  childList: true,
  characterData: true,
  subtree: true,
  attributes: true,
  characterDataOldValue: true
};
var jp = me.ie && me.ie_version <= 11;
var FZ = class {
  constructor(e) {
    this.view = e, this.active = false, this.selectionRange = new wF(), this.selectionChanged = false, this.delayedFlush = -1, this.resizeTimeout = -1, this.queue = [], this.delayedAndroidKey = null, this.flushingAndroidKey = -1, this.lastChange = 0, this.scrollTargets = [], this.intersection = null, this.resizeScroll = null, this.intersecting = false, this.gapIntersection = null, this.gaps = [], this.printQuery = null, this.parentCheck = -1, this.dom = e.contentDOM, this.observer = new MutationObserver((n) => {
      for (let r of n)
        this.queue.push(r);
      (me.ie && me.ie_version <= 11 || me.ios && e.composing) && n.some((r) => r.type == "childList" && r.removedNodes.length || r.type == "characterData" && r.oldValue.length > r.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), jp && (this.onCharData = (n) => {
      this.queue.push({
        target: n.target,
        type: "characterData",
        oldValue: n.prevValue
      }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this), this.onResize = this.onResize.bind(this), this.onPrint = this.onPrint.bind(this), this.onScroll = this.onScroll.bind(this), window.matchMedia && (this.printQuery = window.matchMedia("print")), typeof ResizeObserver == "function" && (this.resizeScroll = new ResizeObserver(() => {
      var n;
      ((n = this.view.docView) === null || n === void 0 ? void 0 : n.lastUpdate) < Date.now() - 75 && this.onResize();
    }), this.resizeScroll.observe(e.scrollDOM)), this.addWindowListeners(this.win = e.win), this.start(), typeof IntersectionObserver == "function" && (this.intersection = new IntersectionObserver((n) => {
      this.parentCheck < 0 && (this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3)), n.length > 0 && n[n.length - 1].intersectionRatio > 0 != this.intersecting && (this.intersecting = !this.intersecting, this.intersecting != this.view.inView && this.onScrollChanged(document.createEvent("Event")));
    }, { threshold: [0, 1e-3] }), this.intersection.observe(this.dom), this.gapIntersection = new IntersectionObserver((n) => {
      n.length > 0 && n[n.length - 1].intersectionRatio > 0 && this.onScrollChanged(document.createEvent("Event"));
    }, {})), this.listenForScroll(), this.readSelectionRange();
  }
  onScrollChanged(e) {
    this.view.inputState.runHandlers("scroll", e), this.intersecting && this.view.measure();
  }
  onScroll(e) {
    this.intersecting && this.flush(false), this.onScrollChanged(e);
  }
  onResize() {
    this.resizeTimeout < 0 && (this.resizeTimeout = setTimeout(() => {
      this.resizeTimeout = -1, this.view.requestMeasure();
    }, 50));
  }
  onPrint(e) {
    e.type == "change" && !e.matches || (this.view.viewState.printing = true, this.view.measure(), setTimeout(() => {
      this.view.viewState.printing = false, this.view.requestMeasure();
    }, 500));
  }
  updateGaps(e) {
    if (this.gapIntersection && (e.length != this.gaps.length || this.gaps.some((n, r) => n != e[r]))) {
      this.gapIntersection.disconnect();
      for (let n of e)
        this.gapIntersection.observe(n);
      this.gaps = e;
    }
  }
  onSelectionChange(e) {
    let n = this.selectionChanged;
    if (!this.readSelectionRange() || this.delayedAndroidKey)
      return;
    let { view: r } = this, i = this.selectionRange;
    if (r.state.facet(xh) ? r.root.activeElement != this.dom : !uf(r.dom, i))
      return;
    let o = i.anchorNode && r.docView.nearest(i.anchorNode);
    if (o && o.ignoreEvent(e)) {
      n || (this.selectionChanged = false);
      return;
    }
    (me.ie && me.ie_version <= 11 || me.android && me.chrome) && !r.state.selection.main.empty && // (Selection.isCollapsed isn't reliable on IE)
    i.focusNode && Wl(i.focusNode, i.focusOffset, i.anchorNode, i.anchorOffset) ? this.flushSoon() : this.flush(false);
  }
  readSelectionRange() {
    let { view: e } = this, n = ed(e.root);
    if (!n)
      return false;
    let r = me.safari && e.root.nodeType == 11 && vF(this.dom.ownerDocument) == this.dom && ZZ(this.view, n) || n;
    if (!r || this.selectionRange.eq(r))
      return false;
    let i = uf(this.dom, r);
    return i && !this.selectionChanged && e.inputState.lastFocusTime > Date.now() - 200 && e.inputState.lastTouchTime < Date.now() - 300 && kF(this.dom, r) ? (this.view.inputState.lastFocusTime = 0, e.docView.updateSelection(), false) : (this.selectionRange.setRange(r), i && (this.selectionChanged = true), true);
  }
  setSelectionRange(e, n) {
    this.selectionRange.set(e.node, e.offset, n.node, n.offset), this.selectionChanged = false;
  }
  clearSelectionRange() {
    this.selectionRange.set(null, 0, null, 0);
  }
  listenForScroll() {
    this.parentCheck = -1;
    let e = 0, n = null;
    for (let r = this.dom; r; )
      if (r.nodeType == 1)
        !n && e < this.scrollTargets.length && this.scrollTargets[e] == r ? e++ : n || (n = this.scrollTargets.slice(0, e)), n && n.push(r), r = r.assignedSlot || r.parentNode;
      else if (r.nodeType == 11)
        r = r.host;
      else
        break;
    if (e < this.scrollTargets.length && !n && (n = this.scrollTargets.slice(0, e)), n) {
      for (let r of this.scrollTargets)
        r.removeEventListener("scroll", this.onScroll);
      for (let r of this.scrollTargets = n)
        r.addEventListener("scroll", this.onScroll);
    }
  }
  ignore(e) {
    if (!this.active)
      return e();
    try {
      return this.stop(), e();
    } finally {
      this.start(), this.clear();
    }
  }
  start() {
    this.active || (this.observer.observe(this.dom, NZ), jp && this.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.active = true);
  }
  stop() {
    this.active && (this.active = false, this.observer.disconnect(), jp && this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData));
  }
  // Throw away any pending changes
  clear() {
    this.processRecords(), this.queue.length = 0, this.selectionChanged = false;
  }
  // Chrome Android, especially in combination with GBoard, not only
  // doesn't reliably fire regular key events, but also often
  // surrounds the effect of enter or backspace with a bunch of
  // composition events that, when interrupted, cause text duplication
  // or other kinds of corruption. This hack makes the editor back off
  // from handling DOM changes for a moment when such a key is
  // detected (via beforeinput or keydown), and then tries to flush
  // them or, if that has no effect, dispatches the given key.
  delayAndroidKey(e, n) {
    var r;
    if (!this.delayedAndroidKey) {
      let i = () => {
        let o = this.delayedAndroidKey;
        o && (this.clearDelayedAndroidKey(), this.view.inputState.lastKeyCode = o.keyCode, this.view.inputState.lastKeyTime = Date.now(), !this.flush() && o.force && la(this.dom, o.key, o.keyCode));
      };
      this.flushingAndroidKey = this.view.win.requestAnimationFrame(i);
    }
    (!this.delayedAndroidKey || e == "Enter") && (this.delayedAndroidKey = {
      key: e,
      keyCode: n,
      // Only run the key handler when no changes are detected if
      // this isn't coming right after another change, in which case
      // it is probably part of a weird chain of updates, and should
      // be ignored if it returns the DOM to its previous state.
      force: this.lastChange < Date.now() - 50 || !!(!((r = this.delayedAndroidKey) === null || r === void 0) && r.force)
    });
  }
  clearDelayedAndroidKey() {
    this.win.cancelAnimationFrame(this.flushingAndroidKey), this.delayedAndroidKey = null, this.flushingAndroidKey = -1;
  }
  flushSoon() {
    this.delayedFlush < 0 && (this.delayedFlush = this.view.win.requestAnimationFrame(() => {
      this.delayedFlush = -1, this.flush();
    }));
  }
  forceFlush() {
    this.delayedFlush >= 0 && (this.view.win.cancelAnimationFrame(this.delayedFlush), this.delayedFlush = -1), this.flush();
  }
  pendingRecords() {
    for (let e of this.observer.takeRecords())
      this.queue.push(e);
    return this.queue;
  }
  processRecords() {
    let e = this.pendingRecords();
    e.length && (this.queue = []);
    let n = -1, r = -1, i = false;
    for (let o of e) {
      let s = this.readMutation(o);
      s && (s.typeOver && (i = true), n == -1 ? { from: n, to: r } = s : (n = Math.min(s.from, n), r = Math.max(s.to, r)));
    }
    return { from: n, to: r, typeOver: i };
  }
  readChange() {
    let { from: e, to: n, typeOver: r } = this.processRecords(), i = this.selectionChanged && uf(this.dom, this.selectionRange);
    if (e < 0 && !i)
      return null;
    e > -1 && (this.lastChange = Date.now()), this.view.inputState.lastFocusTime = 0, this.selectionChanged = false;
    let o = new DZ(this.view, e, n, r);
    return this.view.docView.domChanged = { newSel: o.newSel ? o.newSel.main : null }, o;
  }
  // Apply pending changes, if any
  flush(e = true) {
    if (this.delayedFlush >= 0 || this.delayedAndroidKey)
      return false;
    e && this.readSelectionRange();
    let n = this.readChange();
    if (!n)
      return this.view.requestMeasure(), false;
    let r = this.view.state, i = VE(this.view, n);
    return this.view.state == r && this.view.update([]), i;
  }
  readMutation(e) {
    let n = this.view.docView.nearest(e.target);
    if (!n || n.ignoreMutation(e))
      return null;
    if (n.markDirty(e.type == "attributes"), e.type == "attributes" && (n.flags |= 4), e.type == "childList") {
      let r = m1(n, e.previousSibling || e.target.previousSibling, -1), i = m1(n, e.nextSibling || e.target.nextSibling, 1);
      return {
        from: r ? n.posAfter(r) : n.posAtStart,
        to: i ? n.posBefore(i) : n.posAtEnd,
        typeOver: false
      };
    } else
      return e.type == "characterData" ? { from: n.posAtStart, to: n.posAtEnd, typeOver: e.target.nodeValue == e.oldValue } : null;
  }
  setWindow(e) {
    e != this.win && (this.removeWindowListeners(this.win), this.win = e, this.addWindowListeners(this.win));
  }
  addWindowListeners(e) {
    e.addEventListener("resize", this.onResize), this.printQuery ? this.printQuery.addEventListener("change", this.onPrint) : e.addEventListener("beforeprint", this.onPrint), e.addEventListener("scroll", this.onScroll), e.document.addEventListener("selectionchange", this.onSelectionChange);
  }
  removeWindowListeners(e) {
    e.removeEventListener("scroll", this.onScroll), e.removeEventListener("resize", this.onResize), this.printQuery ? this.printQuery.removeEventListener("change", this.onPrint) : e.removeEventListener("beforeprint", this.onPrint), e.document.removeEventListener("selectionchange", this.onSelectionChange);
  }
  destroy() {
    var e, n, r;
    this.stop(), (e = this.intersection) === null || e === void 0 || e.disconnect(), (n = this.gapIntersection) === null || n === void 0 || n.disconnect(), (r = this.resizeScroll) === null || r === void 0 || r.disconnect();
    for (let i of this.scrollTargets)
      i.removeEventListener("scroll", this.onScroll);
    this.removeWindowListeners(this.win), clearTimeout(this.parentCheck), clearTimeout(this.resizeTimeout), this.win.cancelAnimationFrame(this.delayedFlush), this.win.cancelAnimationFrame(this.flushingAndroidKey);
  }
};
function m1(t4, e, n) {
  for (; e; ) {
    let r = It.get(e);
    if (r && r.parent == t4)
      return r;
    let i = e.parentNode;
    e = i != t4.dom ? i : n > 0 ? e.nextSibling : e.previousSibling;
  }
  return null;
}
function O1(t4, e) {
  let n = e.startContainer, r = e.startOffset, i = e.endContainer, o = e.endOffset, s = t4.docView.domAtPos(t4.state.selection.main.anchor);
  return Wl(s.node, s.offset, i, o) && ([n, r, i, o] = [i, o, n, r]), { anchorNode: n, anchorOffset: r, focusNode: i, focusOffset: o };
}
function ZZ(t4, e) {
  if (e.getComposedRanges) {
    let i = e.getComposedRanges(t4.root)[0];
    if (i)
      return O1(t4, i);
  }
  let n = null;
  function r(i) {
    i.preventDefault(), i.stopImmediatePropagation(), n = i.getTargetRanges()[0];
  }
  return t4.contentDOM.addEventListener("beforeinput", r, true), t4.dom.ownerDocument.execCommand("indent"), t4.contentDOM.removeEventListener("beforeinput", r, true), n ? O1(t4, n) : null;
}
var ue = class {
  /**
  The current editor state.
  */
  get state() {
    return this.viewState.state;
  }
  /**
  To be able to display large documents without consuming too much
  memory or overloading the browser, CodeMirror only draws the
  code that is visible (plus a margin around it) to the DOM. This
  property tells you the extent of the current drawn viewport, in
  document positions.
  */
  get viewport() {
    return this.viewState.viewport;
  }
  /**
  When there are, for example, large collapsed ranges in the
  viewport, its size can be a lot bigger than the actual visible
  content. Thus, if you are doing something like styling the
  content in the viewport, it is preferable to only do so for
  these ranges, which are the subset of the viewport that is
  actually drawn.
  */
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  /**
  Returns false when the editor is entirely scrolled out of view
  or otherwise hidden.
  */
  get inView() {
    return this.viewState.inView;
  }
  /**
  Indicates whether the user is currently composing text via
  [IME](https://en.wikipedia.org/wiki/Input_method), and at least
  one change has been made in the current composition.
  */
  get composing() {
    return this.inputState.composing > 0;
  }
  /**
  Indicates whether the user is currently in composing state. Note
  that on some platforms, like Android, this will be the case a
  lot, since just putting the cursor on a word starts a
  composition there.
  */
  get compositionStarted() {
    return this.inputState.composing >= 0;
  }
  /**
  The document or shadow root that the view lives in.
  */
  get root() {
    return this._root;
  }
  /**
  @internal
  */
  get win() {
    return this.dom.ownerDocument.defaultView || window;
  }
  /**
  Construct a new view. You'll want to either provide a `parent`
  option, or put `view.dom` into your document after creating a
  view, so that the user can see the editor.
  */
  constructor(e = {}) {
    this.plugins = [], this.pluginMap = /* @__PURE__ */ new Map(), this.editorAttrs = {}, this.contentAttrs = {}, this.bidiCache = [], this.destroyed = false, this.updateState = 2, this.measureScheduled = -1, this.measureRequests = [], this.contentDOM = document.createElement("div"), this.scrollDOM = document.createElement("div"), this.scrollDOM.tabIndex = -1, this.scrollDOM.className = "cm-scroller", this.scrollDOM.appendChild(this.contentDOM), this.announceDOM = document.createElement("div"), this.announceDOM.className = "cm-announced", this.announceDOM.setAttribute("aria-live", "polite"), this.dom = document.createElement("div"), this.dom.appendChild(this.announceDOM), this.dom.appendChild(this.scrollDOM), e.parent && e.parent.appendChild(this.dom);
    let { dispatch: n } = e;
    this.dispatchTransactions = e.dispatchTransactions || n && ((r) => r.forEach((i) => n(i, this))) || ((r) => this.update(r)), this.dispatch = this.dispatch.bind(this), this._root = e.root || CF(e.parent) || document, this.viewState = new h1(e.state || et.create(e)), e.scrollTo && e.scrollTo.is(ku) && (this.viewState.scrollTarget = e.scrollTo.value.clip(this.viewState.state)), this.plugins = this.state.facet(Pl).map((r) => new Ep(r));
    for (let r of this.plugins)
      r.update(this);
    this.observer = new FZ(this), this.inputState = new nZ(this), this.inputState.ensureHandlers(this.plugins), this.docView = new qb(this), this.mountStyles(), this.updateAttrs(), this.updateState = 0, this.requestMeasure();
  }
  dispatch(...e) {
    let n = e.length == 1 && e[0] instanceof tn ? e : e.length == 1 && Array.isArray(e[0]) ? e[0] : [this.state.update(...e)];
    this.dispatchTransactions(n, this);
  }
  /**
  Update the view for the given array of transactions. This will
  update the visible document and selection to match the state
  produced by the transactions, and notify view plugins of the
  change. You should usually call
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this
  as a primitive.
  */
  update(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
    let n = false, r = false, i, o = this.state;
    for (let d of e) {
      if (d.startState != o)
        throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      o = d.state;
    }
    if (this.destroyed) {
      this.viewState.state = o;
      return;
    }
    let s = this.hasFocus, a = 0, l = null;
    e.some((d) => d.annotation(BE)) ? (this.inputState.notifiedFocused = s, a = 1) : s != this.inputState.notifiedFocused && (this.inputState.notifiedFocused = s, l = _E(o, s), l || (a = 1));
    let c = this.observer.delayedAndroidKey, u = null;
    if (c ? (this.observer.clearDelayedAndroidKey(), u = this.observer.readChange(), (u && !this.state.doc.eq(o.doc) || !this.state.selection.eq(o.selection)) && (u = null)) : this.observer.clear(), o.facet(et.phrases) != this.state.facet(et.phrases))
      return this.setState(o);
    i = nd.create(this, o, e), i.flags |= a;
    let f = this.viewState.scrollTarget;
    try {
      this.updateState = 2;
      for (let d of e) {
        if (f && (f = f.map(d.changes)), d.scrollIntoView) {
          let { main: h } = d.state.selection;
          f = new ca(h.empty ? h : ne.cursor(h.head, h.head > h.anchor ? -1 : 1));
        }
        for (let h of d.effects)
          h.is(ku) && (f = h.value.clip(this.state));
      }
      this.viewState.update(i, f), this.bidiCache = rd.update(this.bidiCache, i.changes), i.empty || (this.updatePlugins(i), this.inputState.update(i)), n = this.docView.update(i), this.state.facet(El) != this.styleModules && this.mountStyles(), r = this.updateAttrs(), this.showAnnouncements(e), this.docView.updateSelection(n, e.some((d) => d.isUserEvent("select.pointer")));
    } finally {
      this.updateState = 0;
    }
    if (i.startState.facet($u) != i.state.facet($u) && (this.viewState.mustMeasureContent = true), (n || r || f || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) && this.requestMeasure(), n && this.docViewUpdate(), !i.empty)
      for (let d of this.state.facet(gm))
        try {
          d(i);
        } catch (h) {
          Gn(this.state, h, "update listener");
        }
    (l || u) && Promise.resolve().then(() => {
      l && this.state == l.startState && this.dispatch(l), u && !VE(this, u) && c.force && la(this.contentDOM, c.key, c.keyCode);
    });
  }
  /**
  Reset the view to the given state. (This will cause the entire
  document to be redrawn and all view plugins to be reinitialized,
  so you should probably only use it when the new state isn't
  derived from the old state. Otherwise, use
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)
  */
  setState(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
    if (this.destroyed) {
      this.viewState.state = e;
      return;
    }
    this.updateState = 2;
    let n = this.hasFocus;
    try {
      for (let r of this.plugins)
        r.destroy(this);
      this.viewState = new h1(e), this.plugins = e.facet(Pl).map((r) => new Ep(r)), this.pluginMap.clear();
      for (let r of this.plugins)
        r.update(this);
      this.docView.destroy(), this.docView = new qb(this), this.inputState.ensureHandlers(this.plugins), this.mountStyles(), this.updateAttrs(), this.bidiCache = [];
    } finally {
      this.updateState = 0;
    }
    n && this.focus(), this.requestMeasure();
  }
  updatePlugins(e) {
    let n = e.startState.facet(Pl), r = e.state.facet(Pl);
    if (n != r) {
      let i = [];
      for (let o of r) {
        let s = n.indexOf(o);
        if (s < 0)
          i.push(new Ep(o));
        else {
          let a = this.plugins[s];
          a.mustUpdate = e, i.push(a);
        }
      }
      for (let o of this.plugins)
        o.mustUpdate != e && o.destroy(this);
      this.plugins = i, this.pluginMap.clear();
    } else
      for (let i of this.plugins)
        i.mustUpdate = e;
    for (let i = 0; i < this.plugins.length; i++)
      this.plugins[i].update(this);
    n != r && this.inputState.ensureHandlers(this.plugins);
  }
  docViewUpdate() {
    for (let e of this.plugins) {
      let n = e.value;
      if (n && n.docViewUpdate)
        try {
          n.docViewUpdate(this);
        } catch (r) {
          Gn(this.state, r, "doc view update listener");
        }
    }
  }
  /**
  @internal
  */
  measure(e = true) {
    if (this.destroyed)
      return;
    if (this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.observer.delayedAndroidKey) {
      this.measureScheduled = -1, this.requestMeasure();
      return;
    }
    this.measureScheduled = 0, e && this.observer.forceFlush();
    let n = null, r = this.scrollDOM, i = r.scrollTop * this.scaleY, { scrollAnchorPos: o, scrollAnchorHeight: s } = this.viewState;
    Math.abs(i - this.viewState.scrollTop) > 1 && (s = -1), this.viewState.scrollAnchorHeight = -1;
    try {
      for (let a = 0; ; a++) {
        if (s < 0)
          if (H2(r))
            o = -1, s = this.viewState.heightMap.height;
          else {
            let h = this.viewState.scrollAnchorAt(i);
            o = h.from, s = h.top;
          }
        this.updateState = 1;
        let l = this.viewState.measure(this);
        if (!l && !this.measureRequests.length && this.viewState.scrollTarget == null)
          break;
        if (a > 5) {
          console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
          break;
        }
        let c = [];
        l & 4 || ([this.measureRequests, c] = [c, this.measureRequests]);
        let u = c.map((h) => {
          try {
            return h.read(this);
          } catch (p) {
            return Gn(this.state, p), x1;
          }
        }), f = nd.create(this, this.state, []), d = false;
        f.flags |= l, n ? n.flags |= l : n = f, this.updateState = 2, f.empty || (this.updatePlugins(f), this.inputState.update(f), this.updateAttrs(), d = this.docView.update(f), d && this.docViewUpdate());
        for (let h = 0; h < c.length; h++)
          if (u[h] != x1)
            try {
              let p = c[h];
              p.write && p.write(u[h], this);
            } catch (p) {
              Gn(this.state, p);
            }
        if (d && this.docView.updateSelection(true), !f.viewportChanged && this.measureRequests.length == 0) {
          if (this.viewState.editorHeight)
            if (this.viewState.scrollTarget) {
              this.docView.scrollIntoView(this.viewState.scrollTarget), this.viewState.scrollTarget = null, s = -1;
              continue;
            } else {
              let p = (o < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(o).top) - s;
              if (p > 1 || p < -1) {
                i = i + p, r.scrollTop = i / this.scaleY, s = -1;
                continue;
              }
            }
          break;
        }
      }
    } finally {
      this.updateState = 0, this.measureScheduled = -1;
    }
    if (n && !n.empty)
      for (let a of this.state.facet(gm))
        a(n);
  }
  /**
  Get the CSS classes for the currently active editor themes.
  */
  get themeClasses() {
    return ym + " " + (this.state.facet(vm) ? ZE : FE) + " " + this.state.facet($u);
  }
  updateAttrs() {
    let e = v1(this, wE, {
      class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
    }), n = {
      spellcheck: "false",
      autocorrect: "off",
      autocapitalize: "off",
      translate: "no",
      contenteditable: this.state.facet(xh) ? "true" : "false",
      class: "cm-content",
      style: `${me.tabSize}: ${this.state.tabSize}`,
      role: "textbox",
      "aria-multiline": "true"
    };
    this.state.readOnly && (n["aria-readonly"] = "true"), v1(this, Cx, n);
    let r = this.observer.ignore(() => {
      let i = um(this.contentDOM, this.contentAttrs, n), o = um(this.dom, this.editorAttrs, e);
      return i || o;
    });
    return this.editorAttrs = e, this.contentAttrs = n, r;
  }
  showAnnouncements(e) {
    let n = true;
    for (let r of e)
      for (let i of r.effects)
        if (i.is(ue.announce)) {
          n && (this.announceDOM.textContent = ""), n = false;
          let o = this.announceDOM.appendChild(document.createElement("div"));
          o.textContent = i.value;
        }
  }
  mountStyles() {
    this.styleModules = this.state.facet(El);
    let e = this.state.facet(ue.cspNonce);
    Io.mount(this.root, this.styleModules.concat($Z).reverse(), e ? { nonce: e } : void 0);
  }
  readMeasured() {
    if (this.updateState == 2)
      throw new Error("Reading the editor layout isn't allowed during an update");
    this.updateState == 0 && this.measureScheduled > -1 && this.measure(false);
  }
  /**
  Schedule a layout measurement, optionally providing callbacks to
  do custom DOM measuring followed by a DOM write phase. Using
  this is preferable reading DOM layout directly from, for
  example, an event handler, because it'll make sure measuring and
  drawing done by other components is synchronized, avoiding
  unnecessary DOM layout computations.
  */
  requestMeasure(e) {
    if (this.measureScheduled < 0 && (this.measureScheduled = this.win.requestAnimationFrame(() => this.measure())), e) {
      if (this.measureRequests.indexOf(e) > -1)
        return;
      if (e.key != null) {
        for (let n = 0; n < this.measureRequests.length; n++)
          if (this.measureRequests[n].key === e.key) {
            this.measureRequests[n] = e;
            return;
          }
      }
      this.measureRequests.push(e);
    }
  }
  /**
  Get the value of a specific plugin, if present. Note that
  plugins that crash can be dropped from a view, so even when you
  know you registered a given plugin, it is recommended to check
  the return value of this method.
  */
  plugin(e) {
    let n = this.pluginMap.get(e);
    return (n === void 0 || n && n.spec != e) && this.pluginMap.set(e, n = this.plugins.find((r) => r.spec == e) || null), n && n.update(this).value;
  }
  /**
  The top position of the document, in screen coordinates. This
  may be negative when the editor is scrolled down. Points
  directly to the top of the first line, not above the padding.
  */
  get documentTop() {
    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
  }
  /**
  Reports the padding above and below the document.
  */
  get documentPadding() {
    return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
  }
  /**
  If the editor is transformed with CSS, this provides the scale
  along the X axis. Otherwise, it will just be 1. Note that
  transforms other than translation and scaling are not supported.
  */
  get scaleX() {
    return this.viewState.scaleX;
  }
  /**
  Provide the CSS transformed scale along the Y axis.
  */
  get scaleY() {
    return this.viewState.scaleY;
  }
  /**
  Find the text line or block widget at the given vertical
  position (which is interpreted as relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).
  */
  elementAtHeight(e) {
    return this.readMeasured(), this.viewState.elementAtHeight(e);
  }
  /**
  Find the line block (see
  [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) at the given
  height, again interpreted relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).
  */
  lineBlockAtHeight(e) {
    return this.readMeasured(), this.viewState.lineBlockAtHeight(e);
  }
  /**
  Get the extent and vertical position of all [line
  blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions
  are relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);
  */
  get viewportLineBlocks() {
    return this.viewState.viewportLines;
  }
  /**
  Find the line block around the given document position. A line
  block is a range delimited on both sides by either a
  non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line breaks, or the
  start/end of the document. It will usually just hold a line of
  text, but may be broken into multiple textblocks by block
  widgets.
  */
  lineBlockAt(e) {
    return this.viewState.lineBlockAt(e);
  }
  /**
  The editor's total content height.
  */
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  /**
  Move a cursor position by [grapheme
  cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether
  the motion is away from the line start, or towards it. In
  bidirectional text, the line is traversed in visual order, using
  the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
  When the start position was the last one on the line, the
  returned position will be across the line break. If there is no
  further line, the original position is returned.
  
  By default, this method moves over a single cluster. The
  optional `by` argument can be used to move across more. It will
  be called with the first cluster as argument, and should return
  a predicate that determines, for each subsequent cluster,
  whether it should also be moved over.
  */
  moveByChar(e, n, r) {
    return Ip(this, e, t1(this, e, n, r));
  }
  /**
  Move a cursor position across the next group of either
  [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter
  non-whitespace characters.
  */
  moveByGroup(e, n) {
    return Ip(this, e, t1(this, e, n, (r) => eZ(this, e.head, r)));
  }
  /**
  Get the cursor position visually at the start or end of a line.
  Note that this may differ from the _logical_ position at its
  start or end (which is simply at `line.from`/`line.to`) if text
  at the start or end goes against the line's base text direction.
  */
  visualLineSide(e, n) {
    let r = this.bidiSpans(e), i = this.textDirectionAt(e.from), o = r[n ? r.length - 1 : 0];
    return ne.cursor(o.side(n, i) + e.from, o.forward(!n, i) ? 1 : -1);
  }
  /**
  Move to the next line boundary in the given direction. If
  `includeWrap` is true, line wrapping is on, and there is a
  further wrap point on the current line, the wrap point will be
  returned. Otherwise this function will return the start or end
  of the line.
  */
  moveToLineBoundary(e, n, r = true) {
    return KF(this, e, n, r);
  }
  /**
  Move a cursor position vertically. When `distance` isn't given,
  it defaults to moving to the next line (including wrapped
  lines). Otherwise, `distance` should provide a positive distance
  in pixels.
  
  When `start` has a
  [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical
  motion will use that as a target horizontal position. Otherwise,
  the cursor's own horizontal position is used. The returned
  cursor will have its goal column set to whichever column was
  used.
  */
  moveVertically(e, n, r) {
    return Ip(this, e, tZ(this, e, n, r));
  }
  /**
  Find the DOM parent node and offset (child offset if `node` is
  an element, character offset when it is a text node) at the
  given document position.
  
  Note that for positions that aren't currently in
  `visibleRanges`, the resulting DOM position isn't necessarily
  meaningful (it may just point before or after a placeholder
  element).
  */
  domAtPos(e) {
    return this.docView.domAtPos(e);
  }
  /**
  Find the document position at the given DOM node. Can be useful
  for associating positions with DOM events. Will raise an error
  when `node` isn't part of the editor content.
  */
  posAtDOM(e, n = 0) {
    return this.docView.posFromDOM(e, n);
  }
  posAtCoords(e, n = true) {
    return this.readMeasured(), TE(this, e, n);
  }
  /**
  Get the screen coordinates at the given document position.
  `side` determines whether the coordinates are based on the
  element before (-1) or after (1) the position (if no element is
  available on the given side, the method will transparently use
  another strategy to get reasonable coordinates).
  */
  coordsAtPos(e, n = 1) {
    this.readMeasured();
    let r = this.docView.coordsAt(e, n);
    if (!r || r.left == r.right)
      return r;
    let i = this.state.doc.lineAt(e), o = this.bidiSpans(i), s = o[vo.find(o, e - i.from, -1, n)];
    return mh(r, s.dir == _t.LTR == n > 0);
  }
  /**
  Return the rectangle around a given character. If `pos` does not
  point in front of a character that is in the viewport and
  rendered (i.e. not replaced, not a line break), this will return
  null. For space characters that are a line wrap point, this will
  return the position before the line break.
  */
  coordsForChar(e) {
    return this.readMeasured(), this.docView.coordsForChar(e);
  }
  /**
  The default width of a character in the editor. May not
  accurately reflect the width of all characters (given variable
  width fonts or styling of invididual ranges).
  */
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  /**
  The default height of a line in the editor. May not be accurate
  for all lines.
  */
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  /**
  The text direction
  ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)
  CSS property) of the editor's content element.
  */
  get textDirection() {
    return this.viewState.defaultTextDirection;
  }
  /**
  Find the text direction of the block at the given position, as
  assigned by CSS. If
  [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)
  isn't enabled, or the given position is outside of the viewport,
  this will always return the same as
  [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that
  this may trigger a DOM layout.
  */
  textDirectionAt(e) {
    return !this.state.facet(yE) || e < this.viewport.from || e > this.viewport.to ? this.textDirection : (this.readMeasured(), this.docView.textDirectionAt(e));
  }
  /**
  Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)
  (as determined by the
  [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)
  CSS property of its content element).
  */
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  /**
  Returns the bidirectional text structure of the given line
  (which should be in the current document) as an array of span
  objects. The order of these spans matches the [text
  direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)—if that is
  left-to-right, the leftmost spans come first, otherwise the
  rightmost spans come first.
  */
  bidiSpans(e) {
    if (e.length > WZ)
      return dE(e.length);
    let n = this.textDirectionAt(e.from), r;
    for (let o of this.bidiCache)
      if (o.from == e.from && o.dir == n && (o.fresh || fE(o.isolates, r = Yb(this, e))))
        return o.order;
    r || (r = Yb(this, e));
    let i = _F(e.text, n, r);
    return this.bidiCache.push(new rd(e.from, e.to, n, r, true, i)), i;
  }
  /**
  Check whether the editor has focus.
  */
  get hasFocus() {
    var e;
    return (this.dom.ownerDocument.hasFocus() || me.safari && ((e = this.inputState) === null || e === void 0 ? void 0 : e.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
  }
  /**
  Put focus on the editor.
  */
  focus() {
    this.observer.ignore(() => {
      q2(this.contentDOM), this.docView.updateSelection();
    });
  }
  /**
  Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only
  necessary when moving the editor's existing DOM to a new window or shadow root.
  */
  setRoot(e) {
    this._root != e && (this._root = e, this.observer.setWindow((e.nodeType == 9 ? e : e.ownerDocument).defaultView || window), this.mountStyles());
  }
  /**
  Clean up this editor view, removing its element from the
  document, unregistering event handlers, and notifying
  plugins. The view instance can no longer be used after
  calling this.
  */
  destroy() {
    for (let e of this.plugins)
      e.destroy(this);
    this.plugins = [], this.inputState.destroy(), this.docView.destroy(), this.dom.remove(), this.observer.destroy(), this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.destroyed = true;
  }
  /**
  Returns an effect that can be
  [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to
  cause it to scroll the given position or range into view.
  */
  static scrollIntoView(e, n = {}) {
    return ku.of(new ca(typeof e == "number" ? ne.cursor(e) : e, n.y, n.x, n.yMargin, n.xMargin));
  }
  /**
  Return an effect that resets the editor to its current (at the
  time this method was called) scroll position. Note that this
  only affects the editor's own scrollable element, not parents.
  See also
  [`EditorViewConfig.scrollTo`](https://codemirror.net/6/docs/ref/#view.EditorViewConfig.scrollTo).
  
  The effect should be used with a document identical to the one
  it was created for. Failing to do so is not an error, but may
  not scroll to the expected position. You can
  [map](https://codemirror.net/6/docs/ref/#state.StateEffect.map) the effect to account for changes.
  */
  scrollSnapshot() {
    let { scrollTop: e, scrollLeft: n } = this.scrollDOM, r = this.viewState.scrollAnchorAt(e);
    return ku.of(new ca(ne.cursor(r.from), "start", "start", r.top - e, n, true));
  }
  /**
  Returns an extension that can be used to add DOM event handlers.
  The value should be an object mapping event names to handler
  functions. For any given event, such functions are ordered by
  extension precedence, and the first handler to return true will
  be assumed to have handled that event, and no other handlers or
  built-in behavior will be activated for it. These are registered
  on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except
  for `scroll` handlers, which will be called any time the
  editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of
  its parent nodes is scrolled.
  */
  static domEventHandlers(e) {
    return Wt.define(() => ({}), { eventHandlers: e });
  }
  /**
  Create an extension that registers DOM event observers. Contrary
  to event [handlers](https://codemirror.net/6/docs/ref/#view.EditorView^domEventHandlers),
  observers can't be prevented from running by a higher-precedence
  handler returning true. They also don't prevent other handlers
  and observers from running when they return true, and should not
  call `preventDefault`.
  */
  static domEventObservers(e) {
    return Wt.define(() => ({}), { eventObservers: e });
  }
  /**
  Create a theme extension. The first argument can be a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)
  style spec providing the styles for the theme. These will be
  prefixed with a generated class for the style.
  
  Because the selectors will be prefixed with a scope class, rule
  that directly match the editor's [wrapper
  element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)—to which the scope class will be
  added—need to be explicitly differentiated by adding an `&` to
  the selector for that element—for example
  `&.cm-focused`.
  
  When `dark` is set to true, the theme will be marked as dark,
  which will cause the `&dark` rules from [base
  themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to
  `&light` when a light theme is active).
  */
  static theme(e, n) {
    let r = Io.newName(), i = [$u.of(r), El.of(bm(`.${r}`, e))];
    return n && n.dark && i.push(vm.of(true)), i;
  }
  /**
  Create an extension that adds styles to the base theme. Like
  with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the
  place of the editor wrapper element when directly targeting
  that. You can also use `&dark` or `&light` instead to only
  target editors with a dark or light theme.
  */
  static baseTheme(e) {
    return ji.lowest(El.of(bm("." + ym, e, WE)));
  }
  /**
  Retrieve an editor view instance from the view's DOM
  representation.
  */
  static findFromDOM(e) {
    var n;
    let r = e.querySelector(".cm-content"), i = r && It.get(r) || It.get(e);
    return ((n = i == null ? void 0 : i.rootView) === null || n === void 0 ? void 0 : n.view) || null;
  }
};
ue.styleModule = El;
ue.inputHandler = xE;
ue.scrollHandler = SE;
ue.focusChangeEffect = vE;
ue.perLineTextDirection = yE;
ue.exceptionSink = OE;
ue.updateListener = gm;
ue.editable = xh;
ue.mouseSelectionStyle = mE;
ue.dragMovesSelection = gE;
ue.clickAddsSelectionRange = pE;
ue.decorations = ic;
ue.outerDecorations = CE;
ue.atomicRanges = kx;
ue.bidiIsolatedRanges = kE;
ue.scrollMargins = AE;
ue.darkTheme = vm;
ue.cspNonce = /* @__PURE__ */ ge.define({ combine: (t4) => t4.length ? t4[0] : "" });
ue.contentAttributes = Cx;
ue.editorAttributes = wE;
ue.lineWrapping = /* @__PURE__ */ ue.contentAttributes.of({ class: "cm-lineWrapping" });
ue.announce = /* @__PURE__ */ Me.define();
var WZ = 4096;
var x1 = {};
var rd = class {
  constructor(e, n, r, i, o, s) {
    this.from = e, this.to = n, this.dir = r, this.isolates = i, this.fresh = o, this.order = s;
  }
  static update(e, n) {
    if (n.empty && !e.some((o) => o.fresh))
      return e;
    let r = [], i = e.length ? e[e.length - 1].dir : _t.LTR;
    for (let o = Math.max(0, e.length - 10); o < e.length; o++) {
      let s = e[o];
      s.dir == i && !n.touchesRange(s.from, s.to) && r.push(new rd(n.mapPos(s.from, 1), n.mapPos(s.to, -1), s.dir, s.isolates, false, s.order));
    }
    return r;
  }
};
function v1(t4, e, n) {
  for (let r = t4.state.facet(e), i = r.length - 1; i >= 0; i--) {
    let o = r[i], s = typeof o == "function" ? o(t4) : o;
    s && cm(s, n);
  }
  return n;
}
var VZ = me.mac ? "mac" : me.windows ? "win" : me.linux ? "linux" : "key";
function zZ(t4, e) {
  const n = t4.split(/-(?!$)/);
  let r = n[n.length - 1];
  r == "Space" && (r = " ");
  let i, o, s, a;
  for (let l = 0; l < n.length - 1; ++l) {
    const c = n[l];
    if (/^(cmd|meta|m)$/i.test(c))
      a = true;
    else if (/^a(lt)?$/i.test(c))
      i = true;
    else if (/^(c|ctrl|control)$/i.test(c))
      o = true;
    else if (/^s(hift)?$/i.test(c))
      s = true;
    else if (/^mod$/i.test(c))
      e == "mac" ? a = true : o = true;
    else
      throw new Error("Unrecognized modifier name: " + c);
  }
  return i && (r = "Alt-" + r), o && (r = "Ctrl-" + r), a && (r = "Meta-" + r), s && (r = "Shift-" + r), r;
}
function ju(t4, e, n) {
  return e.altKey && (t4 = "Alt-" + t4), e.ctrlKey && (t4 = "Ctrl-" + t4), e.metaKey && (t4 = "Meta-" + t4), n !== false && e.shiftKey && (t4 = "Shift-" + t4), t4;
}
var LZ = /* @__PURE__ */ ji.default(/* @__PURE__ */ ue.domEventHandlers({
  keydown(t4, e) {
    return LE(zE(e.state), t4, e, "editor");
  }
}));
var qa = /* @__PURE__ */ ge.define({ enables: LZ });
var y1 = /* @__PURE__ */ new WeakMap();
function zE(t4) {
  let e = t4.facet(qa), n = y1.get(e);
  return n || y1.set(e, n = YZ(e.reduce((r, i) => r.concat(i), []))), n;
}
function XZ(t4, e, n) {
  return LE(zE(t4.state), e, t4, n);
}
var go = null;
var GZ = 4e3;
function YZ(t4, e = VZ) {
  let n = /* @__PURE__ */ Object.create(null), r = /* @__PURE__ */ Object.create(null), i = (s, a) => {
    let l = r[s];
    if (l == null)
      r[s] = a;
    else if (l != a)
      throw new Error("Key binding " + s + " is used both as a regular binding and as a multi-stroke prefix");
  }, o = (s, a, l, c, u) => {
    var f, d;
    let h = n[s] || (n[s] = /* @__PURE__ */ Object.create(null)), p = a.split(/ (?!$)/).map((x) => zZ(x, e));
    for (let x = 1; x < p.length; x++) {
      let v = p.slice(0, x).join(" ");
      i(v, true), h[v] || (h[v] = {
        preventDefault: true,
        stopPropagation: false,
        run: [(y) => {
          let S = go = { view: y, prefix: v, scope: s };
          return setTimeout(() => {
            go == S && (go = null);
          }, GZ), true;
        }]
      });
    }
    let O = p.join(" ");
    i(O, false);
    let m = h[O] || (h[O] = {
      preventDefault: false,
      stopPropagation: false,
      run: ((d = (f = h._any) === null || f === void 0 ? void 0 : f.run) === null || d === void 0 ? void 0 : d.slice()) || []
    });
    l && m.run.push(l), c && (m.preventDefault = true), u && (m.stopPropagation = true);
  };
  for (let s of t4) {
    let a = s.scope ? s.scope.split(" ") : ["editor"];
    if (s.any)
      for (let c of a) {
        let u = n[c] || (n[c] = /* @__PURE__ */ Object.create(null));
        u._any || (u._any = { preventDefault: false, stopPropagation: false, run: [] });
        for (let f in u)
          u[f].run.push(s.any);
      }
    let l = s[e] || s.key;
    if (l)
      for (let c of a)
        o(c, l, s.run, s.preventDefault, s.stopPropagation), s.shift && o(c, "Shift-" + l, s.shift, s.preventDefault, s.stopPropagation);
  }
  return n;
}
function LE(t4, e, n, r) {
  let i = xF(e), o = Pn(i, 0), s = jr(o) == i.length && i != " ", a = "", l = false, c = false, u = false;
  go && go.view == n && go.scope == r && (a = go.prefix + " ", $E.indexOf(e.keyCode) < 0 && (c = true, go = null));
  let f = /* @__PURE__ */ new Set(), d = (m) => {
    if (m) {
      for (let x of m.run)
        if (!f.has(x) && (f.add(x), x(n, e)))
          return m.stopPropagation && (u = true), true;
      m.preventDefault && (m.stopPropagation && (u = true), c = true);
    }
    return false;
  }, h = t4[r], p, O;
  return h && (d(h[a + ju(i, e, !s)]) ? l = true : s && (e.altKey || e.metaKey || e.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
  !(me.windows && e.ctrlKey && e.altKey) && (p = $o[e.keyCode]) && p != i ? (d(h[a + ju(p, e, true)]) || e.shiftKey && (O = rc[e.keyCode]) != i && O != p && d(h[a + ju(O, e, false)])) && (l = true) : s && e.shiftKey && d(h[a + ju(i, e, true)]) && (l = true), !l && d(h._any) && (l = true)), c && (l = true), l && u && e.stopPropagation(), l;
}
var Qc = class {
  /**
  Create a marker with the given class and dimensions. If `width`
  is null, the DOM element will get no width style.
  */
  constructor(e, n, r, i, o) {
    this.className = e, this.left = n, this.top = r, this.width = i, this.height = o;
  }
  draw() {
    let e = document.createElement("div");
    return e.className = this.className, this.adjust(e), e;
  }
  update(e, n) {
    return n.className != this.className ? false : (this.adjust(e), true);
  }
  adjust(e) {
    e.style.left = this.left + "px", e.style.top = this.top + "px", this.width != null && (e.style.width = this.width + "px"), e.style.height = this.height + "px";
  }
  eq(e) {
    return this.left == e.left && this.top == e.top && this.width == e.width && this.height == e.height && this.className == e.className;
  }
  /**
  Create a set of rectangles for the given selection range,
  assigning them theclass`className`. Will create a single
  rectangle for empty ranges, and a set of selection-style
  rectangles covering the range's content (in a bidi-aware
  way) for non-empty ones.
  */
  static forRange(e, n, r) {
    if (r.empty) {
      let i = e.coordsAtPos(r.head, r.assoc || 1);
      if (!i)
        return [];
      let o = XE(e);
      return [new Qc(n, i.left - o.left, i.top - o.top, null, i.bottom - i.top)];
    } else
      return qZ(e, n, r);
  }
};
function XE(t4) {
  let e = t4.scrollDOM.getBoundingClientRect();
  return { left: (t4.textDirection == _t.LTR ? e.left : e.right - t4.scrollDOM.clientWidth * t4.scaleX) - t4.scrollDOM.scrollLeft * t4.scaleX, top: e.top - t4.scrollDOM.scrollTop * t4.scaleY };
}
function b1(t4, e, n) {
  let r = ne.cursor(e);
  return {
    from: Math.max(n.from, t4.moveToLineBoundary(r, false, true).from),
    to: Math.min(n.to, t4.moveToLineBoundary(r, true, true).from),
    type: Yn.Text
  };
}
function qZ(t4, e, n) {
  if (n.to <= t4.viewport.from || n.from >= t4.viewport.to)
    return [];
  let r = Math.max(n.from, t4.viewport.from), i = Math.min(n.to, t4.viewport.to), o = t4.textDirection == _t.LTR, s = t4.contentDOM, a = s.getBoundingClientRect(), l = XE(t4), c = s.querySelector(".cm-line"), u = c && window.getComputedStyle(c), f = a.left + (u ? parseInt(u.paddingLeft) + Math.min(0, parseInt(u.textIndent)) : 0), d = a.right - (u ? parseInt(u.paddingRight) : 0), h = Om(t4, r), p = Om(t4, i), O = h.type == Yn.Text ? h : null, m = p.type == Yn.Text ? p : null;
  if (O && (t4.lineWrapping || h.widgetLineBreaks) && (O = b1(t4, r, O)), m && (t4.lineWrapping || p.widgetLineBreaks) && (m = b1(t4, i, m)), O && m && O.from == m.from)
    return v(y(n.from, n.to, O));
  {
    let b = O ? y(n.from, null, O) : S(h, false), w = m ? y(null, n.to, m) : S(p, true), C = [];
    return (O || h).to < (m || p).from - (O && m ? 1 : 0) || h.widgetLineBreaks > 1 && b.bottom + t4.defaultLineHeight / 2 < w.top ? C.push(x(f, b.bottom, d, w.top)) : b.bottom < w.top && t4.elementAtHeight((b.bottom + w.top) / 2).type == Yn.Text && (b.bottom = w.top = (b.bottom + w.top) / 2), v(b).concat(C).concat(v(w));
  }
  function x(b, w, C, k) {
    return new Qc(
      e,
      b - l.left,
      w - l.top - 0.01,
      C - b,
      k - w + 0.01
      /* C.Epsilon */
    );
  }
  function v({ top: b, bottom: w, horizontal: C }) {
    let k = [];
    for (let T = 0; T < C.length; T += 2)
      k.push(x(C[T], b, C[T + 1], w));
    return k;
  }
  function y(b, w, C) {
    let k = 1e9, T = -1e9, A = [];
    function E(B, D, N, z, Z) {
      let J = t4.coordsAtPos(B, B == C.to ? -2 : 2), L = t4.coordsAtPos(N, N == C.from ? 2 : -2);
      !J || !L || (k = Math.min(J.top, L.top, k), T = Math.max(J.bottom, L.bottom, T), Z == _t.LTR ? A.push(o && D ? f : J.left, o && z ? d : L.right) : A.push(!o && z ? f : L.left, !o && D ? d : J.right));
    }
    let $ = b ?? C.from, j = w ?? C.to;
    for (let B of t4.visibleRanges)
      if (B.to > $ && B.from < j)
        for (let D = Math.max(B.from, $), N = Math.min(B.to, j); ; ) {
          let z = t4.state.doc.lineAt(D);
          for (let Z of t4.bidiSpans(z)) {
            let J = Z.from + z.from, L = Z.to + z.from;
            if (J >= N)
              break;
            L > D && E(Math.max(J, D), b == null && J <= $, Math.min(L, N), w == null && L >= j, Z.dir);
          }
          if (D = z.to + 1, D >= N)
            break;
        }
    return A.length == 0 && E($, b == null, j, w == null, t4.textDirection), { top: k, bottom: T, horizontal: A };
  }
  function S(b, w) {
    let C = a.top + (w ? b.top : b.bottom);
    return { top: C, bottom: C, horizontal: [] };
  }
}
function UZ(t4, e) {
  return t4.constructor == e.constructor && t4.eq(e);
}
var HZ = class {
  constructor(e, n) {
    this.view = e, this.layer = n, this.drawn = [], this.scaleX = 1, this.scaleY = 1, this.measureReq = { read: this.measure.bind(this), write: this.draw.bind(this) }, this.dom = e.scrollDOM.appendChild(document.createElement("div")), this.dom.classList.add("cm-layer"), n.above && this.dom.classList.add("cm-layer-above"), n.class && this.dom.classList.add(n.class), this.scale(), this.dom.setAttribute("aria-hidden", "true"), this.setOrder(e.state), e.requestMeasure(this.measureReq), n.mount && n.mount(this.dom, e);
  }
  update(e) {
    e.startState.facet(hf) != e.state.facet(hf) && this.setOrder(e.state), (this.layer.update(e, this.dom) || e.geometryChanged) && (this.scale(), e.view.requestMeasure(this.measureReq));
  }
  docViewUpdate(e) {
    this.layer.updateOnDocViewUpdate !== false && e.requestMeasure(this.measureReq);
  }
  setOrder(e) {
    let n = 0, r = e.facet(hf);
    for (; n < r.length && r[n] != this.layer; )
      n++;
    this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - n);
  }
  measure() {
    return this.layer.markers(this.view);
  }
  scale() {
    let { scaleX: e, scaleY: n } = this.view;
    (e != this.scaleX || n != this.scaleY) && (this.scaleX = e, this.scaleY = n, this.dom.style.transform = `scale(${1 / e}, ${1 / n})`);
  }
  draw(e) {
    if (e.length != this.drawn.length || e.some((n, r) => !UZ(n, this.drawn[r]))) {
      let n = this.dom.firstChild, r = 0;
      for (let i of e)
        i.update && n && i.constructor && this.drawn[r].constructor && i.update(n, this.drawn[r]) ? (n = n.nextSibling, r++) : this.dom.insertBefore(i.draw(), n);
      for (; n; ) {
        let i = n.nextSibling;
        n.remove(), n = i;
      }
      this.drawn = e;
    }
  }
  destroy() {
    this.layer.destroy && this.layer.destroy(this.dom, this.view), this.dom.remove();
  }
};
var hf = /* @__PURE__ */ ge.define();
function GE(t4) {
  return [
    Wt.define((e) => new HZ(e, t4)),
    hf.of(t4)
  ];
}
var YE = !me.ios;
var oc = /* @__PURE__ */ ge.define({
  combine(t4) {
    return Di(t4, {
      cursorBlinkRate: 1200,
      drawRangeCursor: true
    }, {
      cursorBlinkRate: (e, n) => Math.min(e, n),
      drawRangeCursor: (e, n) => e || n
    });
  }
});
function JZ(t4 = {}) {
  return [
    oc.of(t4),
    KZ,
    e6,
    t6,
    bE.of(true)
  ];
}
function qE(t4) {
  return t4.startState.facet(oc) != t4.state.facet(oc);
}
var KZ = /* @__PURE__ */ GE({
  above: true,
  markers(t4) {
    let { state: e } = t4, n = e.facet(oc), r = [];
    for (let i of e.selection.ranges) {
      let o = i == e.selection.main;
      if (i.empty ? !o || YE : n.drawRangeCursor) {
        let s = o ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary", a = i.empty ? i : ne.cursor(i.head, i.head > i.anchor ? -1 : 1);
        for (let l of Qc.forRange(t4, s, a))
          r.push(l);
      }
    }
    return r;
  },
  update(t4, e) {
    t4.transactions.some((r) => r.selection) && (e.style.animationName = e.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink");
    let n = qE(t4);
    return n && S1(t4.state, e), t4.docChanged || t4.selectionSet || n;
  },
  mount(t4, e) {
    S1(e.state, t4);
  },
  class: "cm-cursorLayer"
});
function S1(t4, e) {
  e.style.animationDuration = t4.facet(oc).cursorBlinkRate + "ms";
}
var e6 = /* @__PURE__ */ GE({
  above: false,
  markers(t4) {
    return t4.state.selection.ranges.map((e) => e.empty ? [] : Qc.forRange(t4, "cm-selectionBackground", e)).reduce((e, n) => e.concat(n));
  },
  update(t4, e) {
    return t4.docChanged || t4.selectionSet || t4.viewportChanged || qE(t4);
  },
  class: "cm-selectionLayer"
});
var Sm = {
  ".cm-line": {
    "& ::selection": { backgroundColor: "transparent !important" },
    "&::selection": { backgroundColor: "transparent !important" }
  }
};
YE && (Sm[".cm-line"].caretColor = "transparent !important", Sm[".cm-content"] = { caretColor: "transparent !important" });
var t6 = /* @__PURE__ */ ji.highest(/* @__PURE__ */ ue.theme(Sm));
var UE = /* @__PURE__ */ Me.define({
  map(t4, e) {
    return t4 == null ? null : e.mapPos(t4);
  }
});
var $l = /* @__PURE__ */ pn.define({
  create() {
    return null;
  },
  update(t4, e) {
    return t4 != null && (t4 = e.changes.mapPos(t4)), e.effects.reduce((n, r) => r.is(UE) ? r.value : n, t4);
  }
});
var n6 = /* @__PURE__ */ Wt.fromClass(class {
  constructor(t4) {
    this.view = t4, this.cursor = null, this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) };
  }
  update(t4) {
    var e;
    let n = t4.state.field($l);
    n == null ? this.cursor != null && ((e = this.cursor) === null || e === void 0 || e.remove(), this.cursor = null) : (this.cursor || (this.cursor = this.view.scrollDOM.appendChild(document.createElement("div")), this.cursor.className = "cm-dropCursor"), (t4.startState.field($l) != n || t4.docChanged || t4.geometryChanged) && this.view.requestMeasure(this.measureReq));
  }
  readPos() {
    let { view: t4 } = this, e = t4.state.field($l), n = e != null && t4.coordsAtPos(e);
    if (!n)
      return null;
    let r = t4.scrollDOM.getBoundingClientRect();
    return {
      left: n.left - r.left + t4.scrollDOM.scrollLeft * t4.scaleX,
      top: n.top - r.top + t4.scrollDOM.scrollTop * t4.scaleY,
      height: n.bottom - n.top
    };
  }
  drawCursor(t4) {
    if (this.cursor) {
      let { scaleX: e, scaleY: n } = this.view;
      t4 ? (this.cursor.style.left = t4.left / e + "px", this.cursor.style.top = t4.top / n + "px", this.cursor.style.height = t4.height / n + "px") : this.cursor.style.left = "-100000px";
    }
  }
  destroy() {
    this.cursor && this.cursor.remove();
  }
  setDropPos(t4) {
    this.view.state.field($l) != t4 && this.view.dispatch({ effects: UE.of(t4) });
  }
}, {
  eventObservers: {
    dragover(t4) {
      this.setDropPos(this.view.posAtCoords({ x: t4.clientX, y: t4.clientY }));
    },
    dragleave(t4) {
      (t4.target == this.view.contentDOM || !this.view.contentDOM.contains(t4.relatedTarget)) && this.setDropPos(null);
    },
    dragend() {
      this.setDropPos(null);
    },
    drop() {
      this.setDropPos(null);
    }
  }
});
function r6() {
  return [$l, n6];
}
function w1(t4, e, n, r, i) {
  e.lastIndex = 0;
  for (let o = t4.iterRange(n, r), s = n, a; !o.next().done; s += o.value.length)
    if (!o.lineBreak)
      for (; a = e.exec(o.value); )
        i(s + a.index, a);
}
function i6(t4, e) {
  let n = t4.visibleRanges;
  if (n.length == 1 && n[0].from == t4.viewport.from && n[0].to == t4.viewport.to)
    return n;
  let r = [];
  for (let { from: i, to: o } of n)
    i = Math.max(t4.state.doc.lineAt(i).from, i - e), o = Math.min(t4.state.doc.lineAt(o).to, o + e), r.length && r[r.length - 1].to >= i ? r[r.length - 1].to = o : r.push({ from: i, to: o });
  return r;
}
var HE = class {
  /**
  Create a decorator.
  */
  constructor(e) {
    const { regexp: n, decoration: r, decorate: i, boundary: o, maxLength: s = 1e3 } = e;
    if (!n.global)
      throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
    if (this.regexp = n, i)
      this.addMatch = (a, l, c, u) => i(u, c, c + a[0].length, a, l);
    else if (typeof r == "function")
      this.addMatch = (a, l, c, u) => {
        let f = r(a, l, c);
        f && u(c, c + a[0].length, f);
      };
    else if (r)
      this.addMatch = (a, l, c, u) => u(c, c + a[0].length, r);
    else
      throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
    this.boundary = o, this.maxLength = s;
  }
  /**
  Compute the full set of decorations for matches in the given
  view's viewport. You'll want to call this when initializing your
  plugin.
  */
  createDeco(e) {
    let n = new To(), r = n.add.bind(n);
    for (let { from: i, to: o } of i6(e, this.maxLength))
      w1(e.state.doc, this.regexp, i, o, (s, a) => this.addMatch(a, e, s, r));
    return n.finish();
  }
  /**
  Update a set of decorations for a view update. `deco` _must_ be
  the set of decorations produced by _this_ `MatchDecorator` for
  the view state before the update.
  */
  updateDeco(e, n) {
    let r = 1e9, i = -1;
    return e.docChanged && e.changes.iterChanges((o, s, a, l) => {
      l > e.view.viewport.from && a < e.view.viewport.to && (r = Math.min(a, r), i = Math.max(l, i));
    }), e.viewportChanged || i - r > 1e3 ? this.createDeco(e.view) : i > -1 ? this.updateRange(e.view, n.map(e.changes), r, i) : n;
  }
  updateRange(e, n, r, i) {
    for (let o of e.visibleRanges) {
      let s = Math.max(o.from, r), a = Math.min(o.to, i);
      if (a > s) {
        let l = e.state.doc.lineAt(s), c = l.to < a ? e.state.doc.lineAt(a) : l, u = Math.max(o.from, l.from), f = Math.min(o.to, c.to);
        if (this.boundary) {
          for (; s > l.from; s--)
            if (this.boundary.test(l.text[s - 1 - l.from])) {
              u = s;
              break;
            }
          for (; a < c.to; a++)
            if (this.boundary.test(c.text[a - c.from])) {
              f = a;
              break;
            }
        }
        let d = [], h, p = (O, m, x) => d.push(x.range(O, m));
        if (l == c)
          for (this.regexp.lastIndex = u - l.from; (h = this.regexp.exec(l.text)) && h.index < f - l.from; )
            this.addMatch(h, e, h.index + l.from, p);
        else
          w1(e.state.doc, this.regexp, u, f, (O, m) => this.addMatch(m, e, O, p));
        n = n.update({ filterFrom: u, filterTo: f, filter: (O, m) => O < u || m > f, add: d });
      }
    }
    return n;
  }
};
var wm = /x/.unicode != null ? "gu" : "g";
var o6 = /* @__PURE__ */ new RegExp(`[\0-\b
-\x7F-\x9F\xAD\u061C\u200B\u200E\u200F\u2028\u2029\u202D\u202E\u2066\u2067\u2069\uFEFF\uFFF9-\uFFFC]`, wm);
var s6 = {
  0: "null",
  7: "bell",
  8: "backspace",
  10: "newline",
  11: "vertical tab",
  13: "carriage return",
  27: "escape",
  8203: "zero width space",
  8204: "zero width non-joiner",
  8205: "zero width joiner",
  8206: "left-to-right mark",
  8207: "right-to-left mark",
  8232: "line separator",
  8237: "left-to-right override",
  8238: "right-to-left override",
  8294: "left-to-right isolate",
  8295: "right-to-left isolate",
  8297: "pop directional isolate",
  8233: "paragraph separator",
  65279: "zero width no-break space",
  65532: "object replacement"
};
var Rp = null;
function a6() {
  var t4;
  if (Rp == null && typeof document < "u" && document.body) {
    let e = document.body.style;
    Rp = ((t4 = e.tabSize) !== null && t4 !== void 0 ? t4 : e.MozTabSize) != null;
  }
  return Rp || false;
}
var pf = /* @__PURE__ */ ge.define({
  combine(t4) {
    let e = Di(t4, {
      render: null,
      specialChars: o6,
      addSpecialChars: null
    });
    return (e.replaceTabs = !a6()) && (e.specialChars = new RegExp("	|" + e.specialChars.source, wm)), e.addSpecialChars && (e.specialChars = new RegExp(e.specialChars.source + "|" + e.addSpecialChars.source, wm)), e;
  }
});
function l6(t4 = {}) {
  return [pf.of(t4), c6()];
}
var C1 = null;
function c6() {
  return C1 || (C1 = Wt.fromClass(class {
    constructor(t4) {
      this.view = t4, this.decorations = we.none, this.decorationCache = /* @__PURE__ */ Object.create(null), this.decorator = this.makeDecorator(t4.state.facet(pf)), this.decorations = this.decorator.createDeco(t4);
    }
    makeDecorator(t4) {
      return new HE({
        regexp: t4.specialChars,
        decoration: (e, n, r) => {
          let { doc: i } = n.state, o = Pn(e[0], 0);
          if (o == 9) {
            let s = i.lineAt(r), a = n.state.tabSize, l = Ya(s.text, a, r - s.from);
            return we.replace({
              widget: new h6((a - l % a) * this.view.defaultCharacterWidth / this.view.scaleX)
            });
          }
          return this.decorationCache[o] || (this.decorationCache[o] = we.replace({ widget: new d6(t4, o) }));
        },
        boundary: t4.replaceTabs ? void 0 : /[^]/
      });
    }
    update(t4) {
      let e = t4.state.facet(pf);
      t4.startState.facet(pf) != e ? (this.decorator = this.makeDecorator(e), this.decorations = this.decorator.createDeco(t4.view)) : this.decorations = this.decorator.updateDeco(t4, this.decorations);
    }
  }, {
    decorations: (t4) => t4.decorations
  }));
}
var u6 = "\u2022";
function f6(t4) {
  return t4 >= 32 ? u6 : t4 == 10 ? "\u2424" : String.fromCharCode(9216 + t4);
}
var d6 = class extends Qi {
  constructor(e, n) {
    super(), this.options = e, this.code = n;
  }
  eq(e) {
    return e.code == this.code;
  }
  toDOM(e) {
    let n = f6(this.code), r = e.state.phrase("Control character") + " " + (s6[this.code] || "0x" + this.code.toString(16)), i = this.options.render && this.options.render(this.code, r, n);
    if (i)
      return i;
    let o = document.createElement("span");
    return o.textContent = n, o.title = r, o.setAttribute("aria-label", r), o.className = "cm-specialChar", o;
  }
  ignoreEvent() {
    return false;
  }
};
var h6 = class extends Qi {
  constructor(e) {
    super(), this.width = e;
  }
  eq(e) {
    return e.width == this.width;
  }
  toDOM() {
    let e = document.createElement("span");
    return e.textContent = "	", e.className = "cm-tab", e.style.width = this.width + "px", e;
  }
  ignoreEvent() {
    return false;
  }
};
function p6() {
  return m6;
}
var g6 = /* @__PURE__ */ we.line({ class: "cm-activeLine" });
var m6 = /* @__PURE__ */ Wt.fromClass(class {
  constructor(t4) {
    this.decorations = this.getDeco(t4);
  }
  update(t4) {
    (t4.docChanged || t4.selectionSet) && (this.decorations = this.getDeco(t4.view));
  }
  getDeco(t4) {
    let e = -1, n = [];
    for (let r of t4.state.selection.ranges) {
      let i = t4.lineBlockAt(r.head);
      i.from > e && (n.push(g6.range(i.from)), e = i.from);
    }
    return we.set(n);
  }
}, {
  decorations: (t4) => t4.decorations
});
var O6 = class extends Qi {
  constructor(e) {
    super(), this.content = e;
  }
  toDOM() {
    let e = document.createElement("span");
    return e.className = "cm-placeholder", e.style.pointerEvents = "none", e.appendChild(typeof this.content == "string" ? document.createTextNode(this.content) : this.content), typeof this.content == "string" ? e.setAttribute("aria-label", "placeholder " + this.content) : e.setAttribute("aria-hidden", "true"), e;
  }
  coordsAt(e) {
    let n = e.firstChild ? Ca(e.firstChild) : [];
    if (!n.length)
      return null;
    let r = window.getComputedStyle(e.parentNode), i = mh(n[0], r.direction != "rtl"), o = parseInt(r.lineHeight);
    return i.bottom - i.top > o * 1.5 ? { left: i.left, right: i.right, top: i.top, bottom: i.top + o } : i;
  }
  ignoreEvent() {
    return false;
  }
};
function x6(t4) {
  return Wt.fromClass(class {
    constructor(e) {
      this.view = e, this.placeholder = t4 ? we.set([we.widget({ widget: new O6(t4), side: 1 }).range(0)]) : we.none;
    }
    get decorations() {
      return this.view.state.doc.length ? we.none : this.placeholder;
    }
  }, { decorations: (e) => e.decorations });
}
var Cm = 2e3;
function v6(t4, e, n) {
  let r = Math.min(e.line, n.line), i = Math.max(e.line, n.line), o = [];
  if (e.off > Cm || n.off > Cm || e.col < 0 || n.col < 0) {
    let s = Math.min(e.off, n.off), a = Math.max(e.off, n.off);
    for (let l = r; l <= i; l++) {
      let c = t4.doc.line(l);
      c.length <= a && o.push(ne.range(c.from + s, c.to + a));
    }
  } else {
    let s = Math.min(e.col, n.col), a = Math.max(e.col, n.col);
    for (let l = r; l <= i; l++) {
      let c = t4.doc.line(l), u = nm(c.text, s, t4.tabSize, true);
      if (u < 0)
        o.push(ne.cursor(c.to));
      else {
        let f = nm(c.text, a, t4.tabSize);
        o.push(ne.range(c.from + u, c.from + f));
      }
    }
  }
  return o;
}
function y6(t4, e) {
  let n = t4.coordsAtPos(t4.viewport.from);
  return n ? Math.round(Math.abs((n.left - e) / t4.defaultCharacterWidth)) : -1;
}
function k1(t4, e) {
  let n = t4.posAtCoords({ x: e.clientX, y: e.clientY }, false), r = t4.state.doc.lineAt(n), i = n - r.from, o = i > Cm ? -1 : i == r.length ? y6(t4, e.clientX) : Ya(r.text, t4.state.tabSize, n - r.from);
  return { line: r.number, col: o, off: i };
}
function b6(t4, e) {
  let n = k1(t4, e), r = t4.state.selection;
  return n ? {
    update(i) {
      if (i.docChanged) {
        let o = i.changes.mapPos(i.startState.doc.line(n.line).from), s = i.state.doc.lineAt(o);
        n = { line: s.number, col: n.col, off: Math.min(n.off, s.length) }, r = r.map(i.changes);
      }
    },
    get(i, o, s) {
      let a = k1(t4, i);
      if (!a)
        return r;
      let l = v6(t4.state, n, a);
      return l.length ? s ? ne.create(l.concat(r.ranges)) : ne.create(l) : r;
    }
  } : null;
}
function S6(t4) {
  let e = (n) => n.altKey && n.button == 0;
  return ue.mouseSelectionStyle.of((n, r) => e(r) ? b6(n, r) : null);
}
var w6 = {
  Alt: [18, (t4) => !!t4.altKey],
  Control: [17, (t4) => !!t4.ctrlKey],
  Shift: [16, (t4) => !!t4.shiftKey],
  Meta: [91, (t4) => !!t4.metaKey]
};
var C6 = { style: "cursor: crosshair" };
function k6(t4 = {}) {
  let [e, n] = w6[t4.key || "Alt"], r = Wt.fromClass(class {
    constructor(i) {
      this.view = i, this.isDown = false;
    }
    set(i) {
      this.isDown != i && (this.isDown = i, this.view.update([]));
    }
  }, {
    eventObservers: {
      keydown(i) {
        this.set(i.keyCode == e || n(i));
      },
      keyup(i) {
        (i.keyCode == e || !n(i)) && this.set(false);
      },
      mousemove(i) {
        this.set(n(i));
      }
    }
  });
  return [
    r,
    ue.contentAttributes.of((i) => {
      var o;
      return !((o = i.plugin(r)) === null || o === void 0) && o.isDown ? C6 : null;
    })
  ];
}
var ml = "-10000px";
var JE = class {
  constructor(e, n, r, i) {
    this.facet = n, this.createTooltipView = r, this.removeTooltipView = i, this.input = e.state.facet(n), this.tooltips = this.input.filter((s) => s);
    let o = null;
    this.tooltipViews = this.tooltips.map((s) => o = r(s, o));
  }
  update(e, n) {
    var r;
    let i = e.state.facet(this.facet), o = i.filter((l) => l);
    if (i === this.input) {
      for (let l of this.tooltipViews)
        l.update && l.update(e);
      return false;
    }
    let s = [], a = n ? [] : null;
    for (let l = 0; l < o.length; l++) {
      let c = o[l], u = -1;
      if (c) {
        for (let f = 0; f < this.tooltips.length; f++) {
          let d = this.tooltips[f];
          d && d.create == c.create && (u = f);
        }
        if (u < 0)
          s[l] = this.createTooltipView(c, l ? s[l - 1] : null), a && (a[l] = !!c.above);
        else {
          let f = s[l] = this.tooltipViews[u];
          a && (a[l] = n[u]), f.update && f.update(e);
        }
      }
    }
    for (let l of this.tooltipViews)
      s.indexOf(l) < 0 && (this.removeTooltipView(l), (r = l.destroy) === null || r === void 0 || r.call(l));
    return n && (a.forEach((l, c) => n[c] = l), n.length = a.length), this.input = i, this.tooltips = o, this.tooltipViews = s, true;
  }
};
function A6(t4) {
  let { win: e } = t4;
  return { top: 0, left: 0, bottom: e.innerHeight, right: e.innerWidth };
}
var Dp = /* @__PURE__ */ ge.define({
  combine: (t4) => {
    var e, n, r;
    return {
      position: me.ios ? "absolute" : ((e = t4.find((i) => i.position)) === null || e === void 0 ? void 0 : e.position) || "fixed",
      parent: ((n = t4.find((i) => i.parent)) === null || n === void 0 ? void 0 : n.parent) || null,
      tooltipSpace: ((r = t4.find((i) => i.tooltipSpace)) === null || r === void 0 ? void 0 : r.tooltipSpace) || A6
    };
  }
});
var A1 = /* @__PURE__ */ new WeakMap();
var Px = /* @__PURE__ */ Wt.fromClass(class {
  constructor(t4) {
    this.view = t4, this.above = [], this.inView = true, this.madeAbsolute = false, this.lastTransaction = 0, this.measureTimeout = -1;
    let e = t4.state.facet(Dp);
    this.position = e.position, this.parent = e.parent, this.classes = t4.themeClasses, this.createContainer(), this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this }, this.resizeObserver = typeof ResizeObserver == "function" ? new ResizeObserver(() => this.measureSoon()) : null, this.manager = new JE(t4, Ex, (n, r) => this.createTooltip(n, r), (n) => {
      this.resizeObserver && this.resizeObserver.unobserve(n.dom), n.dom.remove();
    }), this.above = this.manager.tooltips.map((n) => !!n.above), this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((n) => {
      Date.now() > this.lastTransaction - 50 && n.length > 0 && n[n.length - 1].intersectionRatio < 1 && this.measureSoon();
    }, { threshold: [1] }) : null, this.observeIntersection(), t4.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this)), this.maybeMeasure();
  }
  createContainer() {
    this.parent ? (this.container = document.createElement("div"), this.container.style.position = "relative", this.container.className = this.view.themeClasses, this.parent.appendChild(this.container)) : this.container = this.view.dom;
  }
  observeIntersection() {
    if (this.intersectionObserver) {
      this.intersectionObserver.disconnect();
      for (let t4 of this.manager.tooltipViews)
        this.intersectionObserver.observe(t4.dom);
    }
  }
  measureSoon() {
    this.measureTimeout < 0 && (this.measureTimeout = setTimeout(() => {
      this.measureTimeout = -1, this.maybeMeasure();
    }, 50));
  }
  update(t4) {
    t4.transactions.length && (this.lastTransaction = Date.now());
    let e = this.manager.update(t4, this.above);
    e && this.observeIntersection();
    let n = e || t4.geometryChanged, r = t4.state.facet(Dp);
    if (r.position != this.position && !this.madeAbsolute) {
      this.position = r.position;
      for (let i of this.manager.tooltipViews)
        i.dom.style.position = this.position;
      n = true;
    }
    if (r.parent != this.parent) {
      this.parent && this.container.remove(), this.parent = r.parent, this.createContainer();
      for (let i of this.manager.tooltipViews)
        this.container.appendChild(i.dom);
      n = true;
    } else
      this.parent && this.view.themeClasses != this.classes && (this.classes = this.container.className = this.view.themeClasses);
    n && this.maybeMeasure();
  }
  createTooltip(t4, e) {
    let n = t4.create(this.view), r = e ? e.dom : null;
    if (n.dom.classList.add("cm-tooltip"), t4.arrow && !n.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
      let i = document.createElement("div");
      i.className = "cm-tooltip-arrow", n.dom.appendChild(i);
    }
    return n.dom.style.position = this.position, n.dom.style.top = ml, n.dom.style.left = "0px", this.container.insertBefore(n.dom, r), n.mount && n.mount(this.view), this.resizeObserver && this.resizeObserver.observe(n.dom), n;
  }
  destroy() {
    var t4, e, n;
    this.view.win.removeEventListener("resize", this.measureSoon);
    for (let r of this.manager.tooltipViews)
      r.dom.remove(), (t4 = r.destroy) === null || t4 === void 0 || t4.call(r);
    this.parent && this.container.remove(), (e = this.resizeObserver) === null || e === void 0 || e.disconnect(), (n = this.intersectionObserver) === null || n === void 0 || n.disconnect(), clearTimeout(this.measureTimeout);
  }
  readMeasure() {
    let t4 = this.view.dom.getBoundingClientRect(), e = 1, n = 1, r = false;
    if (this.position == "fixed" && this.manager.tooltipViews.length) {
      let { dom: i } = this.manager.tooltipViews[0];
      if (me.gecko)
        r = i.offsetParent != this.container.ownerDocument.body;
      else if (i.style.top == ml && i.style.left == "0px") {
        let o = i.getBoundingClientRect();
        r = Math.abs(o.top + 1e4) > 1 || Math.abs(o.left) > 1;
      }
    }
    if (r || this.position == "absolute")
      if (this.parent) {
        let i = this.parent.getBoundingClientRect();
        i.width && i.height && (e = i.width / this.parent.offsetWidth, n = i.height / this.parent.offsetHeight);
      } else
        ({ scaleX: e, scaleY: n } = this.view.viewState);
    return {
      editor: t4,
      parent: this.parent ? this.container.getBoundingClientRect() : t4,
      pos: this.manager.tooltips.map((i, o) => {
        let s = this.manager.tooltipViews[o];
        return s.getCoords ? s.getCoords(i.pos) : this.view.coordsAtPos(i.pos);
      }),
      size: this.manager.tooltipViews.map(({ dom: i }) => i.getBoundingClientRect()),
      space: this.view.state.facet(Dp).tooltipSpace(this.view),
      scaleX: e,
      scaleY: n,
      makeAbsolute: r
    };
  }
  writeMeasure(t4) {
    var e;
    if (t4.makeAbsolute) {
      this.madeAbsolute = true, this.position = "absolute";
      for (let a of this.manager.tooltipViews)
        a.dom.style.position = "absolute";
    }
    let { editor: n, space: r, scaleX: i, scaleY: o } = t4, s = [];
    for (let a = 0; a < this.manager.tooltips.length; a++) {
      let l = this.manager.tooltips[a], c = this.manager.tooltipViews[a], { dom: u } = c, f = t4.pos[a], d = t4.size[a];
      if (!f || f.bottom <= Math.max(n.top, r.top) || f.top >= Math.min(n.bottom, r.bottom) || f.right < Math.max(n.left, r.left) - 0.1 || f.left > Math.min(n.right, r.right) + 0.1) {
        u.style.top = ml;
        continue;
      }
      let h = l.arrow ? c.dom.querySelector(".cm-tooltip-arrow") : null, p = h ? 7 : 0, O = d.right - d.left, m = (e = A1.get(c)) !== null && e !== void 0 ? e : d.bottom - d.top, x = c.offset || E6, v = this.view.textDirection == _t.LTR, y = d.width > r.right - r.left ? v ? r.left : r.right - d.width : v ? Math.min(f.left - (h ? 14 : 0) + x.x, r.right - O) : Math.max(r.left, f.left - O + (h ? 14 : 0) - x.x), S = this.above[a];
      !l.strictSide && (S ? f.top - (d.bottom - d.top) - x.y < r.top : f.bottom + (d.bottom - d.top) + x.y > r.bottom) && S == r.bottom - f.bottom > f.top - r.top && (S = this.above[a] = !S);
      let b = (S ? f.top - r.top : r.bottom - f.bottom) - p;
      if (b < m && c.resize !== false) {
        if (b < this.view.defaultLineHeight) {
          u.style.top = ml;
          continue;
        }
        A1.set(c, m), u.style.height = (m = b) / o + "px";
      } else
        u.style.height && (u.style.height = "");
      let w = S ? f.top - m - p - x.y : f.bottom + p + x.y, C = y + O;
      if (c.overlap !== true)
        for (let k of s)
          k.left < C && k.right > y && k.top < w + m && k.bottom > w && (w = S ? k.top - m - 2 - p : k.bottom + p + 2);
      if (this.position == "absolute" ? (u.style.top = (w - t4.parent.top) / o + "px", u.style.left = (y - t4.parent.left) / i + "px") : (u.style.top = w / o + "px", u.style.left = y / i + "px"), h) {
        let k = f.left + (v ? x.x : -x.x) - (y + 14 - 7);
        h.style.left = k / i + "px";
      }
      c.overlap !== true && s.push({ left: y, top: w, right: C, bottom: w + m }), u.classList.toggle("cm-tooltip-above", S), u.classList.toggle("cm-tooltip-below", !S), c.positioned && c.positioned(t4.space);
    }
  }
  maybeMeasure() {
    if (this.manager.tooltips.length && (this.view.inView && this.view.requestMeasure(this.measureReq), this.inView != this.view.inView && (this.inView = this.view.inView, !this.inView)))
      for (let t4 of this.manager.tooltipViews)
        t4.dom.style.top = ml;
  }
}, {
  eventObservers: {
    scroll() {
      this.maybeMeasure();
    }
  }
});
var P6 = /* @__PURE__ */ ue.baseTheme({
  ".cm-tooltip": {
    zIndex: 100,
    boxSizing: "border-box"
  },
  "&light .cm-tooltip": {
    border: "1px solid #bbb",
    backgroundColor: "#f5f5f5"
  },
  "&light .cm-tooltip-section:not(:first-child)": {
    borderTop: "1px solid #bbb"
  },
  "&dark .cm-tooltip": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tooltip-arrow": {
    height: "7px",
    width: `${7 * 2}px`,
    position: "absolute",
    zIndex: -1,
    overflow: "hidden",
    "&:before, &:after": {
      content: "''",
      position: "absolute",
      width: 0,
      height: 0,
      borderLeft: "7px solid transparent",
      borderRight: "7px solid transparent"
    },
    ".cm-tooltip-above &": {
      bottom: "-7px",
      "&:before": {
        borderTop: "7px solid #bbb"
      },
      "&:after": {
        borderTop: "7px solid #f5f5f5",
        bottom: "1px"
      }
    },
    ".cm-tooltip-below &": {
      top: "-7px",
      "&:before": {
        borderBottom: "7px solid #bbb"
      },
      "&:after": {
        borderBottom: "7px solid #f5f5f5",
        top: "1px"
      }
    }
  },
  "&dark .cm-tooltip .cm-tooltip-arrow": {
    "&:before": {
      borderTopColor: "#333338",
      borderBottomColor: "#333338"
    },
    "&:after": {
      borderTopColor: "transparent",
      borderBottomColor: "transparent"
    }
  }
});
var E6 = { x: 0, y: 0 };
var Ex = /* @__PURE__ */ ge.define({
  enables: [Px, P6]
});
var id = /* @__PURE__ */ ge.define({
  combine: (t4) => t4.reduce((e, n) => e.concat(n), [])
});
var vh = class {
  // Needs to be static so that host tooltip instances always match
  static create(e) {
    return new vh(e);
  }
  constructor(e) {
    this.view = e, this.mounted = false, this.dom = document.createElement("div"), this.dom.classList.add("cm-tooltip-hover"), this.manager = new JE(e, id, (n, r) => this.createHostedView(n, r), (n) => n.dom.remove());
  }
  createHostedView(e, n) {
    let r = e.create(this.view);
    return r.dom.classList.add("cm-tooltip-section"), this.dom.insertBefore(r.dom, n ? n.dom.nextSibling : this.dom.firstChild), this.mounted && r.mount && r.mount(this.view), r;
  }
  mount(e) {
    for (let n of this.manager.tooltipViews)
      n.mount && n.mount(e);
    this.mounted = true;
  }
  positioned(e) {
    for (let n of this.manager.tooltipViews)
      n.positioned && n.positioned(e);
  }
  update(e) {
    this.manager.update(e);
  }
  destroy() {
    var e;
    for (let n of this.manager.tooltipViews)
      (e = n.destroy) === null || e === void 0 || e.call(n);
  }
  passProp(e) {
    let n;
    for (let r of this.manager.tooltipViews) {
      let i = r[e];
      if (i !== void 0) {
        if (n === void 0)
          n = i;
        else if (n !== i)
          return;
      }
    }
    return n;
  }
  get offset() {
    return this.passProp("offset");
  }
  get getCoords() {
    return this.passProp("getCoords");
  }
  get overlap() {
    return this.passProp("overlap");
  }
  get resize() {
    return this.passProp("resize");
  }
};
var T6 = /* @__PURE__ */ Ex.compute([id], (t4) => {
  let e = t4.facet(id);
  return e.length === 0 ? null : {
    pos: Math.min(...e.map((n) => n.pos)),
    end: Math.max(...e.map((n) => {
      var r;
      return (r = n.end) !== null && r !== void 0 ? r : n.pos;
    })),
    create: vh.create,
    above: e[0].above,
    arrow: e.some((n) => n.arrow)
  };
});
var I6 = class {
  constructor(e, n, r, i, o) {
    this.view = e, this.source = n, this.field = r, this.setHover = i, this.hoverTime = o, this.hoverTimeout = -1, this.restartTimeout = -1, this.pending = null, this.lastMove = { x: 0, y: 0, target: e.dom, time: 0 }, this.checkHover = this.checkHover.bind(this), e.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this)), e.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
  }
  update() {
    this.pending && (this.pending = null, clearTimeout(this.restartTimeout), this.restartTimeout = setTimeout(() => this.startHover(), 20));
  }
  get active() {
    return this.view.state.field(this.field);
  }
  checkHover() {
    if (this.hoverTimeout = -1, this.active.length)
      return;
    let e = Date.now() - this.lastMove.time;
    e < this.hoverTime ? this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - e) : this.startHover();
  }
  startHover() {
    clearTimeout(this.restartTimeout);
    let { view: e, lastMove: n } = this, r = e.docView.nearest(n.target);
    if (!r)
      return;
    let i, o = 1;
    if (r instanceof xo)
      i = r.posAtStart;
    else {
      if (i = e.posAtCoords(n), i == null)
        return;
      let a = e.coordsAtPos(i);
      if (!a || n.y < a.top || n.y > a.bottom || n.x < a.left - e.defaultCharacterWidth || n.x > a.right + e.defaultCharacterWidth)
        return;
      let l = e.bidiSpans(e.state.doc.lineAt(i)).find((u) => u.from <= i && u.to >= i), c = l && l.dir == _t.RTL ? -1 : 1;
      o = n.x < a.left ? -c : c;
    }
    let s = this.source(e, i, o);
    if (s != null && s.then) {
      let a = this.pending = { pos: i };
      s.then((l) => {
        this.pending == a && (this.pending = null, l && !(Array.isArray(l) && !l.length) && e.dispatch({ effects: this.setHover.of(Array.isArray(l) ? l : [l]) }));
      }, (l) => Gn(e.state, l, "hover tooltip"));
    } else
      s && !(Array.isArray(s) && !s.length) && e.dispatch({ effects: this.setHover.of(Array.isArray(s) ? s : [s]) });
  }
  get tooltip() {
    let e = this.view.plugin(Px), n = e ? e.manager.tooltips.findIndex((r) => r.create == vh.create) : -1;
    return n > -1 ? e.manager.tooltipViews[n] : null;
  }
  mousemove(e) {
    var n, r;
    this.lastMove = { x: e.clientX, y: e.clientY, target: e.target, time: Date.now() }, this.hoverTimeout < 0 && (this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime));
    let { active: i, tooltip: o } = this;
    if (i.length && o && !$6(o.dom, e) || this.pending) {
      let { pos: s } = i[0] || this.pending, a = (r = (n = i[0]) === null || n === void 0 ? void 0 : n.end) !== null && r !== void 0 ? r : s;
      (s == a ? this.view.posAtCoords(this.lastMove) != s : !j6(this.view, s, a, e.clientX, e.clientY)) && (this.view.dispatch({ effects: this.setHover.of([]) }), this.pending = null);
    }
  }
  mouseleave(e) {
    clearTimeout(this.hoverTimeout), this.hoverTimeout = -1;
    let { active: n } = this;
    if (n.length) {
      let { tooltip: r } = this;
      r && r.dom.contains(e.relatedTarget) ? this.watchTooltipLeave(r.dom) : this.view.dispatch({ effects: this.setHover.of([]) });
    }
  }
  watchTooltipLeave(e) {
    let n = (r) => {
      e.removeEventListener("mouseleave", n), this.active.length && !this.view.dom.contains(r.relatedTarget) && this.view.dispatch({ effects: this.setHover.of([]) });
    };
    e.addEventListener("mouseleave", n);
  }
  destroy() {
    clearTimeout(this.hoverTimeout), this.view.dom.removeEventListener("mouseleave", this.mouseleave), this.view.dom.removeEventListener("mousemove", this.mousemove);
  }
};
var Ru = 4;
function $6(t4, e) {
  let n = t4.getBoundingClientRect();
  return e.clientX >= n.left - Ru && e.clientX <= n.right + Ru && e.clientY >= n.top - Ru && e.clientY <= n.bottom + Ru;
}
function j6(t4, e, n, r, i, o) {
  let s = t4.scrollDOM.getBoundingClientRect(), a = t4.documentTop + t4.documentPadding.top + t4.contentHeight;
  if (s.left > r || s.right < r || s.top > i || Math.min(s.bottom, a) < i)
    return false;
  let l = t4.posAtCoords({ x: r, y: i }, false);
  return l >= e && l <= n;
}
function R6(t4, e = {}) {
  let n = Me.define(), r = pn.define({
    create() {
      return [];
    },
    update(i, o) {
      if (i.length && (e.hideOnChange && (o.docChanged || o.selection) ? i = [] : e.hideOn && (i = i.filter((s) => !e.hideOn(o, s))), o.docChanged)) {
        let s = [];
        for (let a of i) {
          let l = o.changes.mapPos(a.pos, -1, Tn.TrackDel);
          if (l != null) {
            let c = Object.assign(/* @__PURE__ */ Object.create(null), a);
            c.pos = l, c.end != null && (c.end = o.changes.mapPos(c.end)), s.push(c);
          }
        }
        i = s;
      }
      for (let s of o.effects)
        s.is(n) && (i = s.value), s.is(D6) && (i = []);
      return i;
    },
    provide: (i) => id.from(i)
  });
  return [
    r,
    Wt.define((i) => new I6(
      i,
      t4,
      r,
      n,
      e.hoverTime || 300
      /* Hover.Time */
    )),
    T6
  ];
}
function KE(t4, e) {
  let n = t4.plugin(Px);
  if (!n)
    return null;
  let r = n.manager.tooltips.indexOf(e);
  return r < 0 ? null : n.manager.tooltipViews[r];
}
var D6 = /* @__PURE__ */ Me.define();
var P1 = /* @__PURE__ */ ge.define({
  combine(t4) {
    let e, n;
    for (let r of t4)
      e = e || r.topContainer, n = n || r.bottomContainer;
    return { topContainer: e, bottomContainer: n };
  }
});
function sc(t4, e) {
  let n = t4.plugin(eT), r = n ? n.specs.indexOf(e) : -1;
  return r > -1 ? n.panels[r] : null;
}
var eT = /* @__PURE__ */ Wt.fromClass(class {
  constructor(t4) {
    this.input = t4.state.facet(ac), this.specs = this.input.filter((n) => n), this.panels = this.specs.map((n) => n(t4));
    let e = t4.state.facet(P1);
    this.top = new Du(t4, true, e.topContainer), this.bottom = new Du(t4, false, e.bottomContainer), this.top.sync(this.panels.filter((n) => n.top)), this.bottom.sync(this.panels.filter((n) => !n.top));
    for (let n of this.panels)
      n.dom.classList.add("cm-panel"), n.mount && n.mount();
  }
  update(t4) {
    let e = t4.state.facet(P1);
    this.top.container != e.topContainer && (this.top.sync([]), this.top = new Du(t4.view, true, e.topContainer)), this.bottom.container != e.bottomContainer && (this.bottom.sync([]), this.bottom = new Du(t4.view, false, e.bottomContainer)), this.top.syncClasses(), this.bottom.syncClasses();
    let n = t4.state.facet(ac);
    if (n != this.input) {
      let r = n.filter((l) => l), i = [], o = [], s = [], a = [];
      for (let l of r) {
        let c = this.specs.indexOf(l), u;
        c < 0 ? (u = l(t4.view), a.push(u)) : (u = this.panels[c], u.update && u.update(t4)), i.push(u), (u.top ? o : s).push(u);
      }
      this.specs = r, this.panels = i, this.top.sync(o), this.bottom.sync(s);
      for (let l of a)
        l.dom.classList.add("cm-panel"), l.mount && l.mount();
    } else
      for (let r of this.panels)
        r.update && r.update(t4);
  }
  destroy() {
    this.top.sync([]), this.bottom.sync([]);
  }
}, {
  provide: (t4) => ue.scrollMargins.of((e) => {
    let n = e.plugin(t4);
    return n && { top: n.top.scrollMargin(), bottom: n.bottom.scrollMargin() };
  })
});
var Du = class {
  constructor(e, n, r) {
    this.view = e, this.top = n, this.container = r, this.dom = void 0, this.classes = "", this.panels = [], this.syncClasses();
  }
  sync(e) {
    for (let n of this.panels)
      n.destroy && e.indexOf(n) < 0 && n.destroy();
    this.panels = e, this.syncDOM();
  }
  syncDOM() {
    if (this.panels.length == 0) {
      this.dom && (this.dom.remove(), this.dom = void 0);
      return;
    }
    if (!this.dom) {
      this.dom = document.createElement("div"), this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom", this.dom.style[this.top ? "top" : "bottom"] = "0";
      let n = this.container || this.view.dom;
      n.insertBefore(this.dom, this.top ? n.firstChild : null);
    }
    let e = this.dom.firstChild;
    for (let n of this.panels)
      if (n.dom.parentNode == this.dom) {
        for (; e != n.dom; )
          e = E1(e);
        e = e.nextSibling;
      } else
        this.dom.insertBefore(n.dom, e);
    for (; e; )
      e = E1(e);
  }
  scrollMargin() {
    return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
  }
  syncClasses() {
    if (!(!this.container || this.classes == this.view.themeClasses)) {
      for (let e of this.classes.split(" "))
        e && this.container.classList.remove(e);
      for (let e of (this.classes = this.view.themeClasses).split(" "))
        e && this.container.classList.add(e);
    }
  }
};
function E1(t4) {
  let e = t4.nextSibling;
  return t4.remove(), e;
}
var ac = /* @__PURE__ */ ge.define({
  enables: eT
});
var Ji = class extends fs {
  /**
  @internal
  */
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  /**
  Compare this marker to another marker of the same type.
  */
  eq(e) {
    return false;
  }
  /**
  Called if the marker has a `toDOM` method and its representation
  was removed from a gutter.
  */
  destroy(e) {
  }
};
Ji.prototype.elementClass = "";
Ji.prototype.toDOM = void 0;
Ji.prototype.mapMode = Tn.TrackBefore;
Ji.prototype.startSide = Ji.prototype.endSide = -1;
Ji.prototype.point = true;
var gf = /* @__PURE__ */ ge.define();
var Q6 = {
  class: "",
  renderEmptyElements: false,
  elementStyle: "",
  markers: () => ot.empty,
  lineMarker: () => null,
  widgetMarker: () => null,
  lineMarkerChange: null,
  initialSpacer: null,
  updateSpacer: null,
  domEventHandlers: {}
};
var zl = /* @__PURE__ */ ge.define();
function B6(t4) {
  return [tT(), zl.of(Object.assign(Object.assign({}, Q6), t4))];
}
var T1 = /* @__PURE__ */ ge.define({
  combine: (t4) => t4.some((e) => e)
});
function tT(t4) {
  return [
    _6
  ];
}
var _6 = /* @__PURE__ */ Wt.fromClass(class {
  constructor(t4) {
    this.view = t4, this.prevViewport = t4.viewport, this.dom = document.createElement("div"), this.dom.className = "cm-gutters", this.dom.setAttribute("aria-hidden", "true"), this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px", this.gutters = t4.state.facet(zl).map((e) => new $1(t4, e));
    for (let e of this.gutters)
      this.dom.appendChild(e.dom);
    this.fixed = !t4.state.facet(T1), this.fixed && (this.dom.style.position = "sticky"), this.syncGutters(false), t4.scrollDOM.insertBefore(this.dom, t4.contentDOM);
  }
  update(t4) {
    if (this.updateGutters(t4)) {
      let e = this.prevViewport, n = t4.view.viewport, r = Math.min(e.to, n.to) - Math.max(e.from, n.from);
      this.syncGutters(r < (n.to - n.from) * 0.8);
    }
    t4.geometryChanged && (this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px"), this.view.state.facet(T1) != !this.fixed && (this.fixed = !this.fixed, this.dom.style.position = this.fixed ? "sticky" : ""), this.prevViewport = t4.view.viewport;
  }
  syncGutters(t4) {
    let e = this.dom.nextSibling;
    t4 && this.dom.remove();
    let n = ot.iter(this.view.state.facet(gf), this.view.viewport.from), r = [], i = this.gutters.map((o) => new M6(o, this.view.viewport, -this.view.documentPadding.top));
    for (let o of this.view.viewportLineBlocks)
      if (r.length && (r = []), Array.isArray(o.type)) {
        let s = true;
        for (let a of o.type)
          if (a.type == Yn.Text && s) {
            km(n, r, a.from);
            for (let l of i)
              l.line(this.view, a, r);
            s = false;
          } else if (a.widget)
            for (let l of i)
              l.widget(this.view, a);
      } else if (o.type == Yn.Text) {
        km(n, r, o.from);
        for (let s of i)
          s.line(this.view, o, r);
      } else if (o.widget)
        for (let s of i)
          s.widget(this.view, o);
    for (let o of i)
      o.finish();
    t4 && this.view.scrollDOM.insertBefore(this.dom, e);
  }
  updateGutters(t4) {
    let e = t4.startState.facet(zl), n = t4.state.facet(zl), r = t4.docChanged || t4.heightChanged || t4.viewportChanged || !ot.eq(t4.startState.facet(gf), t4.state.facet(gf), t4.view.viewport.from, t4.view.viewport.to);
    if (e == n)
      for (let i of this.gutters)
        i.update(t4) && (r = true);
    else {
      r = true;
      let i = [];
      for (let o of n) {
        let s = e.indexOf(o);
        s < 0 ? i.push(new $1(this.view, o)) : (this.gutters[s].update(t4), i.push(this.gutters[s]));
      }
      for (let o of this.gutters)
        o.dom.remove(), i.indexOf(o) < 0 && o.destroy();
      for (let o of i)
        this.dom.appendChild(o.dom);
      this.gutters = i;
    }
    return r;
  }
  destroy() {
    for (let t4 of this.gutters)
      t4.destroy();
    this.dom.remove();
  }
}, {
  provide: (t4) => ue.scrollMargins.of((e) => {
    let n = e.plugin(t4);
    return !n || n.gutters.length == 0 || !n.fixed ? null : e.textDirection == _t.LTR ? { left: n.dom.offsetWidth * e.scaleX } : { right: n.dom.offsetWidth * e.scaleX };
  })
});
function I1(t4) {
  return Array.isArray(t4) ? t4 : [t4];
}
function km(t4, e, n) {
  for (; t4.value && t4.from <= n; )
    t4.from == n && e.push(t4.value), t4.next();
}
var M6 = class {
  constructor(e, n, r) {
    this.gutter = e, this.height = r, this.i = 0, this.cursor = ot.iter(e.markers, n.from);
  }
  addElement(e, n, r) {
    let { gutter: i } = this, o = (n.top - this.height) / e.scaleY, s = n.height / e.scaleY;
    if (this.i == i.elements.length) {
      let a = new nT(e, s, o, r);
      i.elements.push(a), i.dom.appendChild(a.dom);
    } else
      i.elements[this.i].update(e, s, o, r);
    this.height = n.bottom, this.i++;
  }
  line(e, n, r) {
    let i = [];
    km(this.cursor, i, n.from), r.length && (i = i.concat(r));
    let o = this.gutter.config.lineMarker(e, n, i);
    o && i.unshift(o);
    let s = this.gutter;
    i.length == 0 && !s.config.renderEmptyElements || this.addElement(e, n, i);
  }
  widget(e, n) {
    let r = this.gutter.config.widgetMarker(e, n.widget, n);
    r && this.addElement(e, n, [r]);
  }
  finish() {
    let e = this.gutter;
    for (; e.elements.length > this.i; ) {
      let n = e.elements.pop();
      e.dom.removeChild(n.dom), n.destroy();
    }
  }
};
var $1 = class {
  constructor(e, n) {
    this.view = e, this.config = n, this.elements = [], this.spacer = null, this.dom = document.createElement("div"), this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
    for (let r in n.domEventHandlers)
      this.dom.addEventListener(r, (i) => {
        let o = i.target, s;
        if (o != this.dom && this.dom.contains(o)) {
          for (; o.parentNode != this.dom; )
            o = o.parentNode;
          let l = o.getBoundingClientRect();
          s = (l.top + l.bottom) / 2;
        } else
          s = i.clientY;
        let a = e.lineBlockAtHeight(s - e.documentTop);
        n.domEventHandlers[r](e, a, i) && i.preventDefault();
      });
    this.markers = I1(n.markers(e)), n.initialSpacer && (this.spacer = new nT(e, 0, 0, [n.initialSpacer(e)]), this.dom.appendChild(this.spacer.dom), this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none");
  }
  update(e) {
    let n = this.markers;
    if (this.markers = I1(this.config.markers(e.view)), this.spacer && this.config.updateSpacer) {
      let i = this.config.updateSpacer(this.spacer.markers[0], e);
      i != this.spacer.markers[0] && this.spacer.update(e.view, 0, 0, [i]);
    }
    let r = e.view.viewport;
    return !ot.eq(this.markers, n, r.from, r.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(e) : false);
  }
  destroy() {
    for (let e of this.elements)
      e.destroy();
  }
};
var nT = class {
  constructor(e, n, r, i) {
    this.height = -1, this.above = 0, this.markers = [], this.dom = document.createElement("div"), this.dom.className = "cm-gutterElement", this.update(e, n, r, i);
  }
  update(e, n, r, i) {
    this.height != n && (this.height = n, this.dom.style.height = n + "px"), this.above != r && (this.dom.style.marginTop = (this.above = r) ? r + "px" : ""), N6(this.markers, i) || this.setMarkers(e, i);
  }
  setMarkers(e, n) {
    let r = "cm-gutterElement", i = this.dom.firstChild;
    for (let o = 0, s = 0; ; ) {
      let a = s, l = o < n.length ? n[o++] : null, c = false;
      if (l) {
        let u = l.elementClass;
        u && (r += " " + u);
        for (let f = s; f < this.markers.length; f++)
          if (this.markers[f].compare(l)) {
            a = f, c = true;
            break;
          }
      } else
        a = this.markers.length;
      for (; s < a; ) {
        let u = this.markers[s++];
        if (u.toDOM) {
          u.destroy(i);
          let f = i.nextSibling;
          i.remove(), i = f;
        }
      }
      if (!l)
        break;
      l.toDOM && (c ? i = i.nextSibling : this.dom.insertBefore(l.toDOM(e), i)), c && s++;
    }
    this.dom.className = r, this.markers = n;
  }
  destroy() {
    this.setMarkers(null, []);
  }
};
function N6(t4, e) {
  if (t4.length != e.length)
    return false;
  for (let n = 0; n < t4.length; n++)
    if (!t4[n].compare(e[n]))
      return false;
  return true;
}
var F6 = /* @__PURE__ */ ge.define();
var qs = /* @__PURE__ */ ge.define({
  combine(t4) {
    return Di(t4, { formatNumber: String, domEventHandlers: {} }, {
      domEventHandlers(e, n) {
        let r = Object.assign({}, e);
        for (let i in n) {
          let o = r[i], s = n[i];
          r[i] = o ? (a, l, c) => o(a, l, c) || s(a, l, c) : s;
        }
        return r;
      }
    });
  }
});
var Qp = class extends Ji {
  constructor(e) {
    super(), this.number = e;
  }
  eq(e) {
    return this.number == e.number;
  }
  toDOM() {
    return document.createTextNode(this.number);
  }
};
function Bp(t4, e) {
  return t4.state.facet(qs).formatNumber(e, t4.state);
}
var Z6 = /* @__PURE__ */ zl.compute([qs], (t4) => ({
  class: "cm-lineNumbers",
  renderEmptyElements: false,
  markers(e) {
    return e.state.facet(F6);
  },
  lineMarker(e, n, r) {
    return r.some((i) => i.toDOM) ? null : new Qp(Bp(e, e.state.doc.lineAt(n.from).number));
  },
  widgetMarker: () => null,
  lineMarkerChange: (e) => e.startState.facet(qs) != e.state.facet(qs),
  initialSpacer(e) {
    return new Qp(Bp(e, j1(e.state.doc.lines)));
  },
  updateSpacer(e, n) {
    let r = Bp(n.view, j1(n.view.state.doc.lines));
    return r == e.number ? e : new Qp(r);
  },
  domEventHandlers: t4.facet(qs).domEventHandlers
}));
function W6(t4 = {}) {
  return [
    qs.of(t4),
    tT(),
    Z6
  ];
}
function j1(t4) {
  let e = 9;
  for (; e < t4; )
    e = e * 10 + 9;
  return e;
}
var V6 = /* @__PURE__ */ new class extends Ji {
  constructor() {
    super(...arguments), this.elementClass = "cm-activeLineGutter";
  }
}();
var z6 = /* @__PURE__ */ gf.compute(["selection"], (t4) => {
  let e = [], n = -1;
  for (let r of t4.selection.ranges) {
    let i = t4.doc.lineAt(r.head).from;
    i > n && (n = i, e.push(V6.range(i)));
  }
  return ot.of(e);
});
function L6() {
  return z6;
}
var rT = 1024;
var X6 = 0;
var Rr = class {
  constructor(e, n) {
    this.from = e, this.to = n;
  }
};
var Xe = class {
  /**
  Create a new node prop type.
  */
  constructor(e = {}) {
    this.id = X6++, this.perNode = !!e.perNode, this.deserialize = e.deserialize || (() => {
      throw new Error("This node type doesn't define a deserialize function");
    });
  }
  /**
  This is meant to be used with
  [`NodeSet.extend`](#common.NodeSet.extend) or
  [`LRParser.configure`](#lr.ParserConfig.props) to compute
  prop values for each node type in the set. Takes a [match
  object](#common.NodeType^match) or function that returns undefined
  if the node type doesn't get this prop, and the prop's value if
  it does.
  */
  add(e) {
    if (this.perNode)
      throw new RangeError("Can't add per-node props to node types");
    return typeof e != "function" && (e = Hn.match(e)), (n) => {
      let r = e(n);
      return r === void 0 ? null : [this, r];
    };
  }
};
Xe.closedBy = new Xe({ deserialize: (t4) => t4.split(" ") });
Xe.openedBy = new Xe({ deserialize: (t4) => t4.split(" ") });
Xe.group = new Xe({ deserialize: (t4) => t4.split(" ") });
Xe.isolate = new Xe({ deserialize: (t4) => {
  if (t4 && t4 != "rtl" && t4 != "ltr" && t4 != "auto")
    throw new RangeError("Invalid value for isolate: " + t4);
  return t4 || "auto";
} });
Xe.contextHash = new Xe({ perNode: true });
Xe.lookAhead = new Xe({ perNode: true });
Xe.mounted = new Xe({ perNode: true });
var lc = class {
  constructor(e, n, r) {
    this.tree = e, this.overlay = n, this.parser = r;
  }
  /**
  @internal
  */
  static get(e) {
    return e && e.props && e.props[Xe.mounted.id];
  }
};
var G6 = /* @__PURE__ */ Object.create(null);
var Hn = class {
  /**
  @internal
  */
  constructor(e, n, r, i = 0) {
    this.name = e, this.props = n, this.id = r, this.flags = i;
  }
  /**
  Define a node type.
  */
  static define(e) {
    let n = e.props && e.props.length ? /* @__PURE__ */ Object.create(null) : G6, r = (e.top ? 1 : 0) | (e.skipped ? 2 : 0) | (e.error ? 4 : 0) | (e.name == null ? 8 : 0), i = new Hn(e.name || "", n, e.id, r);
    if (e.props) {
      for (let o of e.props)
        if (Array.isArray(o) || (o = o(i)), o) {
          if (o[0].perNode)
            throw new RangeError("Can't store a per-node prop on a node type");
          n[o[0].id] = o[1];
        }
    }
    return i;
  }
  /**
  Retrieves a node prop for this type. Will return `undefined` if
  the prop isn't present on this node.
  */
  prop(e) {
    return this.props[e.id];
  }
  /**
  True when this is the top node of a grammar.
  */
  get isTop() {
    return (this.flags & 1) > 0;
  }
  /**
  True when this node is produced by a skip rule.
  */
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  /**
  Indicates whether this is an error node.
  */
  get isError() {
    return (this.flags & 4) > 0;
  }
  /**
  When true, this node type doesn't correspond to a user-declared
  named node, for example because it is used to cache repetition.
  */
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  /**
  Returns true when this node's name or one of its
  [groups](#common.NodeProp^group) matches the given string.
  */
  is(e) {
    if (typeof e == "string") {
      if (this.name == e)
        return true;
      let n = this.prop(Xe.group);
      return n ? n.indexOf(e) > -1 : false;
    }
    return this.id == e;
  }
  /**
  Create a function from node types to arbitrary values by
  specifying an object whose property names are node or
  [group](#common.NodeProp^group) names. Often useful with
  [`NodeProp.add`](#common.NodeProp.add). You can put multiple
  names, separated by spaces, in a single property name to map
  multiple node names to a single value.
  */
  static match(e) {
    let n = /* @__PURE__ */ Object.create(null);
    for (let r in e)
      for (let i of r.split(" "))
        n[i] = e[r];
    return (r) => {
      for (let i = r.prop(Xe.group), o = -1; o < (i ? i.length : 0); o++) {
        let s = n[o < 0 ? r.name : i[o]];
        if (s)
          return s;
      }
    };
  }
};
Hn.none = new Hn(
  "",
  /* @__PURE__ */ Object.create(null),
  0,
  8
  /* NodeFlag.Anonymous */
);
var Tx = class {
  /**
  Create a set with the given types. The `id` property of each
  type should correspond to its position within the array.
  */
  constructor(e) {
    this.types = e;
    for (let n = 0; n < e.length; n++)
      if (e[n].id != n)
        throw new RangeError("Node type ids should correspond to array positions when creating a node set");
  }
  /**
  Create a copy of this set with some node properties added. The
  arguments to this method can be created with
  [`NodeProp.add`](#common.NodeProp.add).
  */
  extend(...e) {
    let n = [];
    for (let r of this.types) {
      let i = null;
      for (let o of e) {
        let s = o(r);
        s && (i || (i = Object.assign({}, r.props)), i[s[0].id] = s[1]);
      }
      n.push(i ? new Hn(r.name, i, r.id, r.flags) : r);
    }
    return new Tx(n);
  }
};
var Qu = /* @__PURE__ */ new WeakMap();
var R1 = /* @__PURE__ */ new WeakMap();
var Rt;
(function(t4) {
  t4[t4.ExcludeBuffers = 1] = "ExcludeBuffers", t4[t4.IncludeAnonymous = 2] = "IncludeAnonymous", t4[t4.IgnoreMounts = 4] = "IgnoreMounts", t4[t4.IgnoreOverlays = 8] = "IgnoreOverlays";
})(Rt || (Rt = {}));
var Zt = class {
  /**
  Construct a new tree. See also [`Tree.build`](#common.Tree^build).
  */
  constructor(e, n, r, i, o) {
    if (this.type = e, this.children = n, this.positions = r, this.length = i, this.props = null, o && o.length) {
      this.props = /* @__PURE__ */ Object.create(null);
      for (let [s, a] of o)
        this.props[typeof s == "number" ? s : s.id] = a;
    }
  }
  /**
  @internal
  */
  toString() {
    let e = lc.get(this);
    if (e && !e.overlay)
      return e.tree.toString();
    let n = "";
    for (let r of this.children) {
      let i = r.toString();
      i && (n && (n += ","), n += i);
    }
    return this.type.name ? (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (n.length ? "(" + n + ")" : "") : n;
  }
  /**
  Get a [tree cursor](#common.TreeCursor) positioned at the top of
  the tree. Mode can be used to [control](#common.IterMode) which
  nodes the cursor visits.
  */
  cursor(e = 0) {
    return new od(this.topNode, e);
  }
  /**
  Get a [tree cursor](#common.TreeCursor) pointing into this tree
  at the given position and side (see
  [`moveTo`](#common.TreeCursor.moveTo).
  */
  cursorAt(e, n = 0, r = 0) {
    let i = Qu.get(this) || this.topNode, o = new od(i);
    return o.moveTo(e, n), Qu.set(this, o._tree), o;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) object for the top of the
  tree.
  */
  get topNode() {
    return new Nn(this, 0, 0, null);
  }
  /**
  Get the [syntax node](#common.SyntaxNode) at the given position.
  If `side` is -1, this will move into nodes that end at the
  position. If 1, it'll move into nodes that start at the
  position. With 0, it'll only enter nodes that cover the position
  from both sides.
  
  Note that this will not enter
  [overlays](#common.MountedTree.overlay), and you often want
  [`resolveInner`](#common.Tree.resolveInner) instead.
  */
  resolve(e, n = 0) {
    let r = cc(Qu.get(this) || this.topNode, e, n, false);
    return Qu.set(this, r), r;
  }
  /**
  Like [`resolve`](#common.Tree.resolve), but will enter
  [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
  pointing into the innermost overlaid tree at the given position
  (with parent links going through all parent structure, including
  the host trees).
  */
  resolveInner(e, n = 0) {
    let r = cc(R1.get(this) || this.topNode, e, n, true);
    return R1.set(this, r), r;
  }
  /**
  In some situations, it can be useful to iterate through all
  nodes around a position, including those in overlays that don't
  directly cover the position. This method gives you an iterator
  that will produce all nodes, from small to big, around the given
  position.
  */
  resolveStack(e, n = 0) {
    return U6(this, e, n);
  }
  /**
  Iterate over the tree and its children, calling `enter` for any
  node that touches the `from`/`to` region (if given) before
  running over such a node's children, and `leave` (if given) when
  leaving the node. When `enter` returns `false`, that node will
  not have its children iterated over (or `leave` called).
  */
  iterate(e) {
    let { enter: n, leave: r, from: i = 0, to: o = this.length } = e, s = e.mode || 0, a = (s & Rt.IncludeAnonymous) > 0;
    for (let l = this.cursor(s | Rt.IncludeAnonymous); ; ) {
      let c = false;
      if (l.from <= o && l.to >= i && (!a && l.type.isAnonymous || n(l) !== false)) {
        if (l.firstChild())
          continue;
        c = true;
      }
      for (; c && r && (a || !l.type.isAnonymous) && r(l), !l.nextSibling(); ) {
        if (!l.parent())
          return;
        c = true;
      }
    }
  }
  /**
  Get the value of the given [node prop](#common.NodeProp) for this
  node. Works with both per-node and per-type props.
  */
  prop(e) {
    return e.perNode ? this.props ? this.props[e.id] : void 0 : this.type.prop(e);
  }
  /**
  Returns the node's [per-node props](#common.NodeProp.perNode) in a
  format that can be passed to the [`Tree`](#common.Tree)
  constructor.
  */
  get propValues() {
    let e = [];
    if (this.props)
      for (let n in this.props)
        e.push([+n, this.props[n]]);
    return e;
  }
  /**
  Balance the direct children of this tree, producing a copy of
  which may have children grouped into subtrees with type
  [`NodeType.none`](#common.NodeType^none).
  */
  balance(e = {}) {
    return this.children.length <= 8 ? this : jx(Hn.none, this.children, this.positions, 0, this.children.length, 0, this.length, (n, r, i) => new Zt(this.type, n, r, i, this.propValues), e.makeTree || ((n, r, i) => new Zt(Hn.none, n, r, i)));
  }
  /**
  Build a tree from a postfix-ordered buffer of node information,
  or a cursor over such a buffer.
  */
  static build(e) {
    return H6(e);
  }
};
Zt.empty = new Zt(Hn.none, [], [], 0);
var Ix = class {
  constructor(e, n) {
    this.buffer = e, this.index = n;
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new Ix(this.buffer, this.index);
  }
};
var Ro = class {
  /**
  Create a tree buffer.
  */
  constructor(e, n, r) {
    this.buffer = e, this.length = n, this.set = r;
  }
  /**
  @internal
  */
  get type() {
    return Hn.none;
  }
  /**
  @internal
  */
  toString() {
    let e = [];
    for (let n = 0; n < this.buffer.length; )
      e.push(this.childString(n)), n = this.buffer[n + 3];
    return e.join(",");
  }
  /**
  @internal
  */
  childString(e) {
    let n = this.buffer[e], r = this.buffer[e + 3], i = this.set.types[n], o = i.name;
    if (/\W/.test(o) && !i.isError && (o = JSON.stringify(o)), e += 4, r == e)
      return o;
    let s = [];
    for (; e < r; )
      s.push(this.childString(e)), e = this.buffer[e + 3];
    return o + "(" + s.join(",") + ")";
  }
  /**
  @internal
  */
  findChild(e, n, r, i, o) {
    let { buffer: s } = this, a = -1;
    for (let l = e; l != n && !(iT(o, i, s[l + 1], s[l + 2]) && (a = l, r > 0)); l = s[l + 3])
      ;
    return a;
  }
  /**
  @internal
  */
  slice(e, n, r) {
    let i = this.buffer, o = new Uint16Array(n - e), s = 0;
    for (let a = e, l = 0; a < n; ) {
      o[l++] = i[a++], o[l++] = i[a++] - r;
      let c = o[l++] = i[a++] - r;
      o[l++] = i[a++] - e, s = Math.max(s, c);
    }
    return new Ro(o, s, this.set);
  }
};
function iT(t4, e, n, r) {
  switch (t4) {
    case -2:
      return n < e;
    case -1:
      return r >= e && n < e;
    case 0:
      return n < e && r > e;
    case 1:
      return n <= e && r > e;
    case 2:
      return r > e;
    case 4:
      return true;
  }
}
function cc(t4, e, n, r) {
  for (var i; t4.from == t4.to || (n < 1 ? t4.from >= e : t4.from > e) || (n > -1 ? t4.to <= e : t4.to < e); ) {
    let s = !r && t4 instanceof Nn && t4.index < 0 ? null : t4.parent;
    if (!s)
      return t4;
    t4 = s;
  }
  let o = r ? 0 : Rt.IgnoreOverlays;
  if (r)
    for (let s = t4, a = s.parent; a; s = a, a = s.parent)
      s instanceof Nn && s.index < 0 && ((i = a.enter(e, n, o)) === null || i === void 0 ? void 0 : i.from) != s.from && (t4 = a);
  for (; ; ) {
    let s = t4.enter(e, n, o);
    if (!s)
      return t4;
    t4 = s;
  }
}
var oT = class {
  cursor(e = 0) {
    return new od(this, e);
  }
  getChild(e, n = null, r = null) {
    let i = D1(this, e, n, r);
    return i.length ? i[0] : null;
  }
  getChildren(e, n = null, r = null) {
    return D1(this, e, n, r);
  }
  resolve(e, n = 0) {
    return cc(this, e, n, false);
  }
  resolveInner(e, n = 0) {
    return cc(this, e, n, true);
  }
  matchContext(e) {
    return Am(this, e);
  }
  enterUnfinishedNodesBefore(e) {
    let n = this.childBefore(e), r = this;
    for (; n; ) {
      let i = n.lastChild;
      if (!i || i.to != n.to)
        break;
      i.type.isError && i.from == i.to ? (r = n, n = i.prevSibling) : n = i;
    }
    return r;
  }
  get node() {
    return this;
  }
  get next() {
    return this.parent;
  }
};
var Nn = class extends oT {
  constructor(e, n, r, i) {
    super(), this._tree = e, this.from = n, this.index = r, this._parent = i;
  }
  get type() {
    return this._tree.type;
  }
  get name() {
    return this._tree.type.name;
  }
  get to() {
    return this.from + this._tree.length;
  }
  nextChild(e, n, r, i, o = 0) {
    for (let s = this; ; ) {
      for (let { children: a, positions: l } = s._tree, c = n > 0 ? a.length : -1; e != c; e += n) {
        let u = a[e], f = l[e] + s.from;
        if (iT(i, r, f, f + u.length)) {
          if (u instanceof Ro) {
            if (o & Rt.ExcludeBuffers)
              continue;
            let d = u.findChild(0, u.buffer.length, n, r - f, i);
            if (d > -1)
              return new mi(new Y6(s, u, e, f), null, d);
          } else if (o & Rt.IncludeAnonymous || !u.type.isAnonymous || $x(u)) {
            let d;
            if (!(o & Rt.IgnoreMounts) && (d = lc.get(u)) && !d.overlay)
              return new Nn(d.tree, f, e, s);
            let h = new Nn(u, f, e, s);
            return o & Rt.IncludeAnonymous || !h.type.isAnonymous ? h : h.nextChild(n < 0 ? u.children.length - 1 : 0, n, r, i);
          }
        }
      }
      if (o & Rt.IncludeAnonymous || !s.type.isAnonymous || (s.index >= 0 ? e = s.index + n : e = n < 0 ? -1 : s._parent._tree.children.length, s = s._parent, !s))
        return null;
    }
  }
  get firstChild() {
    return this.nextChild(
      0,
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(e) {
    return this.nextChild(
      0,
      1,
      e,
      2
      /* Side.After */
    );
  }
  childBefore(e) {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  enter(e, n, r = 0) {
    let i;
    if (!(r & Rt.IgnoreOverlays) && (i = lc.get(this._tree)) && i.overlay) {
      let o = e - this.from;
      for (let { from: s, to: a } of i.overlay)
        if ((n > 0 ? s <= o : s < o) && (n < 0 ? a >= o : a > o))
          return new Nn(i.tree, i.overlay[0].from + this.from, -1, this);
    }
    return this.nextChild(0, 1, e, n, r);
  }
  nextSignificantParent() {
    let e = this;
    for (; e.type.isAnonymous && e._parent; )
      e = e._parent;
    return e;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index + 1,
      1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get tree() {
    return this._tree;
  }
  toTree() {
    return this._tree;
  }
  /**
  @internal
  */
  toString() {
    return this._tree.toString();
  }
};
function D1(t4, e, n, r) {
  let i = t4.cursor(), o = [];
  if (!i.firstChild())
    return o;
  if (n != null) {
    for (let s = false; !s; )
      if (s = i.type.is(n), !i.nextSibling())
        return o;
  }
  for (; ; ) {
    if (r != null && i.type.is(r))
      return o;
    if (i.type.is(e) && o.push(i.node), !i.nextSibling())
      return r == null ? o : [];
  }
}
function Am(t4, e, n = e.length - 1) {
  for (let r = t4.parent; n >= 0; r = r.parent) {
    if (!r)
      return false;
    if (!r.type.isAnonymous) {
      if (e[n] && e[n] != r.name)
        return false;
      n--;
    }
  }
  return true;
}
var Y6 = class {
  constructor(e, n, r, i) {
    this.parent = e, this.buffer = n, this.index = r, this.start = i;
  }
};
var mi = class extends oT {
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  constructor(e, n, r) {
    super(), this.context = e, this._parent = n, this.index = r, this.type = e.buffer.set.types[e.buffer.buffer[r]];
  }
  child(e, n, r) {
    let { buffer: i } = this.context, o = i.findChild(this.index + 4, i.buffer[this.index + 3], e, n - this.context.start, r);
    return o < 0 ? null : new mi(this.context, this, o);
  }
  get firstChild() {
    return this.child(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.child(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(e) {
    return this.child(
      1,
      e,
      2
      /* Side.After */
    );
  }
  childBefore(e) {
    return this.child(
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  enter(e, n, r = 0) {
    if (r & Rt.ExcludeBuffers)
      return null;
    let { buffer: i } = this.context, o = i.findChild(this.index + 4, i.buffer[this.index + 3], n > 0 ? 1 : -1, e - this.context.start, n);
    return o < 0 ? null : new mi(this.context, this, o);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(e) {
    return this._parent ? null : this.context.parent.nextChild(
      this.context.index + e,
      e,
      0,
      4
      /* Side.DontCare */
    );
  }
  get nextSibling() {
    let { buffer: e } = this.context, n = e.buffer[this.index + 3];
    return n < (this._parent ? e.buffer[this._parent.index + 3] : e.buffer.length) ? new mi(this.context, this._parent, n) : this.externalSibling(1);
  }
  get prevSibling() {
    let { buffer: e } = this.context, n = this._parent ? this._parent.index + 4 : 0;
    return this.index == n ? this.externalSibling(-1) : new mi(this.context, this._parent, e.findChild(
      n,
      this.index,
      -1,
      0,
      4
      /* Side.DontCare */
    ));
  }
  get tree() {
    return null;
  }
  toTree() {
    let e = [], n = [], { buffer: r } = this.context, i = this.index + 4, o = r.buffer[this.index + 3];
    if (o > i) {
      let s = r.buffer[this.index + 1];
      e.push(r.slice(i, o, s)), n.push(0);
    }
    return new Zt(this.type, e, n, this.to - this.from);
  }
  /**
  @internal
  */
  toString() {
    return this.context.buffer.childString(this.index);
  }
};
function sT(t4) {
  if (!t4.length)
    return null;
  let e = 0, n = t4[0];
  for (let o = 1; o < t4.length; o++) {
    let s = t4[o];
    (s.from > n.from || s.to < n.to) && (n = s, e = o);
  }
  let r = n instanceof Nn && n.index < 0 ? null : n.parent, i = t4.slice();
  return r ? i[e] = r : i.splice(e, 1), new q6(i, n);
}
var q6 = class {
  constructor(e, n) {
    this.heads = e, this.node = n;
  }
  get next() {
    return sT(this.heads);
  }
};
function U6(t4, e, n) {
  let r = t4.resolveInner(e, n), i = null;
  for (let o = r instanceof Nn ? r : r.context.parent; o; o = o.parent)
    if (o.index < 0) {
      let s = o.parent;
      (i || (i = [r])).push(s.resolve(e, n)), o = s;
    } else {
      let s = lc.get(o.tree);
      if (s && s.overlay && s.overlay[0].from <= e && s.overlay[s.overlay.length - 1].to >= e) {
        let a = new Nn(s.tree, s.overlay[0].from + o.from, -1, o);
        (i || (i = [r])).push(cc(a, e, n, false));
      }
    }
  return i ? sT(i) : r;
}
var od = class {
  /**
  Shorthand for `.type.name`.
  */
  get name() {
    return this.type.name;
  }
  /**
  @internal
  */
  constructor(e, n = 0) {
    if (this.mode = n, this.buffer = null, this.stack = [], this.index = 0, this.bufferNode = null, e instanceof Nn)
      this.yieldNode(e);
    else {
      this._tree = e.context.parent, this.buffer = e.context;
      for (let r = e._parent; r; r = r._parent)
        this.stack.unshift(r.index);
      this.bufferNode = e, this.yieldBuf(e.index);
    }
  }
  yieldNode(e) {
    return e ? (this._tree = e, this.type = e.type, this.from = e.from, this.to = e.to, true) : false;
  }
  yieldBuf(e, n) {
    this.index = e;
    let { start: r, buffer: i } = this.buffer;
    return this.type = n || i.set.types[i.buffer[e]], this.from = r + i.buffer[e + 1], this.to = r + i.buffer[e + 2], true;
  }
  /**
  @internal
  */
  yield(e) {
    return e ? e instanceof Nn ? (this.buffer = null, this.yieldNode(e)) : (this.buffer = e.context, this.yieldBuf(e.index, e.type)) : false;
  }
  /**
  @internal
  */
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  /**
  @internal
  */
  enterChild(e, n, r) {
    if (!this.buffer)
      return this.yield(this._tree.nextChild(e < 0 ? this._tree._tree.children.length - 1 : 0, e, n, r, this.mode));
    let { buffer: i } = this.buffer, o = i.findChild(this.index + 4, i.buffer[this.index + 3], e, n - this.buffer.start, r);
    return o < 0 ? false : (this.stack.push(this.index), this.yieldBuf(o));
  }
  /**
  Move the cursor to this node's first child. When this returns
  false, the node has no child, and the cursor has not been moved.
  */
  firstChild() {
    return this.enterChild(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to this node's last child.
  */
  lastChild() {
    return this.enterChild(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to the first child that ends after `pos`.
  */
  childAfter(e) {
    return this.enterChild(
      1,
      e,
      2
      /* Side.After */
    );
  }
  /**
  Move to the last child that starts before `pos`.
  */
  childBefore(e) {
    return this.enterChild(
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  /**
  Move the cursor to the child around `pos`. If side is -1 the
  child may end at that position, when 1 it may start there. This
  will also enter [overlaid](#common.MountedTree.overlay)
  [mounted](#common.NodeProp^mounted) trees unless `overlays` is
  set to false.
  */
  enter(e, n, r = this.mode) {
    return this.buffer ? r & Rt.ExcludeBuffers ? false : this.enterChild(1, e, n) : this.yield(this._tree.enter(e, n, r));
  }
  /**
  Move to the node's parent node, if this isn't the top node.
  */
  parent() {
    if (!this.buffer)
      return this.yieldNode(this.mode & Rt.IncludeAnonymous ? this._tree._parent : this._tree.parent);
    if (this.stack.length)
      return this.yieldBuf(this.stack.pop());
    let e = this.mode & Rt.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    return this.buffer = null, this.yieldNode(e);
  }
  /**
  @internal
  */
  sibling(e) {
    if (!this.buffer)
      return this._tree._parent ? this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + e, e, 0, 4, this.mode)) : false;
    let { buffer: n } = this.buffer, r = this.stack.length - 1;
    if (e < 0) {
      let i = r < 0 ? 0 : this.stack[r] + 4;
      if (this.index != i)
        return this.yieldBuf(n.findChild(
          i,
          this.index,
          -1,
          0,
          4
          /* Side.DontCare */
        ));
    } else {
      let i = n.buffer[this.index + 3];
      if (i < (r < 0 ? n.buffer.length : n.buffer[this.stack[r] + 3]))
        return this.yieldBuf(i);
    }
    return r < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + e, e, 0, 4, this.mode)) : false;
  }
  /**
  Move to this node's next sibling, if any.
  */
  nextSibling() {
    return this.sibling(1);
  }
  /**
  Move to this node's previous sibling, if any.
  */
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(e) {
    let n, r, { buffer: i } = this;
    if (i) {
      if (e > 0) {
        if (this.index < i.buffer.buffer.length)
          return false;
      } else
        for (let o = 0; o < this.index; o++)
          if (i.buffer.buffer[o + 3] < this.index)
            return false;
      ({ index: n, parent: r } = i);
    } else
      ({ index: n, _parent: r } = this._tree);
    for (; r; { index: n, _parent: r } = r)
      if (n > -1)
        for (let o = n + e, s = e < 0 ? -1 : r._tree.children.length; o != s; o += e) {
          let a = r._tree.children[o];
          if (this.mode & Rt.IncludeAnonymous || a instanceof Ro || !a.type.isAnonymous || $x(a))
            return false;
        }
    return true;
  }
  move(e, n) {
    if (n && this.enterChild(
      e,
      0,
      4
      /* Side.DontCare */
    ))
      return true;
    for (; ; ) {
      if (this.sibling(e))
        return true;
      if (this.atLastNode(e) || !this.parent())
        return false;
    }
  }
  /**
  Move to the next node in a
  [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)
  traversal, going from a node to its first child or, if the
  current node is empty or `enter` is false, its next sibling or
  the next sibling of the first parent node that has one.
  */
  next(e = true) {
    return this.move(1, e);
  }
  /**
  Move to the next node in a last-to-first pre-order traveral. A
  node is followed by its last child or, if it has none, its
  previous sibling or the previous sibling of the first parent
  node that has one.
  */
  prev(e = true) {
    return this.move(-1, e);
  }
  /**
  Move the cursor to the innermost node that covers `pos`. If
  `side` is -1, it will enter nodes that end at `pos`. If it is 1,
  it will enter nodes that start at `pos`.
  */
  moveTo(e, n = 0) {
    for (; (this.from == this.to || (n < 1 ? this.from >= e : this.from > e) || (n > -1 ? this.to <= e : this.to < e)) && this.parent(); )
      ;
    for (; this.enterChild(1, e, n); )
      ;
    return this;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) at the cursor's current
  position.
  */
  get node() {
    if (!this.buffer)
      return this._tree;
    let e = this.bufferNode, n = null, r = 0;
    if (e && e.context == this.buffer)
      e:
        for (let i = this.index, o = this.stack.length; o >= 0; ) {
          for (let s = e; s; s = s._parent)
            if (s.index == i) {
              if (i == this.index)
                return s;
              n = s, r = o + 1;
              break e;
            }
          i = this.stack[--o];
        }
    for (let i = r; i < this.stack.length; i++)
      n = new mi(this.buffer, n, this.stack[i]);
    return this.bufferNode = new mi(this.buffer, n, this.index);
  }
  /**
  Get the [tree](#common.Tree) that represents the current node, if
  any. Will return null when the node is in a [tree
  buffer](#common.TreeBuffer).
  */
  get tree() {
    return this.buffer ? null : this._tree._tree;
  }
  /**
  Iterate over the current node and all its descendants, calling
  `enter` when entering a node and `leave`, if given, when leaving
  one. When `enter` returns `false`, any children of that node are
  skipped, and `leave` isn't called for it.
  */
  iterate(e, n) {
    for (let r = 0; ; ) {
      let i = false;
      if (this.type.isAnonymous || e(this) !== false) {
        if (this.firstChild()) {
          r++;
          continue;
        }
        this.type.isAnonymous || (i = true);
      }
      for (; i && n && n(this), i = this.type.isAnonymous, !this.nextSibling(); ) {
        if (!r)
          return;
        this.parent(), r--, i = true;
      }
    }
  }
  /**
  Test whether the current node matches a given context—a sequence
  of direct parent node names. Empty strings in the context array
  are treated as wildcards.
  */
  matchContext(e) {
    if (!this.buffer)
      return Am(this.node, e);
    let { buffer: n } = this.buffer, { types: r } = n.set;
    for (let i = e.length - 1, o = this.stack.length - 1; i >= 0; o--) {
      if (o < 0)
        return Am(this.node, e, i);
      let s = r[n.buffer[this.stack[o]]];
      if (!s.isAnonymous) {
        if (e[i] && e[i] != s.name)
          return false;
        i--;
      }
    }
    return true;
  }
};
function $x(t4) {
  return t4.children.some((e) => e instanceof Ro || !e.type.isAnonymous || $x(e));
}
function H6(t4) {
  var e;
  let { buffer: n, nodeSet: r, maxBufferLength: i = rT, reused: o = [], minRepeatType: s = r.types.length } = t4, a = Array.isArray(n) ? new Ix(n, n.length) : n, l = r.types, c = 0, u = 0;
  function f(b, w, C, k, T, A) {
    let { id: E, start: $, end: j, size: B } = a, D = u;
    for (; B < 0; )
      if (a.next(), B == -1) {
        let L = o[E];
        C.push(L), k.push($ - b);
        return;
      } else if (B == -3) {
        c = E;
        return;
      } else if (B == -4) {
        u = E;
        return;
      } else
        throw new RangeError(`Unrecognized record size: ${B}`);
    let N = l[E], z, Z, J = $ - b;
    if (j - $ <= i && (Z = m(a.pos - w, T))) {
      let L = new Uint16Array(Z.size - Z.skip), W = a.pos - Z.size, R = L.length;
      for (; a.pos > W; )
        R = x(Z.start, L, R);
      z = new Ro(L, j - Z.start, r), J = Z.start - b;
    } else {
      let L = a.pos - B;
      a.next();
      let W = [], R = [], Q = E >= s ? E : -1, _ = 0, G = j;
      for (; a.pos > L; )
        Q >= 0 && a.id == Q && a.size >= 0 ? (a.end <= G - i && (p(W, R, $, _, a.end, G, Q, D), _ = W.length, G = a.end), a.next()) : A > 2500 ? d($, L, W, R) : f($, L, W, R, Q, A + 1);
      if (Q >= 0 && _ > 0 && _ < W.length && p(W, R, $, _, $, G, Q, D), W.reverse(), R.reverse(), Q > -1 && _ > 0) {
        let M = h(N);
        z = jx(N, W, R, 0, W.length, 0, j - $, M, M);
      } else
        z = O(N, W, R, j - $, D - j);
    }
    C.push(z), k.push(J);
  }
  function d(b, w, C, k) {
    let T = [], A = 0, E = -1;
    for (; a.pos > w; ) {
      let { id: $, start: j, end: B, size: D } = a;
      if (D > 4)
        a.next();
      else {
        if (E > -1 && j < E)
          break;
        E < 0 && (E = B - i), T.push($, j, B), A++, a.next();
      }
    }
    if (A) {
      let $ = new Uint16Array(A * 4), j = T[T.length - 2];
      for (let B = T.length - 3, D = 0; B >= 0; B -= 3)
        $[D++] = T[B], $[D++] = T[B + 1] - j, $[D++] = T[B + 2] - j, $[D++] = D;
      C.push(new Ro($, T[2] - j, r)), k.push(j - b);
    }
  }
  function h(b) {
    return (w, C, k) => {
      let T = 0, A = w.length - 1, E, $;
      if (A >= 0 && (E = w[A]) instanceof Zt) {
        if (!A && E.type == b && E.length == k)
          return E;
        ($ = E.prop(Xe.lookAhead)) && (T = C[A] + E.length + $);
      }
      return O(b, w, C, k, T);
    };
  }
  function p(b, w, C, k, T, A, E, $) {
    let j = [], B = [];
    for (; b.length > k; )
      j.push(b.pop()), B.push(w.pop() + C - T);
    b.push(O(r.types[E], j, B, A - T, $ - A)), w.push(T - C);
  }
  function O(b, w, C, k, T = 0, A) {
    if (c) {
      let E = [Xe.contextHash, c];
      A = A ? [E].concat(A) : [E];
    }
    if (T > 25) {
      let E = [Xe.lookAhead, T];
      A = A ? [E].concat(A) : [E];
    }
    return new Zt(b, w, C, k, A);
  }
  function m(b, w) {
    let C = a.fork(), k = 0, T = 0, A = 0, E = C.end - i, $ = { size: 0, start: 0, skip: 0 };
    e:
      for (let j = C.pos - b; C.pos > j; ) {
        let B = C.size;
        if (C.id == w && B >= 0) {
          $.size = k, $.start = T, $.skip = A, A += 4, k += 4, C.next();
          continue;
        }
        let D = C.pos - B;
        if (B < 0 || D < j || C.start < E)
          break;
        let N = C.id >= s ? 4 : 0, z = C.start;
        for (C.next(); C.pos > D; ) {
          if (C.size < 0)
            if (C.size == -3)
              N += 4;
            else
              break e;
          else
            C.id >= s && (N += 4);
          C.next();
        }
        T = z, k += B, A += N;
      }
    return (w < 0 || k == b) && ($.size = k, $.start = T, $.skip = A), $.size > 4 ? $ : void 0;
  }
  function x(b, w, C) {
    let { id: k, start: T, end: A, size: E } = a;
    if (a.next(), E >= 0 && k < s) {
      let $ = C;
      if (E > 4) {
        let j = a.pos - (E - 4);
        for (; a.pos > j; )
          C = x(b, w, C);
      }
      w[--C] = $, w[--C] = A - b, w[--C] = T - b, w[--C] = k;
    } else
      E == -3 ? c = k : E == -4 && (u = k);
    return C;
  }
  let v = [], y = [];
  for (; a.pos > 0; )
    f(t4.start || 0, t4.bufferStart || 0, v, y, -1, 0);
  let S = (e = t4.length) !== null && e !== void 0 ? e : v.length ? y[0] + v[0].length : 0;
  return new Zt(l[t4.topID], v.reverse(), y.reverse(), S);
}
var Q1 = /* @__PURE__ */ new WeakMap();
function mf(t4, e) {
  if (!t4.isAnonymous || e instanceof Ro || e.type != t4)
    return 1;
  let n = Q1.get(e);
  if (n == null) {
    n = 1;
    for (let r of e.children) {
      if (r.type != t4 || !(r instanceof Zt)) {
        n = 1;
        break;
      }
      n += mf(t4, r);
    }
    Q1.set(e, n);
  }
  return n;
}
function jx(t4, e, n, r, i, o, s, a, l) {
  let c = 0;
  for (let p = r; p < i; p++)
    c += mf(t4, e[p]);
  let u = Math.ceil(
    c * 1.5 / 8
    /* Balance.BranchFactor */
  ), f = [], d = [];
  function h(p, O, m, x, v) {
    for (let y = m; y < x; ) {
      let S = y, b = O[y], w = mf(t4, p[y]);
      for (y++; y < x; y++) {
        let C = mf(t4, p[y]);
        if (w + C >= u)
          break;
        w += C;
      }
      if (y == S + 1) {
        if (w > u) {
          let C = p[S];
          h(C.children, C.positions, 0, C.children.length, O[S] + v);
          continue;
        }
        f.push(p[S]);
      } else {
        let C = O[y - 1] + p[y - 1].length - b;
        f.push(jx(t4, p, O, S, y, b, C, null, l));
      }
      d.push(b + v - o);
    }
  }
  return h(e, n, r, i, 0), (a || l)(f, d, s);
}
var aT = class {
  constructor() {
    this.map = /* @__PURE__ */ new WeakMap();
  }
  setBuffer(e, n, r) {
    let i = this.map.get(e);
    i || this.map.set(e, i = /* @__PURE__ */ new Map()), i.set(n, r);
  }
  getBuffer(e, n) {
    let r = this.map.get(e);
    return r && r.get(n);
  }
  /**
  Set the value for this syntax node.
  */
  set(e, n) {
    e instanceof mi ? this.setBuffer(e.context.buffer, e.index, n) : e instanceof Nn && this.map.set(e.tree, n);
  }
  /**
  Retrieve value for this syntax node, if it exists in the map.
  */
  get(e) {
    return e instanceof mi ? this.getBuffer(e.context.buffer, e.index) : e instanceof Nn ? this.map.get(e.tree) : void 0;
  }
  /**
  Set the value for the node that a cursor currently points to.
  */
  cursorSet(e, n) {
    e.buffer ? this.setBuffer(e.buffer.buffer, e.index, n) : this.map.set(e.tree, n);
  }
  /**
  Retrieve the value for the node that a cursor currently points
  to.
  */
  cursorGet(e) {
    return e.buffer ? this.getBuffer(e.buffer.buffer, e.index) : this.map.get(e.tree);
  }
};
var Gi = class {
  /**
  Construct a tree fragment. You'll usually want to use
  [`addTree`](#common.TreeFragment^addTree) and
  [`applyChanges`](#common.TreeFragment^applyChanges) instead of
  calling this directly.
  */
  constructor(e, n, r, i, o = false, s = false) {
    this.from = e, this.to = n, this.tree = r, this.offset = i, this.open = (o ? 1 : 0) | (s ? 2 : 0);
  }
  /**
  Whether the start of the fragment represents the start of a
  parse, or the end of a change. (In the second case, it may not
  be safe to reuse some nodes at the start, depending on the
  parsing algorithm.)
  */
  get openStart() {
    return (this.open & 1) > 0;
  }
  /**
  Whether the end of the fragment represents the end of a
  full-document parse, or the start of a change.
  */
  get openEnd() {
    return (this.open & 2) > 0;
  }
  /**
  Create a set of fragments from a freshly parsed tree, or update
  an existing set of fragments by replacing the ones that overlap
  with a tree with content from the new tree. When `partial` is
  true, the parse is treated as incomplete, and the resulting
  fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
  true.
  */
  static addTree(e, n = [], r = false) {
    let i = [new Gi(0, e.length, e, 0, false, r)];
    for (let o of n)
      o.to > e.length && i.push(o);
    return i;
  }
  /**
  Apply a set of edits to an array of fragments, removing or
  splitting fragments as necessary to remove edited ranges, and
  adjusting offsets for fragments that moved.
  */
  static applyChanges(e, n, r = 128) {
    if (!n.length)
      return e;
    let i = [], o = 1, s = e.length ? e[0] : null;
    for (let a = 0, l = 0, c = 0; ; a++) {
      let u = a < n.length ? n[a] : null, f = u ? u.fromA : 1e9;
      if (f - l >= r)
        for (; s && s.from < f; ) {
          let d = s;
          if (l >= d.from || f <= d.to || c) {
            let h = Math.max(d.from, l) - c, p = Math.min(d.to, f) - c;
            d = h >= p ? null : new Gi(h, p, d.tree, d.offset + c, a > 0, !!u);
          }
          if (d && i.push(d), s.to > f)
            break;
          s = o < e.length ? e[o++] : null;
        }
      if (!u)
        break;
      l = u.toA, c = u.toA - u.toB;
    }
    return i;
  }
};
var lT = class {
  /**
  Start a parse, returning a [partial parse](#common.PartialParse)
  object. [`fragments`](#common.TreeFragment) can be passed in to
  make the parse incremental.
  
  By default, the entire input is parsed. You can pass `ranges`,
  which should be a sorted array of non-empty, non-overlapping
  ranges, to parse only those ranges. The tree returned in that
  case will start at `ranges[0].from`.
  */
  startParse(e, n, r) {
    return typeof e == "string" && (e = new J6(e)), r = r ? r.length ? r.map((i) => new Rr(i.from, i.to)) : [new Rr(0, 0)] : [new Rr(0, e.length)], this.createParse(e, n || [], r);
  }
  /**
  Run a full parse, returning the resulting tree.
  */
  parse(e, n, r) {
    let i = this.startParse(e, n, r);
    for (; ; ) {
      let o = i.advance();
      if (o)
        return o;
    }
  }
};
var J6 = class {
  constructor(e) {
    this.string = e;
  }
  get length() {
    return this.string.length;
  }
  chunk(e) {
    return this.string.slice(e);
  }
  get lineChunks() {
    return false;
  }
  read(e, n) {
    return this.string.slice(e, n);
  }
};
function K6(t4) {
  return (e, n, r, i) => new tW(e, t4, n, r, i);
}
var B1 = class {
  constructor(e, n, r, i, o) {
    this.parser = e, this.parse = n, this.overlay = r, this.target = i, this.from = o;
  }
};
function _1(t4) {
  if (!t4.length || t4.some((e) => e.from >= e.to))
    throw new RangeError("Invalid inner parse ranges given: " + JSON.stringify(t4));
}
var eW = class {
  constructor(e, n, r, i, o, s, a) {
    this.parser = e, this.predicate = n, this.mounts = r, this.index = i, this.start = o, this.target = s, this.prev = a, this.depth = 0, this.ranges = [];
  }
};
var Pm = new Xe({ perNode: true });
var tW = class {
  constructor(e, n, r, i, o) {
    this.nest = n, this.input = r, this.fragments = i, this.ranges = o, this.inner = [], this.innerDone = 0, this.baseTree = null, this.stoppedAt = null, this.baseParse = e;
  }
  advance() {
    if (this.baseParse) {
      let r = this.baseParse.advance();
      if (!r)
        return null;
      if (this.baseParse = null, this.baseTree = r, this.startInner(), this.stoppedAt != null)
        for (let i of this.inner)
          i.parse.stopAt(this.stoppedAt);
    }
    if (this.innerDone == this.inner.length) {
      let r = this.baseTree;
      return this.stoppedAt != null && (r = new Zt(r.type, r.children, r.positions, r.length, r.propValues.concat([[Pm, this.stoppedAt]]))), r;
    }
    let e = this.inner[this.innerDone], n = e.parse.advance();
    if (n) {
      this.innerDone++;
      let r = Object.assign(/* @__PURE__ */ Object.create(null), e.target.props);
      r[Xe.mounted.id] = new lc(n, e.overlay, e.parser), e.target.props = r;
    }
    return null;
  }
  get parsedPos() {
    if (this.baseParse)
      return 0;
    let e = this.input.length;
    for (let n = this.innerDone; n < this.inner.length; n++)
      this.inner[n].from < e && (e = Math.min(e, this.inner[n].parse.parsedPos));
    return e;
  }
  stopAt(e) {
    if (this.stoppedAt = e, this.baseParse)
      this.baseParse.stopAt(e);
    else
      for (let n = this.innerDone; n < this.inner.length; n++)
        this.inner[n].parse.stopAt(e);
  }
  startInner() {
    let e = new iW(this.fragments), n = null, r = null, i = new od(new Nn(this.baseTree, this.ranges[0].from, 0, null), Rt.IncludeAnonymous | Rt.IgnoreMounts);
    e:
      for (let o, s; ; ) {
        let a = true, l;
        if (this.stoppedAt != null && i.from >= this.stoppedAt)
          a = false;
        else if (e.hasNode(i)) {
          if (n) {
            let c = n.mounts.find((u) => u.frag.from <= i.from && u.frag.to >= i.to && u.mount.overlay);
            if (c)
              for (let u of c.mount.overlay) {
                let f = u.from + c.pos, d = u.to + c.pos;
                f >= i.from && d <= i.to && !n.ranges.some((h) => h.from < d && h.to > f) && n.ranges.push({ from: f, to: d });
              }
          }
          a = false;
        } else if (r && (s = nW(r.ranges, i.from, i.to)))
          a = s != 2;
        else if (!i.type.isAnonymous && (o = this.nest(i, this.input)) && (i.from < i.to || !o.overlay)) {
          i.tree || rW(i);
          let c = e.findMounts(i.from, o.parser);
          if (typeof o.overlay == "function")
            n = new eW(o.parser, o.overlay, c, this.inner.length, i.from, i.tree, n);
          else {
            let u = F1(this.ranges, o.overlay || (i.from < i.to ? [new Rr(i.from, i.to)] : []));
            u.length && _1(u), (u.length || !o.overlay) && this.inner.push(new B1(o.parser, u.length ? o.parser.startParse(this.input, Z1(c, u), u) : o.parser.startParse(""), o.overlay ? o.overlay.map((f) => new Rr(f.from - i.from, f.to - i.from)) : null, i.tree, u.length ? u[0].from : i.from)), o.overlay ? u.length && (r = { ranges: u, depth: 0, prev: r }) : a = false;
          }
        } else
          n && (l = n.predicate(i)) && (l === true && (l = new Rr(i.from, i.to)), l.from < l.to && n.ranges.push(l));
        if (a && i.firstChild())
          n && n.depth++, r && r.depth++;
        else
          for (; !i.nextSibling(); ) {
            if (!i.parent())
              break e;
            if (n && !--n.depth) {
              let c = F1(this.ranges, n.ranges);
              c.length && (_1(c), this.inner.splice(n.index, 0, new B1(n.parser, n.parser.startParse(this.input, Z1(n.mounts, c), c), n.ranges.map((u) => new Rr(u.from - n.start, u.to - n.start)), n.target, c[0].from))), n = n.prev;
            }
            r && !--r.depth && (r = r.prev);
          }
      }
  }
};
function nW(t4, e, n) {
  for (let r of t4) {
    if (r.from >= n)
      break;
    if (r.to > e)
      return r.from <= e && r.to >= n ? 2 : 1;
  }
  return 0;
}
function M1(t4, e, n, r, i, o) {
  if (e < n) {
    let s = t4.buffer[e + 1];
    r.push(t4.slice(e, n, s)), i.push(s - o);
  }
}
function rW(t4) {
  let { node: e } = t4, n = [], r = e.context.buffer;
  do
    n.push(t4.index), t4.parent();
  while (!t4.tree);
  let i = t4.tree, o = i.children.indexOf(r), s = i.children[o], a = s.buffer, l = [o];
  function c(u, f, d, h, p, O) {
    let m = n[O], x = [], v = [];
    M1(s, u, m, x, v, h);
    let y = a[m + 1], S = a[m + 2];
    l.push(x.length);
    let b = O ? c(m + 4, a[m + 3], s.set.types[a[m]], y, S - y, O - 1) : e.toTree();
    return x.push(b), v.push(y - h), M1(s, a[m + 3], f, x, v, h), new Zt(d, x, v, p);
  }
  i.children[o] = c(0, a.length, Hn.none, 0, s.length, n.length - 1);
  for (let u of l) {
    let f = t4.tree.children[u], d = t4.tree.positions[u];
    t4.yield(new Nn(f, d + t4.from, u, t4._tree));
  }
}
var N1 = class {
  constructor(e, n) {
    this.offset = n, this.done = false, this.cursor = e.cursor(Rt.IncludeAnonymous | Rt.IgnoreMounts);
  }
  // Move to the first node (in pre-order) that starts at or after `pos`.
  moveTo(e) {
    let { cursor: n } = this, r = e - this.offset;
    for (; !this.done && n.from < r; )
      n.to >= e && n.enter(r, 1, Rt.IgnoreOverlays | Rt.ExcludeBuffers) || n.next(false) || (this.done = true);
  }
  hasNode(e) {
    if (this.moveTo(e.from), !this.done && this.cursor.from + this.offset == e.from && this.cursor.tree)
      for (let n = this.cursor.tree; ; ) {
        if (n == e.tree)
          return true;
        if (n.children.length && n.positions[0] == 0 && n.children[0] instanceof Zt)
          n = n.children[0];
        else
          break;
      }
    return false;
  }
};
var iW = class {
  constructor(e) {
    var n;
    if (this.fragments = e, this.curTo = 0, this.fragI = 0, e.length) {
      let r = this.curFrag = e[0];
      this.curTo = (n = r.tree.prop(Pm)) !== null && n !== void 0 ? n : r.to, this.inner = new N1(r.tree, -r.offset);
    } else
      this.curFrag = this.inner = null;
  }
  hasNode(e) {
    for (; this.curFrag && e.from >= this.curTo; )
      this.nextFrag();
    return this.curFrag && this.curFrag.from <= e.from && this.curTo >= e.to && this.inner.hasNode(e);
  }
  nextFrag() {
    var e;
    if (this.fragI++, this.fragI == this.fragments.length)
      this.curFrag = this.inner = null;
    else {
      let n = this.curFrag = this.fragments[this.fragI];
      this.curTo = (e = n.tree.prop(Pm)) !== null && e !== void 0 ? e : n.to, this.inner = new N1(n.tree, -n.offset);
    }
  }
  findMounts(e, n) {
    var r;
    let i = [];
    if (this.inner) {
      this.inner.cursor.moveTo(e, 1);
      for (let o = this.inner.cursor.node; o; o = o.parent) {
        let s = (r = o.tree) === null || r === void 0 ? void 0 : r.prop(Xe.mounted);
        if (s && s.parser == n)
          for (let a = this.fragI; a < this.fragments.length; a++) {
            let l = this.fragments[a];
            if (l.from >= o.to)
              break;
            l.tree == this.curFrag.tree && i.push({
              frag: l,
              pos: o.from - l.offset,
              mount: s
            });
          }
      }
    }
    return i;
  }
};
function F1(t4, e) {
  let n = null, r = e;
  for (let i = 1, o = 0; i < t4.length; i++) {
    let s = t4[i - 1].to, a = t4[i].from;
    for (; o < r.length; o++) {
      let l = r[o];
      if (l.from >= a)
        break;
      l.to <= s || (n || (r = n = e.slice()), l.from < s ? (n[o] = new Rr(l.from, s), l.to > a && n.splice(o + 1, 0, new Rr(a, l.to))) : l.to > a ? n[o--] = new Rr(a, l.to) : n.splice(o--, 1));
    }
  }
  return r;
}
function oW(t4, e, n, r) {
  let i = 0, o = 0, s = false, a = false, l = -1e9, c = [];
  for (; ; ) {
    let u = i == t4.length ? 1e9 : s ? t4[i].to : t4[i].from, f = o == e.length ? 1e9 : a ? e[o].to : e[o].from;
    if (s != a) {
      let d = Math.max(l, n), h = Math.min(u, f, r);
      d < h && c.push(new Rr(d, h));
    }
    if (l = Math.min(u, f), l == 1e9)
      break;
    u == l && (s ? (s = false, i++) : s = true), f == l && (a ? (a = false, o++) : a = true);
  }
  return c;
}
function Z1(t4, e) {
  let n = [];
  for (let { pos: r, mount: i, frag: o } of t4) {
    let s = r + (i.overlay ? i.overlay[0].from : 0), a = s + i.tree.length, l = Math.max(o.from, s), c = Math.min(o.to, a);
    if (i.overlay) {
      let u = i.overlay.map((d) => new Rr(d.from + r, d.to + r)), f = oW(e, u, l, c);
      for (let d = 0, h = l; ; d++) {
        let p = d == f.length, O = p ? c : f[d].from;
        if (O > h && n.push(new Gi(h, O, i.tree, -s, o.from >= h || o.openStart, o.to <= O || o.openEnd)), p)
          break;
        h = f[d].to;
      }
    } else
      n.push(new Gi(l, c, i.tree, -s, o.from >= s || o.openStart, o.to <= a || o.openEnd));
  }
  return n;
}
var sW = 0;
var uo = class cT {
  /**
  @internal
  */
  constructor(e, n, r) {
    this.set = e, this.base = n, this.modified = r, this.id = sW++;
  }
  /**
  Define a new tag. If `parent` is given, the tag is treated as a
  sub-tag of that parent, and
  [highlighters](#highlight.tagHighlighter) that don't mention
  this tag will try to fall back to the parent tag (or grandparent
  tag, etc).
  */
  static define(e) {
    if (e != null && e.base)
      throw new Error("Can not derive from a modified tag");
    let n = new cT([], null, []);
    if (n.set.push(n), e)
      for (let r of e.set)
        n.set.push(r);
    return n;
  }
  /**
  Define a tag _modifier_, which is a function that, given a tag,
  will return a tag that is a subtag of the original. Applying the
  same modifier to a twice tag will return the same value (`m1(t1)
  == m1(t1)`) and applying multiple modifiers will, regardless or
  order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).
  
  When multiple modifiers are applied to a given base tag, each
  smaller set of modifiers is registered as a parent, so that for
  example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,
  `m1(m3(t1)`, and so on.
  */
  static defineModifier() {
    let e = new sd();
    return (n) => n.modified.indexOf(e) > -1 ? n : sd.get(n.base || n, n.modified.concat(e).sort((r, i) => r.id - i.id));
  }
};
var aW = 0;
var sd = class {
  constructor() {
    this.instances = [], this.id = aW++;
  }
  static get(e, n) {
    if (!n.length)
      return e;
    let r = n[0].instances.find((a) => a.base == e && lW(n, a.modified));
    if (r)
      return r;
    let i = [], o = new uo(i, e, n);
    for (let a of n)
      a.instances.push(o);
    let s = cW(n);
    for (let a of e.set)
      if (!a.modified.length)
        for (let l of s)
          i.push(sd.get(a, l));
    return o;
  }
};
function lW(t4, e) {
  return t4.length == e.length && t4.every((n, r) => n == e[r]);
}
function cW(t4) {
  let e = [[]];
  for (let n = 0; n < t4.length; n++)
    for (let r = 0, i = e.length; r < i; r++)
      e.push(e[r].concat(t4[n]));
  return e.sort((n, r) => r.length - n.length);
}
function Ua(t4) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let n in t4) {
    let r = t4[n];
    Array.isArray(r) || (r = [r]);
    for (let i of n.split(" "))
      if (i) {
        let o = [], s = 2, a = i;
        for (let f = 0; ; ) {
          if (a == "..." && f > 0 && f + 3 == i.length) {
            s = 1;
            break;
          }
          let d = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(a);
          if (!d)
            throw new RangeError("Invalid path: " + i);
          if (o.push(d[0] == "*" ? "" : d[0][0] == '"' ? JSON.parse(d[0]) : d[0]), f += d[0].length, f == i.length)
            break;
          let h = i[f++];
          if (f == i.length && h == "!") {
            s = 0;
            break;
          }
          if (h != "/")
            throw new RangeError("Invalid path: " + i);
          a = i.slice(f);
        }
        let l = o.length - 1, c = o[l];
        if (!c)
          throw new RangeError("Invalid path: " + i);
        let u = new ad(r, s, l > 0 ? o.slice(0, l) : null);
        e[c] = u.sort(e[c]);
      }
  }
  return uT.add(e);
}
var uT = new Xe();
var ad = class {
  constructor(e, n, r, i) {
    this.tags = e, this.mode = n, this.context = r, this.next = i;
  }
  get opaque() {
    return this.mode == 0;
  }
  get inherit() {
    return this.mode == 1;
  }
  sort(e) {
    return !e || e.depth < this.depth ? (this.next = e, this) : (e.next = this.sort(e.next), e);
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
};
ad.empty = new ad([], 2, null);
function fT(t4, e) {
  let n = /* @__PURE__ */ Object.create(null);
  for (let o of t4)
    if (!Array.isArray(o.tag))
      n[o.tag.id] = o.class;
    else
      for (let s of o.tag)
        n[s.id] = o.class;
  let { scope: r, all: i = null } = e || {};
  return {
    style: (o) => {
      let s = i;
      for (let a of o)
        for (let l of a.set) {
          let c = n[l.id];
          if (c) {
            s = s ? s + " " + c : c;
            break;
          }
        }
      return s;
    },
    scope: r
  };
}
function uW(t4, e) {
  let n = null;
  for (let r of t4) {
    let i = r.style(e);
    i && (n = n ? n + " " + i : i);
  }
  return n;
}
function fW(t4, e, n, r = 0, i = t4.length) {
  let o = new dW(r, Array.isArray(e) ? e : [e], n);
  o.highlightRange(t4.cursor(), r, i, "", o.highlighters), o.flush(i);
}
var dW = class {
  constructor(e, n, r) {
    this.at = e, this.highlighters = n, this.span = r, this.class = "";
  }
  startSpan(e, n) {
    n != this.class && (this.flush(e), e > this.at && (this.at = e), this.class = n);
  }
  flush(e) {
    e > this.at && this.class && this.span(this.at, e, this.class);
  }
  highlightRange(e, n, r, i, o) {
    let { type: s, from: a, to: l } = e;
    if (a >= r || l <= n)
      return;
    s.isTop && (o = this.highlighters.filter((h) => !h.scope || h.scope(s)));
    let c = i, u = hW(e) || ad.empty, f = uW(o, u.tags);
    if (f && (c && (c += " "), c += f, u.mode == 1 && (i += (i ? " " : "") + f)), this.startSpan(Math.max(n, a), c), u.opaque)
      return;
    let d = e.tree && e.tree.prop(Xe.mounted);
    if (d && d.overlay) {
      let h = e.node.enter(d.overlay[0].from + a, 1), p = this.highlighters.filter((m) => !m.scope || m.scope(d.tree.type)), O = e.firstChild();
      for (let m = 0, x = a; ; m++) {
        let v = m < d.overlay.length ? d.overlay[m] : null, y = v ? v.from + a : l, S = Math.max(n, x), b = Math.min(r, y);
        if (S < b && O)
          for (; e.from < b && (this.highlightRange(e, S, b, i, o), this.startSpan(Math.min(b, e.to), c), !(e.to >= y || !e.nextSibling())); )
            ;
        if (!v || y > r)
          break;
        x = v.to + a, x > n && (this.highlightRange(h.cursor(), Math.max(n, v.from + a), Math.min(r, x), "", p), this.startSpan(Math.min(r, x), c));
      }
      O && e.parent();
    } else if (e.firstChild()) {
      d && (i = "");
      do
        if (!(e.to <= n)) {
          if (e.from >= r)
            break;
          this.highlightRange(e, n, r, i, o), this.startSpan(Math.min(r, e.to), c);
        }
      while (e.nextSibling());
      e.parent();
    }
  }
};
function hW(t4) {
  let e = t4.type.prop(uT);
  for (; e && e.context && !t4.matchContext(e.context); )
    e = e.next;
  return e || null;
}
var ce = uo.define;
var Bu = ce();
var fo = ce();
var W1 = ce(fo);
var V1 = ce(fo);
var ho = ce();
var _u = ce(ho);
var _p = ce(ho);
var ui = ce();
var Uo = ce(ui);
var li = ce();
var ci = ce();
var Em = ce();
var Ol = ce(Em);
var Mu = ce();
var P = {
  /**
  A comment.
  */
  comment: Bu,
  /**
  A line [comment](#highlight.tags.comment).
  */
  lineComment: ce(Bu),
  /**
  A block [comment](#highlight.tags.comment).
  */
  blockComment: ce(Bu),
  /**
  A documentation [comment](#highlight.tags.comment).
  */
  docComment: ce(Bu),
  /**
  Any kind of identifier.
  */
  name: fo,
  /**
  The [name](#highlight.tags.name) of a variable.
  */
  variableName: ce(fo),
  /**
  A type [name](#highlight.tags.name).
  */
  typeName: W1,
  /**
  A tag name (subtag of [`typeName`](#highlight.tags.typeName)).
  */
  tagName: ce(W1),
  /**
  A property or field [name](#highlight.tags.name).
  */
  propertyName: V1,
  /**
  An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).
  */
  attributeName: ce(V1),
  /**
  The [name](#highlight.tags.name) of a class.
  */
  className: ce(fo),
  /**
  A label [name](#highlight.tags.name).
  */
  labelName: ce(fo),
  /**
  A namespace [name](#highlight.tags.name).
  */
  namespace: ce(fo),
  /**
  The [name](#highlight.tags.name) of a macro.
  */
  macroName: ce(fo),
  /**
  A literal value.
  */
  literal: ho,
  /**
  A string [literal](#highlight.tags.literal).
  */
  string: _u,
  /**
  A documentation [string](#highlight.tags.string).
  */
  docString: ce(_u),
  /**
  A character literal (subtag of [string](#highlight.tags.string)).
  */
  character: ce(_u),
  /**
  An attribute value (subtag of [string](#highlight.tags.string)).
  */
  attributeValue: ce(_u),
  /**
  A number [literal](#highlight.tags.literal).
  */
  number: _p,
  /**
  An integer [number](#highlight.tags.number) literal.
  */
  integer: ce(_p),
  /**
  A floating-point [number](#highlight.tags.number) literal.
  */
  float: ce(_p),
  /**
  A boolean [literal](#highlight.tags.literal).
  */
  bool: ce(ho),
  /**
  Regular expression [literal](#highlight.tags.literal).
  */
  regexp: ce(ho),
  /**
  An escape [literal](#highlight.tags.literal), for example a
  backslash escape in a string.
  */
  escape: ce(ho),
  /**
  A color [literal](#highlight.tags.literal).
  */
  color: ce(ho),
  /**
  A URL [literal](#highlight.tags.literal).
  */
  url: ce(ho),
  /**
  A language keyword.
  */
  keyword: li,
  /**
  The [keyword](#highlight.tags.keyword) for the self or this
  object.
  */
  self: ce(li),
  /**
  The [keyword](#highlight.tags.keyword) for null.
  */
  null: ce(li),
  /**
  A [keyword](#highlight.tags.keyword) denoting some atomic value.
  */
  atom: ce(li),
  /**
  A [keyword](#highlight.tags.keyword) that represents a unit.
  */
  unit: ce(li),
  /**
  A modifier [keyword](#highlight.tags.keyword).
  */
  modifier: ce(li),
  /**
  A [keyword](#highlight.tags.keyword) that acts as an operator.
  */
  operatorKeyword: ce(li),
  /**
  A control-flow related [keyword](#highlight.tags.keyword).
  */
  controlKeyword: ce(li),
  /**
  A [keyword](#highlight.tags.keyword) that defines something.
  */
  definitionKeyword: ce(li),
  /**
  A [keyword](#highlight.tags.keyword) related to defining or
  interfacing with modules.
  */
  moduleKeyword: ce(li),
  /**
  An operator.
  */
  operator: ci,
  /**
  An [operator](#highlight.tags.operator) that dereferences something.
  */
  derefOperator: ce(ci),
  /**
  Arithmetic-related [operator](#highlight.tags.operator).
  */
  arithmeticOperator: ce(ci),
  /**
  Logical [operator](#highlight.tags.operator).
  */
  logicOperator: ce(ci),
  /**
  Bit [operator](#highlight.tags.operator).
  */
  bitwiseOperator: ce(ci),
  /**
  Comparison [operator](#highlight.tags.operator).
  */
  compareOperator: ce(ci),
  /**
  [Operator](#highlight.tags.operator) that updates its operand.
  */
  updateOperator: ce(ci),
  /**
  [Operator](#highlight.tags.operator) that defines something.
  */
  definitionOperator: ce(ci),
  /**
  Type-related [operator](#highlight.tags.operator).
  */
  typeOperator: ce(ci),
  /**
  Control-flow [operator](#highlight.tags.operator).
  */
  controlOperator: ce(ci),
  /**
  Program or markup punctuation.
  */
  punctuation: Em,
  /**
  [Punctuation](#highlight.tags.punctuation) that separates
  things.
  */
  separator: ce(Em),
  /**
  Bracket-style [punctuation](#highlight.tags.punctuation).
  */
  bracket: Ol,
  /**
  Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`
  tokens).
  */
  angleBracket: ce(Ol),
  /**
  Square [brackets](#highlight.tags.bracket) (usually `[` and `]`
  tokens).
  */
  squareBracket: ce(Ol),
  /**
  Parentheses (usually `(` and `)` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  paren: ce(Ol),
  /**
  Braces (usually `{` and `}` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  brace: ce(Ol),
  /**
  Content, for example plain text in XML or markup documents.
  */
  content: ui,
  /**
  [Content](#highlight.tags.content) that represents a heading.
  */
  heading: Uo,
  /**
  A level 1 [heading](#highlight.tags.heading).
  */
  heading1: ce(Uo),
  /**
  A level 2 [heading](#highlight.tags.heading).
  */
  heading2: ce(Uo),
  /**
  A level 3 [heading](#highlight.tags.heading).
  */
  heading3: ce(Uo),
  /**
  A level 4 [heading](#highlight.tags.heading).
  */
  heading4: ce(Uo),
  /**
  A level 5 [heading](#highlight.tags.heading).
  */
  heading5: ce(Uo),
  /**
  A level 6 [heading](#highlight.tags.heading).
  */
  heading6: ce(Uo),
  /**
  A prose separator (such as a horizontal rule).
  */
  contentSeparator: ce(ui),
  /**
  [Content](#highlight.tags.content) that represents a list.
  */
  list: ce(ui),
  /**
  [Content](#highlight.tags.content) that represents a quote.
  */
  quote: ce(ui),
  /**
  [Content](#highlight.tags.content) that is emphasized.
  */
  emphasis: ce(ui),
  /**
  [Content](#highlight.tags.content) that is styled strong.
  */
  strong: ce(ui),
  /**
  [Content](#highlight.tags.content) that is part of a link.
  */
  link: ce(ui),
  /**
  [Content](#highlight.tags.content) that is styled as code or
  monospace.
  */
  monospace: ce(ui),
  /**
  [Content](#highlight.tags.content) that has a strike-through
  style.
  */
  strikethrough: ce(ui),
  /**
  Inserted text in a change-tracking format.
  */
  inserted: ce(),
  /**
  Deleted text.
  */
  deleted: ce(),
  /**
  Changed text.
  */
  changed: ce(),
  /**
  An invalid or unsyntactic element.
  */
  invalid: ce(),
  /**
  Metadata or meta-instruction.
  */
  meta: Mu,
  /**
  [Metadata](#highlight.tags.meta) that applies to the entire
  document.
  */
  documentMeta: ce(Mu),
  /**
  [Metadata](#highlight.tags.meta) that annotates or adds
  attributes to a given syntactic element.
  */
  annotation: ce(Mu),
  /**
  Processing instruction or preprocessor directive. Subtag of
  [meta](#highlight.tags.meta).
  */
  processingInstruction: ce(Mu),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that a
  given element is being defined. Expected to be used with the
  various [name](#highlight.tags.name) tags.
  */
  definition: uo.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that
  something is constant. Mostly expected to be used with
  [variable names](#highlight.tags.variableName).
  */
  constant: uo.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) used to indicate that
  a [variable](#highlight.tags.variableName) or [property
  name](#highlight.tags.propertyName) is being called or defined
  as a function.
  */
  function: uo.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) that can be applied to
  [names](#highlight.tags.name) to indicate that they belong to
  the language's standard environment.
  */
  standard: uo.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates a given
  [names](#highlight.tags.name) is local to some scope.
  */
  local: uo.defineModifier(),
  /**
  A generic variant [modifier](#highlight.Tag^defineModifier) that
  can be used to tag language-specific alternative variants of
  some common tag. It is recommended for themes to define special
  forms of at least the [string](#highlight.tags.string) and
  [variable name](#highlight.tags.variableName) tags, since those
  come up a lot.
  */
  special: uo.defineModifier()
};
fT([
  { tag: P.link, class: "tok-link" },
  { tag: P.heading, class: "tok-heading" },
  { tag: P.emphasis, class: "tok-emphasis" },
  { tag: P.strong, class: "tok-strong" },
  { tag: P.keyword, class: "tok-keyword" },
  { tag: P.atom, class: "tok-atom" },
  { tag: P.bool, class: "tok-bool" },
  { tag: P.url, class: "tok-url" },
  { tag: P.labelName, class: "tok-labelName" },
  { tag: P.inserted, class: "tok-inserted" },
  { tag: P.deleted, class: "tok-deleted" },
  { tag: P.literal, class: "tok-literal" },
  { tag: P.string, class: "tok-string" },
  { tag: P.number, class: "tok-number" },
  { tag: [P.regexp, P.escape, P.special(P.string)], class: "tok-string2" },
  { tag: P.variableName, class: "tok-variableName" },
  { tag: P.local(P.variableName), class: "tok-variableName tok-local" },
  { tag: P.definition(P.variableName), class: "tok-variableName tok-definition" },
  { tag: P.special(P.variableName), class: "tok-variableName2" },
  { tag: P.definition(P.propertyName), class: "tok-propertyName tok-definition" },
  { tag: P.typeName, class: "tok-typeName" },
  { tag: P.namespace, class: "tok-namespace" },
  { tag: P.className, class: "tok-className" },
  { tag: P.macroName, class: "tok-macroName" },
  { tag: P.propertyName, class: "tok-propertyName" },
  { tag: P.operator, class: "tok-operator" },
  { tag: P.comment, class: "tok-comment" },
  { tag: P.meta, class: "tok-meta" },
  { tag: P.invalid, class: "tok-invalid" },
  { tag: P.punctuation, class: "tok-punctuation" }
]);
var Mp;
var Us = /* @__PURE__ */ new Xe();
function dT(t4) {
  return ge.define({
    combine: t4 ? (e) => e.concat(t4) : void 0
  });
}
var Rx = /* @__PURE__ */ new Xe();
var Ur = class {
  /**
  Construct a language object. If you need to invoke this
  directly, first define a data facet with
  [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then
  configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it
  to the language's outer syntax node.
  */
  constructor(e, n, r = [], i = "") {
    this.data = e, this.name = i, et.prototype.hasOwnProperty("tree") || Object.defineProperty(et.prototype, "tree", { get() {
      return Ft(this);
    } }), this.parser = n, this.extension = [
      Qo.of(this),
      et.languageData.of((o, s, a) => {
        let l = z1(o, s, a), c = l.type.prop(Us);
        if (!c)
          return [];
        let u = o.facet(c), f = l.type.prop(Rx);
        if (f) {
          let d = l.resolve(s - l.from, a);
          for (let h of f)
            if (h.test(d, o)) {
              let p = o.facet(h.facet);
              return h.type == "replace" ? p : p.concat(u);
            }
        }
        return u;
      })
    ].concat(r);
  }
  /**
  Query whether this language is active at the given position.
  */
  isActiveAt(e, n, r = -1) {
    return z1(e, n, r).type.prop(Us) == this.data;
  }
  /**
  Find the document regions that were parsed using this language.
  The returned regions will _include_ any nested languages rooted
  in this language, when those exist.
  */
  findRegions(e) {
    let n = e.facet(Qo);
    if ((n == null ? void 0 : n.data) == this.data)
      return [{ from: 0, to: e.doc.length }];
    if (!n || !n.allowsNesting)
      return [];
    let r = [], i = (o, s) => {
      if (o.prop(Us) == this.data) {
        r.push({ from: s, to: s + o.length });
        return;
      }
      let a = o.prop(Xe.mounted);
      if (a) {
        if (a.tree.prop(Us) == this.data) {
          if (a.overlay)
            for (let l of a.overlay)
              r.push({ from: l.from + s, to: l.to + s });
          else
            r.push({ from: s, to: s + o.length });
          return;
        } else if (a.overlay) {
          let l = r.length;
          if (i(a.tree, a.overlay[0].from + s), r.length > l)
            return;
        }
      }
      for (let l = 0; l < o.children.length; l++) {
        let c = o.children[l];
        c instanceof Zt && i(c, o.positions[l] + s);
      }
    };
    return i(Ft(e), 0), r;
  }
  /**
  Indicates whether this language allows nested languages. The
  default implementation returns true.
  */
  get allowsNesting() {
    return true;
  }
};
Ur.setState = /* @__PURE__ */ Me.define();
function z1(t4, e, n) {
  let r = t4.facet(Qo), i = Ft(t4).topNode;
  if (!r || r.allowsNesting)
    for (let o = i; o; o = o.enter(e, n, Rt.ExcludeBuffers))
      o.type.isTop && (i = o);
  return i;
}
var Do = class extends Ur {
  constructor(e, n, r) {
    super(e, n, [], r), this.parser = n;
  }
  /**
  Define a language from a parser.
  */
  static define(e) {
    let n = dT(e.languageData);
    return new Do(n, e.parser.configure({
      props: [Us.add((r) => r.isTop ? n : void 0)]
    }), e.name);
  }
  /**
  Create a new instance of this language with a reconfigured
  version of its parser and optionally a new name.
  */
  configure(e, n) {
    return new Do(this.data, this.parser.configure(e), n || this.name);
  }
  get allowsNesting() {
    return this.parser.hasWrappers();
  }
};
function Ft(t4) {
  let e = t4.field(Ur.state, false);
  return e ? e.tree : Zt.empty;
}
var pW = class {
  /**
  Create an input object for the given document.
  */
  constructor(e) {
    this.doc = e, this.cursorPos = 0, this.string = "", this.cursor = e.iter();
  }
  get length() {
    return this.doc.length;
  }
  syncTo(e) {
    return this.string = this.cursor.next(e - this.cursorPos).value, this.cursorPos = e + this.string.length, this.cursorPos - this.string.length;
  }
  chunk(e) {
    return this.syncTo(e), this.string;
  }
  get lineChunks() {
    return true;
  }
  read(e, n) {
    let r = this.cursorPos - this.string.length;
    return e < r || n >= this.cursorPos ? this.doc.sliceString(e, n) : this.string.slice(e - r, n - r);
  }
};
var xl = null;
var ld = class {
  constructor(e, n, r = [], i, o, s, a, l) {
    this.parser = e, this.state = n, this.fragments = r, this.tree = i, this.treeLen = o, this.viewport = s, this.skipped = a, this.scheduleOn = l, this.parse = null, this.tempSkipped = [];
  }
  /**
  @internal
  */
  static create(e, n, r) {
    return new ld(e, n, [], Zt.empty, 0, r, [], null);
  }
  startParse() {
    return this.parser.startParse(new pW(this.state.doc), this.fragments);
  }
  /**
  @internal
  */
  work(e, n) {
    return n != null && n >= this.state.doc.length && (n = void 0), this.tree != Zt.empty && this.isDone(n ?? this.state.doc.length) ? (this.takeTree(), true) : this.withContext(() => {
      var r;
      if (typeof e == "number") {
        let i = Date.now() + e;
        e = () => Date.now() > i;
      }
      for (this.parse || (this.parse = this.startParse()), n != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > n) && n < this.state.doc.length && this.parse.stopAt(n); ; ) {
        let i = this.parse.advance();
        if (i)
          if (this.fragments = this.withoutTempSkipped(Gi.addTree(i, this.fragments, this.parse.stoppedAt != null)), this.treeLen = (r = this.parse.stoppedAt) !== null && r !== void 0 ? r : this.state.doc.length, this.tree = i, this.parse = null, this.treeLen < (n ?? this.state.doc.length))
            this.parse = this.startParse();
          else
            return true;
        if (e())
          return false;
      }
    });
  }
  /**
  @internal
  */
  takeTree() {
    let e, n;
    this.parse && (e = this.parse.parsedPos) >= this.treeLen && ((this.parse.stoppedAt == null || this.parse.stoppedAt > e) && this.parse.stopAt(e), this.withContext(() => {
      for (; !(n = this.parse.advance()); )
        ;
    }), this.treeLen = e, this.tree = n, this.fragments = this.withoutTempSkipped(Gi.addTree(this.tree, this.fragments, true)), this.parse = null);
  }
  withContext(e) {
    let n = xl;
    xl = this;
    try {
      return e();
    } finally {
      xl = n;
    }
  }
  withoutTempSkipped(e) {
    for (let n; n = this.tempSkipped.pop(); )
      e = L1(e, n.from, n.to);
    return e;
  }
  /**
  @internal
  */
  changes(e, n) {
    let { fragments: r, tree: i, treeLen: o, viewport: s, skipped: a } = this;
    if (this.takeTree(), !e.empty) {
      let l = [];
      if (e.iterChangedRanges((c, u, f, d) => l.push({ fromA: c, toA: u, fromB: f, toB: d })), r = Gi.applyChanges(r, l), i = Zt.empty, o = 0, s = { from: e.mapPos(s.from, -1), to: e.mapPos(s.to, 1) }, this.skipped.length) {
        a = [];
        for (let c of this.skipped) {
          let u = e.mapPos(c.from, 1), f = e.mapPos(c.to, -1);
          u < f && a.push({ from: u, to: f });
        }
      }
    }
    return new ld(this.parser, n, r, i, o, s, a, this.scheduleOn);
  }
  /**
  @internal
  */
  updateViewport(e) {
    if (this.viewport.from == e.from && this.viewport.to == e.to)
      return false;
    this.viewport = e;
    let n = this.skipped.length;
    for (let r = 0; r < this.skipped.length; r++) {
      let { from: i, to: o } = this.skipped[r];
      i < e.to && o > e.from && (this.fragments = L1(this.fragments, i, o), this.skipped.splice(r--, 1));
    }
    return this.skipped.length >= n ? false : (this.reset(), true);
  }
  /**
  @internal
  */
  reset() {
    this.parse && (this.takeTree(), this.parse = null);
  }
  /**
  Notify the parse scheduler that the given region was skipped
  because it wasn't in view, and the parse should be restarted
  when it comes into view.
  */
  skipUntilInView(e, n) {
    this.skipped.push({ from: e, to: n });
  }
  /**
  Returns a parser intended to be used as placeholder when
  asynchronously loading a nested parser. It'll skip its input and
  mark it as not-really-parsed, so that the next update will parse
  it again.
  
  When `until` is given, a reparse will be scheduled when that
  promise resolves.
  */
  static getSkippingParser(e) {
    return new class extends lT {
      createParse(n, r, i) {
        let o = i[0].from, s = i[i.length - 1].to;
        return {
          parsedPos: o,
          advance() {
            let l = xl;
            if (l) {
              for (let c of i)
                l.tempSkipped.push(c);
              e && (l.scheduleOn = l.scheduleOn ? Promise.all([l.scheduleOn, e]) : e);
            }
            return this.parsedPos = s, new Zt(Hn.none, [], [], s - o);
          },
          stoppedAt: null,
          stopAt() {
          }
        };
      }
    }();
  }
  /**
  @internal
  */
  isDone(e) {
    e = Math.min(e, this.state.doc.length);
    let n = this.fragments;
    return this.treeLen >= e && n.length && n[0].from == 0 && n[0].to >= e;
  }
  /**
  Get the context for the current parse, or `null` if no editor
  parse is in progress.
  */
  static get() {
    return xl;
  }
};
function L1(t4, e, n) {
  return Gi.applyChanges(t4, [{ fromA: e, toA: n, fromB: e, toB: n }]);
}
var Pa = class {
  constructor(e) {
    this.context = e, this.tree = e.tree;
  }
  apply(e) {
    if (!e.docChanged && this.tree == this.context.tree)
      return this;
    let n = this.context.changes(e.changes, e.state), r = this.context.treeLen == e.startState.doc.length ? void 0 : Math.max(e.changes.mapPos(this.context.treeLen), n.viewport.to);
    return n.work(20, r) || n.takeTree(), new Pa(n);
  }
  static init(e) {
    let n = Math.min(3e3, e.doc.length), r = ld.create(e.facet(Qo).parser, e, { from: 0, to: n });
    return r.work(20, n) || r.takeTree(), new Pa(r);
  }
};
Ur.state = /* @__PURE__ */ pn.define({
  create: Pa.init,
  update(t4, e) {
    for (let n of e.effects)
      if (n.is(Ur.setState))
        return n.value;
    return e.startState.facet(Qo) != e.state.facet(Qo) ? Pa.init(e.state) : t4.apply(e);
  }
});
var hT = (t4) => {
  let e = setTimeout(
    () => t4(),
    500
    /* Work.MaxPause */
  );
  return () => clearTimeout(e);
};
typeof requestIdleCallback < "u" && (hT = (t4) => {
  let e = -1, n = setTimeout(
    () => {
      e = requestIdleCallback(t4, {
        timeout: 400
        /* Work.MinPause */
      });
    },
    100
    /* Work.MinPause */
  );
  return () => e < 0 ? clearTimeout(n) : cancelIdleCallback(e);
});
var Np = typeof navigator < "u" && (!((Mp = navigator.scheduling) === null || Mp === void 0) && Mp.isInputPending) ? () => navigator.scheduling.isInputPending() : null;
var gW = /* @__PURE__ */ Wt.fromClass(class {
  constructor(e) {
    this.view = e, this.working = null, this.workScheduled = 0, this.chunkEnd = -1, this.chunkBudget = -1, this.work = this.work.bind(this), this.scheduleWork();
  }
  update(e) {
    let n = this.view.state.field(Ur.state).context;
    (n.updateViewport(e.view.viewport) || this.view.viewport.to > n.treeLen) && this.scheduleWork(), (e.docChanged || e.selectionSet) && (this.view.hasFocus && (this.chunkBudget += 50), this.scheduleWork()), this.checkAsyncSchedule(n);
  }
  scheduleWork() {
    if (this.working)
      return;
    let { state: e } = this.view, n = e.field(Ur.state);
    (n.tree != n.context.tree || !n.context.isDone(e.doc.length)) && (this.working = hT(this.work));
  }
  work(e) {
    this.working = null;
    let n = Date.now();
    if (this.chunkEnd < n && (this.chunkEnd < 0 || this.view.hasFocus) && (this.chunkEnd = n + 3e4, this.chunkBudget = 3e3), this.chunkBudget <= 0)
      return;
    let { state: r, viewport: { to: i } } = this.view, o = r.field(Ur.state);
    if (o.tree == o.context.tree && o.context.isDone(
      i + 1e5
      /* Work.MaxParseAhead */
    ))
      return;
    let s = Date.now() + Math.min(this.chunkBudget, 100, e && !Np ? Math.max(25, e.timeRemaining() - 5) : 1e9), a = o.context.treeLen < i && r.doc.length > i + 1e3, l = o.context.work(() => Np && Np() || Date.now() > s, i + (a ? 0 : 1e5));
    this.chunkBudget -= Date.now() - n, (l || this.chunkBudget <= 0) && (o.context.takeTree(), this.view.dispatch({ effects: Ur.setState.of(new Pa(o.context)) })), this.chunkBudget > 0 && !(l && !a) && this.scheduleWork(), this.checkAsyncSchedule(o.context);
  }
  checkAsyncSchedule(e) {
    e.scheduleOn && (this.workScheduled++, e.scheduleOn.then(() => this.scheduleWork()).catch((n) => Gn(this.view.state, n)).then(() => this.workScheduled--), e.scheduleOn = null);
  }
  destroy() {
    this.working && this.working();
  }
  isWorking() {
    return !!(this.working || this.workScheduled > 0);
  }
}, {
  eventHandlers: { focus() {
    this.scheduleWork();
  } }
});
var Qo = /* @__PURE__ */ ge.define({
  combine(t4) {
    return t4.length ? t4[0] : null;
  },
  enables: (t4) => [
    Ur.state,
    gW,
    ue.contentAttributes.compute([t4], (e) => {
      let n = e.facet(t4);
      return n && n.name ? { "data-language": n.name } : {};
    })
  ]
});
var Bc = class {
  /**
  Create a language support object.
  */
  constructor(e, n = []) {
    this.language = e, this.support = n, this.extension = [e, n];
  }
};
var mW = /* @__PURE__ */ ge.define();
var _c = /* @__PURE__ */ ge.define({
  combine: (t4) => {
    if (!t4.length)
      return "  ";
    let e = t4[0];
    if (!e || /\S/.test(e) || Array.from(e).some((n) => n != e[0]))
      throw new Error("Invalid indent unit: " + JSON.stringify(t4[0]));
    return e;
  }
});
function cd(t4) {
  let e = t4.facet(_c);
  return e.charCodeAt(0) == 9 ? t4.tabSize * e.length : e.length;
}
function uc(t4, e) {
  let n = "", r = t4.tabSize, i = t4.facet(_c)[0];
  if (i == "	") {
    for (; e >= r; )
      n += "	", e -= r;
    i = " ";
  }
  for (let o = 0; o < e; o++)
    n += i;
  return n;
}
function Dx(t4, e) {
  t4 instanceof et && (t4 = new yh(t4));
  for (let r of t4.state.facet(mW)) {
    let i = r(t4, e);
    if (i !== void 0)
      return i;
  }
  let n = Ft(t4.state);
  return n.length >= e ? OW(t4, n, e) : null;
}
var yh = class {
  /**
  Create an indent context.
  */
  constructor(e, n = {}) {
    this.state = e, this.options = n, this.unit = cd(e);
  }
  /**
  Get a description of the line at the given position, taking
  [simulated line
  breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  into account. If there is such a break at `pos`, the `bias`
  argument determines whether the part of the line line before or
  after the break is used.
  */
  lineAt(e, n = 1) {
    let r = this.state.doc.lineAt(e), { simulateBreak: i, simulateDoubleBreak: o } = this.options;
    return i != null && i >= r.from && i <= r.to ? o && i == e ? { text: "", from: e } : (n < 0 ? i < e : i <= e) ? { text: r.text.slice(i - r.from), from: i } : { text: r.text.slice(0, i - r.from), from: r.from } : r;
  }
  /**
  Get the text directly after `pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  textAfterPos(e, n = 1) {
    if (this.options.simulateDoubleBreak && e == this.options.simulateBreak)
      return "";
    let { text: r, from: i } = this.lineAt(e, n);
    return r.slice(e - i, Math.min(r.length, e + 100 - i));
  }
  /**
  Find the column for the given position.
  */
  column(e, n = 1) {
    let { text: r, from: i } = this.lineAt(e, n), o = this.countColumn(r, e - i), s = this.options.overrideIndentation ? this.options.overrideIndentation(i) : -1;
    return s > -1 && (o += s - this.countColumn(r, r.search(/\S|$/))), o;
  }
  /**
  Find the column position (taking tabs into account) of the given
  position in the given string.
  */
  countColumn(e, n = e.length) {
    return Ya(e, this.state.tabSize, n);
  }
  /**
  Find the indentation column of the line at the given point.
  */
  lineIndent(e, n = 1) {
    let { text: r, from: i } = this.lineAt(e, n), o = this.options.overrideIndentation;
    if (o) {
      let s = o(i);
      if (s > -1)
        return s;
    }
    return this.countColumn(r, r.search(/\S|$/));
  }
  /**
  Returns the [simulated line
  break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  for this context, if any.
  */
  get simulatedBreak() {
    return this.options.simulateBreak || null;
  }
};
var Ha = /* @__PURE__ */ new Xe();
function OW(t4, e, n) {
  let r = e.resolveStack(n), i = r.node.enterUnfinishedNodesBefore(n);
  if (i != r.node) {
    let o = [];
    for (let s = i; s != r.node; s = s.parent)
      o.push(s);
    for (let s = o.length - 1; s >= 0; s--)
      r = { node: o[s], next: r };
  }
  return pT(r, t4, n);
}
function pT(t4, e, n) {
  for (let r = t4; r; r = r.next) {
    let i = vW(r.node);
    if (i)
      return i(Qx.create(e, n, r));
  }
  return 0;
}
function xW(t4) {
  return t4.pos == t4.options.simulateBreak && t4.options.simulateDoubleBreak;
}
function vW(t4) {
  let e = t4.type.prop(Ha);
  if (e)
    return e;
  let n = t4.firstChild, r;
  if (n && (r = n.type.prop(Xe.closedBy))) {
    let i = t4.lastChild, o = i && r.indexOf(i.name) > -1;
    return (s) => gT(s, true, 1, void 0, o && !xW(s) ? i.from : void 0);
  }
  return t4.parent == null ? yW : null;
}
function yW() {
  return 0;
}
var Qx = class extends yh {
  constructor(e, n, r) {
    super(e.state, e.options), this.base = e, this.pos = n, this.context = r;
  }
  /**
  The syntax tree node to which the indentation strategy
  applies.
  */
  get node() {
    return this.context.node;
  }
  /**
  @internal
  */
  static create(e, n, r) {
    return new Qx(e, n, r);
  }
  /**
  Get the text directly after `this.pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  get textAfter() {
    return this.textAfterPos(this.pos);
  }
  /**
  Get the indentation at the reference line for `this.node`, which
  is the line on which it starts, unless there is a node that is
  _not_ a parent of this node covering the start of that line. If
  so, the line at the start of that node is tried, again skipping
  on if it is covered by another such node.
  */
  get baseIndent() {
    return this.baseIndentFor(this.node);
  }
  /**
  Get the indentation for the reference line of the given node
  (see [`baseIndent`](https://codemirror.net/6/docs/ref/#language.TreeIndentContext.baseIndent)).
  */
  baseIndentFor(e) {
    let n = this.state.doc.lineAt(e.from);
    for (; ; ) {
      let r = e.resolve(n.from);
      for (; r.parent && r.parent.from == r.from; )
        r = r.parent;
      if (bW(r, e))
        break;
      n = this.state.doc.lineAt(r.from);
    }
    return this.lineIndent(n.from);
  }
  /**
  Continue looking for indentations in the node's parent nodes,
  and return the result of that.
  */
  continue() {
    return pT(this.context.next, this.base, this.pos);
  }
};
function bW(t4, e) {
  for (let n = e; n; n = n.parent)
    if (t4 == n)
      return true;
  return false;
}
function SW(t4) {
  let e = t4.node, n = e.childAfter(e.from), r = e.lastChild;
  if (!n)
    return null;
  let i = t4.options.simulateBreak, o = t4.state.doc.lineAt(n.from), s = i == null || i <= o.from ? o.to : Math.min(o.to, i);
  for (let a = n.to; ; ) {
    let l = e.childAfter(a);
    if (!l || l == r)
      return null;
    if (!l.type.isSkipped)
      return l.from < s ? n : null;
    a = l.to;
  }
}
function wW({ closing: t4, align: e = true, units: n = 1 }) {
  return (r) => gT(r, e, n, t4);
}
function gT(t4, e, n, r, i) {
  let o = t4.textAfter, s = o.match(/^\s*/)[0].length, a = r && o.slice(s, s + r.length) == r || i == t4.pos + s, l = e ? SW(t4) : null;
  return l ? a ? t4.column(l.from) : t4.column(l.to) : t4.baseIndent + (a ? 0 : t4.unit * n);
}
var CW = (t4) => t4.baseIndent;
function ua({ except: t4, units: e = 1 } = {}) {
  return (n) => {
    let r = t4 && t4.test(n.textAfter);
    return n.baseIndent + (r ? 0 : e * n.unit);
  };
}
var kW = 200;
function AW() {
  return et.transactionFilter.of((t4) => {
    if (!t4.docChanged || !t4.isUserEvent("input.type") && !t4.isUserEvent("input.complete"))
      return t4;
    let e = t4.startState.languageDataAt("indentOnInput", t4.startState.selection.main.head);
    if (!e.length)
      return t4;
    let n = t4.newDoc, { head: r } = t4.newSelection.main, i = n.lineAt(r);
    if (r > i.from + kW)
      return t4;
    let o = n.sliceString(i.from, r);
    if (!e.some((c) => c.test(o)))
      return t4;
    let { state: s } = t4, a = -1, l = [];
    for (let { head: c } of s.selection.ranges) {
      let u = s.doc.lineAt(c);
      if (u.from == a)
        continue;
      a = u.from;
      let f = Dx(s, u.from);
      if (f == null)
        continue;
      let d = /^\s*/.exec(u.text)[0], h = uc(s, f);
      d != h && l.push({ from: u.from, to: u.from + d.length, insert: h });
    }
    return l.length ? [t4, { changes: l, sequential: true }] : t4;
  });
}
var PW = /* @__PURE__ */ ge.define();
var Ja = /* @__PURE__ */ new Xe();
function Bx(t4) {
  let e = t4.firstChild, n = t4.lastChild;
  return e && e.to < n.from ? { from: e.to, to: n.type.isError ? t4.to : n.from } : null;
}
function EW(t4, e, n) {
  let r = Ft(t4);
  if (r.length < n)
    return null;
  let i = r.resolveStack(n, 1), o = null;
  for (let s = i; s; s = s.next) {
    let a = s.node;
    if (a.to <= n || a.from > n)
      continue;
    if (o && a.from < e)
      break;
    let l = a.type.prop(Ja);
    if (l && (a.to < r.length - 50 || r.length == t4.doc.length || !TW(a))) {
      let c = l(a, t4);
      c && c.from <= n && c.from >= e && c.to > n && (o = c);
    }
  }
  return o;
}
function TW(t4) {
  let e = t4.lastChild;
  return e && e.to == t4.to && e.type.isError;
}
function ud(t4, e, n) {
  for (let r of t4.facet(PW)) {
    let i = r(t4, e, n);
    if (i)
      return i;
  }
  return EW(t4, e, n);
}
function mT(t4, e) {
  let n = e.mapPos(t4.from, 1), r = e.mapPos(t4.to, -1);
  return n >= r ? void 0 : { from: n, to: r };
}
var bh = /* @__PURE__ */ Me.define({ map: mT });
var Mc = /* @__PURE__ */ Me.define({ map: mT });
function OT(t4) {
  let e = [];
  for (let { head: n } of t4.state.selection.ranges)
    e.some((r) => r.from <= n && r.to >= n) || e.push(t4.lineBlockAt(n));
  return e;
}
var gs = /* @__PURE__ */ pn.define({
  create() {
    return we.none;
  },
  update(t4, e) {
    t4 = t4.map(e.changes);
    for (let n of e.effects)
      if (n.is(bh) && !IW(t4, n.value.from, n.value.to)) {
        let { preparePlaceholder: r } = e.state.facet(yT), i = r ? we.replace({ widget: new _W(r(e.state, n.value)) }) : X1;
        t4 = t4.update({ add: [i.range(n.value.from, n.value.to)] });
      } else
        n.is(Mc) && (t4 = t4.update({
          filter: (r, i) => n.value.from != r || n.value.to != i,
          filterFrom: n.value.from,
          filterTo: n.value.to
        }));
    if (e.selection) {
      let n = false, { head: r } = e.selection.main;
      t4.between(r, r, (i, o) => {
        i < r && o > r && (n = true);
      }), n && (t4 = t4.update({
        filterFrom: r,
        filterTo: r,
        filter: (i, o) => o <= r || i >= r
      }));
    }
    return t4;
  },
  provide: (t4) => ue.decorations.from(t4),
  toJSON(t4, e) {
    let n = [];
    return t4.between(0, e.doc.length, (r, i) => {
      n.push(r, i);
    }), n;
  },
  fromJSON(t4) {
    if (!Array.isArray(t4) || t4.length % 2)
      throw new RangeError("Invalid JSON for fold state");
    let e = [];
    for (let n = 0; n < t4.length; ) {
      let r = t4[n++], i = t4[n++];
      if (typeof r != "number" || typeof i != "number")
        throw new RangeError("Invalid JSON for fold state");
      e.push(X1.range(r, i));
    }
    return we.set(e, true);
  }
});
function fd(t4, e, n) {
  var r;
  let i = null;
  return (r = t4.field(gs, false)) === null || r === void 0 || r.between(e, n, (o, s) => {
    (!i || i.from > o) && (i = { from: o, to: s });
  }), i;
}
function IW(t4, e, n) {
  let r = false;
  return t4.between(e, e, (i, o) => {
    i == e && o == n && (r = true);
  }), r;
}
function xT(t4, e) {
  return t4.field(gs, false) ? e : e.concat(Me.appendConfig.of(bT()));
}
var $W = (t4) => {
  for (let e of OT(t4)) {
    let n = ud(t4.state, e.from, e.to);
    if (n)
      return t4.dispatch({ effects: xT(t4.state, [bh.of(n), vT(t4, n)]) }), true;
  }
  return false;
};
var jW = (t4) => {
  if (!t4.state.field(gs, false))
    return false;
  let e = [];
  for (let n of OT(t4)) {
    let r = fd(t4.state, n.from, n.to);
    r && e.push(Mc.of(r), vT(t4, r, false));
  }
  return e.length && t4.dispatch({ effects: e }), e.length > 0;
};
function vT(t4, e, n = true) {
  let r = t4.state.doc.lineAt(e.from).number, i = t4.state.doc.lineAt(e.to).number;
  return ue.announce.of(`${t4.state.phrase(n ? "Folded lines" : "Unfolded lines")} ${r} ${t4.state.phrase("to")} ${i}.`);
}
var RW = (t4) => {
  let { state: e } = t4, n = [];
  for (let r = 0; r < e.doc.length; ) {
    let i = t4.lineBlockAt(r), o = ud(e, i.from, i.to);
    o && n.push(bh.of(o)), r = (o ? t4.lineBlockAt(o.to) : i).to + 1;
  }
  return n.length && t4.dispatch({ effects: xT(t4.state, n) }), !!n.length;
};
var DW = (t4) => {
  let e = t4.state.field(gs, false);
  if (!e || !e.size)
    return false;
  let n = [];
  return e.between(0, t4.state.doc.length, (r, i) => {
    n.push(Mc.of({ from: r, to: i }));
  }), t4.dispatch({ effects: n }), true;
};
var QW = [
  { key: "Ctrl-Shift-[", mac: "Cmd-Alt-[", run: $W },
  { key: "Ctrl-Shift-]", mac: "Cmd-Alt-]", run: jW },
  { key: "Ctrl-Alt-[", run: RW },
  { key: "Ctrl-Alt-]", run: DW }
];
var BW = {
  placeholderDOM: null,
  preparePlaceholder: null,
  placeholderText: "\u2026"
};
var yT = /* @__PURE__ */ ge.define({
  combine(t4) {
    return Di(t4, BW);
  }
});
function bT(t4) {
  return [gs, FW];
}
function ST(t4, e) {
  let { state: n } = t4, r = n.facet(yT), i = (s) => {
    let a = t4.lineBlockAt(t4.posAtDOM(s.target)), l = fd(t4.state, a.from, a.to);
    l && t4.dispatch({ effects: Mc.of(l) }), s.preventDefault();
  };
  if (r.placeholderDOM)
    return r.placeholderDOM(t4, i, e);
  let o = document.createElement("span");
  return o.textContent = r.placeholderText, o.setAttribute("aria-label", n.phrase("folded code")), o.title = n.phrase("unfold"), o.className = "cm-foldPlaceholder", o.onclick = i, o;
}
var X1 = /* @__PURE__ */ we.replace({ widget: /* @__PURE__ */ new class extends Qi {
  toDOM(t4) {
    return ST(t4, null);
  }
}() });
var _W = class extends Qi {
  constructor(e) {
    super(), this.value = e;
  }
  eq(e) {
    return this.value == e.value;
  }
  toDOM(e) {
    return ST(e, this.value);
  }
};
var MW = {
  openText: "\u2304",
  closedText: "\u203A",
  markerDOM: null,
  domEventHandlers: {},
  foldingChanged: () => false
};
var Fp = class extends Ji {
  constructor(e, n) {
    super(), this.config = e, this.open = n;
  }
  eq(e) {
    return this.config == e.config && this.open == e.open;
  }
  toDOM(e) {
    if (this.config.markerDOM)
      return this.config.markerDOM(this.open);
    let n = document.createElement("span");
    return n.textContent = this.open ? this.config.openText : this.config.closedText, n.title = e.state.phrase(this.open ? "Fold line" : "Unfold line"), n;
  }
};
function NW(t4 = {}) {
  let e = Object.assign(Object.assign({}, MW), t4), n = new Fp(e, true), r = new Fp(e, false), i = Wt.fromClass(class {
    constructor(s) {
      this.from = s.viewport.from, this.markers = this.buildMarkers(s);
    }
    update(s) {
      (s.docChanged || s.viewportChanged || s.startState.facet(Qo) != s.state.facet(Qo) || s.startState.field(gs, false) != s.state.field(gs, false) || Ft(s.startState) != Ft(s.state) || e.foldingChanged(s)) && (this.markers = this.buildMarkers(s.view));
    }
    buildMarkers(s) {
      let a = new To();
      for (let l of s.viewportLineBlocks) {
        let c = fd(s.state, l.from, l.to) ? r : ud(s.state, l.from, l.to) ? n : null;
        c && a.add(l.from, l.from, c);
      }
      return a.finish();
    }
  }), { domEventHandlers: o } = e;
  return [
    i,
    B6({
      class: "cm-foldGutter",
      markers(s) {
        var a;
        return ((a = s.plugin(i)) === null || a === void 0 ? void 0 : a.markers) || ot.empty;
      },
      initialSpacer() {
        return new Fp(e, false);
      },
      domEventHandlers: Object.assign(Object.assign({}, o), { click: (s, a, l) => {
        if (o.click && o.click(s, a, l))
          return true;
        let c = fd(s.state, a.from, a.to);
        if (c)
          return s.dispatch({ effects: Mc.of(c) }), true;
        let u = ud(s.state, a.from, a.to);
        return u ? (s.dispatch({ effects: bh.of(u) }), true) : false;
      } })
    }),
    bT()
  ];
}
var FW = /* @__PURE__ */ ue.baseTheme({
  ".cm-foldPlaceholder": {
    backgroundColor: "#eee",
    border: "1px solid #ddd",
    color: "#888",
    borderRadius: ".2em",
    margin: "0 1px",
    padding: "0 1px",
    cursor: "pointer"
  },
  ".cm-foldGutter span": {
    padding: "0 1px",
    cursor: "pointer"
  }
});
var Ka = class {
  constructor(e, n) {
    this.specs = e;
    let r;
    function i(a) {
      let l = Io.newName();
      return (r || (r = /* @__PURE__ */ Object.create(null)))["." + l] = a, l;
    }
    const o = typeof n.all == "string" ? n.all : n.all ? i(n.all) : void 0, s = n.scope;
    this.scope = s instanceof Ur ? (a) => a.prop(Us) == s.data : s ? (a) => a == s : void 0, this.style = fT(e.map((a) => ({
      tag: a.tag,
      class: a.class || i(Object.assign({}, a, { tag: null }))
    })), {
      all: o
    }).style, this.module = r ? new Io(r) : null, this.themeType = n.themeType;
  }
  /**
  Create a highlighter style that associates the given styles to
  the given tags. The specs must be objects that hold a style tag
  or array of tags in their `tag` property, and either a single
  `class` property providing a static CSS class (for highlighter
  that rely on external styling), or a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style
  set of CSS properties (which define the styling for those tags).
  
  The CSS rules created for a highlighter will be emitted in the
  order of the spec's properties. That means that for elements that
  have multiple tags associated with them, styles defined further
  down in the list will have a higher CSS precedence than styles
  defined earlier.
  */
  static define(e, n) {
    return new Ka(e, n || {});
  }
};
var Tm = /* @__PURE__ */ ge.define();
var wT = /* @__PURE__ */ ge.define({
  combine(t4) {
    return t4.length ? [t4[0]] : null;
  }
});
function Zp(t4) {
  let e = t4.facet(Tm);
  return e.length ? e : t4.facet(wT);
}
function _x(t4, e) {
  let n = [WW], r;
  return t4 instanceof Ka && (t4.module && n.push(ue.styleModule.of(t4.module)), r = t4.themeType), e != null && e.fallback ? n.push(wT.of(t4)) : r ? n.push(Tm.computeN([ue.darkTheme], (i) => i.facet(ue.darkTheme) == (r == "dark") ? [t4] : [])) : n.push(Tm.of(t4)), n;
}
var ZW = class {
  constructor(e) {
    this.markCache = /* @__PURE__ */ Object.create(null), this.tree = Ft(e.state), this.decorations = this.buildDeco(e, Zp(e.state)), this.decoratedTo = e.viewport.to;
  }
  update(e) {
    let n = Ft(e.state), r = Zp(e.state), i = r != Zp(e.startState), { viewport: o } = e.view, s = e.changes.mapPos(this.decoratedTo, 1);
    n.length < o.to && !i && n.type == this.tree.type && s >= o.to ? (this.decorations = this.decorations.map(e.changes), this.decoratedTo = s) : (n != this.tree || e.viewportChanged || i) && (this.tree = n, this.decorations = this.buildDeco(e.view, r), this.decoratedTo = o.to);
  }
  buildDeco(e, n) {
    if (!n || !this.tree.length)
      return we.none;
    let r = new To();
    for (let { from: i, to: o } of e.visibleRanges)
      fW(this.tree, n, (s, a, l) => {
        r.add(s, a, this.markCache[l] || (this.markCache[l] = we.mark({ class: l })));
      }, i, o);
    return r.finish();
  }
};
var WW = /* @__PURE__ */ ji.high(/* @__PURE__ */ Wt.fromClass(ZW, {
  decorations: (t4) => t4.decorations
}));
var VW = /* @__PURE__ */ Ka.define([
  {
    tag: P.meta,
    color: "#404740"
  },
  {
    tag: P.link,
    textDecoration: "underline"
  },
  {
    tag: P.heading,
    textDecoration: "underline",
    fontWeight: "bold"
  },
  {
    tag: P.emphasis,
    fontStyle: "italic"
  },
  {
    tag: P.strong,
    fontWeight: "bold"
  },
  {
    tag: P.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: P.keyword,
    color: "#708"
  },
  {
    tag: [P.atom, P.bool, P.url, P.contentSeparator, P.labelName],
    color: "#219"
  },
  {
    tag: [P.literal, P.inserted],
    color: "#164"
  },
  {
    tag: [P.string, P.deleted],
    color: "#a11"
  },
  {
    tag: [P.regexp, P.escape, /* @__PURE__ */ P.special(P.string)],
    color: "#e40"
  },
  {
    tag: /* @__PURE__ */ P.definition(P.variableName),
    color: "#00f"
  },
  {
    tag: /* @__PURE__ */ P.local(P.variableName),
    color: "#30a"
  },
  {
    tag: [P.typeName, P.namespace],
    color: "#085"
  },
  {
    tag: P.className,
    color: "#167"
  },
  {
    tag: [/* @__PURE__ */ P.special(P.variableName), P.macroName],
    color: "#256"
  },
  {
    tag: /* @__PURE__ */ P.definition(P.propertyName),
    color: "#00c"
  },
  {
    tag: P.comment,
    color: "#940"
  },
  {
    tag: P.invalid,
    color: "#f00"
  }
]);
var zW = /* @__PURE__ */ ue.baseTheme({
  "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" },
  "&.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bb555544" }
});
var CT = 1e4;
var kT = "()[]{}";
var AT = /* @__PURE__ */ ge.define({
  combine(t4) {
    return Di(t4, {
      afterCursor: true,
      brackets: kT,
      maxScanDistance: CT,
      renderMatch: GW
    });
  }
});
var LW = /* @__PURE__ */ we.mark({ class: "cm-matchingBracket" });
var XW = /* @__PURE__ */ we.mark({ class: "cm-nonmatchingBracket" });
function GW(t4) {
  let e = [], n = t4.matched ? LW : XW;
  return e.push(n.range(t4.start.from, t4.start.to)), t4.end && e.push(n.range(t4.end.from, t4.end.to)), e;
}
var YW = /* @__PURE__ */ pn.define({
  create() {
    return we.none;
  },
  update(t4, e) {
    if (!e.docChanged && !e.selection)
      return t4;
    let n = [], r = e.state.facet(AT);
    for (let i of e.state.selection.ranges) {
      if (!i.empty)
        continue;
      let o = Oi(e.state, i.head, -1, r) || i.head > 0 && Oi(e.state, i.head - 1, 1, r) || r.afterCursor && (Oi(e.state, i.head, 1, r) || i.head < e.state.doc.length && Oi(e.state, i.head + 1, -1, r));
      o && (n = n.concat(r.renderMatch(o, e.state)));
    }
    return we.set(n, true);
  },
  provide: (t4) => ue.decorations.from(t4)
});
var qW = [
  YW,
  zW
];
function UW(t4 = {}) {
  return [AT.of(t4), qW];
}
var Mx = /* @__PURE__ */ new Xe();
function Im(t4, e, n) {
  let r = t4.prop(e < 0 ? Xe.openedBy : Xe.closedBy);
  if (r)
    return r;
  if (t4.name.length == 1) {
    let i = n.indexOf(t4.name);
    if (i > -1 && i % 2 == (e < 0 ? 1 : 0))
      return [n[i + e]];
  }
  return null;
}
function $m(t4) {
  let e = t4.type.prop(Mx);
  return e ? e(t4.node) : t4;
}
function Oi(t4, e, n, r = {}) {
  let i = r.maxScanDistance || CT, o = r.brackets || kT, s = Ft(t4), a = s.resolveInner(e, n);
  for (let l = a; l; l = l.parent) {
    let c = Im(l.type, n, o);
    if (c && l.from < l.to) {
      let u = $m(l);
      if (u && (n > 0 ? e >= u.from && e < u.to : e > u.from && e <= u.to))
        return HW(t4, e, n, l, u, c, o);
    }
  }
  return JW(t4, e, n, s, a.type, i, o);
}
function HW(t4, e, n, r, i, o, s) {
  let a = r.parent, l = { from: i.from, to: i.to }, c = 0, u = a == null ? void 0 : a.cursor();
  if (u && (n < 0 ? u.childBefore(r.from) : u.childAfter(r.to)))
    do
      if (n < 0 ? u.to <= r.from : u.from >= r.to) {
        if (c == 0 && o.indexOf(u.type.name) > -1 && u.from < u.to) {
          let f = $m(u);
          return { start: l, end: f ? { from: f.from, to: f.to } : void 0, matched: true };
        } else if (Im(u.type, n, s))
          c++;
        else if (Im(u.type, -n, s)) {
          if (c == 0) {
            let f = $m(u);
            return {
              start: l,
              end: f && f.from < f.to ? { from: f.from, to: f.to } : void 0,
              matched: false
            };
          }
          c--;
        }
      }
    while (n < 0 ? u.prevSibling() : u.nextSibling());
  return { start: l, matched: false };
}
function JW(t4, e, n, r, i, o, s) {
  let a = n < 0 ? t4.sliceDoc(e - 1, e) : t4.sliceDoc(e, e + 1), l = s.indexOf(a);
  if (l < 0 || l % 2 == 0 != n > 0)
    return null;
  let c = { from: n < 0 ? e - 1 : e, to: n > 0 ? e + 1 : e }, u = t4.doc.iterRange(e, n > 0 ? t4.doc.length : 0), f = 0;
  for (let d = 0; !u.next().done && d <= o; ) {
    let h = u.value;
    n < 0 && (d += h.length);
    let p = e + d * n;
    for (let O = n > 0 ? 0 : h.length - 1, m = n > 0 ? h.length : -1; O != m; O += n) {
      let x = s.indexOf(h[O]);
      if (!(x < 0 || r.resolveInner(p + O, 1).type != i))
        if (x % 2 == 0 == n > 0)
          f++;
        else {
          if (f == 1)
            return { start: c, end: { from: p + O, to: p + O + 1 }, matched: x >> 1 == l >> 1 };
          f--;
        }
    }
    n > 0 && (d += h.length);
  }
  return u.done ? { start: c, matched: false } : null;
}
var KW = /* @__PURE__ */ Object.create(null);
var G1 = [Hn.none];
var Y1 = [];
var q1 = /* @__PURE__ */ Object.create(null);
var eV = /* @__PURE__ */ Object.create(null);
for (let [t4, e] of [
  ["variable", "variableName"],
  ["variable-2", "variableName.special"],
  ["string-2", "string.special"],
  ["def", "variableName.definition"],
  ["tag", "tagName"],
  ["attribute", "attributeName"],
  ["type", "typeName"],
  ["builtin", "variableName.standard"],
  ["qualifier", "modifier"],
  ["error", "invalid"],
  ["header", "heading"],
  ["property", "propertyName"]
])
  eV[t4] = /* @__PURE__ */ tV(KW, e);
function Wp(t4, e) {
  Y1.indexOf(t4) > -1 || (Y1.push(t4), console.warn(e));
}
function tV(t4, e) {
  let n = [];
  for (let a of e.split(" ")) {
    let l = [];
    for (let c of a.split(".")) {
      let u = t4[c] || P[c];
      u ? typeof u == "function" ? l.length ? l = l.map(u) : Wp(c, `Modifier ${c} used at start of tag`) : l.length ? Wp(c, `Tag ${c} used as modifier`) : l = Array.isArray(u) ? u : [u] : Wp(c, `Unknown highlighting tag ${c}`);
    }
    for (let c of l)
      n.push(c);
  }
  if (!n.length)
    return 0;
  let r = e.replace(/ /g, "_"), i = r + " " + n.map((a) => a.id), o = q1[i];
  if (o)
    return o.id;
  let s = q1[i] = Hn.define({
    id: G1.length,
    name: r,
    props: [Ua({ [r]: n })]
  });
  return G1.push(s), s.id;
}
_t.RTL, _t.LTR;
var nV = (t4) => {
  let { state: e } = t4, n = e.doc.lineAt(e.selection.main.from), r = Fx(t4.state, n.from);
  return r.line ? rV(t4) : r.block ? oV(t4) : false;
};
function Nx(t4, e) {
  return ({ state: n, dispatch: r }) => {
    if (n.readOnly)
      return false;
    let i = t4(e, n);
    return i ? (r(n.update(i)), true) : false;
  };
}
var rV = /* @__PURE__ */ Nx(
  lV,
  0
  /* CommentOption.Toggle */
);
var iV = /* @__PURE__ */ Nx(
  PT,
  0
  /* CommentOption.Toggle */
);
var oV = /* @__PURE__ */ Nx(
  (t4, e) => PT(t4, e, aV(e)),
  0
  /* CommentOption.Toggle */
);
function Fx(t4, e) {
  let n = t4.languageDataAt("commentTokens", e);
  return n.length ? n[0] : {};
}
var vl = 50;
function sV(t4, { open: e, close: n }, r, i) {
  let o = t4.sliceDoc(r - vl, r), s = t4.sliceDoc(i, i + vl), a = /\s*$/.exec(o)[0].length, l = /^\s*/.exec(s)[0].length, c = o.length - a;
  if (o.slice(c - e.length, c) == e && s.slice(l, l + n.length) == n)
    return {
      open: { pos: r - a, margin: a && 1 },
      close: { pos: i + l, margin: l && 1 }
    };
  let u, f;
  i - r <= 2 * vl ? u = f = t4.sliceDoc(r, i) : (u = t4.sliceDoc(r, r + vl), f = t4.sliceDoc(i - vl, i));
  let d = /^\s*/.exec(u)[0].length, h = /\s*$/.exec(f)[0].length, p = f.length - h - n.length;
  return u.slice(d, d + e.length) == e && f.slice(p, p + n.length) == n ? {
    open: {
      pos: r + d + e.length,
      margin: /\s/.test(u.charAt(d + e.length)) ? 1 : 0
    },
    close: {
      pos: i - h - n.length,
      margin: /\s/.test(f.charAt(p - 1)) ? 1 : 0
    }
  } : null;
}
function aV(t4) {
  let e = [];
  for (let n of t4.selection.ranges) {
    let r = t4.doc.lineAt(n.from), i = n.to <= r.to ? r : t4.doc.lineAt(n.to), o = e.length - 1;
    o >= 0 && e[o].to > r.from ? e[o].to = i.to : e.push({ from: r.from + /^\s*/.exec(r.text)[0].length, to: i.to });
  }
  return e;
}
function PT(t4, e, n = e.selection.ranges) {
  let r = n.map((o) => Fx(e, o.from).block);
  if (!r.every((o) => o))
    return null;
  let i = n.map((o, s) => sV(e, r[s], o.from, o.to));
  if (t4 != 2 && !i.every((o) => o))
    return { changes: e.changes(n.map((o, s) => i[s] ? [] : [{ from: o.from, insert: r[s].open + " " }, { from: o.to, insert: " " + r[s].close }])) };
  if (t4 != 1 && i.some((o) => o)) {
    let o = [];
    for (let s = 0, a; s < i.length; s++)
      if (a = i[s]) {
        let l = r[s], { open: c, close: u } = a;
        o.push({ from: c.pos - l.open.length, to: c.pos + c.margin }, { from: u.pos - u.margin, to: u.pos + l.close.length });
      }
    return { changes: o };
  }
  return null;
}
function lV(t4, e, n = e.selection.ranges) {
  let r = [], i = -1;
  for (let { from: o, to: s } of n) {
    let a = r.length, l = 1e9, c = Fx(e, o).line;
    if (c) {
      for (let u = o; u <= s; ) {
        let f = e.doc.lineAt(u);
        if (f.from > i && (o == s || s > f.from)) {
          i = f.from;
          let d = /^\s*/.exec(f.text)[0].length, h = d == f.length, p = f.text.slice(d, d + c.length) == c ? d : -1;
          d < f.text.length && d < l && (l = d), r.push({ line: f, comment: p, token: c, indent: d, empty: h, single: false });
        }
        u = f.to + 1;
      }
      if (l < 1e9)
        for (let u = a; u < r.length; u++)
          r[u].indent < r[u].line.text.length && (r[u].indent = l);
      r.length == a + 1 && (r[a].single = true);
    }
  }
  if (t4 != 2 && r.some((o) => o.comment < 0 && (!o.empty || o.single))) {
    let o = [];
    for (let { line: a, token: l, indent: c, empty: u, single: f } of r)
      (f || !u) && o.push({ from: a.from + c, insert: l + " " });
    let s = e.changes(o);
    return { changes: s, selection: e.selection.map(s, 1) };
  } else if (t4 != 1 && r.some((o) => o.comment >= 0)) {
    let o = [];
    for (let { line: s, comment: a, token: l } of r)
      if (a >= 0) {
        let c = s.from + a, u = c + l.length;
        s.text[u - s.from] == " " && u++, o.push({ from: c, to: u });
      }
    return { changes: o };
  }
  return null;
}
var jm = /* @__PURE__ */ Ri.define();
var cV = /* @__PURE__ */ Ri.define();
var uV = /* @__PURE__ */ ge.define();
var ET = /* @__PURE__ */ ge.define({
  combine(t4) {
    return Di(t4, {
      minDepth: 100,
      newGroupDelay: 500,
      joinToEvent: (e, n) => n
    }, {
      minDepth: Math.max,
      newGroupDelay: Math.min,
      joinToEvent: (e, n) => (r, i) => e(r, i) || n(r, i)
    });
  }
});
var TT = /* @__PURE__ */ pn.define({
  create() {
    return xi.empty;
  },
  update(t4, e) {
    let n = e.state.facet(ET), r = e.annotation(jm);
    if (r) {
      let l = ir.fromTransaction(e, r.selection), c = r.side, u = c == 0 ? t4.undone : t4.done;
      return l ? u = dd(u, u.length, n.minDepth, l) : u = jT(u, e.startState.selection), new xi(c == 0 ? r.rest : u, c == 0 ? u : r.rest);
    }
    let i = e.annotation(cV);
    if ((i == "full" || i == "before") && (t4 = t4.isolate()), e.annotation(tn.addToHistory) === false)
      return e.changes.empty ? t4 : t4.addMapping(e.changes.desc);
    let o = ir.fromTransaction(e), s = e.annotation(tn.time), a = e.annotation(tn.userEvent);
    return o ? t4 = t4.addChanges(o, s, a, n, e) : e.selection && (t4 = t4.addSelection(e.startState.selection, s, a, n.newGroupDelay)), (i == "full" || i == "after") && (t4 = t4.isolate()), t4;
  },
  toJSON(t4) {
    return { done: t4.done.map((e) => e.toJSON()), undone: t4.undone.map((e) => e.toJSON()) };
  },
  fromJSON(t4) {
    return new xi(t4.done.map(ir.fromJSON), t4.undone.map(ir.fromJSON));
  }
});
function fV(t4 = {}) {
  return [
    TT,
    ET.of(t4),
    ue.domEventHandlers({
      beforeinput(e, n) {
        let r = e.inputType == "historyUndo" ? IT : e.inputType == "historyRedo" ? Rm : null;
        return r ? (e.preventDefault(), r(n)) : false;
      }
    })
  ];
}
function Sh(t4, e) {
  return function({ state: n, dispatch: r }) {
    if (!e && n.readOnly)
      return false;
    let i = n.field(TT, false);
    if (!i)
      return false;
    let o = i.pop(t4, n, e);
    return o ? (r(o), true) : false;
  };
}
var IT = /* @__PURE__ */ Sh(0, false);
var Rm = /* @__PURE__ */ Sh(1, false);
var dV = /* @__PURE__ */ Sh(0, true);
var hV = /* @__PURE__ */ Sh(1, true);
var ir = class {
  constructor(e, n, r, i, o) {
    this.changes = e, this.effects = n, this.mapped = r, this.startSelection = i, this.selectionsAfter = o;
  }
  setSelAfter(e) {
    return new ir(this.changes, this.effects, this.mapped, this.startSelection, e);
  }
  toJSON() {
    var e, n, r;
    return {
      changes: (e = this.changes) === null || e === void 0 ? void 0 : e.toJSON(),
      mapped: (n = this.mapped) === null || n === void 0 ? void 0 : n.toJSON(),
      startSelection: (r = this.startSelection) === null || r === void 0 ? void 0 : r.toJSON(),
      selectionsAfter: this.selectionsAfter.map((i) => i.toJSON())
    };
  }
  static fromJSON(e) {
    return new ir(e.changes && un.fromJSON(e.changes), [], e.mapped && wi.fromJSON(e.mapped), e.startSelection && ne.fromJSON(e.startSelection), e.selectionsAfter.map(ne.fromJSON));
  }
  // This does not check `addToHistory` and such, it assumes the
  // transaction needs to be converted to an item. Returns null when
  // there are no changes or effects in the transaction.
  static fromTransaction(e, n) {
    let r = Dr;
    for (let i of e.startState.facet(uV)) {
      let o = i(e);
      o.length && (r = r.concat(o));
    }
    return !r.length && e.changes.empty ? null : new ir(e.changes.invert(e.startState.doc), r, void 0, n || e.startState.selection, Dr);
  }
  static selection(e) {
    return new ir(void 0, Dr, void 0, void 0, e);
  }
};
function dd(t4, e, n, r) {
  let i = e + 1 > n + 20 ? e - n - 1 : 0, o = t4.slice(i, e);
  return o.push(r), o;
}
function pV(t4, e) {
  let n = [], r = false;
  return t4.iterChangedRanges((i, o) => n.push(i, o)), e.iterChangedRanges((i, o, s, a) => {
    for (let l = 0; l < n.length; ) {
      let c = n[l++], u = n[l++];
      a >= c && s <= u && (r = true);
    }
  }), r;
}
function gV(t4, e) {
  return t4.ranges.length == e.ranges.length && t4.ranges.filter((n, r) => n.empty != e.ranges[r].empty).length === 0;
}
function $T(t4, e) {
  return t4.length ? e.length ? t4.concat(e) : t4 : e;
}
var Dr = [];
var mV = 200;
function jT(t4, e) {
  if (t4.length) {
    let n = t4[t4.length - 1], r = n.selectionsAfter.slice(Math.max(0, n.selectionsAfter.length - mV));
    return r.length && r[r.length - 1].eq(e) ? t4 : (r.push(e), dd(t4, t4.length - 1, 1e9, n.setSelAfter(r)));
  } else
    return [ir.selection([e])];
}
function OV(t4) {
  let e = t4[t4.length - 1], n = t4.slice();
  return n[t4.length - 1] = e.setSelAfter(e.selectionsAfter.slice(0, e.selectionsAfter.length - 1)), n;
}
function Vp(t4, e) {
  if (!t4.length)
    return t4;
  let n = t4.length, r = Dr;
  for (; n; ) {
    let i = xV(t4[n - 1], e, r);
    if (i.changes && !i.changes.empty || i.effects.length) {
      let o = t4.slice(0, n);
      return o[n - 1] = i, o;
    } else
      e = i.mapped, n--, r = i.selectionsAfter;
  }
  return r.length ? [ir.selection(r)] : Dr;
}
function xV(t4, e, n) {
  let r = $T(t4.selectionsAfter.length ? t4.selectionsAfter.map((a) => a.map(e)) : Dr, n);
  if (!t4.changes)
    return ir.selection(r);
  let i = t4.changes.map(e), o = e.mapDesc(t4.changes, true), s = t4.mapped ? t4.mapped.composeDesc(o) : o;
  return new ir(i, Me.mapEffects(t4.effects, e), s, t4.startSelection.map(o), r);
}
var vV = /^(input\.type|delete)($|\.)/;
var xi = class {
  constructor(e, n, r = 0, i = void 0) {
    this.done = e, this.undone = n, this.prevTime = r, this.prevUserEvent = i;
  }
  isolate() {
    return this.prevTime ? new xi(this.done, this.undone) : this;
  }
  addChanges(e, n, r, i, o) {
    let s = this.done, a = s[s.length - 1];
    return a && a.changes && !a.changes.empty && e.changes && (!r || vV.test(r)) && (!a.selectionsAfter.length && n - this.prevTime < i.newGroupDelay && i.joinToEvent(o, pV(a.changes, e.changes)) || // For compose (but not compose.start) events, always join with previous event
    r == "input.type.compose") ? s = dd(s, s.length - 1, i.minDepth, new ir(e.changes.compose(a.changes), $T(e.effects, a.effects), a.mapped, a.startSelection, Dr)) : s = dd(s, s.length, i.minDepth, e), new xi(s, Dr, n, r);
  }
  addSelection(e, n, r, i) {
    let o = this.done.length ? this.done[this.done.length - 1].selectionsAfter : Dr;
    return o.length > 0 && n - this.prevTime < i && r == this.prevUserEvent && r && /^select($|\.)/.test(r) && gV(o[o.length - 1], e) ? this : new xi(jT(this.done, e), this.undone, n, r);
  }
  addMapping(e) {
    return new xi(Vp(this.done, e), Vp(this.undone, e), this.prevTime, this.prevUserEvent);
  }
  pop(e, n, r) {
    let i = e == 0 ? this.done : this.undone;
    if (i.length == 0)
      return null;
    let o = i[i.length - 1], s = o.selectionsAfter[0] || n.selection;
    if (r && o.selectionsAfter.length)
      return n.update({
        selection: o.selectionsAfter[o.selectionsAfter.length - 1],
        annotations: jm.of({ side: e, rest: OV(i), selection: s }),
        userEvent: e == 0 ? "select.undo" : "select.redo",
        scrollIntoView: true
      });
    if (o.changes) {
      let a = i.length == 1 ? Dr : i.slice(0, i.length - 1);
      return o.mapped && (a = Vp(a, o.mapped)), n.update({
        changes: o.changes,
        selection: o.startSelection,
        effects: o.effects,
        annotations: jm.of({ side: e, rest: a, selection: s }),
        filter: false,
        userEvent: e == 0 ? "undo" : "redo",
        scrollIntoView: true
      });
    } else
      return null;
  }
};
xi.empty = /* @__PURE__ */ new xi(Dr, Dr);
var yV = [
  { key: "Mod-z", run: IT, preventDefault: true },
  { key: "Mod-y", mac: "Mod-Shift-z", run: Rm, preventDefault: true },
  { linux: "Ctrl-Shift-z", run: Rm, preventDefault: true },
  { key: "Mod-u", run: dV, preventDefault: true },
  { key: "Alt-u", mac: "Mod-Shift-u", run: hV, preventDefault: true }
];
function el(t4, e) {
  return ne.create(t4.ranges.map(e), t4.mainIndex);
}
function Bi(t4, e) {
  return t4.update({ selection: e, scrollIntoView: true, userEvent: "select" });
}
function ei({ state: t4, dispatch: e }, n) {
  let r = el(t4.selection, n);
  return r.eq(t4.selection, true) ? false : (e(Bi(t4, r)), true);
}
function wh(t4, e) {
  return ne.cursor(e ? t4.to : t4.from);
}
function RT(t4, e) {
  return ei(t4, (n) => n.empty ? t4.moveByChar(n, e) : wh(n, e));
}
function Fn(t4) {
  return t4.textDirectionAt(t4.state.selection.main.head) == _t.LTR;
}
var DT = (t4) => RT(t4, !Fn(t4));
var QT = (t4) => RT(t4, Fn(t4));
function BT(t4, e) {
  return ei(t4, (n) => n.empty ? t4.moveByGroup(n, e) : wh(n, e));
}
var bV = (t4) => BT(t4, !Fn(t4));
var SV = (t4) => BT(t4, Fn(t4));
function wV(t4, e, n) {
  if (e.type.prop(n))
    return true;
  let r = e.to - e.from;
  return r && (r > 2 || /[^\s,.;:]/.test(t4.sliceDoc(e.from, e.to))) || e.firstChild;
}
function Ch(t4, e, n) {
  let r = Ft(t4).resolveInner(e.head), i = n ? Xe.closedBy : Xe.openedBy;
  for (let l = e.head; ; ) {
    let c = n ? r.childAfter(l) : r.childBefore(l);
    if (!c)
      break;
    wV(t4, c, i) ? r = c : l = n ? c.to : c.from;
  }
  let o = r.type.prop(i), s, a;
  return o && (s = n ? Oi(t4, r.from, 1) : Oi(t4, r.to, -1)) && s.matched ? a = n ? s.end.to : s.end.from : a = n ? r.to : r.from, ne.cursor(a, n ? -1 : 1);
}
var CV = (t4) => ei(t4, (e) => Ch(t4.state, e, !Fn(t4)));
var kV = (t4) => ei(t4, (e) => Ch(t4.state, e, Fn(t4)));
function _T(t4, e) {
  return ei(t4, (n) => {
    if (!n.empty)
      return wh(n, e);
    let r = t4.moveVertically(n, e);
    return r.head != n.head ? r : t4.moveToLineBoundary(n, e);
  });
}
var MT = (t4) => _T(t4, false);
var NT = (t4) => _T(t4, true);
function FT(t4) {
  let e = t4.scrollDOM.clientHeight < t4.scrollDOM.scrollHeight - 2, n = 0, r = 0, i;
  if (e) {
    for (let o of t4.state.facet(ue.scrollMargins)) {
      let s = o(t4);
      s != null && s.top && (n = Math.max(s == null ? void 0 : s.top, n)), s != null && s.bottom && (r = Math.max(s == null ? void 0 : s.bottom, r));
    }
    i = t4.scrollDOM.clientHeight - n - r;
  } else
    i = (t4.dom.ownerDocument.defaultView || window).innerHeight;
  return {
    marginTop: n,
    marginBottom: r,
    selfScroll: e,
    height: Math.max(t4.defaultLineHeight, i - 5)
  };
}
function ZT(t4, e) {
  let n = FT(t4), { state: r } = t4, i = el(r.selection, (s) => s.empty ? t4.moveVertically(s, e, n.height) : wh(s, e));
  if (i.eq(r.selection))
    return false;
  let o;
  if (n.selfScroll) {
    let s = t4.coordsAtPos(r.selection.main.head), a = t4.scrollDOM.getBoundingClientRect(), l = a.top + n.marginTop, c = a.bottom - n.marginBottom;
    s && s.top > l && s.bottom < c && (o = ue.scrollIntoView(i.main.head, { y: "start", yMargin: s.top - l }));
  }
  return t4.dispatch(Bi(r, i), { effects: o }), true;
}
var U1 = (t4) => ZT(t4, false);
var Dm = (t4) => ZT(t4, true);
function Zo(t4, e, n) {
  let r = t4.lineBlockAt(e.head), i = t4.moveToLineBoundary(e, n);
  if (i.head == e.head && i.head != (n ? r.to : r.from) && (i = t4.moveToLineBoundary(e, n, false)), !n && i.head == r.from && r.length) {
    let o = /^\s*/.exec(t4.state.sliceDoc(r.from, Math.min(r.from + 100, r.to)))[0].length;
    o && e.head != r.from + o && (i = ne.cursor(r.from + o));
  }
  return i;
}
var AV = (t4) => ei(t4, (e) => Zo(t4, e, true));
var PV = (t4) => ei(t4, (e) => Zo(t4, e, false));
var EV = (t4) => ei(t4, (e) => Zo(t4, e, !Fn(t4)));
var TV = (t4) => ei(t4, (e) => Zo(t4, e, Fn(t4)));
var IV = (t4) => ei(t4, (e) => ne.cursor(t4.lineBlockAt(e.head).from, 1));
var $V = (t4) => ei(t4, (e) => ne.cursor(t4.lineBlockAt(e.head).to, -1));
function jV(t4, e, n) {
  let r = false, i = el(t4.selection, (o) => {
    let s = Oi(t4, o.head, -1) || Oi(t4, o.head, 1) || o.head > 0 && Oi(t4, o.head - 1, 1) || o.head < t4.doc.length && Oi(t4, o.head + 1, -1);
    if (!s || !s.end)
      return o;
    r = true;
    let a = s.start.from == o.head ? s.end.to : s.end.from;
    return ne.cursor(a);
  });
  return r ? (e(Bi(t4, i)), true) : false;
}
var RV = ({ state: t4, dispatch: e }) => jV(t4, e);
function Zr(t4, e) {
  let n = el(t4.state.selection, (r) => {
    let i = e(r);
    return ne.range(r.anchor, i.head, i.goalColumn, i.bidiLevel || void 0);
  });
  return n.eq(t4.state.selection) ? false : (t4.dispatch(Bi(t4.state, n)), true);
}
function WT(t4, e) {
  return Zr(t4, (n) => t4.moveByChar(n, e));
}
var VT = (t4) => WT(t4, !Fn(t4));
var zT = (t4) => WT(t4, Fn(t4));
function LT(t4, e) {
  return Zr(t4, (n) => t4.moveByGroup(n, e));
}
var DV = (t4) => LT(t4, !Fn(t4));
var QV = (t4) => LT(t4, Fn(t4));
var BV = (t4) => Zr(t4, (e) => Ch(t4.state, e, !Fn(t4)));
var _V = (t4) => Zr(t4, (e) => Ch(t4.state, e, Fn(t4)));
function XT(t4, e) {
  return Zr(t4, (n) => t4.moveVertically(n, e));
}
var GT = (t4) => XT(t4, false);
var YT = (t4) => XT(t4, true);
function qT(t4, e) {
  return Zr(t4, (n) => t4.moveVertically(n, e, FT(t4).height));
}
var H1 = (t4) => qT(t4, false);
var J1 = (t4) => qT(t4, true);
var MV = (t4) => Zr(t4, (e) => Zo(t4, e, true));
var NV = (t4) => Zr(t4, (e) => Zo(t4, e, false));
var FV = (t4) => Zr(t4, (e) => Zo(t4, e, !Fn(t4)));
var ZV = (t4) => Zr(t4, (e) => Zo(t4, e, Fn(t4)));
var WV = (t4) => Zr(t4, (e) => ne.cursor(t4.lineBlockAt(e.head).from));
var VV = (t4) => Zr(t4, (e) => ne.cursor(t4.lineBlockAt(e.head).to));
var K1 = ({ state: t4, dispatch: e }) => (e(Bi(t4, { anchor: 0 })), true);
var eS = ({ state: t4, dispatch: e }) => (e(Bi(t4, { anchor: t4.doc.length })), true);
var tS = ({ state: t4, dispatch: e }) => (e(Bi(t4, { anchor: t4.selection.main.anchor, head: 0 })), true);
var nS = ({ state: t4, dispatch: e }) => (e(Bi(t4, { anchor: t4.selection.main.anchor, head: t4.doc.length })), true);
var zV = ({ state: t4, dispatch: e }) => (e(t4.update({ selection: { anchor: 0, head: t4.doc.length }, userEvent: "select" })), true);
var LV = ({ state: t4, dispatch: e }) => {
  let n = kh(t4).map(({ from: r, to: i }) => ne.range(r, Math.min(i + 1, t4.doc.length)));
  return e(t4.update({ selection: ne.create(n), userEvent: "select" })), true;
};
var XV = ({ state: t4, dispatch: e }) => {
  let n = el(t4.selection, (r) => {
    var i;
    let o = Ft(t4).resolveStack(r.from, 1);
    for (let s = o; s; s = s.next) {
      let { node: a } = s;
      if ((a.from < r.from && a.to >= r.to || a.to > r.to && a.from <= r.from) && (!((i = a.parent) === null || i === void 0) && i.parent))
        return ne.range(a.to, a.from);
    }
    return r;
  });
  return e(Bi(t4, n)), true;
};
var GV = ({ state: t4, dispatch: e }) => {
  let n = t4.selection, r = null;
  return n.ranges.length > 1 ? r = ne.create([n.main]) : n.main.empty || (r = ne.create([ne.cursor(n.main.head)])), r ? (e(Bi(t4, r)), true) : false;
};
function Nc(t4, e) {
  if (t4.state.readOnly)
    return false;
  let n = "delete.selection", { state: r } = t4, i = r.changeByRange((o) => {
    let { from: s, to: a } = o;
    if (s == a) {
      let l = e(o);
      l < s ? (n = "delete.backward", l = Nu(t4, l, false)) : l > s && (n = "delete.forward", l = Nu(t4, l, true)), s = Math.min(s, l), a = Math.max(a, l);
    } else
      s = Nu(t4, s, false), a = Nu(t4, a, true);
    return s == a ? { range: o } : { changes: { from: s, to: a }, range: ne.cursor(s, s < o.head ? -1 : 1) };
  });
  return i.changes.empty ? false : (t4.dispatch(r.update(i, {
    scrollIntoView: true,
    userEvent: n,
    effects: n == "delete.selection" ? ue.announce.of(r.phrase("Selection deleted")) : void 0
  })), true);
}
function Nu(t4, e, n) {
  if (t4 instanceof ue)
    for (let r of t4.state.facet(ue.atomicRanges).map((i) => i(t4)))
      r.between(e, e, (i, o) => {
        i < e && o > e && (e = n ? o : i);
      });
  return e;
}
var UT = (t4, e) => Nc(t4, (n) => {
  let r = n.from, { state: i } = t4, o = i.doc.lineAt(r), s, a;
  if (!e && r > o.from && r < o.from + 200 && !/[^ \t]/.test(s = o.text.slice(0, r - o.from))) {
    if (s[s.length - 1] == "	")
      return r - 1;
    let l = Ya(s, i.tabSize), c = l % cd(i) || cd(i);
    for (let u = 0; u < c && s[s.length - 1 - u] == " "; u++)
      r--;
    a = r;
  } else
    a = $n(o.text, r - o.from, e, e) + o.from, a == r && o.number != (e ? i.doc.lines : 1) ? a += e ? 1 : -1 : !e && /[\ufe00-\ufe0f]/.test(o.text.slice(a - o.from, r - o.from)) && (a = $n(o.text, a - o.from, false, false) + o.from);
  return a;
});
var Qm = (t4) => UT(t4, false);
var HT = (t4) => UT(t4, true);
var JT = (t4, e) => Nc(t4, (n) => {
  let r = n.head, { state: i } = t4, o = i.doc.lineAt(r), s = i.charCategorizer(r);
  for (let a = null; ; ) {
    if (r == (e ? o.to : o.from)) {
      r == n.head && o.number != (e ? i.doc.lines : 1) && (r += e ? 1 : -1);
      break;
    }
    let l = $n(o.text, r - o.from, e) + o.from, c = o.text.slice(Math.min(r, l) - o.from, Math.max(r, l) - o.from), u = s(c);
    if (a != null && u != a)
      break;
    (c != " " || r != n.head) && (a = u), r = l;
  }
  return r;
});
var KT = (t4) => JT(t4, false);
var YV = (t4) => JT(t4, true);
var qV = (t4) => Nc(t4, (e) => {
  let n = t4.lineBlockAt(e.head).to;
  return e.head < n ? n : Math.min(t4.state.doc.length, e.head + 1);
});
var UV = (t4) => Nc(t4, (e) => {
  let n = t4.moveToLineBoundary(e, false).head;
  return e.head > n ? n : Math.max(0, e.head - 1);
});
var HV = (t4) => Nc(t4, (e) => {
  let n = t4.moveToLineBoundary(e, true).head;
  return e.head < n ? n : Math.min(t4.state.doc.length, e.head + 1);
});
var JV = ({ state: t4, dispatch: e }) => {
  if (t4.readOnly)
    return false;
  let n = t4.changeByRange((r) => ({
    changes: { from: r.from, to: r.to, insert: ft.of(["", ""]) },
    range: ne.cursor(r.from)
  }));
  return e(t4.update(n, { scrollIntoView: true, userEvent: "input" })), true;
};
var KV = ({ state: t4, dispatch: e }) => {
  if (t4.readOnly)
    return false;
  let n = t4.changeByRange((r) => {
    if (!r.empty || r.from == 0 || r.from == t4.doc.length)
      return { range: r };
    let i = r.from, o = t4.doc.lineAt(i), s = i == o.from ? i - 1 : $n(o.text, i - o.from, false) + o.from, a = i == o.to ? i + 1 : $n(o.text, i - o.from, true) + o.from;
    return {
      changes: { from: s, to: a, insert: t4.doc.slice(i, a).append(t4.doc.slice(s, i)) },
      range: ne.cursor(a)
    };
  });
  return n.changes.empty ? false : (e(t4.update(n, { scrollIntoView: true, userEvent: "move.character" })), true);
};
function kh(t4) {
  let e = [], n = -1;
  for (let r of t4.selection.ranges) {
    let i = t4.doc.lineAt(r.from), o = t4.doc.lineAt(r.to);
    if (!r.empty && r.to == o.from && (o = t4.doc.lineAt(r.to - 1)), n >= i.number) {
      let s = e[e.length - 1];
      s.to = o.to, s.ranges.push(r);
    } else
      e.push({ from: i.from, to: o.to, ranges: [r] });
    n = o.number + 1;
  }
  return e;
}
function eI(t4, e, n) {
  if (t4.readOnly)
    return false;
  let r = [], i = [];
  for (let o of kh(t4)) {
    if (n ? o.to == t4.doc.length : o.from == 0)
      continue;
    let s = t4.doc.lineAt(n ? o.to + 1 : o.from - 1), a = s.length + 1;
    if (n) {
      r.push({ from: o.to, to: s.to }, { from: o.from, insert: s.text + t4.lineBreak });
      for (let l of o.ranges)
        i.push(ne.range(Math.min(t4.doc.length, l.anchor + a), Math.min(t4.doc.length, l.head + a)));
    } else {
      r.push({ from: s.from, to: o.from }, { from: o.to, insert: t4.lineBreak + s.text });
      for (let l of o.ranges)
        i.push(ne.range(l.anchor - a, l.head - a));
    }
  }
  return r.length ? (e(t4.update({
    changes: r,
    scrollIntoView: true,
    selection: ne.create(i, t4.selection.mainIndex),
    userEvent: "move.line"
  })), true) : false;
}
var e7 = ({ state: t4, dispatch: e }) => eI(t4, e, false);
var t7 = ({ state: t4, dispatch: e }) => eI(t4, e, true);
function tI(t4, e, n) {
  if (t4.readOnly)
    return false;
  let r = [];
  for (let i of kh(t4))
    n ? r.push({ from: i.from, insert: t4.doc.slice(i.from, i.to) + t4.lineBreak }) : r.push({ from: i.to, insert: t4.lineBreak + t4.doc.slice(i.from, i.to) });
  return e(t4.update({ changes: r, scrollIntoView: true, userEvent: "input.copyline" })), true;
}
var n7 = ({ state: t4, dispatch: e }) => tI(t4, e, false);
var r7 = ({ state: t4, dispatch: e }) => tI(t4, e, true);
var i7 = (t4) => {
  if (t4.state.readOnly)
    return false;
  let { state: e } = t4, n = e.changes(kh(e).map(({ from: i, to: o }) => (i > 0 ? i-- : o < e.doc.length && o++, { from: i, to: o }))), r = el(e.selection, (i) => t4.moveVertically(i, true)).map(n);
  return t4.dispatch({ changes: n, selection: r, scrollIntoView: true, userEvent: "delete.line" }), true;
};
function o7(t4, e) {
  if (/\(\)|\[\]|\{\}/.test(t4.sliceDoc(e - 1, e + 1)))
    return { from: e, to: e };
  let n = Ft(t4).resolveInner(e), r = n.childBefore(e), i = n.childAfter(e), o;
  return r && i && r.to <= e && i.from >= e && (o = r.type.prop(Xe.closedBy)) && o.indexOf(i.name) > -1 && t4.doc.lineAt(r.to).from == t4.doc.lineAt(i.from).from && !/\S/.test(t4.sliceDoc(r.to, i.from)) ? { from: r.to, to: i.from } : null;
}
var s7 = /* @__PURE__ */ nI(false);
var a7 = /* @__PURE__ */ nI(true);
function nI(t4) {
  return ({ state: e, dispatch: n }) => {
    if (e.readOnly)
      return false;
    let r = e.changeByRange((i) => {
      let { from: o, to: s } = i, a = e.doc.lineAt(o), l = !t4 && o == s && o7(e, o);
      t4 && (o = s = (s <= a.to ? a : e.doc.lineAt(s)).to);
      let c = new yh(e, { simulateBreak: o, simulateDoubleBreak: !!l }), u = Dx(c, o);
      for (u == null && (u = Ya(/^\s*/.exec(e.doc.lineAt(o).text)[0], e.tabSize)); s < a.to && /\s/.test(a.text[s - a.from]); )
        s++;
      l ? { from: o, to: s } = l : o > a.from && o < a.from + 100 && !/\S/.test(a.text.slice(0, o)) && (o = a.from);
      let f = ["", uc(e, u)];
      return l && f.push(uc(e, c.lineIndent(a.from, -1))), {
        changes: { from: o, to: s, insert: ft.of(f) },
        range: ne.cursor(o + 1 + f[1].length)
      };
    });
    return n(e.update(r, { scrollIntoView: true, userEvent: "input" })), true;
  };
}
function Zx(t4, e) {
  let n = -1;
  return t4.changeByRange((r) => {
    let i = [];
    for (let s = r.from; s <= r.to; ) {
      let a = t4.doc.lineAt(s);
      a.number > n && (r.empty || r.to > a.from) && (e(a, i, r), n = a.number), s = a.to + 1;
    }
    let o = t4.changes(i);
    return {
      changes: i,
      range: ne.range(o.mapPos(r.anchor, 1), o.mapPos(r.head, 1))
    };
  });
}
var l7 = ({ state: t4, dispatch: e }) => {
  if (t4.readOnly)
    return false;
  let n = /* @__PURE__ */ Object.create(null), r = new yh(t4, { overrideIndentation: (o) => {
    let s = n[o];
    return s ?? -1;
  } }), i = Zx(t4, (o, s, a) => {
    let l = Dx(r, o.from);
    if (l == null)
      return;
    /\S/.test(o.text) || (l = 0);
    let c = /^\s*/.exec(o.text)[0], u = uc(t4, l);
    (c != u || a.from < o.from + c.length) && (n[o.from] = l, s.push({ from: o.from, to: o.from + c.length, insert: u }));
  });
  return i.changes.empty || e(t4.update(i, { userEvent: "indent" })), true;
};
var rI = ({ state: t4, dispatch: e }) => t4.readOnly ? false : (e(t4.update(Zx(t4, (n, r) => {
  r.push({ from: n.from, insert: t4.facet(_c) });
}), { userEvent: "input.indent" })), true);
var iI = ({ state: t4, dispatch: e }) => t4.readOnly ? false : (e(t4.update(Zx(t4, (n, r) => {
  let i = /^\s*/.exec(n.text)[0];
  if (!i)
    return;
  let o = Ya(i, t4.tabSize), s = 0, a = uc(t4, Math.max(0, o - cd(t4)));
  for (; s < i.length && s < a.length && i.charCodeAt(s) == a.charCodeAt(s); )
    s++;
  r.push({ from: n.from + s, to: n.from + i.length, insert: a.slice(s) });
}), { userEvent: "delete.dedent" })), true);
var c7 = [
  { key: "Ctrl-b", run: DT, shift: VT, preventDefault: true },
  { key: "Ctrl-f", run: QT, shift: zT },
  { key: "Ctrl-p", run: MT, shift: GT },
  { key: "Ctrl-n", run: NT, shift: YT },
  { key: "Ctrl-a", run: IV, shift: WV },
  { key: "Ctrl-e", run: $V, shift: VV },
  { key: "Ctrl-d", run: HT },
  { key: "Ctrl-h", run: Qm },
  { key: "Ctrl-k", run: qV },
  { key: "Ctrl-Alt-h", run: KT },
  { key: "Ctrl-o", run: JV },
  { key: "Ctrl-t", run: KV },
  { key: "Ctrl-v", run: Dm }
];
var u7 = /* @__PURE__ */ [
  { key: "ArrowLeft", run: DT, shift: VT, preventDefault: true },
  { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: bV, shift: DV, preventDefault: true },
  { mac: "Cmd-ArrowLeft", run: EV, shift: FV, preventDefault: true },
  { key: "ArrowRight", run: QT, shift: zT, preventDefault: true },
  { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: SV, shift: QV, preventDefault: true },
  { mac: "Cmd-ArrowRight", run: TV, shift: ZV, preventDefault: true },
  { key: "ArrowUp", run: MT, shift: GT, preventDefault: true },
  { mac: "Cmd-ArrowUp", run: K1, shift: tS },
  { mac: "Ctrl-ArrowUp", run: U1, shift: H1 },
  { key: "ArrowDown", run: NT, shift: YT, preventDefault: true },
  { mac: "Cmd-ArrowDown", run: eS, shift: nS },
  { mac: "Ctrl-ArrowDown", run: Dm, shift: J1 },
  { key: "PageUp", run: U1, shift: H1 },
  { key: "PageDown", run: Dm, shift: J1 },
  { key: "Home", run: PV, shift: NV, preventDefault: true },
  { key: "Mod-Home", run: K1, shift: tS },
  { key: "End", run: AV, shift: MV, preventDefault: true },
  { key: "Mod-End", run: eS, shift: nS },
  { key: "Enter", run: s7 },
  { key: "Mod-a", run: zV },
  { key: "Backspace", run: Qm, shift: Qm },
  { key: "Delete", run: HT },
  { key: "Mod-Backspace", mac: "Alt-Backspace", run: KT },
  { key: "Mod-Delete", mac: "Alt-Delete", run: YV },
  { mac: "Mod-Backspace", run: UV },
  { mac: "Mod-Delete", run: HV }
].concat(/* @__PURE__ */ c7.map((t4) => ({ mac: t4.key, run: t4.run, shift: t4.shift })));
var f7 = /* @__PURE__ */ [
  { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: CV, shift: BV },
  { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: kV, shift: _V },
  { key: "Alt-ArrowUp", run: e7 },
  { key: "Shift-Alt-ArrowUp", run: n7 },
  { key: "Alt-ArrowDown", run: t7 },
  { key: "Shift-Alt-ArrowDown", run: r7 },
  { key: "Escape", run: GV },
  { key: "Mod-Enter", run: a7 },
  { key: "Alt-l", mac: "Ctrl-l", run: LV },
  { key: "Mod-i", run: XV, preventDefault: true },
  { key: "Mod-[", run: iI },
  { key: "Mod-]", run: rI },
  { key: "Mod-Alt-\\", run: l7 },
  { key: "Shift-Mod-k", run: i7 },
  { key: "Shift-Mod-\\", run: RV },
  { key: "Mod-/", run: nV },
  { key: "Alt-A", run: iV }
].concat(u7);
var d7 = { key: "Tab", run: rI, shift: iI };
function jt() {
  var t4 = arguments[0];
  typeof t4 == "string" && (t4 = document.createElement(t4));
  var e = 1, n = arguments[1];
  if (n && typeof n == "object" && n.nodeType == null && !Array.isArray(n)) {
    for (var r in n)
      if (Object.prototype.hasOwnProperty.call(n, r)) {
        var i = n[r];
        typeof i == "string" ? t4.setAttribute(r, i) : i != null && (t4[r] = i);
      }
    e++;
  }
  for (; e < arguments.length; e++)
    oI(t4, arguments[e]);
  return t4;
}
function oI(t4, e) {
  if (typeof e == "string")
    t4.appendChild(document.createTextNode(e));
  else if (e != null)
    if (e.nodeType != null)
      t4.appendChild(e);
    else if (Array.isArray(e))
      for (var n = 0; n < e.length; n++)
        oI(t4, e[n]);
    else
      throw new RangeError("Unsupported child node: " + e);
}
var rS = typeof String.prototype.normalize == "function" ? (t4) => t4.normalize("NFKD") : (t4) => t4;
var Ea = class {
  /**
  Create a text cursor. The query is the search string, `from` to
  `to` provides the region to search.
  
  When `normalize` is given, it will be called, on both the query
  string and the content it is matched against, before comparing.
  You can, for example, create a case-insensitive search by
  passing `s => s.toLowerCase()`.
  
  Text is always normalized with
  [`.normalize("NFKD")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)
  (when supported).
  */
  constructor(e, n, r = 0, i = e.length, o, s) {
    this.test = s, this.value = { from: 0, to: 0 }, this.done = false, this.matches = [], this.buffer = "", this.bufferPos = 0, this.iter = e.iterRange(r, i), this.bufferStart = r, this.normalize = o ? (a) => o(rS(a)) : rS, this.query = this.normalize(n);
  }
  peek() {
    if (this.bufferPos == this.buffer.length) {
      if (this.bufferStart += this.buffer.length, this.iter.next(), this.iter.done)
        return -1;
      this.bufferPos = 0, this.buffer = this.iter.value;
    }
    return Pn(this.buffer, this.bufferPos);
  }
  /**
  Look for the next match. Updates the iterator's
  [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and
  [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called
  at least once before using the cursor.
  */
  next() {
    for (; this.matches.length; )
      this.matches.pop();
    return this.nextOverlapping();
  }
  /**
  The `next` method will ignore matches that partially overlap a
  previous match. This method behaves like `next`, but includes
  such matches.
  */
  nextOverlapping() {
    for (; ; ) {
      let e = this.peek();
      if (e < 0)
        return this.done = true, this;
      let n = Ox(e), r = this.bufferStart + this.bufferPos;
      this.bufferPos += jr(e);
      let i = this.normalize(n);
      for (let o = 0, s = r; ; o++) {
        let a = i.charCodeAt(o), l = this.match(a, s, this.bufferPos + this.bufferStart);
        if (o == i.length - 1) {
          if (l)
            return this.value = l, this;
          break;
        }
        s == r && o < n.length && n.charCodeAt(o) == a && s++;
      }
    }
  }
  match(e, n, r) {
    let i = null;
    for (let o = 0; o < this.matches.length; o += 2) {
      let s = this.matches[o], a = false;
      this.query.charCodeAt(s) == e && (s == this.query.length - 1 ? i = { from: this.matches[o + 1], to: r } : (this.matches[o]++, a = true)), a || (this.matches.splice(o, 2), o -= 2);
    }
    return this.query.charCodeAt(0) == e && (this.query.length == 1 ? i = { from: n, to: r } : this.matches.push(1, n)), i && this.test && !this.test(i.from, i.to, this.buffer, this.bufferStart) && (i = null), i;
  }
};
typeof Symbol < "u" && (Ea.prototype[Symbol.iterator] = function() {
  return this;
});
var sI = { from: -1, to: -1, match: /* @__PURE__ */ /.*/.exec("") };
var Wx = "gm" + (/x/.unicode == null ? "" : "u");
var aI = class {
  /**
  Create a cursor that will search the given range in the given
  document. `query` should be the raw pattern (as you'd pass it to
  `new RegExp`).
  */
  constructor(e, n, r, i = 0, o = e.length) {
    if (this.text = e, this.to = o, this.curLine = "", this.done = false, this.value = sI, /\\[sWDnr]|\n|\r|\[\^/.test(n))
      return new lI(e, n, r, i, o);
    this.re = new RegExp(n, Wx + (r != null && r.ignoreCase ? "i" : "")), this.test = r == null ? void 0 : r.test, this.iter = e.iter();
    let s = e.lineAt(i);
    this.curLineStart = s.from, this.matchPos = hd(e, i), this.getLine(this.curLineStart);
  }
  getLine(e) {
    this.iter.next(e), this.iter.lineBreak ? this.curLine = "" : (this.curLine = this.iter.value, this.curLineStart + this.curLine.length > this.to && (this.curLine = this.curLine.slice(0, this.to - this.curLineStart)), this.iter.next());
  }
  nextLine() {
    this.curLineStart = this.curLineStart + this.curLine.length + 1, this.curLineStart > this.to ? this.curLine = "" : this.getLine(0);
  }
  /**
  Move to the next match, if there is one.
  */
  next() {
    for (let e = this.matchPos - this.curLineStart; ; ) {
      this.re.lastIndex = e;
      let n = this.matchPos <= this.to && this.re.exec(this.curLine);
      if (n) {
        let r = this.curLineStart + n.index, i = r + n[0].length;
        if (this.matchPos = hd(this.text, i + (r == i ? 1 : 0)), r == this.curLineStart + this.curLine.length && this.nextLine(), (r < i || r > this.value.to) && (!this.test || this.test(r, i, n)))
          return this.value = { from: r, to: i, match: n }, this;
        e = this.matchPos - this.curLineStart;
      } else if (this.curLineStart + this.curLine.length < this.to)
        this.nextLine(), e = 0;
      else
        return this.done = true, this;
    }
  }
};
var zp = /* @__PURE__ */ new WeakMap();
var fa = class {
  constructor(e, n) {
    this.from = e, this.text = n;
  }
  get to() {
    return this.from + this.text.length;
  }
  static get(e, n, r) {
    let i = zp.get(e);
    if (!i || i.from >= r || i.to <= n) {
      let a = new fa(n, e.sliceString(n, r));
      return zp.set(e, a), a;
    }
    if (i.from == n && i.to == r)
      return i;
    let { text: o, from: s } = i;
    return s > n && (o = e.sliceString(n, s) + o, s = n), i.to < r && (o += e.sliceString(i.to, r)), zp.set(e, new fa(s, o)), new fa(n, o.slice(n - s, r - s));
  }
};
var lI = class {
  constructor(e, n, r, i, o) {
    this.text = e, this.to = o, this.done = false, this.value = sI, this.matchPos = hd(e, i), this.re = new RegExp(n, Wx + (r != null && r.ignoreCase ? "i" : "")), this.test = r == null ? void 0 : r.test, this.flat = fa.get(e, i, this.chunkEnd(
      i + 5e3
      /* Chunk.Base */
    ));
  }
  chunkEnd(e) {
    return e >= this.to ? this.to : this.text.lineAt(e).to;
  }
  next() {
    for (; ; ) {
      let e = this.re.lastIndex = this.matchPos - this.flat.from, n = this.re.exec(this.flat.text);
      if (n && !n[0] && n.index == e && (this.re.lastIndex = e + 1, n = this.re.exec(this.flat.text)), n) {
        let r = this.flat.from + n.index, i = r + n[0].length;
        if ((this.flat.to >= this.to || n.index + n[0].length <= this.flat.text.length - 10) && (!this.test || this.test(r, i, n)))
          return this.value = { from: r, to: i, match: n }, this.matchPos = hd(this.text, i + (r == i ? 1 : 0)), this;
      }
      if (this.flat.to == this.to)
        return this.done = true, this;
      this.flat = fa.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
    }
  }
};
typeof Symbol < "u" && (aI.prototype[Symbol.iterator] = lI.prototype[Symbol.iterator] = function() {
  return this;
});
function h7(t4) {
  try {
    return new RegExp(t4, Wx), true;
  } catch {
    return false;
  }
}
function hd(t4, e) {
  if (e >= t4.length)
    return e;
  let n = t4.lineAt(e), r;
  for (; e < n.to && (r = n.text.charCodeAt(e - n.from)) >= 56320 && r < 57344; )
    e++;
  return e;
}
function Bm(t4) {
  let e = String(t4.state.doc.lineAt(t4.state.selection.main.head).number), n = jt("input", { class: "cm-textfield", name: "line", value: e }), r = jt("form", {
    class: "cm-gotoLine",
    onkeydown: (o) => {
      o.keyCode == 27 ? (o.preventDefault(), t4.dispatch({ effects: pd.of(false) }), t4.focus()) : o.keyCode == 13 && (o.preventDefault(), i());
    },
    onsubmit: (o) => {
      o.preventDefault(), i();
    }
  }, jt("label", t4.state.phrase("Go to line"), ": ", n), " ", jt("button", { class: "cm-button", type: "submit" }, t4.state.phrase("go")));
  function i() {
    let o = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(n.value);
    if (!o)
      return;
    let { state: s } = t4, a = s.doc.lineAt(s.selection.main.head), [, l, c, u, f] = o, d = u ? +u.slice(1) : 0, h = c ? +c : a.number;
    if (c && f) {
      let m = h / 100;
      l && (m = m * (l == "-" ? -1 : 1) + a.number / s.doc.lines), h = Math.round(s.doc.lines * m);
    } else
      c && l && (h = h * (l == "-" ? -1 : 1) + a.number);
    let p = s.doc.line(Math.max(1, Math.min(s.doc.lines, h))), O = ne.cursor(p.from + Math.max(0, Math.min(d, p.length)));
    t4.dispatch({
      effects: [pd.of(false), ue.scrollIntoView(O.from, { y: "center" })],
      selection: O
    }), t4.focus();
  }
  return { dom: r };
}
var pd = /* @__PURE__ */ Me.define();
var iS = /* @__PURE__ */ pn.define({
  create() {
    return true;
  },
  update(t4, e) {
    for (let n of e.effects)
      n.is(pd) && (t4 = n.value);
    return t4;
  },
  provide: (t4) => ac.from(t4, (e) => e ? Bm : null)
});
var p7 = (t4) => {
  let e = sc(t4, Bm);
  if (!e) {
    let n = [pd.of(true)];
    t4.state.field(iS, false) == null && n.push(Me.appendConfig.of([iS, g7])), t4.dispatch({ effects: n }), e = sc(t4, Bm);
  }
  return e && e.dom.querySelector("input").select(), true;
};
var g7 = /* @__PURE__ */ ue.baseTheme({
  ".cm-panel.cm-gotoLine": {
    padding: "2px 6px 4px",
    "& label": { fontSize: "80%" }
  }
});
var m7 = {
  highlightWordAroundCursor: false,
  minSelectionLength: 1,
  maxMatches: 100,
  wholeWords: false
};
var O7 = /* @__PURE__ */ ge.define({
  combine(t4) {
    return Di(t4, m7, {
      highlightWordAroundCursor: (e, n) => e || n,
      minSelectionLength: Math.min,
      maxMatches: Math.min
    });
  }
});
function x7(t4) {
  return [w7, S7];
}
var v7 = /* @__PURE__ */ we.mark({ class: "cm-selectionMatch" });
var y7 = /* @__PURE__ */ we.mark({ class: "cm-selectionMatch cm-selectionMatch-main" });
function oS(t4, e, n, r) {
  return (n == 0 || t4(e.sliceDoc(n - 1, n)) != Nt.Word) && (r == e.doc.length || t4(e.sliceDoc(r, r + 1)) != Nt.Word);
}
function b7(t4, e, n, r) {
  return t4(e.sliceDoc(n, n + 1)) == Nt.Word && t4(e.sliceDoc(r - 1, r)) == Nt.Word;
}
var S7 = /* @__PURE__ */ Wt.fromClass(class {
  constructor(t4) {
    this.decorations = this.getDeco(t4);
  }
  update(t4) {
    (t4.selectionSet || t4.docChanged || t4.viewportChanged) && (this.decorations = this.getDeco(t4.view));
  }
  getDeco(t4) {
    let e = t4.state.facet(O7), { state: n } = t4, r = n.selection;
    if (r.ranges.length > 1)
      return we.none;
    let i = r.main, o, s = null;
    if (i.empty) {
      if (!e.highlightWordAroundCursor)
        return we.none;
      let l = n.wordAt(i.head);
      if (!l)
        return we.none;
      s = n.charCategorizer(i.head), o = n.sliceDoc(l.from, l.to);
    } else {
      let l = i.to - i.from;
      if (l < e.minSelectionLength || l > 200)
        return we.none;
      if (e.wholeWords) {
        if (o = n.sliceDoc(i.from, i.to), s = n.charCategorizer(i.head), !(oS(s, n, i.from, i.to) && b7(s, n, i.from, i.to)))
          return we.none;
      } else if (o = n.sliceDoc(i.from, i.to), !o)
        return we.none;
    }
    let a = [];
    for (let l of t4.visibleRanges) {
      let c = new Ea(n.doc, o, l.from, l.to);
      for (; !c.next().done; ) {
        let { from: u, to: f } = c.value;
        if ((!s || oS(s, n, u, f)) && (i.empty && u <= i.from && f >= i.to ? a.push(y7.range(u, f)) : (u >= i.to || f <= i.from) && a.push(v7.range(u, f)), a.length > e.maxMatches))
          return we.none;
      }
    }
    return we.set(a);
  }
}, {
  decorations: (t4) => t4.decorations
});
var w7 = /* @__PURE__ */ ue.baseTheme({
  ".cm-selectionMatch": { backgroundColor: "#99ff7780" },
  ".cm-searchMatch .cm-selectionMatch": { backgroundColor: "transparent" }
});
var C7 = ({ state: t4, dispatch: e }) => {
  let { selection: n } = t4, r = ne.create(n.ranges.map((i) => t4.wordAt(i.head) || ne.cursor(i.head)), n.mainIndex);
  return r.eq(n) ? false : (e(t4.update({ selection: r })), true);
};
function k7(t4, e) {
  let { main: n, ranges: r } = t4.selection, i = t4.wordAt(n.head), o = i && i.from == n.from && i.to == n.to;
  for (let s = false, a = new Ea(t4.doc, e, r[r.length - 1].to); ; )
    if (a.next(), a.done) {
      if (s)
        return null;
      a = new Ea(t4.doc, e, 0, Math.max(0, r[r.length - 1].from - 1)), s = true;
    } else {
      if (s && r.some((l) => l.from == a.value.from))
        continue;
      if (o) {
        let l = t4.wordAt(a.value.from);
        if (!l || l.from != a.value.from || l.to != a.value.to)
          continue;
      }
      return a.value;
    }
}
var A7 = ({ state: t4, dispatch: e }) => {
  let { ranges: n } = t4.selection;
  if (n.some((o) => o.from === o.to))
    return C7({ state: t4, dispatch: e });
  let r = t4.sliceDoc(n[0].from, n[0].to);
  if (t4.selection.ranges.some((o) => t4.sliceDoc(o.from, o.to) != r))
    return false;
  let i = k7(t4, r);
  return i ? (e(t4.update({
    selection: t4.selection.addRange(ne.range(i.from, i.to), false),
    effects: ue.scrollIntoView(i.to)
  })), true) : false;
};
var tl = /* @__PURE__ */ ge.define({
  combine(t4) {
    return Di(t4, {
      top: false,
      caseSensitive: false,
      literal: false,
      regexp: false,
      wholeWord: false,
      createPanel: (e) => new M7(e),
      scrollToMatch: (e) => ue.scrollIntoView(e)
    });
  }
});
var cI = class {
  /**
  Create a query object.
  */
  constructor(e) {
    this.search = e.search, this.caseSensitive = !!e.caseSensitive, this.literal = !!e.literal, this.regexp = !!e.regexp, this.replace = e.replace || "", this.valid = !!this.search && (!this.regexp || h7(this.search)), this.unquoted = this.unquote(this.search), this.wholeWord = !!e.wholeWord;
  }
  /**
  @internal
  */
  unquote(e) {
    return this.literal ? e : e.replace(/\\([nrt\\])/g, (n, r) => r == "n" ? `
` : r == "r" ? "\r" : r == "t" ? "	" : "\\");
  }
  /**
  Compare this query to another query.
  */
  eq(e) {
    return this.search == e.search && this.replace == e.replace && this.caseSensitive == e.caseSensitive && this.regexp == e.regexp && this.wholeWord == e.wholeWord;
  }
  /**
  @internal
  */
  create() {
    return this.regexp ? new I7(this) : new E7(this);
  }
  /**
  Get a search cursor for this query, searching through the given
  range in the given state.
  */
  getCursor(e, n = 0, r) {
    let i = e.doc ? e : et.create({ doc: e });
    return r == null && (r = i.doc.length), this.regexp ? zs(this, i, n, r) : Vs(this, i, n, r);
  }
};
var uI = class {
  constructor(e) {
    this.spec = e;
  }
};
function Vs(t4, e, n, r) {
  return new Ea(e.doc, t4.unquoted, n, r, t4.caseSensitive ? void 0 : (i) => i.toLowerCase(), t4.wholeWord ? P7(e.doc, e.charCategorizer(e.selection.main.head)) : void 0);
}
function P7(t4, e) {
  return (n, r, i, o) => ((o > n || o + i.length < r) && (o = Math.max(0, n - 2), i = t4.sliceString(o, Math.min(t4.length, r + 2))), (e(gd(i, n - o)) != Nt.Word || e(md(i, n - o)) != Nt.Word) && (e(md(i, r - o)) != Nt.Word || e(gd(i, r - o)) != Nt.Word));
}
var E7 = class extends uI {
  constructor(e) {
    super(e);
  }
  nextMatch(e, n, r) {
    let i = Vs(this.spec, e, r, e.doc.length).nextOverlapping();
    return i.done && (i = Vs(this.spec, e, 0, n).nextOverlapping()), i.done ? null : i.value;
  }
  // Searching in reverse is, rather than implementing an inverted search
  // cursor, done by scanning chunk after chunk forward.
  prevMatchInRange(e, n, r) {
    for (let i = r; ; ) {
      let o = Math.max(n, i - 1e4 - this.spec.unquoted.length), s = Vs(this.spec, e, o, i), a = null;
      for (; !s.nextOverlapping().done; )
        a = s.value;
      if (a)
        return a;
      if (o == n)
        return null;
      i -= 1e4;
    }
  }
  prevMatch(e, n, r) {
    return this.prevMatchInRange(e, 0, n) || this.prevMatchInRange(e, r, e.doc.length);
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace);
  }
  matchAll(e, n) {
    let r = Vs(this.spec, e, 0, e.doc.length), i = [];
    for (; !r.next().done; ) {
      if (i.length >= n)
        return null;
      i.push(r.value);
    }
    return i;
  }
  highlight(e, n, r, i) {
    let o = Vs(this.spec, e, Math.max(0, n - this.spec.unquoted.length), Math.min(r + this.spec.unquoted.length, e.doc.length));
    for (; !o.next().done; )
      i(o.value.from, o.value.to);
  }
};
function zs(t4, e, n, r) {
  return new aI(e.doc, t4.search, {
    ignoreCase: !t4.caseSensitive,
    test: t4.wholeWord ? T7(e.charCategorizer(e.selection.main.head)) : void 0
  }, n, r);
}
function gd(t4, e) {
  return t4.slice($n(t4, e, false), e);
}
function md(t4, e) {
  return t4.slice(e, $n(t4, e));
}
function T7(t4) {
  return (e, n, r) => !r[0].length || (t4(gd(r.input, r.index)) != Nt.Word || t4(md(r.input, r.index)) != Nt.Word) && (t4(md(r.input, r.index + r[0].length)) != Nt.Word || t4(gd(r.input, r.index + r[0].length)) != Nt.Word);
}
var I7 = class extends uI {
  nextMatch(e, n, r) {
    let i = zs(this.spec, e, r, e.doc.length).next();
    return i.done && (i = zs(this.spec, e, 0, n).next()), i.done ? null : i.value;
  }
  prevMatchInRange(e, n, r) {
    for (let i = 1; ; i++) {
      let o = Math.max(
        n,
        r - i * 1e4
        /* FindPrev.ChunkSize */
      ), s = zs(this.spec, e, o, r), a = null;
      for (; !s.next().done; )
        a = s.value;
      if (a && (o == n || a.from > o + 10))
        return a;
      if (o == n)
        return null;
    }
  }
  prevMatch(e, n, r) {
    return this.prevMatchInRange(e, 0, n) || this.prevMatchInRange(e, r, e.doc.length);
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace).replace(/\$([$&\d+])/g, (n, r) => r == "$" ? "$" : r == "&" ? e.match[0] : r != "0" && +r < e.match.length ? e.match[r] : n);
  }
  matchAll(e, n) {
    let r = zs(this.spec, e, 0, e.doc.length), i = [];
    for (; !r.next().done; ) {
      if (i.length >= n)
        return null;
      i.push(r.value);
    }
    return i;
  }
  highlight(e, n, r, i) {
    let o = zs(this.spec, e, Math.max(
      0,
      n - 250
      /* RegExp.HighlightMargin */
    ), Math.min(r + 250, e.doc.length));
    for (; !o.next().done; )
      i(o.value.from, o.value.to);
  }
};
var fc = /* @__PURE__ */ Me.define();
var Vx = /* @__PURE__ */ Me.define();
var Co = /* @__PURE__ */ pn.define({
  create(t4) {
    return new Lp(_m(t4).create(), null);
  },
  update(t4, e) {
    for (let n of e.effects)
      n.is(fc) ? t4 = new Lp(n.value.create(), t4.panel) : n.is(Vx) && (t4 = new Lp(t4.query, n.value ? zx : null));
    return t4;
  },
  provide: (t4) => ac.from(t4, (e) => e.panel)
});
var Lp = class {
  constructor(e, n) {
    this.query = e, this.panel = n;
  }
};
var $7 = /* @__PURE__ */ we.mark({ class: "cm-searchMatch" });
var j7 = /* @__PURE__ */ we.mark({ class: "cm-searchMatch cm-searchMatch-selected" });
var R7 = /* @__PURE__ */ Wt.fromClass(class {
  constructor(t4) {
    this.view = t4, this.decorations = this.highlight(t4.state.field(Co));
  }
  update(t4) {
    let e = t4.state.field(Co);
    (e != t4.startState.field(Co) || t4.docChanged || t4.selectionSet || t4.viewportChanged) && (this.decorations = this.highlight(e));
  }
  highlight({ query: t4, panel: e }) {
    if (!e || !t4.spec.valid)
      return we.none;
    let { view: n } = this, r = new To();
    for (let i = 0, o = n.visibleRanges, s = o.length; i < s; i++) {
      let { from: a, to: l } = o[i];
      for (; i < s - 1 && l > o[i + 1].from - 2 * 250; )
        l = o[++i].to;
      t4.highlight(n.state, a, l, (c, u) => {
        let f = n.state.selection.ranges.some((d) => d.from == c && d.to == u);
        r.add(c, u, f ? j7 : $7);
      });
    }
    return r.finish();
  }
}, {
  decorations: (t4) => t4.decorations
});
function Fc(t4) {
  return (e) => {
    let n = e.state.field(Co, false);
    return n && n.query.spec.valid ? t4(e, n) : hI(e);
  };
}
var Od = /* @__PURE__ */ Fc((t4, { query: e }) => {
  let { to: n } = t4.state.selection.main, r = e.nextMatch(t4.state, n, n);
  if (!r)
    return false;
  let i = ne.single(r.from, r.to), o = t4.state.facet(tl);
  return t4.dispatch({
    selection: i,
    effects: [Lx(t4, r), o.scrollToMatch(i.main, t4)],
    userEvent: "select.search"
  }), dI(t4), true;
});
var xd = /* @__PURE__ */ Fc((t4, { query: e }) => {
  let { state: n } = t4, { from: r } = n.selection.main, i = e.prevMatch(n, r, r);
  if (!i)
    return false;
  let o = ne.single(i.from, i.to), s = t4.state.facet(tl);
  return t4.dispatch({
    selection: o,
    effects: [Lx(t4, i), s.scrollToMatch(o.main, t4)],
    userEvent: "select.search"
  }), dI(t4), true;
});
var D7 = /* @__PURE__ */ Fc((t4, { query: e }) => {
  let n = e.matchAll(t4.state, 1e3);
  return !n || !n.length ? false : (t4.dispatch({
    selection: ne.create(n.map((r) => ne.range(r.from, r.to))),
    userEvent: "select.search.matches"
  }), true);
});
var Q7 = ({ state: t4, dispatch: e }) => {
  let n = t4.selection;
  if (n.ranges.length > 1 || n.main.empty)
    return false;
  let { from: r, to: i } = n.main, o = [], s = 0;
  for (let a = new Ea(t4.doc, t4.sliceDoc(r, i)); !a.next().done; ) {
    if (o.length > 1e3)
      return false;
    a.value.from == r && (s = o.length), o.push(ne.range(a.value.from, a.value.to));
  }
  return e(t4.update({
    selection: ne.create(o, s),
    userEvent: "select.search.matches"
  })), true;
};
var sS = /* @__PURE__ */ Fc((t4, { query: e }) => {
  let { state: n } = t4, { from: r, to: i } = n.selection.main;
  if (n.readOnly)
    return false;
  let o = e.nextMatch(n, r, r);
  if (!o)
    return false;
  let s = [], a, l, c = [];
  if (o.from == r && o.to == i && (l = n.toText(e.getReplacement(o)), s.push({ from: o.from, to: o.to, insert: l }), o = e.nextMatch(n, o.from, o.to), c.push(ue.announce.of(n.phrase("replaced match on line $", n.doc.lineAt(r).number) + "."))), o) {
    let u = s.length == 0 || s[0].from >= o.to ? 0 : o.to - o.from - l.length;
    a = ne.single(o.from - u, o.to - u), c.push(Lx(t4, o)), c.push(n.facet(tl).scrollToMatch(a.main, t4));
  }
  return t4.dispatch({
    changes: s,
    selection: a,
    effects: c,
    userEvent: "input.replace"
  }), true;
});
var B7 = /* @__PURE__ */ Fc((t4, { query: e }) => {
  if (t4.state.readOnly)
    return false;
  let n = e.matchAll(t4.state, 1e9).map((i) => {
    let { from: o, to: s } = i;
    return { from: o, to: s, insert: e.getReplacement(i) };
  });
  if (!n.length)
    return false;
  let r = t4.state.phrase("replaced $ matches", n.length) + ".";
  return t4.dispatch({
    changes: n,
    effects: ue.announce.of(r),
    userEvent: "input.replace.all"
  }), true;
});
function zx(t4) {
  return t4.state.facet(tl).createPanel(t4);
}
function _m(t4, e) {
  var n, r, i, o, s;
  let a = t4.selection.main, l = a.empty || a.to > a.from + 100 ? "" : t4.sliceDoc(a.from, a.to);
  if (e && !l)
    return e;
  let c = t4.facet(tl);
  return new cI({
    search: ((n = e == null ? void 0 : e.literal) !== null && n !== void 0 ? n : c.literal) ? l : l.replace(/\n/g, "\\n"),
    caseSensitive: (r = e == null ? void 0 : e.caseSensitive) !== null && r !== void 0 ? r : c.caseSensitive,
    literal: (i = e == null ? void 0 : e.literal) !== null && i !== void 0 ? i : c.literal,
    regexp: (o = e == null ? void 0 : e.regexp) !== null && o !== void 0 ? o : c.regexp,
    wholeWord: (s = e == null ? void 0 : e.wholeWord) !== null && s !== void 0 ? s : c.wholeWord
  });
}
function fI(t4) {
  let e = sc(t4, zx);
  return e && e.dom.querySelector("[main-field]");
}
function dI(t4) {
  let e = fI(t4);
  e && e == t4.root.activeElement && e.select();
}
var hI = (t4) => {
  let e = t4.state.field(Co, false);
  if (e && e.panel) {
    let n = fI(t4);
    if (n && n != t4.root.activeElement) {
      let r = _m(t4.state, e.query.spec);
      r.valid && t4.dispatch({ effects: fc.of(r) }), n.focus(), n.select();
    }
  } else
    t4.dispatch({ effects: [
      Vx.of(true),
      e ? fc.of(_m(t4.state, e.query.spec)) : Me.appendConfig.of(F7)
    ] });
  return true;
};
var pI = (t4) => {
  let e = t4.state.field(Co, false);
  if (!e || !e.panel)
    return false;
  let n = sc(t4, zx);
  return n && n.dom.contains(t4.root.activeElement) && t4.focus(), t4.dispatch({ effects: Vx.of(false) }), true;
};
var _7 = [
  { key: "Mod-f", run: hI, scope: "editor search-panel" },
  { key: "F3", run: Od, shift: xd, scope: "editor search-panel", preventDefault: true },
  { key: "Mod-g", run: Od, shift: xd, scope: "editor search-panel", preventDefault: true },
  { key: "Escape", run: pI, scope: "editor search-panel" },
  { key: "Mod-Shift-l", run: Q7 },
  { key: "Mod-Alt-g", run: p7 },
  { key: "Mod-d", run: A7, preventDefault: true }
];
var M7 = class {
  constructor(e) {
    this.view = e;
    let n = this.query = e.state.field(Co).query.spec;
    this.commit = this.commit.bind(this), this.searchField = jt("input", {
      value: n.search,
      placeholder: dr(e, "Find"),
      "aria-label": dr(e, "Find"),
      class: "cm-textfield",
      name: "search",
      form: "",
      "main-field": "true",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.replaceField = jt("input", {
      value: n.replace,
      placeholder: dr(e, "Replace"),
      "aria-label": dr(e, "Replace"),
      class: "cm-textfield",
      name: "replace",
      form: "",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.caseField = jt("input", {
      type: "checkbox",
      name: "case",
      form: "",
      checked: n.caseSensitive,
      onchange: this.commit
    }), this.reField = jt("input", {
      type: "checkbox",
      name: "re",
      form: "",
      checked: n.regexp,
      onchange: this.commit
    }), this.wordField = jt("input", {
      type: "checkbox",
      name: "word",
      form: "",
      checked: n.wholeWord,
      onchange: this.commit
    });
    function r(i, o, s) {
      return jt("button", { class: "cm-button", name: i, onclick: o, type: "button" }, s);
    }
    this.dom = jt("div", { onkeydown: (i) => this.keydown(i), class: "cm-search" }, [
      this.searchField,
      r("next", () => Od(e), [dr(e, "next")]),
      r("prev", () => xd(e), [dr(e, "previous")]),
      r("select", () => D7(e), [dr(e, "all")]),
      jt("label", null, [this.caseField, dr(e, "match case")]),
      jt("label", null, [this.reField, dr(e, "regexp")]),
      jt("label", null, [this.wordField, dr(e, "by word")]),
      ...e.state.readOnly ? [] : [
        jt("br"),
        this.replaceField,
        r("replace", () => sS(e), [dr(e, "replace")]),
        r("replaceAll", () => B7(e), [dr(e, "replace all")])
      ],
      jt("button", {
        name: "close",
        onclick: () => pI(e),
        "aria-label": dr(e, "close"),
        type: "button"
      }, ["\xD7"])
    ]);
  }
  commit() {
    let e = new cI({
      search: this.searchField.value,
      caseSensitive: this.caseField.checked,
      regexp: this.reField.checked,
      wholeWord: this.wordField.checked,
      replace: this.replaceField.value
    });
    e.eq(this.query) || (this.query = e, this.view.dispatch({ effects: fc.of(e) }));
  }
  keydown(e) {
    XZ(this.view, e, "search-panel") ? e.preventDefault() : e.keyCode == 13 && e.target == this.searchField ? (e.preventDefault(), (e.shiftKey ? xd : Od)(this.view)) : e.keyCode == 13 && e.target == this.replaceField && (e.preventDefault(), sS(this.view));
  }
  update(e) {
    for (let n of e.transactions)
      for (let r of n.effects)
        r.is(fc) && !r.value.eq(this.query) && this.setQuery(r.value);
  }
  setQuery(e) {
    this.query = e, this.searchField.value = e.search, this.replaceField.value = e.replace, this.caseField.checked = e.caseSensitive, this.reField.checked = e.regexp, this.wordField.checked = e.wholeWord;
  }
  mount() {
    this.searchField.select();
  }
  get pos() {
    return 80;
  }
  get top() {
    return this.view.state.facet(tl).top;
  }
};
function dr(t4, e) {
  return t4.state.phrase(e);
}
var Fu = 30;
var Zu = /[\s\.,:;?!]/;
function Lx(t4, { from: e, to: n }) {
  let r = t4.state.doc.lineAt(e), i = t4.state.doc.lineAt(n).to, o = Math.max(r.from, e - Fu), s = Math.min(i, n + Fu), a = t4.state.sliceDoc(o, s);
  if (o != r.from) {
    for (let l = 0; l < Fu; l++)
      if (!Zu.test(a[l + 1]) && Zu.test(a[l])) {
        a = a.slice(l);
        break;
      }
  }
  if (s != i) {
    for (let l = a.length - 1; l > a.length - Fu; l--)
      if (!Zu.test(a[l - 1]) && Zu.test(a[l])) {
        a = a.slice(0, l);
        break;
      }
  }
  return ue.announce.of(`${t4.state.phrase("current match")}. ${a} ${t4.state.phrase("on line")} ${r.number}.`);
}
var N7 = /* @__PURE__ */ ue.baseTheme({
  ".cm-panel.cm-search": {
    padding: "2px 6px 4px",
    position: "relative",
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    },
    "& input, & button, & label": {
      margin: ".2em .6em .2em 0"
    },
    "& input[type=checkbox]": {
      marginRight: ".2em"
    },
    "& label": {
      fontSize: "80%",
      whiteSpace: "pre"
    }
  },
  "&light .cm-searchMatch": { backgroundColor: "#ffff0054" },
  "&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" },
  "&light .cm-searchMatch-selected": { backgroundColor: "#ff6a0054" },
  "&dark .cm-searchMatch-selected": { backgroundColor: "#ff00ff8a" }
});
var F7 = [
  Co,
  /* @__PURE__ */ ji.low(R7),
  N7
];
var gI = class {
  /**
  Create a new completion context. (Mostly useful for testing
  completion sources—in the editor, the extension will create
  these for you.)
  */
  constructor(e, n, r) {
    this.state = e, this.pos = n, this.explicit = r, this.abortListeners = [];
  }
  /**
  Get the extent, content, and (if there is a token) type of the
  token before `this.pos`.
  */
  tokenBefore(e) {
    let n = Ft(this.state).resolveInner(this.pos, -1);
    for (; n && e.indexOf(n.name) < 0; )
      n = n.parent;
    return n ? {
      from: n.from,
      to: this.pos,
      text: this.state.sliceDoc(n.from, this.pos),
      type: n.type
    } : null;
  }
  /**
  Get the match of the given expression directly before the
  cursor.
  */
  matchBefore(e) {
    let n = this.state.doc.lineAt(this.pos), r = Math.max(n.from, this.pos - 250), i = n.text.slice(r - n.from, this.pos - n.from), o = i.search(OI(e, false));
    return o < 0 ? null : { from: r + o, to: this.pos, text: i.slice(o) };
  }
  /**
  Yields true when the query has been aborted. Can be useful in
  asynchronous queries to avoid doing work that will be ignored.
  */
  get aborted() {
    return this.abortListeners == null;
  }
  /**
  Allows you to register abort handlers, which will be called when
  the query is
  [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).
  */
  addEventListener(e, n) {
    e == "abort" && this.abortListeners && this.abortListeners.push(n);
  }
};
function aS(t4) {
  let e = Object.keys(t4).join(""), n = /\w/.test(e);
  return n && (e = e.replace(/\w/g, "")), `[${n ? "\\w" : ""}${e.replace(/[^\w\s]/g, "\\$&")}]`;
}
function Z7(t4) {
  let e = /* @__PURE__ */ Object.create(null), n = /* @__PURE__ */ Object.create(null);
  for (let { label: i } of t4) {
    e[i[0]] = true;
    for (let o = 1; o < i.length; o++)
      n[i[o]] = true;
  }
  let r = aS(e) + aS(n) + "*$";
  return [new RegExp("^" + r), new RegExp(r)];
}
function mI(t4) {
  let e = t4.map((i) => typeof i == "string" ? { label: i } : i), [n, r] = e.every((i) => /^\w+$/.test(i.label)) ? [/\w*$/, /\w+$/] : Z7(e);
  return (i) => {
    let o = i.matchBefore(r);
    return o || i.explicit ? { from: o ? o.from : i.pos, options: e, validFor: n } : null;
  };
}
function W7(t4, e) {
  return (n) => {
    for (let r = Ft(n.state).resolveInner(n.pos, -1); r; r = r.parent) {
      if (t4.indexOf(r.name) > -1)
        return null;
      if (r.type.isTop)
        break;
    }
    return e(n);
  };
}
var lS = class {
  constructor(e, n, r, i) {
    this.completion = e, this.source = n, this.match = r, this.score = i;
  }
};
function ko(t4) {
  return t4.selection.main.from;
}
function OI(t4, e) {
  var n;
  let { source: r } = t4, i = e && r[0] != "^", o = r[r.length - 1] != "$";
  return !i && !o ? t4 : new RegExp(`${i ? "^" : ""}(?:${r})${o ? "$" : ""}`, (n = t4.flags) !== null && n !== void 0 ? n : t4.ignoreCase ? "i" : "");
}
var Xx = /* @__PURE__ */ Ri.define();
function V7(t4, e, n, r) {
  let { main: i } = t4.selection, o = n - i.from, s = r - i.from;
  return Object.assign(Object.assign({}, t4.changeByRange((a) => a != i && n != r && t4.sliceDoc(a.from + o, a.from + s) != t4.sliceDoc(n, r) ? { range: a } : {
    changes: { from: a.from + o, to: r == i.from ? a.to : a.from + s, insert: e },
    range: ne.cursor(a.from + o + e.length)
  })), { scrollIntoView: true, userEvent: "input.complete" });
}
var cS = /* @__PURE__ */ new WeakMap();
function z7(t4) {
  if (!Array.isArray(t4))
    return t4;
  let e = cS.get(t4);
  return e || cS.set(t4, e = mI(t4)), e;
}
var vd = /* @__PURE__ */ Me.define();
var dc = /* @__PURE__ */ Me.define();
var L7 = class {
  constructor(e) {
    this.pattern = e, this.chars = [], this.folded = [], this.any = [], this.precise = [], this.byWord = [], this.score = 0, this.matched = [];
    for (let n = 0; n < e.length; ) {
      let r = Pn(e, n), i = jr(r);
      this.chars.push(r);
      let o = e.slice(n, n + i), s = o.toUpperCase();
      this.folded.push(Pn(s == o ? o.toLowerCase() : s, 0)), n += i;
    }
    this.astral = e.length != this.chars.length;
  }
  ret(e, n) {
    return this.score = e, this.matched = n, this;
  }
  // Matches a given word (completion) against the pattern (input).
  // Will return a boolean indicating whether there was a match and,
  // on success, set `this.score` to the score, `this.matched` to an
  // array of `from, to` pairs indicating the matched parts of `word`.
  //
  // The score is a number that is more negative the worse the match
  // is. See `Penalty` above.
  match(e) {
    if (this.pattern.length == 0)
      return this.ret(-100, []);
    if (e.length < this.pattern.length)
      return null;
    let { chars: n, folded: r, any: i, precise: o, byWord: s } = this;
    if (n.length == 1) {
      let v = Pn(e, 0), y = jr(v), S = y == e.length ? 0 : -100;
      if (v != n[0])
        if (v == r[0])
          S += -200;
        else
          return null;
      return this.ret(S, [0, y]);
    }
    let a = e.indexOf(this.pattern);
    if (a == 0)
      return this.ret(e.length == this.pattern.length ? 0 : -100, [0, this.pattern.length]);
    let l = n.length, c = 0;
    if (a < 0) {
      for (let v = 0, y = Math.min(e.length, 200); v < y && c < l; ) {
        let S = Pn(e, v);
        (S == n[c] || S == r[c]) && (i[c++] = v), v += jr(S);
      }
      if (c < l)
        return null;
    }
    let u = 0, f = 0, d = false, h = 0, p = -1, O = -1, m = /[a-z]/.test(e), x = true;
    for (let v = 0, y = Math.min(e.length, 200), S = 0; v < y && f < l; ) {
      let b = Pn(e, v);
      a < 0 && (u < l && b == n[u] && (o[u++] = v), h < l && (b == n[h] || b == r[h] ? (h == 0 && (p = v), O = v + 1, h++) : h = 0));
      let w, C = b < 255 ? b >= 48 && b <= 57 || b >= 97 && b <= 122 ? 2 : b >= 65 && b <= 90 ? 1 : 0 : (w = Ox(b)) != w.toLowerCase() ? 1 : w != w.toUpperCase() ? 2 : 0;
      (!v || C == 1 && m || S == 0 && C != 0) && (n[f] == b || r[f] == b && (d = true) ? s[f++] = v : s.length && (x = false)), S = C, v += jr(b);
    }
    return f == l && s[0] == 0 && x ? this.result(-100 + (d ? -200 : 0), s, e) : h == l && p == 0 ? this.ret(-200 - e.length + (O == e.length ? 0 : -100), [0, O]) : a > -1 ? this.ret(-700 - e.length, [a, a + this.pattern.length]) : h == l ? this.ret(-900 - e.length, [p, O]) : f == l ? this.result(-100 + (d ? -200 : 0) + -700 + (x ? 0 : -1100), s, e) : n.length == 2 ? null : this.result((i[0] ? -700 : 0) + -200 + -1100, i, e);
  }
  result(e, n, r) {
    let i = [], o = 0;
    for (let s of n) {
      let a = s + (this.astral ? jr(Pn(r, s)) : 1);
      o && i[o - 1] == s ? i[o - 1] = a : (i[o++] = s, i[o++] = a);
    }
    return this.ret(e - r.length, i);
  }
};
var X7 = class {
  constructor(e) {
    this.pattern = e, this.matched = [], this.score = 0, this.folded = e.toLowerCase();
  }
  match(e) {
    if (e.length < this.pattern.length)
      return null;
    let n = e.slice(0, this.pattern.length), r = n == this.pattern ? 0 : n.toLowerCase() == this.folded ? -200 : null;
    return r == null ? null : (this.matched = [0, n.length], this.score = r + (e.length == this.pattern.length ? 0 : -100), this);
  }
};
var In = /* @__PURE__ */ ge.define({
  combine(t4) {
    return Di(t4, {
      activateOnTyping: true,
      activateOnCompletion: () => false,
      activateOnTypingDelay: 100,
      selectOnOpen: true,
      override: null,
      closeOnBlur: true,
      maxRenderedOptions: 100,
      defaultKeymap: true,
      tooltipClass: () => "",
      optionClass: () => "",
      aboveCursor: false,
      icons: true,
      addToOptions: [],
      positionInfo: G7,
      filterStrict: false,
      compareCompletions: (e, n) => e.label.localeCompare(n.label),
      interactionDelay: 75,
      updateSyncTime: 100
    }, {
      defaultKeymap: (e, n) => e && n,
      closeOnBlur: (e, n) => e && n,
      icons: (e, n) => e && n,
      tooltipClass: (e, n) => (r) => uS(e(r), n(r)),
      optionClass: (e, n) => (r) => uS(e(r), n(r)),
      addToOptions: (e, n) => e.concat(n),
      filterStrict: (e, n) => e || n
    });
  }
});
function uS(t4, e) {
  return t4 ? e ? t4 + " " + e : t4 : e;
}
function G7(t4, e, n, r, i, o) {
  let s = t4.textDirection == _t.RTL, a = s, l = false, c = "top", u, f, d = e.left - i.left, h = i.right - e.right, p = r.right - r.left, O = r.bottom - r.top;
  if (a && d < Math.min(p, h) ? a = false : !a && h < Math.min(p, d) && (a = true), p <= (a ? d : h))
    u = Math.max(i.top, Math.min(n.top, i.bottom - O)) - e.top, f = Math.min(400, a ? d : h);
  else {
    l = true, f = Math.min(
      400,
      (s ? e.right : i.right - e.left) - 30
      /* Info.Margin */
    );
    let v = i.bottom - e.bottom;
    v >= O || v > e.top ? u = n.bottom - e.top : (c = "bottom", u = e.bottom - n.top);
  }
  let m = (e.bottom - e.top) / o.offsetHeight, x = (e.right - e.left) / o.offsetWidth;
  return {
    style: `${c}: ${u / m}px; max-width: ${f / x}px`,
    class: "cm-completionInfo-" + (l ? s ? "left-narrow" : "right-narrow" : a ? "left" : "right")
  };
}
function Y7(t4) {
  let e = t4.addToOptions.slice();
  return t4.icons && e.push({
    render(n) {
      let r = document.createElement("div");
      return r.classList.add("cm-completionIcon"), n.type && r.classList.add(...n.type.split(/\s+/g).map((i) => "cm-completionIcon-" + i)), r.setAttribute("aria-hidden", "true"), r;
    },
    position: 20
  }), e.push({
    render(n, r, i, o) {
      let s = document.createElement("span");
      s.className = "cm-completionLabel";
      let a = n.displayLabel || n.label, l = 0;
      for (let c = 0; c < o.length; ) {
        let u = o[c++], f = o[c++];
        u > l && s.appendChild(document.createTextNode(a.slice(l, u)));
        let d = s.appendChild(document.createElement("span"));
        d.appendChild(document.createTextNode(a.slice(u, f))), d.className = "cm-completionMatchedText", l = f;
      }
      return l < a.length && s.appendChild(document.createTextNode(a.slice(l))), s;
    },
    position: 50
  }, {
    render(n) {
      if (!n.detail)
        return null;
      let r = document.createElement("span");
      return r.className = "cm-completionDetail", r.textContent = n.detail, r;
    },
    position: 80
  }), e.sort((n, r) => n.position - r.position).map((n) => n.render);
}
function Xp(t4, e, n) {
  if (t4 <= n)
    return { from: 0, to: t4 };
  if (e < 0 && (e = 0), e <= t4 >> 1) {
    let i = Math.floor(e / n);
    return { from: i * n, to: (i + 1) * n };
  }
  let r = Math.floor((t4 - e) / n);
  return { from: t4 - (r + 1) * n, to: t4 - r * n };
}
var q7 = class {
  constructor(e, n, r) {
    this.view = e, this.stateField = n, this.applyCompletion = r, this.info = null, this.infoDestroy = null, this.placeInfoReq = {
      read: () => this.measureInfo(),
      write: (l) => this.placeInfo(l),
      key: this
    }, this.space = null, this.currentClass = "";
    let i = e.state.field(n), { options: o, selected: s } = i.open, a = e.state.facet(In);
    this.optionContent = Y7(a), this.optionClass = a.optionClass, this.tooltipClass = a.tooltipClass, this.range = Xp(o.length, s, a.maxRenderedOptions), this.dom = document.createElement("div"), this.dom.className = "cm-tooltip-autocomplete", this.updateTooltipClass(e.state), this.dom.addEventListener("mousedown", (l) => {
      let { options: c } = e.state.field(n).open;
      for (let u = l.target, f; u && u != this.dom; u = u.parentNode)
        if (u.nodeName == "LI" && (f = /-(\d+)$/.exec(u.id)) && +f[1] < c.length) {
          this.applyCompletion(e, c[+f[1]]), l.preventDefault();
          return;
        }
    }), this.dom.addEventListener("focusout", (l) => {
      let c = e.state.field(this.stateField, false);
      c && c.tooltip && e.state.facet(In).closeOnBlur && l.relatedTarget != e.contentDOM && e.dispatch({ effects: dc.of(null) });
    }), this.showOptions(o, i.id);
  }
  mount() {
    this.updateSel();
  }
  showOptions(e, n) {
    this.list && this.list.remove(), this.list = this.dom.appendChild(this.createListBox(e, n, this.range)), this.list.addEventListener("scroll", () => {
      this.info && this.view.requestMeasure(this.placeInfoReq);
    });
  }
  update(e) {
    var n;
    let r = e.state.field(this.stateField), i = e.startState.field(this.stateField);
    if (this.updateTooltipClass(e.state), r != i) {
      let { options: o, selected: s, disabled: a } = r.open;
      (!i.open || i.open.options != o) && (this.range = Xp(o.length, s, e.state.facet(In).maxRenderedOptions), this.showOptions(o, r.id)), this.updateSel(), a != ((n = i.open) === null || n === void 0 ? void 0 : n.disabled) && this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!a);
    }
  }
  updateTooltipClass(e) {
    let n = this.tooltipClass(e);
    if (n != this.currentClass) {
      for (let r of this.currentClass.split(" "))
        r && this.dom.classList.remove(r);
      for (let r of n.split(" "))
        r && this.dom.classList.add(r);
      this.currentClass = n;
    }
  }
  positioned(e) {
    this.space = e, this.info && this.view.requestMeasure(this.placeInfoReq);
  }
  updateSel() {
    let e = this.view.state.field(this.stateField), n = e.open;
    if ((n.selected > -1 && n.selected < this.range.from || n.selected >= this.range.to) && (this.range = Xp(n.options.length, n.selected, this.view.state.facet(In).maxRenderedOptions), this.showOptions(n.options, e.id)), this.updateSelectedOption(n.selected)) {
      this.destroyInfo();
      let { completion: r } = n.options[n.selected], { info: i } = r;
      if (!i)
        return;
      let o = typeof i == "string" ? document.createTextNode(i) : i(r);
      if (!o)
        return;
      "then" in o ? o.then((s) => {
        s && this.view.state.field(this.stateField, false) == e && this.addInfoPane(s, r);
      }).catch((s) => Gn(this.view.state, s, "completion info")) : this.addInfoPane(o, r);
    }
  }
  addInfoPane(e, n) {
    this.destroyInfo();
    let r = this.info = document.createElement("div");
    if (r.className = "cm-tooltip cm-completionInfo", e.nodeType != null)
      r.appendChild(e), this.infoDestroy = null;
    else {
      let { dom: i, destroy: o } = e;
      r.appendChild(i), this.infoDestroy = o || null;
    }
    this.dom.appendChild(r), this.view.requestMeasure(this.placeInfoReq);
  }
  updateSelectedOption(e) {
    let n = null;
    for (let r = this.list.firstChild, i = this.range.from; r; r = r.nextSibling, i++)
      r.nodeName != "LI" || !r.id ? i-- : i == e ? r.hasAttribute("aria-selected") || (r.setAttribute("aria-selected", "true"), n = r) : r.hasAttribute("aria-selected") && r.removeAttribute("aria-selected");
    return n && H7(this.list, n), n;
  }
  measureInfo() {
    let e = this.dom.querySelector("[aria-selected]");
    if (!e || !this.info)
      return null;
    let n = this.dom.getBoundingClientRect(), r = this.info.getBoundingClientRect(), i = e.getBoundingClientRect(), o = this.space;
    if (!o) {
      let s = this.dom.ownerDocument.defaultView || window;
      o = { left: 0, top: 0, right: s.innerWidth, bottom: s.innerHeight };
    }
    return i.top > Math.min(o.bottom, n.bottom) - 10 || i.bottom < Math.max(o.top, n.top) + 10 ? null : this.view.state.facet(In).positionInfo(this.view, n, i, r, o, this.dom);
  }
  placeInfo(e) {
    this.info && (e ? (e.style && (this.info.style.cssText = e.style), this.info.className = "cm-tooltip cm-completionInfo " + (e.class || "")) : this.info.style.cssText = "top: -1e6px");
  }
  createListBox(e, n, r) {
    const i = document.createElement("ul");
    i.id = n, i.setAttribute("role", "listbox"), i.setAttribute("aria-expanded", "true"), i.setAttribute("aria-label", this.view.state.phrase("Completions"));
    let o = null;
    for (let s = r.from; s < r.to; s++) {
      let { completion: a, match: l } = e[s], { section: c } = a;
      if (c) {
        let d = typeof c == "string" ? c : c.name;
        if (d != o && (s > r.from || r.from == 0))
          if (o = d, typeof c != "string" && c.header)
            i.appendChild(c.header(c));
          else {
            let h = i.appendChild(document.createElement("completion-section"));
            h.textContent = d;
          }
      }
      const u = i.appendChild(document.createElement("li"));
      u.id = n + "-" + s, u.setAttribute("role", "option");
      let f = this.optionClass(a);
      f && (u.className = f);
      for (let d of this.optionContent) {
        let h = d(a, this.view.state, this.view, l);
        h && u.appendChild(h);
      }
    }
    return r.from && i.classList.add("cm-completionListIncompleteTop"), r.to < e.length && i.classList.add("cm-completionListIncompleteBottom"), i;
  }
  destroyInfo() {
    this.info && (this.infoDestroy && this.infoDestroy(), this.info.remove(), this.info = null);
  }
  destroy() {
    this.destroyInfo();
  }
};
function U7(t4, e) {
  return (n) => new q7(n, t4, e);
}
function H7(t4, e) {
  let n = t4.getBoundingClientRect(), r = e.getBoundingClientRect(), i = n.height / t4.offsetHeight;
  r.top < n.top ? t4.scrollTop -= (n.top - r.top) / i : r.bottom > n.bottom && (t4.scrollTop += (r.bottom - n.bottom) / i);
}
function fS(t4) {
  return (t4.boost || 0) * 100 + (t4.apply ? 10 : 0) + (t4.info ? 5 : 0) + (t4.type ? 1 : 0);
}
function J7(t4, e) {
  let n = [], r = null, i = (c) => {
    n.push(c);
    let { section: u } = c.completion;
    if (u) {
      r || (r = []);
      let f = typeof u == "string" ? u : u.name;
      r.some((d) => d.name == f) || r.push(typeof u == "string" ? { name: f } : u);
    }
  }, o = e.facet(In);
  for (let c of t4)
    if (c.hasResult()) {
      let u = c.result.getMatch;
      if (c.result.filter === false)
        for (let f of c.result.options)
          i(new lS(f, c.source, u ? u(f) : [], 1e9 - n.length));
      else {
        let f = e.sliceDoc(c.from, c.to), d, h = o.filterStrict ? new X7(f) : new L7(f);
        for (let p of c.result.options)
          if (d = h.match(p.label)) {
            let O = p.displayLabel ? u ? u(p, d.matched) : [] : d.matched;
            i(new lS(p, c.source, O, d.score + (p.boost || 0)));
          }
      }
    }
  if (r) {
    let c = /* @__PURE__ */ Object.create(null), u = 0, f = (d, h) => {
      var p, O;
      return ((p = d.rank) !== null && p !== void 0 ? p : 1e9) - ((O = h.rank) !== null && O !== void 0 ? O : 1e9) || (d.name < h.name ? -1 : 1);
    };
    for (let d of r.sort(f))
      u -= 1e5, c[d.name] = u;
    for (let d of n) {
      let { section: h } = d.completion;
      h && (d.score += c[typeof h == "string" ? h : h.name]);
    }
  }
  let s = [], a = null, l = o.compareCompletions;
  for (let c of n.sort((u, f) => f.score - u.score || l(u.completion, f.completion))) {
    let u = c.completion;
    !a || a.label != u.label || a.detail != u.detail || a.type != null && u.type != null && a.type != u.type || a.apply != u.apply || a.boost != u.boost ? s.push(c) : fS(c.completion) > fS(a) && (s[s.length - 1] = c), a = c.completion;
  }
  return s;
}
var Hs = class {
  constructor(e, n, r, i, o, s) {
    this.options = e, this.attrs = n, this.tooltip = r, this.timestamp = i, this.selected = o, this.disabled = s;
  }
  setSelected(e, n) {
    return e == this.selected || e >= this.options.length ? this : new Hs(this.options, dS(n, e), this.tooltip, this.timestamp, e, this.disabled);
  }
  static build(e, n, r, i, o) {
    let s = J7(e, n);
    if (!s.length)
      return i && e.some(
        (l) => l.state == 1
        /* State.Pending */
      ) ? new Hs(i.options, i.attrs, i.tooltip, i.timestamp, i.selected, true) : null;
    let a = n.facet(In).selectOnOpen ? 0 : -1;
    if (i && i.selected != a && i.selected != -1) {
      let l = i.options[i.selected].completion;
      for (let c = 0; c < s.length; c++)
        if (s[c].completion == l) {
          a = c;
          break;
        }
    }
    return new Hs(s, dS(r, a), {
      pos: e.reduce((l, c) => c.hasResult() ? Math.min(l, c.from) : l, 1e8),
      create: rz,
      above: o.aboveCursor
    }, i ? i.timestamp : Date.now(), a, false);
  }
  map(e) {
    return new Hs(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), { pos: e.mapPos(this.tooltip.pos) }), this.timestamp, this.selected, this.disabled);
  }
};
var yd = class {
  constructor(e, n, r) {
    this.active = e, this.id = n, this.open = r;
  }
  static start() {
    return new yd(tz, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
  }
  update(e) {
    let { state: n } = e, r = n.facet(In), o = (r.override || n.languageDataAt("autocomplete", ko(n)).map(z7)).map((a) => (this.active.find((c) => c.source == a) || new Ln(
      a,
      this.active.some(
        (c) => c.state != 0
        /* State.Inactive */
      ) ? 1 : 0
      /* State.Inactive */
    )).update(e, r));
    o.length == this.active.length && o.every((a, l) => a == this.active[l]) && (o = this.active);
    let s = this.open;
    s && e.docChanged && (s = s.map(e.changes)), e.selection || o.some((a) => a.hasResult() && e.changes.touchesRange(a.from, a.to)) || !K7(o, this.active) ? s = Hs.build(o, n, this.id, s, r) : s && s.disabled && !o.some(
      (a) => a.state == 1
      /* State.Pending */
    ) && (s = null), !s && o.every(
      (a) => a.state != 1
      /* State.Pending */
    ) && o.some((a) => a.hasResult()) && (o = o.map((a) => a.hasResult() ? new Ln(
      a.source,
      0
      /* State.Inactive */
    ) : a));
    for (let a of e.effects)
      a.is(vI) && (s = s && s.setSelected(a.value, this.id));
    return o == this.active && s == this.open ? this : new yd(o, this.id, s);
  }
  get tooltip() {
    return this.open ? this.open.tooltip : null;
  }
  get attrs() {
    return this.open ? this.open.attrs : ez;
  }
};
function K7(t4, e) {
  if (t4 == e)
    return true;
  for (let n = 0, r = 0; ; ) {
    for (; n < t4.length && !t4[n].hasResult; )
      n++;
    for (; r < e.length && !e[r].hasResult; )
      r++;
    let i = n == t4.length, o = r == e.length;
    if (i || o)
      return i == o;
    if (t4[n++].result != e[r++].result)
      return false;
  }
}
var ez = {
  "aria-autocomplete": "list"
};
function dS(t4, e) {
  let n = {
    "aria-autocomplete": "list",
    "aria-haspopup": "listbox",
    "aria-controls": t4
  };
  return e > -1 && (n["aria-activedescendant"] = t4 + "-" + e), n;
}
var tz = [];
function Mm(t4, e) {
  if (t4.isUserEvent("input.complete")) {
    let n = t4.annotation(Xx);
    if (n && e.activateOnCompletion(n))
      return "input";
  }
  return t4.isUserEvent("input.type") ? "input" : t4.isUserEvent("delete.backward") ? "delete" : null;
}
var Ln = class {
  constructor(e, n, r = -1) {
    this.source = e, this.state = n, this.explicitPos = r;
  }
  hasResult() {
    return false;
  }
  update(e, n) {
    let r = Mm(e, n), i = this;
    r ? i = i.handleUserEvent(e, r, n) : e.docChanged ? i = i.handleChange(e) : e.selection && i.state != 0 && (i = new Ln(
      i.source,
      0
      /* State.Inactive */
    ));
    for (let o of e.effects)
      if (o.is(vd))
        i = new Ln(i.source, 1, o.value ? ko(e.state) : -1);
      else if (o.is(dc))
        i = new Ln(
          i.source,
          0
          /* State.Inactive */
        );
      else if (o.is(xI))
        for (let s of o.value)
          s.source == i.source && (i = s);
    return i;
  }
  handleUserEvent(e, n, r) {
    return n == "delete" || !r.activateOnTyping ? this.map(e.changes) : new Ln(
      this.source,
      1
      /* State.Pending */
    );
  }
  handleChange(e) {
    return e.changes.touchesRange(ko(e.startState)) ? new Ln(
      this.source,
      0
      /* State.Inactive */
    ) : this.map(e.changes);
  }
  map(e) {
    return e.empty || this.explicitPos < 0 ? this : new Ln(this.source, this.state, e.mapPos(this.explicitPos));
  }
};
var da = class extends Ln {
  constructor(e, n, r, i, o) {
    super(e, 2, n), this.result = r, this.from = i, this.to = o;
  }
  hasResult() {
    return true;
  }
  handleUserEvent(e, n, r) {
    var i;
    let o = this.result;
    o.map && !e.changes.empty && (o = o.map(o, e.changes));
    let s = e.changes.mapPos(this.from), a = e.changes.mapPos(this.to, 1), l = ko(e.state);
    if ((this.explicitPos < 0 ? l <= s : l < this.from) || l > a || !o || n == "delete" && ko(e.startState) == this.from)
      return new Ln(
        this.source,
        n == "input" && r.activateOnTyping ? 1 : 0
        /* State.Inactive */
      );
    let c = this.explicitPos < 0 ? -1 : e.changes.mapPos(this.explicitPos);
    return nz(o.validFor, e.state, s, a) ? new da(this.source, c, o, s, a) : o.update && (o = o.update(o, s, a, new gI(e.state, l, c >= 0))) ? new da(this.source, c, o, o.from, (i = o.to) !== null && i !== void 0 ? i : ko(e.state)) : new Ln(this.source, 1, c);
  }
  handleChange(e) {
    return e.changes.touchesRange(this.from, this.to) ? new Ln(
      this.source,
      0
      /* State.Inactive */
    ) : this.map(e.changes);
  }
  map(e) {
    return e.empty ? this : (this.result.map ? this.result.map(this.result, e) : this.result) ? new da(this.source, this.explicitPos < 0 ? -1 : e.mapPos(this.explicitPos), this.result, e.mapPos(this.from), e.mapPos(this.to, 1)) : new Ln(
      this.source,
      0
      /* State.Inactive */
    );
  }
};
function nz(t4, e, n, r) {
  if (!t4)
    return false;
  let i = e.sliceDoc(n, r);
  return typeof t4 == "function" ? t4(i, n, r, e) : OI(t4, true).test(i);
}
var xI = /* @__PURE__ */ Me.define({
  map(t4, e) {
    return t4.map((n) => n.map(e));
  }
});
var vI = /* @__PURE__ */ Me.define();
var rr = /* @__PURE__ */ pn.define({
  create() {
    return yd.start();
  },
  update(t4, e) {
    return t4.update(e);
  },
  provide: (t4) => [
    Ex.from(t4, (e) => e.tooltip),
    ue.contentAttributes.from(t4, (e) => e.attrs)
  ]
});
function Gx(t4, e) {
  const n = e.completion.apply || e.completion.label;
  let r = t4.state.field(rr).active.find((i) => i.source == e.source);
  return r instanceof da ? (typeof n == "string" ? t4.dispatch(Object.assign(Object.assign({}, V7(t4.state, n, r.from, r.to)), { annotations: Xx.of(e.completion) })) : n(t4, e.completion, r.from, r.to), true) : false;
}
var rz = /* @__PURE__ */ U7(rr, Gx);
function Wu(t4, e = "option") {
  return (n) => {
    let r = n.state.field(rr, false);
    if (!r || !r.open || r.open.disabled || Date.now() - r.open.timestamp < n.state.facet(In).interactionDelay)
      return false;
    let i = 1, o;
    e == "page" && (o = KE(n, r.open.tooltip)) && (i = Math.max(2, Math.floor(o.dom.offsetHeight / o.dom.querySelector("li").offsetHeight) - 1));
    let { length: s } = r.open.options, a = r.open.selected > -1 ? r.open.selected + i * (t4 ? 1 : -1) : t4 ? 0 : s - 1;
    return a < 0 ? a = e == "page" ? 0 : s - 1 : a >= s && (a = e == "page" ? s - 1 : 0), n.dispatch({ effects: vI.of(a) }), true;
  };
}
var yI = (t4) => {
  let e = t4.state.field(rr, false);
  return t4.state.readOnly || !e || !e.open || e.open.selected < 0 || e.open.disabled || Date.now() - e.open.timestamp < t4.state.facet(In).interactionDelay ? false : Gx(t4, e.open.options[e.open.selected]);
};
var iz = (t4) => t4.state.field(rr, false) ? (t4.dispatch({ effects: vd.of(true) }), true) : false;
var oz = (t4) => {
  let e = t4.state.field(rr, false);
  return !e || !e.active.some(
    (n) => n.state != 0
    /* State.Inactive */
  ) ? false : (t4.dispatch({ effects: dc.of(null) }), true);
};
var sz = class {
  constructor(e, n) {
    this.active = e, this.context = n, this.time = Date.now(), this.updates = [], this.done = void 0;
  }
};
var az = 50;
var lz = 1e3;
var cz = /* @__PURE__ */ Wt.fromClass(class {
  constructor(t4) {
    this.view = t4, this.debounceUpdate = -1, this.running = [], this.debounceAccept = -1, this.pendingStart = false, this.composing = 0;
    for (let e of t4.state.field(rr).active)
      e.state == 1 && this.startQuery(e);
  }
  update(t4) {
    let e = t4.state.field(rr), n = t4.state.facet(In);
    if (!t4.selectionSet && !t4.docChanged && t4.startState.field(rr) == e)
      return;
    let r = t4.transactions.some((o) => (o.selection || o.docChanged) && !Mm(o, n));
    for (let o = 0; o < this.running.length; o++) {
      let s = this.running[o];
      if (r || s.updates.length + t4.transactions.length > az && Date.now() - s.time > lz) {
        for (let a of s.context.abortListeners)
          try {
            a();
          } catch (l) {
            Gn(this.view.state, l);
          }
        s.context.abortListeners = null, this.running.splice(o--, 1);
      } else
        s.updates.push(...t4.transactions);
    }
    this.debounceUpdate > -1 && clearTimeout(this.debounceUpdate), t4.transactions.some((o) => o.effects.some((s) => s.is(vd))) && (this.pendingStart = true);
    let i = this.pendingStart ? 50 : n.activateOnTypingDelay;
    if (this.debounceUpdate = e.active.some((o) => o.state == 1 && !this.running.some((s) => s.active.source == o.source)) ? setTimeout(() => this.startUpdate(), i) : -1, this.composing != 0)
      for (let o of t4.transactions)
        Mm(o, n) == "input" ? this.composing = 2 : this.composing == 2 && o.selection && (this.composing = 3);
  }
  startUpdate() {
    this.debounceUpdate = -1, this.pendingStart = false;
    let { state: t4 } = this.view, e = t4.field(rr);
    for (let n of e.active)
      n.state == 1 && !this.running.some((r) => r.active.source == n.source) && this.startQuery(n);
  }
  startQuery(t4) {
    let { state: e } = this.view, n = ko(e), r = new gI(e, n, t4.explicitPos == n), i = new sz(t4, r);
    this.running.push(i), Promise.resolve(t4.source(r)).then((o) => {
      i.context.aborted || (i.done = o || null, this.scheduleAccept());
    }, (o) => {
      this.view.dispatch({ effects: dc.of(null) }), Gn(this.view.state, o);
    });
  }
  scheduleAccept() {
    this.running.every((t4) => t4.done !== void 0) ? this.accept() : this.debounceAccept < 0 && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(In).updateSyncTime));
  }
  // For each finished query in this.running, try to create a result
  // or, if appropriate, restart the query.
  accept() {
    var t4;
    this.debounceAccept > -1 && clearTimeout(this.debounceAccept), this.debounceAccept = -1;
    let e = [], n = this.view.state.facet(In);
    for (let r = 0; r < this.running.length; r++) {
      let i = this.running[r];
      if (i.done === void 0)
        continue;
      if (this.running.splice(r--, 1), i.done) {
        let s = new da(i.active.source, i.active.explicitPos, i.done, i.done.from, (t4 = i.done.to) !== null && t4 !== void 0 ? t4 : ko(i.updates.length ? i.updates[0].startState : this.view.state));
        for (let a of i.updates)
          s = s.update(a, n);
        if (s.hasResult()) {
          e.push(s);
          continue;
        }
      }
      let o = this.view.state.field(rr).active.find((s) => s.source == i.active.source);
      if (o && o.state == 1)
        if (i.done == null) {
          let s = new Ln(
            i.active.source,
            0
            /* State.Inactive */
          );
          for (let a of i.updates)
            s = s.update(a, n);
          s.state != 1 && e.push(s);
        } else
          this.startQuery(o);
    }
    e.length && this.view.dispatch({ effects: xI.of(e) });
  }
}, {
  eventHandlers: {
    blur(t4) {
      let e = this.view.state.field(rr, false);
      if (e && e.tooltip && this.view.state.facet(In).closeOnBlur) {
        let n = e.open && KE(this.view, e.open.tooltip);
        (!n || !n.dom.contains(t4.relatedTarget)) && setTimeout(() => this.view.dispatch({ effects: dc.of(null) }), 10);
      }
    },
    compositionstart() {
      this.composing = 1;
    },
    compositionend() {
      this.composing == 3 && setTimeout(() => this.view.dispatch({ effects: vd.of(false) }), 20), this.composing = 0;
    }
  }
});
var uz = typeof navigator == "object" && /* @__PURE__ */ /Win/.test(navigator.platform);
var fz = /* @__PURE__ */ ji.highest(/* @__PURE__ */ ue.domEventHandlers({
  keydown(t4, e) {
    let n = e.state.field(rr, false);
    if (!n || !n.open || n.open.disabled || n.open.selected < 0 || t4.key.length > 1 || t4.ctrlKey && !(uz && t4.altKey) || t4.metaKey)
      return false;
    let r = n.open.options[n.open.selected], i = n.active.find((s) => s.source == r.source), o = r.completion.commitCharacters || i.result.commitCharacters;
    return o && o.indexOf(t4.key) > -1 && Gx(e, r), false;
  }
}));
var bI = /* @__PURE__ */ ue.baseTheme({
  ".cm-tooltip.cm-tooltip-autocomplete": {
    "& > ul": {
      fontFamily: "monospace",
      whiteSpace: "nowrap",
      overflow: "hidden auto",
      maxWidth_fallback: "700px",
      maxWidth: "min(700px, 95vw)",
      minWidth: "250px",
      maxHeight: "10em",
      height: "100%",
      listStyle: "none",
      margin: 0,
      padding: 0,
      "& > li, & > completion-section": {
        padding: "1px 3px",
        lineHeight: 1.2
      },
      "& > li": {
        overflowX: "hidden",
        textOverflow: "ellipsis",
        cursor: "pointer"
      },
      "& > completion-section": {
        display: "list-item",
        borderBottom: "1px solid silver",
        paddingLeft: "0.5em",
        opacity: 0.7
      }
    }
  },
  "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#17c",
    color: "white"
  },
  "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#777"
  },
  "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#347",
    color: "white"
  },
  "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#444"
  },
  ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
    content: '"\xB7\xB7\xB7"',
    opacity: 0.5,
    display: "block",
    textAlign: "center"
  },
  ".cm-tooltip.cm-completionInfo": {
    position: "absolute",
    padding: "3px 9px",
    width: "max-content",
    maxWidth: "400px",
    boxSizing: "border-box"
  },
  ".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
  ".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
  ".cm-completionInfo.cm-completionInfo-left-narrow": { right: "30px" },
  ".cm-completionInfo.cm-completionInfo-right-narrow": { left: "30px" },
  "&light .cm-snippetField": { backgroundColor: "#00000022" },
  "&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
  ".cm-snippetFieldPosition": {
    verticalAlign: "text-top",
    width: 0,
    height: "1.15em",
    display: "inline-block",
    margin: "0 -0.7px -.7em",
    borderLeft: "1.4px dotted #888"
  },
  ".cm-completionMatchedText": {
    textDecoration: "underline"
  },
  ".cm-completionDetail": {
    marginLeft: "0.5em",
    fontStyle: "italic"
  },
  ".cm-completionIcon": {
    fontSize: "90%",
    width: ".8em",
    display: "inline-block",
    textAlign: "center",
    paddingRight: ".6em",
    opacity: "0.6",
    boxSizing: "content-box"
  },
  ".cm-completionIcon-function, .cm-completionIcon-method": {
    "&:after": { content: "'\u0192'" }
  },
  ".cm-completionIcon-class": {
    "&:after": { content: "'\u25CB'" }
  },
  ".cm-completionIcon-interface": {
    "&:after": { content: "'\u25CC'" }
  },
  ".cm-completionIcon-variable": {
    "&:after": { content: "'\u{1D465}'" }
  },
  ".cm-completionIcon-constant": {
    "&:after": { content: "'\u{1D436}'" }
  },
  ".cm-completionIcon-type": {
    "&:after": { content: "'\u{1D461}'" }
  },
  ".cm-completionIcon-enum": {
    "&:after": { content: "'\u222A'" }
  },
  ".cm-completionIcon-property": {
    "&:after": { content: "'\u25A1'" }
  },
  ".cm-completionIcon-keyword": {
    "&:after": { content: "'\u{1F511}\uFE0E'" }
    // Disable emoji rendering
  },
  ".cm-completionIcon-namespace": {
    "&:after": { content: "'\u25A2'" }
  },
  ".cm-completionIcon-text": {
    "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" }
  }
});
var dz = class {
  constructor(e, n, r, i) {
    this.field = e, this.line = n, this.from = r, this.to = i;
  }
};
var Yx = class {
  constructor(e, n, r) {
    this.field = e, this.from = n, this.to = r;
  }
  map(e) {
    let n = e.mapPos(this.from, -1, Tn.TrackDel), r = e.mapPos(this.to, 1, Tn.TrackDel);
    return n == null || r == null ? null : new Yx(this.field, n, r);
  }
};
var qx = class {
  constructor(e, n) {
    this.lines = e, this.fieldPositions = n;
  }
  instantiate(e, n) {
    let r = [], i = [n], o = e.doc.lineAt(n), s = /^\s*/.exec(o.text)[0];
    for (let l of this.lines) {
      if (r.length) {
        let c = s, u = /^\t*/.exec(l)[0].length;
        for (let f = 0; f < u; f++)
          c += e.facet(_c);
        i.push(n + c.length - u), l = c + l.slice(u);
      }
      r.push(l), n += l.length + 1;
    }
    let a = this.fieldPositions.map((l) => new Yx(l.field, i[l.line] + l.from, i[l.line] + l.to));
    return { text: r, ranges: a };
  }
  static parse(e) {
    let n = [], r = [], i = [], o;
    for (let s of e.split(/\r\n?|\n/)) {
      for (; o = /[#$]\{(?:(\d+)(?::([^}]*))?|([^}]*))\}/.exec(s); ) {
        let a = o[1] ? +o[1] : null, l = o[2] || o[3] || "", c = -1;
        for (let u = 0; u < n.length; u++)
          (a != null ? n[u].seq == a : l && n[u].name == l) && (c = u);
        if (c < 0) {
          let u = 0;
          for (; u < n.length && (a == null || n[u].seq != null && n[u].seq < a); )
            u++;
          n.splice(u, 0, { seq: a, name: l }), c = u;
          for (let f of i)
            f.field >= c && f.field++;
        }
        i.push(new dz(c, r.length, o.index, o.index + l.length)), s = s.slice(0, o.index) + l + s.slice(o.index + o[0].length);
      }
      for (let a; a = /\\([{}])/.exec(s); ) {
        s = s.slice(0, a.index) + a[1] + s.slice(a.index + a[0].length);
        for (let l of i)
          l.line == r.length && l.from > a.index && (l.from--, l.to--);
      }
      r.push(s);
    }
    return new qx(r, i);
  }
};
var hz = /* @__PURE__ */ we.widget({ widget: /* @__PURE__ */ new class extends Qi {
  toDOM() {
    let t4 = document.createElement("span");
    return t4.className = "cm-snippetFieldPosition", t4;
  }
  ignoreEvent() {
    return false;
  }
}() });
var pz = /* @__PURE__ */ we.mark({ class: "cm-snippetField" });
var nl = class {
  constructor(e, n) {
    this.ranges = e, this.active = n, this.deco = we.set(e.map((r) => (r.from == r.to ? hz : pz).range(r.from, r.to)));
  }
  map(e) {
    let n = [];
    for (let r of this.ranges) {
      let i = r.map(e);
      if (!i)
        return null;
      n.push(i);
    }
    return new nl(n, this.active);
  }
  selectionInsideField(e) {
    return e.ranges.every((n) => this.ranges.some((r) => r.field == this.active && r.from <= n.from && r.to >= n.to));
  }
};
var Zc = /* @__PURE__ */ Me.define({
  map(t4, e) {
    return t4 && t4.map(e);
  }
});
var gz = /* @__PURE__ */ Me.define();
var hc = /* @__PURE__ */ pn.define({
  create() {
    return null;
  },
  update(t4, e) {
    for (let n of e.effects) {
      if (n.is(Zc))
        return n.value;
      if (n.is(gz) && t4)
        return new nl(t4.ranges, n.value);
    }
    return t4 && e.docChanged && (t4 = t4.map(e.changes)), t4 && e.selection && !t4.selectionInsideField(e.selection) && (t4 = null), t4;
  },
  provide: (t4) => ue.decorations.from(t4, (e) => e ? e.deco : we.none)
});
function Ux(t4, e) {
  return ne.create(t4.filter((n) => n.field == e).map((n) => ne.range(n.from, n.to)));
}
function mz(t4) {
  let e = qx.parse(t4);
  return (n, r, i, o) => {
    let { text: s, ranges: a } = e.instantiate(n.state, i), l = {
      changes: { from: i, to: o, insert: ft.of(s) },
      scrollIntoView: true,
      annotations: r ? [Xx.of(r), tn.userEvent.of("input.complete")] : void 0
    };
    if (a.length && (l.selection = Ux(a, 0)), a.some((c) => c.field > 0)) {
      let c = new nl(a, 0), u = l.effects = [Zc.of(c)];
      n.state.field(hc, false) === void 0 && u.push(Me.appendConfig.of([hc, bz, Sz, bI]));
    }
    n.dispatch(n.state.update(l));
  };
}
function SI(t4) {
  return ({ state: e, dispatch: n }) => {
    let r = e.field(hc, false);
    if (!r || t4 < 0 && r.active == 0)
      return false;
    let i = r.active + t4, o = t4 > 0 && !r.ranges.some((s) => s.field == i + t4);
    return n(e.update({
      selection: Ux(r.ranges, i),
      effects: Zc.of(o ? null : new nl(r.ranges, i)),
      scrollIntoView: true
    })), true;
  };
}
var Oz = ({ state: t4, dispatch: e }) => t4.field(hc, false) ? (e(t4.update({ effects: Zc.of(null) })), true) : false;
var xz = /* @__PURE__ */ SI(1);
var vz = /* @__PURE__ */ SI(-1);
var yz = [
  { key: "Tab", run: xz, shift: vz },
  { key: "Escape", run: Oz }
];
var hS = /* @__PURE__ */ ge.define({
  combine(t4) {
    return t4.length ? t4[0] : yz;
  }
});
var bz = /* @__PURE__ */ ji.highest(/* @__PURE__ */ qa.compute([hS], (t4) => t4.facet(hS)));
function nr(t4, e) {
  return Object.assign(Object.assign({}, e), { apply: mz(t4) });
}
var Sz = /* @__PURE__ */ ue.domEventHandlers({
  mousedown(t4, e) {
    let n = e.state.field(hc, false), r;
    if (!n || (r = e.posAtCoords({ x: t4.clientX, y: t4.clientY })) == null)
      return false;
    let i = n.ranges.find((o) => o.from <= r && o.to >= r);
    return !i || i.field == n.active ? false : (e.dispatch({
      selection: Ux(n.ranges, i.field),
      effects: Zc.of(n.ranges.some((o) => o.field > i.field) ? new nl(n.ranges, i.field) : null),
      scrollIntoView: true
    }), true);
  }
});
var pc = {
  brackets: ["(", "[", "{", "'", '"'],
  before: ")]}:;>",
  stringPrefixes: []
};
var is = /* @__PURE__ */ Me.define({
  map(t4, e) {
    let n = e.mapPos(t4, -1, Tn.TrackAfter);
    return n ?? void 0;
  }
});
var Hx = /* @__PURE__ */ new class extends fs {
}();
Hx.startSide = 1;
Hx.endSide = -1;
var wI = /* @__PURE__ */ pn.define({
  create() {
    return ot.empty;
  },
  update(t4, e) {
    if (t4 = t4.map(e.changes), e.selection) {
      let n = e.state.doc.lineAt(e.selection.main.head);
      t4 = t4.update({ filter: (r) => r >= n.from && r <= n.to });
    }
    for (let n of e.effects)
      n.is(is) && (t4 = t4.update({ add: [Hx.range(n.value, n.value + 1)] }));
    return t4;
  }
});
function wz() {
  return [kz, wI];
}
var Gp = "()[]{}<>";
function CI(t4) {
  for (let e = 0; e < Gp.length; e += 2)
    if (Gp.charCodeAt(e) == t4)
      return Gp.charAt(e + 1);
  return Ox(t4 < 128 ? t4 : t4 + 1);
}
function kI(t4, e) {
  return t4.languageDataAt("closeBrackets", e)[0] || pc;
}
var Cz = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent);
var kz = /* @__PURE__ */ ue.inputHandler.of((t4, e, n, r) => {
  if ((Cz ? t4.composing : t4.compositionStarted) || t4.state.readOnly)
    return false;
  let i = t4.state.selection.main;
  if (r.length > 2 || r.length == 2 && jr(Pn(r, 0)) == 1 || e != i.from || n != i.to)
    return false;
  let o = Ez(t4.state, r);
  return o ? (t4.dispatch(o), true) : false;
});
var Az = ({ state: t4, dispatch: e }) => {
  if (t4.readOnly)
    return false;
  let r = kI(t4, t4.selection.main.head).brackets || pc.brackets, i = null, o = t4.changeByRange((s) => {
    if (s.empty) {
      let a = Tz(t4.doc, s.head);
      for (let l of r)
        if (l == a && Ah(t4.doc, s.head) == CI(Pn(l, 0)))
          return {
            changes: { from: s.head - l.length, to: s.head + l.length },
            range: ne.cursor(s.head - l.length)
          };
    }
    return { range: i = s };
  });
  return i || e(t4.update(o, { scrollIntoView: true, userEvent: "delete.backward" })), !i;
};
var Pz = [
  { key: "Backspace", run: Az }
];
function Ez(t4, e) {
  let n = kI(t4, t4.selection.main.head), r = n.brackets || pc.brackets;
  for (let i of r) {
    let o = CI(Pn(i, 0));
    if (e == i)
      return o == i ? jz(t4, i, r.indexOf(i + i + i) > -1, n) : Iz(t4, i, o, n.before || pc.before);
    if (e == o && AI(t4, t4.selection.main.from))
      return $z(t4, i, o);
  }
  return null;
}
function AI(t4, e) {
  let n = false;
  return t4.field(wI).between(0, t4.doc.length, (r) => {
    r == e && (n = true);
  }), n;
}
function Ah(t4, e) {
  let n = t4.sliceString(e, e + 2);
  return n.slice(0, jr(Pn(n, 0)));
}
function Tz(t4, e) {
  let n = t4.sliceString(e - 2, e);
  return jr(Pn(n, 0)) == n.length ? n : n.slice(1);
}
function Iz(t4, e, n, r) {
  let i = null, o = t4.changeByRange((s) => {
    if (!s.empty)
      return {
        changes: [{ insert: e, from: s.from }, { insert: n, from: s.to }],
        effects: is.of(s.to + e.length),
        range: ne.range(s.anchor + e.length, s.head + e.length)
      };
    let a = Ah(t4.doc, s.head);
    return !a || /\s/.test(a) || r.indexOf(a) > -1 ? {
      changes: { insert: e + n, from: s.head },
      effects: is.of(s.head + e.length),
      range: ne.cursor(s.head + e.length)
    } : { range: i = s };
  });
  return i ? null : t4.update(o, {
    scrollIntoView: true,
    userEvent: "input.type"
  });
}
function $z(t4, e, n) {
  let r = null, i = t4.changeByRange((o) => o.empty && Ah(t4.doc, o.head) == n ? {
    changes: { from: o.head, to: o.head + n.length, insert: n },
    range: ne.cursor(o.head + n.length)
  } : r = { range: o });
  return r ? null : t4.update(i, {
    scrollIntoView: true,
    userEvent: "input.type"
  });
}
function jz(t4, e, n, r) {
  let i = r.stringPrefixes || pc.stringPrefixes, o = null, s = t4.changeByRange((a) => {
    if (!a.empty)
      return {
        changes: [{ insert: e, from: a.from }, { insert: e, from: a.to }],
        effects: is.of(a.to + e.length),
        range: ne.range(a.anchor + e.length, a.head + e.length)
      };
    let l = a.head, c = Ah(t4.doc, l), u;
    if (c == e) {
      if (pS(t4, l))
        return {
          changes: { insert: e + e, from: l },
          effects: is.of(l + e.length),
          range: ne.cursor(l + e.length)
        };
      if (AI(t4, l)) {
        let d = n && t4.sliceDoc(l, l + e.length * 3) == e + e + e ? e + e + e : e;
        return {
          changes: { from: l, to: l + d.length, insert: d },
          range: ne.cursor(l + d.length)
        };
      }
    } else {
      if (n && t4.sliceDoc(l - 2 * e.length, l) == e + e && (u = gS(t4, l - 2 * e.length, i)) > -1 && pS(t4, u))
        return {
          changes: { insert: e + e + e + e, from: l },
          effects: is.of(l + e.length),
          range: ne.cursor(l + e.length)
        };
      if (t4.charCategorizer(l)(c) != Nt.Word && gS(t4, l, i) > -1 && !Rz(t4, l, e, i))
        return {
          changes: { insert: e + e, from: l },
          effects: is.of(l + e.length),
          range: ne.cursor(l + e.length)
        };
    }
    return { range: o = a };
  });
  return o ? null : t4.update(s, {
    scrollIntoView: true,
    userEvent: "input.type"
  });
}
function pS(t4, e) {
  let n = Ft(t4).resolveInner(e + 1);
  return n.parent && n.from == e;
}
function Rz(t4, e, n, r) {
  let i = Ft(t4).resolveInner(e, -1), o = r.reduce((s, a) => Math.max(s, a.length), 0);
  for (let s = 0; s < 5; s++) {
    let a = t4.sliceDoc(i.from, Math.min(i.to, i.from + n.length + o)), l = a.indexOf(n);
    if (!l || l > -1 && r.indexOf(a.slice(0, l)) > -1) {
      let u = i.firstChild;
      for (; u && u.from == i.from && u.to - u.from > n.length + l; ) {
        if (t4.sliceDoc(u.to - n.length, u.to) == n)
          return false;
        u = u.firstChild;
      }
      return true;
    }
    let c = i.to == e && i.parent;
    if (!c)
      break;
    i = c;
  }
  return false;
}
function gS(t4, e, n) {
  let r = t4.charCategorizer(e);
  if (r(t4.sliceDoc(e - 1, e)) != Nt.Word)
    return e;
  for (let i of n) {
    let o = e - i.length;
    if (t4.sliceDoc(o, e) == i && r(t4.sliceDoc(o - 1, o)) != Nt.Word)
      return o;
  }
  return -1;
}
function Dz(t4 = {}) {
  return [
    fz,
    rr,
    In.of(t4),
    cz,
    Qz,
    bI
  ];
}
var PI = [
  { key: "Ctrl-Space", run: iz },
  { key: "Escape", run: oz },
  { key: "ArrowDown", run: /* @__PURE__ */ Wu(true) },
  { key: "ArrowUp", run: /* @__PURE__ */ Wu(false) },
  { key: "PageDown", run: /* @__PURE__ */ Wu(true, "page") },
  { key: "PageUp", run: /* @__PURE__ */ Wu(false, "page") },
  { key: "Enter", run: yI }
];
var Qz = /* @__PURE__ */ ji.highest(/* @__PURE__ */ qa.computeN([In], (t4) => t4.facet(In).defaultKeymap ? [PI] : []));
var Bz = class {
  constructor(e, n, r) {
    this.from = e, this.to = n, this.diagnostic = r;
  }
};
var rs = class {
  constructor(e, n, r) {
    this.diagnostics = e, this.panel = n, this.selected = r;
  }
  static init(e, n, r) {
    let i = e, o = r.facet(yo).markerFilter;
    o && (i = o(i, r));
    let s = we.set(i.map((a) => a.from == a.to || a.from == a.to - 1 && r.doc.lineAt(a.from).to == a.from ? we.widget({
      widget: new Gz(a),
      diagnostic: a
    }).range(a.from) : we.mark({
      attributes: { class: "cm-lintRange cm-lintRange-" + a.severity + (a.markClass ? " " + a.markClass : "") },
      diagnostic: a,
      inclusive: true
    }).range(a.from, a.to)), true);
    return new rs(s, n, Ta(s));
  }
};
function Ta(t4, e = null, n = 0) {
  let r = null;
  return t4.between(n, 1e9, (i, o, { spec: s }) => {
    if (!(e && s.diagnostic != e))
      return r = new Bz(i, o, s.diagnostic), false;
  }), r;
}
function _z(t4, e) {
  let n = e.pos, r = e.end || n, i = t4.state.facet(yo).hideOn(t4, n, r);
  if (i != null)
    return i;
  let o = t4.startState.doc.lineAt(e.pos);
  return !!(t4.effects.some((s) => s.is(Jx)) || t4.changes.touchesRange(o.from, Math.max(o.to, r)));
}
function EI(t4, e) {
  return t4.field(Sr, false) ? e : e.concat(Me.appendConfig.of(jI));
}
function Mz(t4, e) {
  return {
    effects: EI(t4, [Jx.of(e)])
  };
}
var Jx = /* @__PURE__ */ Me.define();
var Kx = /* @__PURE__ */ Me.define();
var TI = /* @__PURE__ */ Me.define();
var Sr = /* @__PURE__ */ pn.define({
  create() {
    return new rs(we.none, null, null);
  },
  update(t4, e) {
    if (e.docChanged) {
      let n = t4.diagnostics.map(e.changes), r = null;
      if (t4.selected) {
        let i = e.changes.mapPos(t4.selected.from, 1);
        r = Ta(n, t4.selected.diagnostic, i) || Ta(n, null, i);
      }
      t4 = new rs(n, t4.panel, r);
    }
    for (let n of e.effects)
      n.is(Jx) ? t4 = rs.init(n.value, t4.panel, e.state) : n.is(Kx) ? t4 = new rs(t4.diagnostics, n.value ? Ph.open : null, t4.selected) : n.is(TI) && (t4 = new rs(t4.diagnostics, t4.panel, n.value));
    return t4;
  },
  provide: (t4) => [
    ac.from(t4, (e) => e.panel),
    ue.decorations.from(t4, (e) => e.diagnostics)
  ]
});
var Nz = /* @__PURE__ */ we.mark({ class: "cm-lintRange cm-lintRange-active", inclusive: true });
function Fz(t4, e, n) {
  let { diagnostics: r } = t4.state.field(Sr), i = [], o = 2e8, s = 0;
  r.between(e - (n < 0 ? 1 : 0), e + (n > 0 ? 1 : 0), (l, c, { spec: u }) => {
    e >= l && e <= c && (l == c || (e > l || n > 0) && (e < c || n < 0)) && (i.push(u.diagnostic), o = Math.min(l, o), s = Math.max(c, s));
  });
  let a = t4.state.facet(yo).tooltipFilter;
  return a && (i = a(i, t4.state)), i.length ? {
    pos: o,
    end: s,
    above: t4.state.doc.lineAt(o).to < s,
    create() {
      return { dom: Zz(t4, i) };
    }
  } : null;
}
function Zz(t4, e) {
  return jt("ul", { class: "cm-tooltip-lint" }, e.map((n) => $I(t4, n, false)));
}
var Wz = (t4) => {
  let e = t4.state.field(Sr, false);
  (!e || !e.panel) && t4.dispatch({ effects: EI(t4.state, [Kx.of(true)]) });
  let n = sc(t4, Ph.open);
  return n && n.dom.querySelector(".cm-panel-lint ul").focus(), true;
};
var mS = (t4) => {
  let e = t4.state.field(Sr, false);
  return !e || !e.panel ? false : (t4.dispatch({ effects: Kx.of(false) }), true);
};
var Vz = (t4) => {
  let e = t4.state.field(Sr, false);
  if (!e)
    return false;
  let n = t4.state.selection.main, r = e.diagnostics.iter(n.to + 1);
  return !r.value && (r = e.diagnostics.iter(0), !r.value || r.from == n.from && r.to == n.to) ? false : (t4.dispatch({ selection: { anchor: r.from, head: r.to }, scrollIntoView: true }), true);
};
var zz = [
  { key: "Mod-Shift-m", run: Wz, preventDefault: true },
  { key: "F8", run: Vz }
];
var Lz = /* @__PURE__ */ Wt.fromClass(class {
  constructor(t4) {
    this.view = t4, this.timeout = -1, this.set = true;
    let { delay: e } = t4.state.facet(yo);
    this.lintTime = Date.now() + e, this.run = this.run.bind(this), this.timeout = setTimeout(this.run, e);
  }
  run() {
    let t4 = Date.now();
    if (t4 < this.lintTime - 10)
      this.timeout = setTimeout(this.run, this.lintTime - t4);
    else {
      this.set = false;
      let { state: e } = this.view, { sources: n } = e.facet(yo);
      n.length && Promise.all(n.map((r) => Promise.resolve(r(this.view)))).then((r) => {
        let i = r.reduce((o, s) => o.concat(s));
        this.view.state.doc == e.doc && this.view.dispatch(Mz(this.view.state, i));
      }, (r) => {
        Gn(this.view.state, r);
      });
    }
  }
  update(t4) {
    let e = t4.state.facet(yo);
    (t4.docChanged || e != t4.startState.facet(yo) || e.needsRefresh && e.needsRefresh(t4)) && (this.lintTime = Date.now() + e.delay, this.set || (this.set = true, this.timeout = setTimeout(this.run, e.delay)));
  }
  force() {
    this.set && (this.lintTime = Date.now(), this.run());
  }
  destroy() {
    clearTimeout(this.timeout);
  }
});
var yo = /* @__PURE__ */ ge.define({
  combine(t4) {
    return Object.assign({ sources: t4.map((e) => e.source).filter((e) => e != null) }, Di(t4.map((e) => e.config), {
      delay: 750,
      markerFilter: null,
      tooltipFilter: null,
      needsRefresh: null,
      hideOn: () => null
    }, {
      needsRefresh: (e, n) => e ? n ? (r) => e(r) || n(r) : e : n
    }));
  }
});
function Xz(t4, e = {}) {
  return [
    yo.of({ source: t4, config: e }),
    Lz,
    jI
  ];
}
function II(t4) {
  let e = [];
  if (t4)
    e:
      for (let { name: n } of t4) {
        for (let r = 0; r < n.length; r++) {
          let i = n[r];
          if (/[a-zA-Z]/.test(i) && !e.some((o) => o.toLowerCase() == i.toLowerCase())) {
            e.push(i);
            continue e;
          }
        }
        e.push("");
      }
  return e;
}
function $I(t4, e, n) {
  var r;
  let i = n ? II(e.actions) : [];
  return jt("li", { class: "cm-diagnostic cm-diagnostic-" + e.severity }, jt("span", { class: "cm-diagnosticText" }, e.renderMessage ? e.renderMessage(t4) : e.message), (r = e.actions) === null || r === void 0 ? void 0 : r.map((o, s) => {
    let a = false, l = (d) => {
      if (d.preventDefault(), a)
        return;
      a = true;
      let h = Ta(t4.state.field(Sr).diagnostics, e);
      h && o.apply(t4, h.from, h.to);
    }, { name: c } = o, u = i[s] ? c.indexOf(i[s]) : -1, f = u < 0 ? c : [
      c.slice(0, u),
      jt("u", c.slice(u, u + 1)),
      c.slice(u + 1)
    ];
    return jt("button", {
      type: "button",
      class: "cm-diagnosticAction",
      onclick: l,
      onmousedown: l,
      "aria-label": ` Action: ${c}${u < 0 ? "" : ` (access key "${i[s]})"`}.`
    }, f);
  }), e.source && jt("div", { class: "cm-diagnosticSource" }, e.source));
}
var Gz = class extends Qi {
  constructor(e) {
    super(), this.diagnostic = e;
  }
  eq(e) {
    return e.diagnostic == this.diagnostic;
  }
  toDOM() {
    return jt("span", { class: "cm-lintPoint cm-lintPoint-" + this.diagnostic.severity });
  }
};
var OS = class {
  constructor(e, n) {
    this.diagnostic = n, this.id = "item_" + Math.floor(Math.random() * 4294967295).toString(16), this.dom = $I(e, n, true), this.dom.id = this.id, this.dom.setAttribute("role", "option");
  }
};
var Ph = class {
  constructor(e) {
    this.view = e, this.items = [];
    let n = (i) => {
      if (i.keyCode == 27)
        mS(this.view), this.view.focus();
      else if (i.keyCode == 38 || i.keyCode == 33)
        this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
      else if (i.keyCode == 40 || i.keyCode == 34)
        this.moveSelection((this.selectedIndex + 1) % this.items.length);
      else if (i.keyCode == 36)
        this.moveSelection(0);
      else if (i.keyCode == 35)
        this.moveSelection(this.items.length - 1);
      else if (i.keyCode == 13)
        this.view.focus();
      else if (i.keyCode >= 65 && i.keyCode <= 90 && this.selectedIndex >= 0) {
        let { diagnostic: o } = this.items[this.selectedIndex], s = II(o.actions);
        for (let a = 0; a < s.length; a++)
          if (s[a].toUpperCase().charCodeAt(0) == i.keyCode) {
            let l = Ta(this.view.state.field(Sr).diagnostics, o);
            l && o.actions[a].apply(e, l.from, l.to);
          }
      } else
        return;
      i.preventDefault();
    }, r = (i) => {
      for (let o = 0; o < this.items.length; o++)
        this.items[o].dom.contains(i.target) && this.moveSelection(o);
    };
    this.list = jt("ul", {
      tabIndex: 0,
      role: "listbox",
      "aria-label": this.view.state.phrase("Diagnostics"),
      onkeydown: n,
      onclick: r
    }), this.dom = jt("div", { class: "cm-panel-lint" }, this.list, jt("button", {
      type: "button",
      name: "close",
      "aria-label": this.view.state.phrase("close"),
      onclick: () => mS(this.view)
    }, "\xD7")), this.update();
  }
  get selectedIndex() {
    let e = this.view.state.field(Sr).selected;
    if (!e)
      return -1;
    for (let n = 0; n < this.items.length; n++)
      if (this.items[n].diagnostic == e.diagnostic)
        return n;
    return -1;
  }
  update() {
    let { diagnostics: e, selected: n } = this.view.state.field(Sr), r = 0, i = false, o = null;
    for (e.between(0, this.view.state.doc.length, (s, a, { spec: l }) => {
      let c = -1, u;
      for (let f = r; f < this.items.length; f++)
        if (this.items[f].diagnostic == l.diagnostic) {
          c = f;
          break;
        }
      c < 0 ? (u = new OS(this.view, l.diagnostic), this.items.splice(r, 0, u), i = true) : (u = this.items[c], c > r && (this.items.splice(r, c - r), i = true)), n && u.diagnostic == n.diagnostic ? u.dom.hasAttribute("aria-selected") || (u.dom.setAttribute("aria-selected", "true"), o = u) : u.dom.hasAttribute("aria-selected") && u.dom.removeAttribute("aria-selected"), r++;
    }); r < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0); )
      i = true, this.items.pop();
    this.items.length == 0 && (this.items.push(new OS(this.view, {
      from: -1,
      to: -1,
      severity: "info",
      message: this.view.state.phrase("No diagnostics")
    })), i = true), o ? (this.list.setAttribute("aria-activedescendant", o.id), this.view.requestMeasure({
      key: this,
      read: () => ({ sel: o.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),
      write: ({ sel: s, panel: a }) => {
        let l = a.height / this.list.offsetHeight;
        s.top < a.top ? this.list.scrollTop -= (a.top - s.top) / l : s.bottom > a.bottom && (this.list.scrollTop += (s.bottom - a.bottom) / l);
      }
    })) : this.selectedIndex < 0 && this.list.removeAttribute("aria-activedescendant"), i && this.sync();
  }
  sync() {
    let e = this.list.firstChild;
    function n() {
      let r = e;
      e = r.nextSibling, r.remove();
    }
    for (let r of this.items)
      if (r.dom.parentNode == this.list) {
        for (; e != r.dom; )
          n();
        e = r.dom.nextSibling;
      } else
        this.list.insertBefore(r.dom, e);
    for (; e; )
      n();
  }
  moveSelection(e) {
    if (this.selectedIndex < 0)
      return;
    let n = this.view.state.field(Sr), r = Ta(n.diagnostics, this.items[e].diagnostic);
    r && this.view.dispatch({
      selection: { anchor: r.from, head: r.to },
      scrollIntoView: true,
      effects: TI.of(r)
    });
  }
  static open(e) {
    return new Ph(e);
  }
};
function Yz(t4, e = 'viewBox="0 0 40 40"') {
  return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${e}>${encodeURIComponent(t4)}</svg>')`;
}
function Vu(t4) {
  return Yz(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${t4}" fill="none" stroke-width=".7"/>`, 'width="6" height="3"');
}
var qz = /* @__PURE__ */ ue.baseTheme({
  ".cm-diagnostic": {
    padding: "3px 6px 3px 8px",
    marginLeft: "-1px",
    display: "block",
    whiteSpace: "pre-wrap"
  },
  ".cm-diagnostic-error": { borderLeft: "5px solid #d11" },
  ".cm-diagnostic-warning": { borderLeft: "5px solid orange" },
  ".cm-diagnostic-info": { borderLeft: "5px solid #999" },
  ".cm-diagnostic-hint": { borderLeft: "5px solid #66d" },
  ".cm-diagnosticAction": {
    font: "inherit",
    border: "none",
    padding: "2px 4px",
    backgroundColor: "#444",
    color: "white",
    borderRadius: "3px",
    marginLeft: "8px",
    cursor: "pointer"
  },
  ".cm-diagnosticSource": {
    fontSize: "70%",
    opacity: 0.7
  },
  ".cm-lintRange": {
    backgroundPosition: "left bottom",
    backgroundRepeat: "repeat-x",
    paddingBottom: "0.7px"
  },
  ".cm-lintRange-error": { backgroundImage: /* @__PURE__ */ Vu("#d11") },
  ".cm-lintRange-warning": { backgroundImage: /* @__PURE__ */ Vu("orange") },
  ".cm-lintRange-info": { backgroundImage: /* @__PURE__ */ Vu("#999") },
  ".cm-lintRange-hint": { backgroundImage: /* @__PURE__ */ Vu("#66d") },
  ".cm-lintRange-active": { backgroundColor: "#ffdd9980" },
  ".cm-tooltip-lint": {
    padding: 0,
    margin: 0
  },
  ".cm-lintPoint": {
    position: "relative",
    "&:after": {
      content: '""',
      position: "absolute",
      bottom: 0,
      left: "-2px",
      borderLeft: "3px solid transparent",
      borderRight: "3px solid transparent",
      borderBottom: "4px solid #d11"
    }
  },
  ".cm-lintPoint-warning": {
    "&:after": { borderBottomColor: "orange" }
  },
  ".cm-lintPoint-info": {
    "&:after": { borderBottomColor: "#999" }
  },
  ".cm-lintPoint-hint": {
    "&:after": { borderBottomColor: "#66d" }
  },
  ".cm-panel.cm-panel-lint": {
    position: "relative",
    "& ul": {
      maxHeight: "100px",
      overflowY: "auto",
      "& [aria-selected]": {
        backgroundColor: "#ddd",
        "& u": { textDecoration: "underline" }
      },
      "&:focus [aria-selected]": {
        background_fallback: "#bdf",
        backgroundColor: "Highlight",
        color_fallback: "white",
        color: "HighlightText"
      },
      "& u": { textDecoration: "none" },
      padding: 0,
      margin: 0
    },
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "2px",
      background: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    }
  }
});
var jI = [
  Sr,
  /* @__PURE__ */ ue.decorations.compute([Sr], (t4) => {
    let { selected: e, panel: n } = t4.field(Sr);
    return !e || !n || e.from == e.to ? we.none : we.set([
      Nz.range(e.from, e.to)
    ]);
  }),
  /* @__PURE__ */ R6(Fz, { hideOn: _z }),
  qz
];
var xS = function(e) {
  e === void 0 && (e = {});
  var {
    crosshairCursor: n = false
  } = e, r = [];
  e.closeBracketsKeymap !== false && (r = r.concat(Pz)), e.defaultKeymap !== false && (r = r.concat(f7)), e.searchKeymap !== false && (r = r.concat(_7)), e.historyKeymap !== false && (r = r.concat(yV)), e.foldKeymap !== false && (r = r.concat(QW)), e.completionKeymap !== false && (r = r.concat(PI)), e.lintKeymap !== false && (r = r.concat(zz));
  var i = [];
  return e.lineNumbers !== false && i.push(W6()), e.highlightActiveLineGutter !== false && i.push(L6()), e.highlightSpecialChars !== false && i.push(l6()), e.history !== false && i.push(fV()), e.foldGutter !== false && i.push(NW()), e.drawSelection !== false && i.push(JZ()), e.dropCursor !== false && i.push(r6()), e.allowMultipleSelections !== false && i.push(et.allowMultipleSelections.of(true)), e.indentOnInput !== false && i.push(AW()), e.syntaxHighlighting !== false && i.push(_x(VW, {
    fallback: true
  })), e.bracketMatching !== false && i.push(UW()), e.closeBrackets !== false && i.push(wz()), e.autocompletion !== false && i.push(Dz()), e.rectangularSelection !== false && i.push(S6()), n !== false && i.push(k6()), e.highlightActiveLine !== false && i.push(p6()), e.highlightSelectionMatches !== false && i.push(x7()), e.tabSize && typeof e.tabSize == "number" && i.push(_c.of(" ".repeat(e.tabSize))), i.concat([qa.of(r.flat())]).filter(Boolean);
};
var Uz = "#e5c07b";
var vS = "#e06c75";
var Hz = "#56b6c2";
var Jz = "#ffffff";
var Of = "#abb2bf";
var Nm = "#7d8799";
var Kz = "#61afef";
var eL = "#98c379";
var yS = "#d19a66";
var tL = "#c678dd";
var nL = "#21252b";
var bS = "#2c313a";
var SS = "#282c34";
var Yp = "#353a42";
var rL = "#3E4451";
var wS = "#528bff";
var iL = /* @__PURE__ */ ue.theme({
  "&": {
    color: Of,
    backgroundColor: SS
  },
  ".cm-content": {
    caretColor: wS
  },
  ".cm-cursor, .cm-dropCursor": { borderLeftColor: wS },
  "&.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": { backgroundColor: rL },
  ".cm-panels": { backgroundColor: nL, color: Of },
  ".cm-panels.cm-panels-top": { borderBottom: "2px solid black" },
  ".cm-panels.cm-panels-bottom": { borderTop: "2px solid black" },
  ".cm-searchMatch": {
    backgroundColor: "#72a1ff59",
    outline: "1px solid #457dff"
  },
  ".cm-searchMatch.cm-searchMatch-selected": {
    backgroundColor: "#6199ff2f"
  },
  ".cm-activeLine": { backgroundColor: "#6699ff0b" },
  ".cm-selectionMatch": { backgroundColor: "#aafe661a" },
  "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": {
    backgroundColor: "#bad0f847"
  },
  ".cm-gutters": {
    backgroundColor: SS,
    color: Nm,
    border: "none"
  },
  ".cm-activeLineGutter": {
    backgroundColor: bS
  },
  ".cm-foldPlaceholder": {
    backgroundColor: "transparent",
    border: "none",
    color: "#ddd"
  },
  ".cm-tooltip": {
    border: "none",
    backgroundColor: Yp
  },
  ".cm-tooltip .cm-tooltip-arrow:before": {
    borderTopColor: "transparent",
    borderBottomColor: "transparent"
  },
  ".cm-tooltip .cm-tooltip-arrow:after": {
    borderTopColor: Yp,
    borderBottomColor: Yp
  },
  ".cm-tooltip-autocomplete": {
    "& > ul > li[aria-selected]": {
      backgroundColor: bS,
      color: Of
    }
  }
}, { dark: true });
var oL = /* @__PURE__ */ Ka.define([
  {
    tag: P.keyword,
    color: tL
  },
  {
    tag: [P.name, P.deleted, P.character, P.propertyName, P.macroName],
    color: vS
  },
  {
    tag: [/* @__PURE__ */ P.function(P.variableName), P.labelName],
    color: Kz
  },
  {
    tag: [P.color, /* @__PURE__ */ P.constant(P.name), /* @__PURE__ */ P.standard(P.name)],
    color: yS
  },
  {
    tag: [/* @__PURE__ */ P.definition(P.name), P.separator],
    color: Of
  },
  {
    tag: [P.typeName, P.className, P.number, P.changed, P.annotation, P.modifier, P.self, P.namespace],
    color: Uz
  },
  {
    tag: [P.operator, P.operatorKeyword, P.url, P.escape, P.regexp, P.link, /* @__PURE__ */ P.special(P.string)],
    color: Hz
  },
  {
    tag: [P.meta, P.comment],
    color: Nm
  },
  {
    tag: P.strong,
    fontWeight: "bold"
  },
  {
    tag: P.emphasis,
    fontStyle: "italic"
  },
  {
    tag: P.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: P.link,
    color: Nm,
    textDecoration: "underline"
  },
  {
    tag: P.heading,
    fontWeight: "bold",
    color: vS
  },
  {
    tag: [P.atom, P.bool, /* @__PURE__ */ P.special(P.variableName)],
    color: yS
  },
  {
    tag: [P.processingInstruction, P.string, P.inserted],
    color: eL
  },
  {
    tag: P.invalid,
    color: Jz
  }
]);
var sL = [iL, /* @__PURE__ */ _x(oL)];
var aL = ue.theme({
  "&": {
    backgroundColor: "#fff"
  }
}, {
  dark: false
});
var lL = function(e) {
  e === void 0 && (e = {});
  var {
    indentWithTab: n = true,
    editable: r = true,
    readOnly: i = false,
    theme: o = "light",
    placeholder: s = "",
    basicSetup: a = true
  } = e, l = [];
  switch (n && l.unshift(qa.of([d7])), a && (typeof a == "boolean" ? l.unshift(xS()) : l.unshift(xS(a))), s && l.unshift(x6(s)), o) {
    case "light":
      l.push(aL);
      break;
    case "dark":
      l.push(sL);
      break;
    case "none":
      break;
    default:
      l.push(o);
      break;
  }
  return r === false && l.push(ue.editable.of(false)), i && l.push(et.readOnly.of(true)), [...l];
};
var cL = (t4) => ({
  line: t4.state.doc.lineAt(t4.state.selection.main.from),
  lineCount: t4.state.doc.lines,
  lineBreak: t4.state.lineBreak,
  length: t4.state.doc.length,
  readOnly: t4.state.readOnly,
  tabSize: t4.state.tabSize,
  selection: t4.state.selection,
  selectionAsSingle: t4.state.selection.asSingle().main,
  ranges: t4.state.selection.ranges,
  selectionCode: t4.state.sliceDoc(t4.state.selection.main.from, t4.state.selection.main.to),
  selections: t4.state.selection.ranges.map((e) => t4.state.sliceDoc(e.from, e.to)),
  selectedText: t4.state.selection.ranges.some((e) => !e.empty)
});
var CS = Ri.define();
var uL = [];
function fL(t4) {
  var {
    value: e,
    selection: n,
    onChange: r,
    onStatistics: i,
    onCreateEditor: o,
    onUpdate: s,
    extensions: a = uL,
    autoFocus: l,
    theme: c = "light",
    height: u = null,
    minHeight: f = null,
    maxHeight: d = null,
    width: h = null,
    minWidth: p = null,
    maxWidth: O = null,
    placeholder: m = "",
    editable: x = true,
    readOnly: v = false,
    indentWithTab: y = true,
    basicSetup: S = true,
    root: b,
    initialState: w
  } = t4, [C, k] = fe(), [T, A] = fe(), [E, $] = fe(), j = ue.theme({
    "&": {
      height: u,
      minHeight: f,
      maxHeight: d,
      width: h,
      minWidth: p,
      maxWidth: O
    },
    "& .cm-scroller": {
      height: "100% !important"
    }
  }), B = ue.updateListener.of((z) => {
    if (z.docChanged && typeof r == "function" && // Fix echoing of the remote changes:
    // If transaction is market as remote we don't have to call `onChange` handler again
    !z.transactions.some((L) => L.annotation(CS))) {
      var Z = z.state.doc, J = Z.toString();
      r(J, z);
    }
    i && i(cL(z));
  }), D = lL({
    theme: c,
    editable: x,
    readOnly: v,
    placeholder: m,
    indentWithTab: y,
    basicSetup: S
  }), N = [B, j, ...D];
  return s && typeof s == "function" && N.push(ue.updateListener.of(s)), N = N.concat(a), _e(() => {
    if (C && !E) {
      var z = {
        doc: e,
        selection: n,
        extensions: N
      }, Z = w ? et.fromJSON(w.json, z, w.fields) : et.create(z);
      if ($(Z), !T) {
        var J = new ue({
          state: Z,
          parent: C,
          root: b
        });
        A(J), o && o(J, Z);
      }
    }
    return () => {
      T && ($(void 0), A(void 0));
    };
  }, [C, E]), _e(() => k(t4.container), [t4.container]), _e(() => () => {
    T && (T.destroy(), A(void 0));
  }, [T]), _e(() => {
    l && T && T.focus();
  }, [l, T]), _e(() => {
    T && T.dispatch({
      effects: Me.reconfigure.of(N)
    });
  }, [c, a, u, f, d, h, p, O, m, x, v, y, S, r, s]), _e(() => {
    if (e !== void 0) {
      var z = T ? T.state.doc.toString() : "";
      T && e !== z && T.dispatch({
        changes: {
          from: 0,
          to: z.length,
          insert: e || ""
        },
        annotations: [CS.of(true)]
      });
    }
  }, [e, T]), {
    state: E,
    setState: $,
    view: T,
    setView: A,
    container: C,
    setContainer: k
  };
}
var dL = ["className", "value", "selection", "extensions", "onChange", "onStatistics", "onCreateEditor", "onUpdate", "autoFocus", "theme", "height", "minHeight", "maxHeight", "width", "minWidth", "maxWidth", "basicSetup", "placeholder", "indentWithTab", "editable", "readOnly", "root", "initialState"];
var RI = /* @__PURE__ */ xs((t4, e) => {
  var {
    className: n,
    value: r = "",
    selection: i,
    extensions: o = [],
    onChange: s,
    onStatistics: a,
    onCreateEditor: l,
    onUpdate: c,
    autoFocus: u,
    theme: f = "light",
    height: d,
    minHeight: h,
    maxHeight: p,
    width: O,
    minWidth: m,
    maxWidth: x,
    basicSetup: v,
    placeholder: y,
    indentWithTab: S,
    editable: b,
    readOnly: w,
    root: C,
    initialState: k
  } = t4, T = AA(t4, dL), A = Ke(null), {
    state: E,
    view: $,
    container: j
  } = fL({
    container: A.current,
    root: C,
    value: r,
    autoFocus: u,
    theme: f,
    height: d,
    minHeight: h,
    maxHeight: p,
    width: O,
    minWidth: m,
    maxWidth: x,
    basicSetup: v,
    placeholder: y,
    indentWithTab: S,
    editable: b,
    readOnly: w,
    selection: i,
    onChange: s,
    onStatistics: a,
    onCreateEditor: l,
    onUpdate: c,
    extensions: o,
    initialState: k
  });
  if ($O(e, () => ({
    editor: A.current,
    state: E,
    view: $
  }), [A, j, E, $]), typeof r != "string")
    throw new Error("value must be typeof string but got " + typeof r);
  var B = typeof f == "string" ? "cm-theme-" + f : "cm-theme";
  return /* @__PURE__ */ g.jsx("div", Ae({
    ref: A,
    className: "" + B + (n ? " " + n : "")
  }, T));
});
RI.displayName = "CodeMirror";
function bd() {
  return bd = Object.assign ? Object.assign.bind() : function(t4) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var r in n)
        ({}).hasOwnProperty.call(n, r) && (t4[r] = n[r]);
    }
    return t4;
  }, bd.apply(null, arguments);
}
var DI = (t4) => {
  var {
    theme: e,
    settings: n = {},
    styles: r = []
  } = t4, i = {
    ".cm-gutters": {}
  }, o = {};
  n.background && (o.backgroundColor = n.background), n.backgroundImage && (o.backgroundImage = n.backgroundImage), n.foreground && (o.color = n.foreground), n.fontSize && (o.fontSize = n.fontSize), (n.background || n.foreground) && (i["&"] = o), n.fontFamily && (i["&.cm-editor .cm-scroller"] = {
    fontFamily: n.fontFamily
  }), n.gutterBackground && (i[".cm-gutters"].backgroundColor = n.gutterBackground), n.gutterForeground && (i[".cm-gutters"].color = n.gutterForeground), n.gutterBorder && (i[".cm-gutters"].borderRightColor = n.gutterBorder), n.caret && (i[".cm-content"] = {
    caretColor: n.caret
  }, i[".cm-cursor, .cm-dropCursor"] = {
    borderLeftColor: n.caret
  });
  var s = {};
  n.gutterActiveForeground && (s.color = n.gutterActiveForeground), n.lineHighlight && (i[".cm-activeLine"] = {
    backgroundColor: n.lineHighlight
  }, s.backgroundColor = n.lineHighlight), i[".cm-activeLineGutter"] = s, n.selection && (i["&.cm-focused .cm-selectionBackground, & .cm-line::selection, & .cm-selectionLayer .cm-selectionBackground, .cm-content ::selection"] = {
    background: n.selection + " !important"
  }), n.selectionMatch && (i["& .cm-selectionMatch"] = {
    backgroundColor: n.selectionMatch
  });
  var a = ue.theme(i, {
    dark: e === "dark"
  }), l = Ka.define(r), c = [a, _x(l)];
  return c;
};
var hL = {
  background: "#2e3235",
  foreground: "#bdbdbd",
  caret: "#a0a4ae",
  selection: "#d7d4f063",
  selectionMatch: "#d7d4f063",
  gutterBackground: "#2e3235",
  gutterForeground: "#999",
  gutterActiveForeground: "#4f5b66",
  lineHighlight: "#545b6130"
};
var ev = (t4) => {
  var {
    theme: e = "dark",
    settings: n = {},
    styles: r = []
  } = t4 || {};
  return DI({
    theme: e,
    settings: bd({}, hL, n),
    styles: [{
      tag: P.keyword,
      color: "#cf6edf"
    }, {
      tag: [P.name, P.deleted, P.character, P.macroName],
      color: "#56c8d8"
    }, {
      tag: [P.propertyName],
      color: "#facf4e"
    }, {
      tag: [P.variableName],
      color: "#bdbdbd"
    }, {
      tag: [P.function(P.variableName)],
      color: "#56c8d8"
    }, {
      tag: [P.labelName],
      color: "#cf6edf"
    }, {
      tag: [P.color, P.constant(P.name), P.standard(P.name)],
      color: "#facf4e"
    }, {
      tag: [P.definition(P.name), P.separator],
      color: "#fa5788"
    }, {
      tag: [P.brace],
      color: "#cf6edf"
    }, {
      tag: [P.annotation],
      color: "#ff5f52"
    }, {
      tag: [P.number, P.changed, P.annotation, P.modifier, P.self, P.namespace],
      color: "#ffad42"
    }, {
      tag: [P.typeName, P.className],
      color: "#ffad42"
    }, {
      tag: [P.operator, P.operatorKeyword],
      color: "#7186f0"
    }, {
      tag: [P.tagName],
      color: "#99d066"
    }, {
      tag: [P.squareBracket],
      color: "#ff5f52"
    }, {
      tag: [P.angleBracket],
      color: "#606f7a"
    }, {
      tag: [P.attributeName],
      color: "#bdbdbd"
    }, {
      tag: [P.regexp],
      color: "#ff5f52"
    }, {
      tag: [P.quote],
      color: "#6abf69"
    }, {
      tag: [P.string],
      color: "#99d066"
    }, {
      tag: P.link,
      color: "#56c8d8",
      textDecoration: "underline",
      textUnderlinePosition: "under"
    }, {
      tag: [P.url, P.escape, P.special(P.string)],
      color: "#facf4e"
    }, {
      tag: [P.meta],
      color: "#707d8b"
    }, {
      tag: [P.comment],
      color: "#707d8b",
      fontStyle: "italic"
    }, {
      tag: P.monospace,
      color: "#bdbdbd"
    }, {
      tag: P.strong,
      fontWeight: "bold",
      color: "#ff5f52"
    }, {
      tag: P.emphasis,
      fontStyle: "italic",
      color: "#99d066"
    }, {
      tag: P.strikethrough,
      textDecoration: "line-through"
    }, {
      tag: P.heading,
      fontWeight: "bold",
      color: "#facf4e"
    }, {
      tag: P.heading1,
      fontWeight: "bold",
      color: "#facf4e"
    }, {
      tag: [P.heading2, P.heading3, P.heading4],
      fontWeight: "bold",
      color: "#facf4e"
    }, {
      tag: [P.heading5, P.heading6],
      color: "#facf4e"
    }, {
      tag: [P.atom, P.bool, P.special(P.variableName)],
      color: "#56c8d8"
    }, {
      tag: [P.processingInstruction, P.inserted],
      color: "#ff5f52"
    }, {
      tag: [P.contentSeparator],
      color: "#56c8d8"
    }, {
      tag: P.invalid,
      color: "#606f7a",
      borderBottom: "1px dotted #ff5f52"
    }, ...r]
  });
};
var pL = ev;
ev();
ev();
var gL = {
  background: "#FAFAFA",
  foreground: "#90A4AE",
  caret: "#272727",
  selection: "#80CBC440",
  selectionMatch: "#80CBC440",
  gutterBackground: "#FAFAFA",
  gutterForeground: "#90A4AE",
  gutterBorder: "transparent",
  lineHighlight: "#CCD7DA50"
};
var Fm = (t4) => {
  var {
    theme: e = "light",
    settings: n = {},
    styles: r = []
  } = t4 || {};
  return DI({
    theme: e,
    settings: bd({}, gL, n),
    styles: [{
      tag: P.keyword,
      color: "#39ADB5"
    }, {
      tag: [P.name, P.deleted, P.character, P.macroName],
      color: "#90A4AE"
    }, {
      tag: [P.propertyName],
      color: "#6182B8"
    }, {
      tag: [P.processingInstruction, P.string, P.inserted, P.special(P.string)],
      color: "#91B859"
    }, {
      tag: [P.function(P.variableName), P.labelName],
      color: "#6182B8"
    }, {
      tag: [P.color, P.constant(P.name), P.standard(P.name)],
      color: "#39ADB5"
    }, {
      tag: [P.definition(P.name), P.separator],
      color: "#90A4AE"
    }, {
      tag: [P.className],
      color: "#E2931D"
    }, {
      tag: [P.number, P.changed, P.annotation, P.modifier, P.self, P.namespace],
      color: "#F76D47"
    }, {
      tag: [P.typeName],
      color: "#E2931D",
      fontStyle: "#E2931D"
    }, {
      tag: [P.operator, P.operatorKeyword],
      color: "#39ADB5"
    }, {
      tag: [P.url, P.escape, P.regexp, P.link],
      color: "#91B859"
    }, {
      tag: [P.meta, P.comment],
      color: "#90A4AE"
    }, {
      tag: P.strong,
      fontWeight: "bold"
    }, {
      tag: P.emphasis,
      fontStyle: "italic"
    }, {
      tag: P.link,
      textDecoration: "underline"
    }, {
      tag: P.heading,
      fontWeight: "bold",
      color: "#39ADB5"
    }, {
      tag: [P.atom, P.bool, P.special(P.variableName)],
      color: "#90A4AE"
    }, {
      tag: P.invalid,
      color: "#E5393570"
    }, {
      tag: P.strikethrough,
      textDecoration: "line-through"
    }, ...r]
  });
};
Fm();
function mL(t4) {
  const e = {
    settings: {
      background: "var(--bg-color-tonal)",
      fontFamily: "var(--code-block-font-family)"
    },
    styles: [
      { tag: [P.propertyName], color: "var(--code-block-tokens-property-string-color)" },
      {
        tag: [P.processingInstruction, P.string, P.inserted, P.special(P.string)],
        color: "var(--code-block-tokens-string-color)"
      },
      { tag: [P.atom, P.bool, P.special(P.variableName)], color: "var(--text-color-secondary)" }
    ]
  };
  switch (t4) {
    case "light":
      return Fm(e);
    case "dark":
      return pL(e);
    default:
      return Fm(e);
  }
}
var QI = Me.define();
function Sd({ dataTestId: t4, ...e }) {
  const n = je(), r = hn(), { stateExtensions: i } = e, o = Ke(null), [s, a] = fe(false), l = We(
    () => i ? i.map((c) => ji.highest(c({ selectedEnvironment: r, state: n }))) : [],
    [i, r, n]
  );
  return _e(() => {
    var u;
    const c = (u = o.current) == null ? void 0 : u.view;
    c && c.dispatch({
      effects: QI.of()
    });
  }, [n.environments, r]), /* @__PURE__ */ g.jsx(OL, { "data-testid": t4, onClick: () => a(true), children: /* @__PURE__ */ g.jsx(
    RI,
    {
      autoFocus: s,
      className: "codemirror-container",
      ref: o,
      theme: mL("light"),
      basicSetup: {
        bracketMatching: true,
        closeBrackets: true,
        tabSize: 2,
        foldGutter: false,
        lineNumbers: true,
        lintKeymap: true,
        drawSelection: false
      },
      onBlur: () => a(false),
      ...e,
      extensions: [...l, ...e.extensions || []]
    }
  ) });
}
var OL = I.div`
  .cm-content {
    background-color: var(--bg-color);
    caret-color: var(--code-block-text-color);
    font-family: var(--font-family-monospaced);
  }

  .cm-gutters {
    background-color: var(--bg-color);
    font-family: var(--font-family-monospaced);
  }
  .codemirror-container {
    display: flex;
    flex-direction: column;
    justify-content: flex-start;
    overflow: hidden;

    .cm-editor {
      flex: 1;
      color: var(--code-block-text-color);
      border-radius: var(--panel-border-radius);
      font-weight: var(--code-block-font-weight);
      font-size: var(--code-block-font-size);
      line-height: var(--code-block-line-height);
      padding: var(--spacing-xs) 0;
      white-space: var(--code-wrap, pre);
      background-color: var(--bg-color);

      .cm-matchingBracket {
        outline: 1px solid grey;
        text-decoration: none;
        color: var(--color-carrot-8);
      }

      .cm-gutter {
        background-color: var(--bg-color);
        border-right: 1px solid var(--border-secondary);
      }

      .cm-gutterElement {
        background-color: var(--bg-color);
        min-width: 36px;
      }

      .cm-nonmatchingBracket {
        color: var(--color-red-8);
      }

      .cm-activeLine {
        background: none;
      }
      .cm-line {
        line-height: var(--code-block-line-height);
      }

      .cm-lintRange,
      .cm-lintPoint:after {
        border: none;
        width: 10px;
        height: 8px;
        left: 0;
        bottom: -2px;
        background-position: left bottom;
        background-repeat: repeat-x;
        background-size: 4px;
        background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAYAAAD+Bd/7AAAAVUlEQVR42mNgQAL/GRjigPg/EP8FYntkCX4gtoVKgvE/BoabcEVAhj6S5DUgfgFl/wFJ2gPxL6iuT1DF+kD2R5AYA5KRj6CS/FAMYvszIBltz4AFAAD9fz0YtLg13wAAAABJRU5ErkJggg==');
      }
    }

    .cm-editor.cm-focused {
      outline: none;

      .cm-matchingBracket,
      .cm-nonmatchingBracket {
        background: none;
      }
    }
  }

  .cm6-json-schema-hover.cm-tooltip-section {
    padding: var(--spacing-xs);
    font-family: var(--font-family-base);
  }

  .cm-diagnosticSource {
    display: none;
  }

  li.cm-diagnostic {
    padding: var(--spacing-xs);
  }

  .cm-tooltip {
    border: 1px solid var(--border-color-primary);
    background-color: var(--bg-color-raised);
    color: var(--text-color-secondary);
    font-family: var(--font-family-base);
    font-size: var(--font-size-sm);
    max-width: 60%;
  }
`;
var wd = class {
  /**
  @internal
  */
  constructor(e, n, r, i, o, s, a, l, c, u = 0, f) {
    this.p = e, this.stack = n, this.state = r, this.reducePos = i, this.pos = o, this.score = s, this.buffer = a, this.bufferBase = l, this.curContext = c, this.lookAhead = u, this.parent = f;
  }
  /**
  @internal
  */
  toString() {
    return `[${this.stack.filter((e, n) => n % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
  }
  // Start an empty stack
  /**
  @internal
  */
  static start(e, n, r = 0) {
    let i = e.parser.context;
    return new wd(e, [], n, r, r, 0, [], 0, i ? new kS(i, i.start) : null, 0, null);
  }
  /**
  The stack's current [context](#lr.ContextTracker) value, if
  any. Its type will depend on the context tracker's type
  parameter, or it will be `null` if there is no context
  tracker.
  */
  get context() {
    return this.curContext ? this.curContext.context : null;
  }
  // Push a state onto the stack, tracking its start position as well
  // as the buffer base at that point.
  /**
  @internal
  */
  pushState(e, n) {
    this.stack.push(this.state, n, this.bufferBase + this.buffer.length), this.state = e;
  }
  // Apply a reduce action
  /**
  @internal
  */
  reduce(e) {
    var n;
    let r = e >> 19, i = e & 65535, { parser: o } = this.p, s = o.dynamicPrecedence(i);
    if (s && (this.score += s), r == 0) {
      this.pushState(o.getGoto(this.state, i, true), this.reducePos), i < o.minRepeatTerm && this.storeNode(i, this.reducePos, this.reducePos, 4, true), this.reduceContext(i, this.reducePos);
      return;
    }
    let a = this.stack.length - (r - 1) * 3 - (e & 262144 ? 6 : 0), l = a ? this.stack[a - 2] : this.p.ranges[0].from, c = this.reducePos - l;
    c >= 2e3 && !(!((n = this.p.parser.nodeSet.types[i]) === null || n === void 0) && n.isAnonymous) && (l == this.p.lastBigReductionStart ? (this.p.bigReductionCount++, this.p.lastBigReductionSize = c) : this.p.lastBigReductionSize < c && (this.p.bigReductionCount = 1, this.p.lastBigReductionStart = l, this.p.lastBigReductionSize = c));
    let u = a ? this.stack[a - 1] : 0, f = this.bufferBase + this.buffer.length - u;
    if (i < o.minRepeatTerm || e & 131072) {
      let d = o.stateFlag(
        this.state,
        1
        /* StateFlag.Skipped */
      ) ? this.pos : this.reducePos;
      this.storeNode(i, l, d, f + 4, true);
    }
    if (e & 262144)
      this.state = this.stack[a];
    else {
      let d = this.stack[a - 3];
      this.state = o.getGoto(d, i, true);
    }
    for (; this.stack.length > a; )
      this.stack.pop();
    this.reduceContext(i, l);
  }
  // Shift a value into the buffer
  /**
  @internal
  */
  storeNode(e, n, r, i = 4, o = false) {
    if (e == 0 && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
      let s = this, a = this.buffer.length;
      if (a == 0 && s.parent && (a = s.bufferBase - s.parent.bufferBase, s = s.parent), a > 0 && s.buffer[a - 4] == 0 && s.buffer[a - 1] > -1) {
        if (n == r)
          return;
        if (s.buffer[a - 2] >= n) {
          s.buffer[a - 2] = r;
          return;
        }
      }
    }
    if (!o || this.pos == r)
      this.buffer.push(e, n, r, i);
    else {
      let s = this.buffer.length;
      if (s > 0 && this.buffer[s - 4] != 0)
        for (; s > 0 && this.buffer[s - 2] > r; )
          this.buffer[s] = this.buffer[s - 4], this.buffer[s + 1] = this.buffer[s - 3], this.buffer[s + 2] = this.buffer[s - 2], this.buffer[s + 3] = this.buffer[s - 1], s -= 4, i > 4 && (i -= 4);
      this.buffer[s] = e, this.buffer[s + 1] = n, this.buffer[s + 2] = r, this.buffer[s + 3] = i;
    }
  }
  // Apply a shift action
  /**
  @internal
  */
  shift(e, n, r, i) {
    if (e & 131072)
      this.pushState(e & 65535, this.pos);
    else if (e & 262144)
      this.pos = i, this.shiftContext(n, r), n <= this.p.parser.maxNode && this.buffer.push(n, r, i, 4);
    else {
      let o = e, { parser: s } = this.p;
      (i > this.pos || n <= s.maxNode) && (this.pos = i, s.stateFlag(
        o,
        1
        /* StateFlag.Skipped */
      ) || (this.reducePos = i)), this.pushState(o, r), this.shiftContext(n, r), n <= s.maxNode && this.buffer.push(n, r, i, 4);
    }
  }
  // Apply an action
  /**
  @internal
  */
  apply(e, n, r, i) {
    e & 65536 ? this.reduce(e) : this.shift(e, n, r, i);
  }
  // Add a prebuilt (reused) node into the buffer.
  /**
  @internal
  */
  useNode(e, n) {
    let r = this.p.reused.length - 1;
    (r < 0 || this.p.reused[r] != e) && (this.p.reused.push(e), r++);
    let i = this.pos;
    this.reducePos = this.pos = i + e.length, this.pushState(n, i), this.buffer.push(
      r,
      i,
      this.reducePos,
      -1
      /* size == -1 means this is a reused value */
    ), this.curContext && this.updateContext(this.curContext.tracker.reuse(this.curContext.context, e, this, this.p.stream.reset(this.pos - e.length)));
  }
  // Split the stack. Due to the buffer sharing and the fact
  // that `this.stack` tends to stay quite shallow, this isn't very
  // expensive.
  /**
  @internal
  */
  split() {
    let e = this, n = e.buffer.length;
    for (; n > 0 && e.buffer[n - 2] > e.reducePos; )
      n -= 4;
    let r = e.buffer.slice(n), i = e.bufferBase + n;
    for (; e && i == e.bufferBase; )
      e = e.parent;
    return new wd(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, r, i, this.curContext, this.lookAhead, e);
  }
  // Try to recover from an error by 'deleting' (ignoring) one token.
  /**
  @internal
  */
  recoverByDelete(e, n) {
    let r = e <= this.p.parser.maxNode;
    r && this.storeNode(e, this.pos, n, 4), this.storeNode(0, this.pos, n, r ? 8 : 4), this.pos = this.reducePos = n, this.score -= 190;
  }
  /**
  Check if the given term would be able to be shifted (optionally
  after some reductions) on this stack. This can be useful for
  external tokenizers that want to make sure they only provide a
  given token when it applies.
  */
  canShift(e) {
    for (let n = new xL(this); ; ) {
      let r = this.p.parser.stateSlot(
        n.state,
        4
        /* ParseState.DefaultReduce */
      ) || this.p.parser.hasAction(n.state, e);
      if (r == 0)
        return false;
      if (!(r & 65536))
        return true;
      n.reduce(r);
    }
  }
  // Apply up to Recover.MaxNext recovery actions that conceptually
  // inserts some missing token or rule.
  /**
  @internal
  */
  recoverByInsert(e) {
    if (this.stack.length >= 300)
      return [];
    let n = this.p.parser.nextStates(this.state);
    if (n.length > 8 || this.stack.length >= 120) {
      let i = [];
      for (let o = 0, s; o < n.length; o += 2)
        (s = n[o + 1]) != this.state && this.p.parser.hasAction(s, e) && i.push(n[o], s);
      if (this.stack.length < 120)
        for (let o = 0; i.length < 8 && o < n.length; o += 2) {
          let s = n[o + 1];
          i.some((a, l) => l & 1 && a == s) || i.push(n[o], s);
        }
      n = i;
    }
    let r = [];
    for (let i = 0; i < n.length && r.length < 4; i += 2) {
      let o = n[i + 1];
      if (o == this.state)
        continue;
      let s = this.split();
      s.pushState(o, this.pos), s.storeNode(0, s.pos, s.pos, 4, true), s.shiftContext(n[i], this.pos), s.reducePos = this.pos, s.score -= 200, r.push(s);
    }
    return r;
  }
  // Force a reduce, if possible. Return false if that can't
  // be done.
  /**
  @internal
  */
  forceReduce() {
    let { parser: e } = this.p, n = e.stateSlot(
      this.state,
      5
      /* ParseState.ForcedReduce */
    );
    if (!(n & 65536))
      return false;
    if (!e.validAction(this.state, n)) {
      let r = n >> 19, i = n & 65535, o = this.stack.length - r * 3;
      if (o < 0 || e.getGoto(this.stack[o], i, false) < 0) {
        let s = this.findForcedReduction();
        if (s == null)
          return false;
        n = s;
      }
      this.storeNode(0, this.pos, this.pos, 4, true), this.score -= 100;
    }
    return this.reducePos = this.pos, this.reduce(n), true;
  }
  /**
  Try to scan through the automaton to find some kind of reduction
  that can be applied. Used when the regular ForcedReduce field
  isn't a valid action. @internal
  */
  findForcedReduction() {
    let { parser: e } = this.p, n = [], r = (i, o) => {
      if (!n.includes(i))
        return n.push(i), e.allActions(i, (s) => {
          if (!(s & 393216))
            if (s & 65536) {
              let a = (s >> 19) - o;
              if (a > 1) {
                let l = s & 65535, c = this.stack.length - a * 3;
                if (c >= 0 && e.getGoto(this.stack[c], l, false) >= 0)
                  return a << 19 | 65536 | l;
              }
            } else {
              let a = r(s, o + 1);
              if (a != null)
                return a;
            }
        });
    };
    return r(this.state, 0);
  }
  /**
  @internal
  */
  forceAll() {
    for (; !this.p.parser.stateFlag(
      this.state,
      2
      /* StateFlag.Accepting */
    ); )
      if (!this.forceReduce()) {
        this.storeNode(0, this.pos, this.pos, 4, true);
        break;
      }
    return this;
  }
  /**
  Check whether this state has no further actions (assumed to be a direct descendant of the
  top state, since any other states must be able to continue
  somehow). @internal
  */
  get deadEnd() {
    if (this.stack.length != 3)
      return false;
    let { parser: e } = this.p;
    return e.data[e.stateSlot(
      this.state,
      1
      /* ParseState.Actions */
    )] == 65535 && !e.stateSlot(
      this.state,
      4
      /* ParseState.DefaultReduce */
    );
  }
  /**
  Restart the stack (put it back in its start state). Only safe
  when this.stack.length == 3 (state is directly below the top
  state). @internal
  */
  restart() {
    this.storeNode(0, this.pos, this.pos, 4, true), this.state = this.stack[0], this.stack.length = 0;
  }
  /**
  @internal
  */
  sameState(e) {
    if (this.state != e.state || this.stack.length != e.stack.length)
      return false;
    for (let n = 0; n < this.stack.length; n += 3)
      if (this.stack[n] != e.stack[n])
        return false;
    return true;
  }
  /**
  Get the parser used by this stack.
  */
  get parser() {
    return this.p.parser;
  }
  /**
  Test whether a given dialect (by numeric ID, as exported from
  the terms file) is enabled.
  */
  dialectEnabled(e) {
    return this.p.parser.dialect.flags[e];
  }
  shiftContext(e, n) {
    this.curContext && this.updateContext(this.curContext.tracker.shift(this.curContext.context, e, this, this.p.stream.reset(n)));
  }
  reduceContext(e, n) {
    this.curContext && this.updateContext(this.curContext.tracker.reduce(this.curContext.context, e, this, this.p.stream.reset(n)));
  }
  /**
  @internal
  */
  emitContext() {
    let e = this.buffer.length - 1;
    (e < 0 || this.buffer[e] != -3) && this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);
  }
  /**
  @internal
  */
  emitLookAhead() {
    let e = this.buffer.length - 1;
    (e < 0 || this.buffer[e] != -4) && this.buffer.push(this.lookAhead, this.pos, this.pos, -4);
  }
  updateContext(e) {
    if (e != this.curContext.context) {
      let n = new kS(this.curContext.tracker, e);
      n.hash != this.curContext.hash && this.emitContext(), this.curContext = n;
    }
  }
  /**
  @internal
  */
  setLookAhead(e) {
    e > this.lookAhead && (this.emitLookAhead(), this.lookAhead = e);
  }
  /**
  @internal
  */
  close() {
    this.curContext && this.curContext.tracker.strict && this.emitContext(), this.lookAhead > 0 && this.emitLookAhead();
  }
};
var kS = class {
  constructor(e, n) {
    this.tracker = e, this.context = n, this.hash = e.strict ? e.hash(n) : 0;
  }
};
var xL = class {
  constructor(e) {
    this.start = e, this.state = e.state, this.stack = e.stack, this.base = this.stack.length;
  }
  reduce(e) {
    let n = e & 65535, r = e >> 19;
    r == 0 ? (this.stack == this.start.stack && (this.stack = this.stack.slice()), this.stack.push(this.state, 0, 0), this.base += 3) : this.base -= (r - 1) * 3;
    let i = this.start.p.parser.getGoto(this.stack[this.base - 3], n, true);
    this.state = i;
  }
};
var Cd = class {
  constructor(e, n, r) {
    this.stack = e, this.pos = n, this.index = r, this.buffer = e.buffer, this.index == 0 && this.maybeNext();
  }
  static create(e, n = e.bufferBase + e.buffer.length) {
    return new Cd(e, n, n - e.bufferBase);
  }
  maybeNext() {
    let e = this.stack.parent;
    e != null && (this.index = this.stack.bufferBase - e.bufferBase, this.stack = e, this.buffer = e.buffer);
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  next() {
    this.index -= 4, this.pos -= 4, this.index == 0 && this.maybeNext();
  }
  fork() {
    return new Cd(this.stack, this.pos, this.index);
  }
};
function jl(t4, e = Uint16Array) {
  if (typeof t4 != "string")
    return t4;
  let n = null;
  for (let r = 0, i = 0; r < t4.length; ) {
    let o = 0;
    for (; ; ) {
      let s = t4.charCodeAt(r++), a = false;
      if (s == 126) {
        o = 65535;
        break;
      }
      s >= 92 && s--, s >= 34 && s--;
      let l = s - 32;
      if (l >= 46 && (l -= 46, a = true), o += l, a)
        break;
      o *= 46;
    }
    n ? n[i++] = o : n = new e(o);
  }
  return n;
}
var xf = class {
  constructor() {
    this.start = -1, this.value = -1, this.end = -1, this.extended = -1, this.lookAhead = 0, this.mask = 0, this.context = 0;
  }
};
var AS = new xf();
var vL = class {
  /**
  @internal
  */
  constructor(e, n) {
    this.input = e, this.ranges = n, this.chunk = "", this.chunkOff = 0, this.chunk2 = "", this.chunk2Pos = 0, this.next = -1, this.token = AS, this.rangeIndex = 0, this.pos = this.chunkPos = n[0].from, this.range = n[0], this.end = n[n.length - 1].to, this.readNext();
  }
  /**
  @internal
  */
  resolveOffset(e, n) {
    let r = this.range, i = this.rangeIndex, o = this.pos + e;
    for (; o < r.from; ) {
      if (!i)
        return null;
      let s = this.ranges[--i];
      o -= r.from - s.to, r = s;
    }
    for (; n < 0 ? o > r.to : o >= r.to; ) {
      if (i == this.ranges.length - 1)
        return null;
      let s = this.ranges[++i];
      o += s.from - r.to, r = s;
    }
    return o;
  }
  /**
  @internal
  */
  clipPos(e) {
    if (e >= this.range.from && e < this.range.to)
      return e;
    for (let n of this.ranges)
      if (n.to > e)
        return Math.max(e, n.from);
    return this.end;
  }
  /**
  Look at a code unit near the stream position. `.peek(0)` equals
  `.next`, `.peek(-1)` gives you the previous character, and so
  on.
  
  Note that looking around during tokenizing creates dependencies
  on potentially far-away content, which may reduce the
  effectiveness incremental parsing—when looking forward—or even
  cause invalid reparses when looking backward more than 25 code
  units, since the library does not track lookbehind.
  */
  peek(e) {
    let n = this.chunkOff + e, r, i;
    if (n >= 0 && n < this.chunk.length)
      r = this.pos + e, i = this.chunk.charCodeAt(n);
    else {
      let o = this.resolveOffset(e, 1);
      if (o == null)
        return -1;
      if (r = o, r >= this.chunk2Pos && r < this.chunk2Pos + this.chunk2.length)
        i = this.chunk2.charCodeAt(r - this.chunk2Pos);
      else {
        let s = this.rangeIndex, a = this.range;
        for (; a.to <= r; )
          a = this.ranges[++s];
        this.chunk2 = this.input.chunk(this.chunk2Pos = r), r + this.chunk2.length > a.to && (this.chunk2 = this.chunk2.slice(0, a.to - r)), i = this.chunk2.charCodeAt(0);
      }
    }
    return r >= this.token.lookAhead && (this.token.lookAhead = r + 1), i;
  }
  /**
  Accept a token. By default, the end of the token is set to the
  current stream position, but you can pass an offset (relative to
  the stream position) to change that.
  */
  acceptToken(e, n = 0) {
    let r = n ? this.resolveOffset(n, -1) : this.pos;
    if (r == null || r < this.token.start)
      throw new RangeError("Token end out of bounds");
    this.token.value = e, this.token.end = r;
  }
  /**
  Accept a token ending at a specific given position.
  */
  acceptTokenTo(e, n) {
    this.token.value = e, this.token.end = n;
  }
  getChunk() {
    if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
      let { chunk: e, chunkPos: n } = this;
      this.chunk = this.chunk2, this.chunkPos = this.chunk2Pos, this.chunk2 = e, this.chunk2Pos = n, this.chunkOff = this.pos - this.chunkPos;
    } else {
      this.chunk2 = this.chunk, this.chunk2Pos = this.chunkPos;
      let e = this.input.chunk(this.pos), n = this.pos + e.length;
      this.chunk = n > this.range.to ? e.slice(0, this.range.to - this.pos) : e, this.chunkPos = this.pos, this.chunkOff = 0;
    }
  }
  readNext() {
    return this.chunkOff >= this.chunk.length && (this.getChunk(), this.chunkOff == this.chunk.length) ? this.next = -1 : this.next = this.chunk.charCodeAt(this.chunkOff);
  }
  /**
  Move the stream forward N (defaults to 1) code units. Returns
  the new value of [`next`](#lr.InputStream.next).
  */
  advance(e = 1) {
    for (this.chunkOff += e; this.pos + e >= this.range.to; ) {
      if (this.rangeIndex == this.ranges.length - 1)
        return this.setDone();
      e -= this.range.to - this.pos, this.range = this.ranges[++this.rangeIndex], this.pos = this.range.from;
    }
    return this.pos += e, this.pos >= this.token.lookAhead && (this.token.lookAhead = this.pos + 1), this.readNext();
  }
  setDone() {
    return this.pos = this.chunkPos = this.end, this.range = this.ranges[this.rangeIndex = this.ranges.length - 1], this.chunk = "", this.next = -1;
  }
  /**
  @internal
  */
  reset(e, n) {
    if (n ? (this.token = n, n.start = e, n.lookAhead = e + 1, n.value = n.extended = -1) : this.token = AS, this.pos != e) {
      if (this.pos = e, e == this.end)
        return this.setDone(), this;
      for (; e < this.range.from; )
        this.range = this.ranges[--this.rangeIndex];
      for (; e >= this.range.to; )
        this.range = this.ranges[++this.rangeIndex];
      e >= this.chunkPos && e < this.chunkPos + this.chunk.length ? this.chunkOff = e - this.chunkPos : (this.chunk = "", this.chunkOff = 0), this.readNext();
    }
    return this;
  }
  /**
  @internal
  */
  read(e, n) {
    if (e >= this.chunkPos && n <= this.chunkPos + this.chunk.length)
      return this.chunk.slice(e - this.chunkPos, n - this.chunkPos);
    if (e >= this.chunk2Pos && n <= this.chunk2Pos + this.chunk2.length)
      return this.chunk2.slice(e - this.chunk2Pos, n - this.chunk2Pos);
    if (e >= this.range.from && n <= this.range.to)
      return this.input.read(e, n);
    let r = "";
    for (let i of this.ranges) {
      if (i.from >= n)
        break;
      i.to > e && (r += this.input.read(Math.max(i.from, e), Math.min(i.to, n)));
    }
    return r;
  }
};
var ha = class {
  constructor(e, n) {
    this.data = e, this.id = n;
  }
  token(e, n) {
    let { parser: r } = n.p;
    BI(this.data, e, n, this.id, r.data, r.tokenPrecTable);
  }
};
ha.prototype.contextual = ha.prototype.fallback = ha.prototype.extend = false;
var kd = class {
  constructor(e, n, r) {
    this.precTable = n, this.elseToken = r, this.data = typeof e == "string" ? jl(e) : e;
  }
  token(e, n) {
    let r = e.pos, i = 0;
    for (; ; ) {
      let o = e.next < 0, s = e.resolveOffset(1, 1);
      if (BI(this.data, e, n, 0, this.data, this.precTable), e.token.value > -1)
        break;
      if (this.elseToken == null)
        return;
      if (o || i++, s == null)
        break;
      e.reset(s, e.token);
    }
    i && (e.reset(r, e.token), e.acceptToken(this.elseToken, i));
  }
};
kd.prototype.contextual = ha.prototype.fallback = ha.prototype.extend = false;
var Cr = class {
  /**
  Create a tokenizer. The first argument is the function that,
  given an input stream, scans for the types of tokens it
  recognizes at the stream's position, and calls
  [`acceptToken`](#lr.InputStream.acceptToken) when it finds
  one.
  */
  constructor(e, n = {}) {
    this.token = e, this.contextual = !!n.contextual, this.fallback = !!n.fallback, this.extend = !!n.extend;
  }
};
function BI(t4, e, n, r, i, o) {
  let s = 0, a = 1 << r, { dialect: l } = n.p.parser;
  e:
    for (; a & t4[s]; ) {
      let c = t4[s + 1];
      for (let h = s + 3; h < c; h += 2)
        if ((t4[h + 1] & a) > 0) {
          let p = t4[h];
          if (l.allows(p) && (e.token.value == -1 || e.token.value == p || yL(p, e.token.value, i, o))) {
            e.acceptToken(p);
            break;
          }
        }
      let u = e.next, f = 0, d = t4[s + 2];
      if (e.next < 0 && d > f && t4[c + d * 3 - 3] == 65535) {
        s = t4[c + d * 3 - 1];
        continue e;
      }
      for (; f < d; ) {
        let h = f + d >> 1, p = c + h + (h << 1), O = t4[p], m = t4[p + 1] || 65536;
        if (u < O)
          d = h;
        else if (u >= m)
          f = h + 1;
        else {
          s = t4[p + 2], e.advance();
          continue e;
        }
      }
      break;
    }
}
function PS(t4, e, n) {
  for (let r = e, i; (i = t4[r]) != 65535; r++)
    if (i == n)
      return r - e;
  return -1;
}
function yL(t4, e, n, r) {
  let i = PS(n, r, e);
  return i < 0 || PS(n, r, t4) < i;
}
var hr = typeof process < "u" && process.env && /\bparse\b/.test(process.env.LOG);
var qp = null;
function ES(t4, e, n) {
  let r = t4.cursor(Rt.IncludeAnonymous);
  for (r.moveTo(e); ; )
    if (!(n < 0 ? r.childBefore(e) : r.childAfter(e)))
      for (; ; ) {
        if ((n < 0 ? r.to < e : r.from > e) && !r.type.isError)
          return n < 0 ? Math.max(0, Math.min(
            r.to - 1,
            e - 25
            /* Safety.Margin */
          )) : Math.min(t4.length, Math.max(
            r.from + 1,
            e + 25
            /* Safety.Margin */
          ));
        if (n < 0 ? r.prevSibling() : r.nextSibling())
          break;
        if (!r.parent())
          return n < 0 ? 0 : t4.length;
      }
}
var bL = class {
  constructor(e, n) {
    this.fragments = e, this.nodeSet = n, this.i = 0, this.fragment = null, this.safeFrom = -1, this.safeTo = -1, this.trees = [], this.start = [], this.index = [], this.nextFragment();
  }
  nextFragment() {
    let e = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
    if (e) {
      for (this.safeFrom = e.openStart ? ES(e.tree, e.from + e.offset, 1) - e.offset : e.from, this.safeTo = e.openEnd ? ES(e.tree, e.to + e.offset, -1) - e.offset : e.to; this.trees.length; )
        this.trees.pop(), this.start.pop(), this.index.pop();
      this.trees.push(e.tree), this.start.push(-e.offset), this.index.push(0), this.nextStart = this.safeFrom;
    } else
      this.nextStart = 1e9;
  }
  // `pos` must be >= any previously given `pos` for this cursor
  nodeAt(e) {
    if (e < this.nextStart)
      return null;
    for (; this.fragment && this.safeTo <= e; )
      this.nextFragment();
    if (!this.fragment)
      return null;
    for (; ; ) {
      let n = this.trees.length - 1;
      if (n < 0)
        return this.nextFragment(), null;
      let r = this.trees[n], i = this.index[n];
      if (i == r.children.length) {
        this.trees.pop(), this.start.pop(), this.index.pop();
        continue;
      }
      let o = r.children[i], s = this.start[n] + r.positions[i];
      if (s > e)
        return this.nextStart = s, null;
      if (o instanceof Zt) {
        if (s == e) {
          if (s < this.safeFrom)
            return null;
          let a = s + o.length;
          if (a <= this.safeTo) {
            let l = o.prop(Xe.lookAhead);
            if (!l || a + l < this.fragment.to)
              return o;
          }
        }
        this.index[n]++, s + o.length >= Math.max(this.safeFrom, e) && (this.trees.push(o), this.start.push(s), this.index.push(0));
      } else
        this.index[n]++, this.nextStart = s + o.length;
    }
  }
};
var SL = class {
  constructor(e, n) {
    this.stream = n, this.tokens = [], this.mainToken = null, this.actions = [], this.tokens = e.tokenizers.map((r) => new xf());
  }
  getActions(e) {
    let n = 0, r = null, { parser: i } = e.p, { tokenizers: o } = i, s = i.stateSlot(
      e.state,
      3
      /* ParseState.TokenizerMask */
    ), a = e.curContext ? e.curContext.hash : 0, l = 0;
    for (let c = 0; c < o.length; c++) {
      if (!(1 << c & s))
        continue;
      let u = o[c], f = this.tokens[c];
      if (!(r && !u.fallback) && ((u.contextual || f.start != e.pos || f.mask != s || f.context != a) && (this.updateCachedToken(f, u, e), f.mask = s, f.context = a), f.lookAhead > f.end + 25 && (l = Math.max(f.lookAhead, l)), f.value != 0)) {
        let d = n;
        if (f.extended > -1 && (n = this.addActions(e, f.extended, f.end, n)), n = this.addActions(e, f.value, f.end, n), !u.extend && (r = f, n > d))
          break;
      }
    }
    for (; this.actions.length > n; )
      this.actions.pop();
    return l && e.setLookAhead(l), !r && e.pos == this.stream.end && (r = new xf(), r.value = e.p.parser.eofTerm, r.start = r.end = e.pos, n = this.addActions(e, r.value, r.end, n)), this.mainToken = r, this.actions;
  }
  getMainToken(e) {
    if (this.mainToken)
      return this.mainToken;
    let n = new xf(), { pos: r, p: i } = e;
    return n.start = r, n.end = Math.min(r + 1, i.stream.end), n.value = r == i.stream.end ? i.parser.eofTerm : 0, n;
  }
  updateCachedToken(e, n, r) {
    let i = this.stream.clipPos(r.pos);
    if (n.token(this.stream.reset(i, e), r), e.value > -1) {
      let { parser: o } = r.p;
      for (let s = 0; s < o.specialized.length; s++)
        if (o.specialized[s] == e.value) {
          let a = o.specializers[s](this.stream.read(e.start, e.end), r);
          if (a >= 0 && r.p.parser.dialect.allows(a >> 1)) {
            a & 1 ? e.extended = a >> 1 : e.value = a >> 1;
            break;
          }
        }
    } else
      e.value = 0, e.end = this.stream.clipPos(i + 1);
  }
  putAction(e, n, r, i) {
    for (let o = 0; o < i; o += 3)
      if (this.actions[o] == e)
        return i;
    return this.actions[i++] = e, this.actions[i++] = n, this.actions[i++] = r, i;
  }
  addActions(e, n, r, i) {
    let { state: o } = e, { parser: s } = e.p, { data: a } = s;
    for (let l = 0; l < 2; l++)
      for (let c = s.stateSlot(
        o,
        l ? 2 : 1
        /* ParseState.Actions */
      ); ; c += 3) {
        if (a[c] == 65535)
          if (a[c + 1] == 1)
            c = Vi(a, c + 2);
          else {
            i == 0 && a[c + 1] == 2 && (i = this.putAction(Vi(a, c + 2), n, r, i));
            break;
          }
        a[c] == n && (i = this.putAction(Vi(a, c + 1), n, r, i));
      }
    return i;
  }
};
var wL = class {
  constructor(e, n, r, i) {
    this.parser = e, this.input = n, this.ranges = i, this.recovering = 0, this.nextStackID = 9812, this.minStackPos = 0, this.reused = [], this.stoppedAt = null, this.lastBigReductionStart = -1, this.lastBigReductionSize = 0, this.bigReductionCount = 0, this.stream = new vL(n, i), this.tokens = new SL(e, this.stream), this.topTerm = e.top[1];
    let { from: o } = i[0];
    this.stacks = [wd.start(this, e.top[0], o)], this.fragments = r.length && this.stream.end - o > e.bufferLength * 4 ? new bL(r, e.nodeSet) : null;
  }
  get parsedPos() {
    return this.minStackPos;
  }
  // Move the parser forward. This will process all parse stacks at
  // `this.pos` and try to advance them to a further position. If no
  // stack for such a position is found, it'll start error-recovery.
  //
  // When the parse is finished, this will return a syntax tree. When
  // not, it returns `null`.
  advance() {
    let e = this.stacks, n = this.minStackPos, r = this.stacks = [], i, o;
    if (this.bigReductionCount > 300 && e.length == 1) {
      let [s] = e;
      for (; s.forceReduce() && s.stack.length && s.stack[s.stack.length - 2] >= this.lastBigReductionStart; )
        ;
      this.bigReductionCount = this.lastBigReductionSize = 0;
    }
    for (let s = 0; s < e.length; s++) {
      let a = e[s];
      for (; ; ) {
        if (this.tokens.mainToken = null, a.pos > n)
          r.push(a);
        else {
          if (this.advanceStack(a, r, e))
            continue;
          {
            i || (i = [], o = []), i.push(a);
            let l = this.tokens.getMainToken(a);
            o.push(l.value, l.end);
          }
        }
        break;
      }
    }
    if (!r.length) {
      let s = i && kL(i);
      if (s)
        return hr && console.log("Finish with " + this.stackID(s)), this.stackToTree(s);
      if (this.parser.strict)
        throw hr && i && console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none")), new SyntaxError("No parse at " + n);
      this.recovering || (this.recovering = 5);
    }
    if (this.recovering && i) {
      let s = this.stoppedAt != null && i[0].pos > this.stoppedAt ? i[0] : this.runRecovery(i, o, r);
      if (s)
        return hr && console.log("Force-finish " + this.stackID(s)), this.stackToTree(s.forceAll());
    }
    if (this.recovering) {
      let s = this.recovering == 1 ? 1 : this.recovering * 3;
      if (r.length > s)
        for (r.sort((a, l) => l.score - a.score); r.length > s; )
          r.pop();
      r.some((a) => a.reducePos > n) && this.recovering--;
    } else if (r.length > 1) {
      e:
        for (let s = 0; s < r.length - 1; s++) {
          let a = r[s];
          for (let l = s + 1; l < r.length; l++) {
            let c = r[l];
            if (a.sameState(c) || a.buffer.length > 500 && c.buffer.length > 500)
              if ((a.score - c.score || a.buffer.length - c.buffer.length) > 0)
                r.splice(l--, 1);
              else {
                r.splice(s--, 1);
                continue e;
              }
          }
        }
      r.length > 12 && r.splice(
        12,
        r.length - 12
        /* Rec.MaxStackCount */
      );
    }
    this.minStackPos = r[0].pos;
    for (let s = 1; s < r.length; s++)
      r[s].pos < this.minStackPos && (this.minStackPos = r[s].pos);
    return null;
  }
  stopAt(e) {
    if (this.stoppedAt != null && this.stoppedAt < e)
      throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = e;
  }
  // Returns an updated version of the given stack, or null if the
  // stack can't advance normally. When `split` and `stacks` are
  // given, stacks split off by ambiguous operations will be pushed to
  // `split`, or added to `stacks` if they move `pos` forward.
  advanceStack(e, n, r) {
    let i = e.pos, { parser: o } = this, s = hr ? this.stackID(e) + " -> " : "";
    if (this.stoppedAt != null && i > this.stoppedAt)
      return e.forceReduce() ? e : null;
    if (this.fragments) {
      let c = e.curContext && e.curContext.tracker.strict, u = c ? e.curContext.hash : 0;
      for (let f = this.fragments.nodeAt(i); f; ) {
        let d = this.parser.nodeSet.types[f.type.id] == f.type ? o.getGoto(e.state, f.type.id) : -1;
        if (d > -1 && f.length && (!c || (f.prop(Xe.contextHash) || 0) == u))
          return e.useNode(f, d), hr && console.log(s + this.stackID(e) + ` (via reuse of ${o.getName(f.type.id)})`), true;
        if (!(f instanceof Zt) || f.children.length == 0 || f.positions[0] > 0)
          break;
        let h = f.children[0];
        if (h instanceof Zt && f.positions[0] == 0)
          f = h;
        else
          break;
      }
    }
    let a = o.stateSlot(
      e.state,
      4
      /* ParseState.DefaultReduce */
    );
    if (a > 0)
      return e.reduce(a), hr && console.log(s + this.stackID(e) + ` (via always-reduce ${o.getName(
        a & 65535
        /* Action.ValueMask */
      )})`), true;
    if (e.stack.length >= 8400)
      for (; e.stack.length > 6e3 && e.forceReduce(); )
        ;
    let l = this.tokens.getActions(e);
    for (let c = 0; c < l.length; ) {
      let u = l[c++], f = l[c++], d = l[c++], h = c == l.length || !r, p = h ? e : e.split(), O = this.tokens.mainToken;
      if (p.apply(u, f, O ? O.start : p.pos, d), hr && console.log(s + this.stackID(p) + ` (via ${u & 65536 ? `reduce of ${o.getName(
        u & 65535
        /* Action.ValueMask */
      )}` : "shift"} for ${o.getName(f)} @ ${i}${p == e ? "" : ", split"})`), h)
        return true;
      p.pos > i ? n.push(p) : r.push(p);
    }
    return false;
  }
  // Advance a given stack forward as far as it will go. Returns the
  // (possibly updated) stack if it got stuck, or null if it moved
  // forward and was given to `pushStackDedup`.
  advanceFully(e, n) {
    let r = e.pos;
    for (; ; ) {
      if (!this.advanceStack(e, null, null))
        return false;
      if (e.pos > r)
        return TS(e, n), true;
    }
  }
  runRecovery(e, n, r) {
    let i = null, o = false;
    for (let s = 0; s < e.length; s++) {
      let a = e[s], l = n[s << 1], c = n[(s << 1) + 1], u = hr ? this.stackID(a) + " -> " : "";
      if (a.deadEnd && (o || (o = true, a.restart(), hr && console.log(u + this.stackID(a) + " (restarted)"), this.advanceFully(a, r))))
        continue;
      let f = a.split(), d = u;
      for (let h = 0; f.forceReduce() && h < 10 && (hr && console.log(d + this.stackID(f) + " (via force-reduce)"), !this.advanceFully(f, r)); h++)
        hr && (d = this.stackID(f) + " -> ");
      for (let h of a.recoverByInsert(l))
        hr && console.log(u + this.stackID(h) + " (via recover-insert)"), this.advanceFully(h, r);
      this.stream.end > a.pos ? (c == a.pos && (c++, l = 0), a.recoverByDelete(l, c), hr && console.log(u + this.stackID(a) + ` (via recover-delete ${this.parser.getName(l)})`), TS(a, r)) : (!i || i.score < a.score) && (i = a);
    }
    return i;
  }
  // Convert the stack's buffer to a syntax tree.
  stackToTree(e) {
    return e.close(), Zt.build({
      buffer: Cd.create(e),
      nodeSet: this.parser.nodeSet,
      topID: this.topTerm,
      maxBufferLength: this.parser.bufferLength,
      reused: this.reused,
      start: this.ranges[0].from,
      length: e.pos - this.ranges[0].from,
      minRepeatType: this.parser.minRepeatTerm
    });
  }
  stackID(e) {
    let n = (qp || (qp = /* @__PURE__ */ new WeakMap())).get(e);
    return n || qp.set(e, n = String.fromCodePoint(this.nextStackID++)), n + e;
  }
};
function TS(t4, e) {
  for (let n = 0; n < e.length; n++) {
    let r = e[n];
    if (r.pos == t4.pos && r.sameState(t4)) {
      e[n].score < t4.score && (e[n] = t4);
      return;
    }
  }
  e.push(t4);
}
var CL = class {
  constructor(e, n, r) {
    this.source = e, this.flags = n, this.disabled = r;
  }
  allows(e) {
    return !this.disabled || this.disabled[e] == 0;
  }
};
var Up = (t4) => t4;
var tv = class {
  /**
  Define a context tracker.
  */
  constructor(e) {
    this.start = e.start, this.shift = e.shift || Up, this.reduce = e.reduce || Up, this.reuse = e.reuse || Up, this.hash = e.hash || (() => 0), this.strict = e.strict !== false;
  }
};
var Bo = class extends lT {
  /**
  @internal
  */
  constructor(e) {
    if (super(), this.wrappers = [], e.version != 14)
      throw new RangeError(`Parser version (${e.version}) doesn't match runtime version (14)`);
    let n = e.nodeNames.split(" ");
    this.minRepeatTerm = n.length;
    for (let a = 0; a < e.repeatNodeCount; a++)
      n.push("");
    let r = Object.keys(e.topRules).map((a) => e.topRules[a][1]), i = [];
    for (let a = 0; a < n.length; a++)
      i.push([]);
    function o(a, l, c) {
      i[a].push([l, l.deserialize(String(c))]);
    }
    if (e.nodeProps)
      for (let a of e.nodeProps) {
        let l = a[0];
        typeof l == "string" && (l = Xe[l]);
        for (let c = 1; c < a.length; ) {
          let u = a[c++];
          if (u >= 0)
            o(u, l, a[c++]);
          else {
            let f = a[c + -u];
            for (let d = -u; d > 0; d--)
              o(a[c++], l, f);
            c++;
          }
        }
      }
    this.nodeSet = new Tx(n.map((a, l) => Hn.define({
      name: l >= this.minRepeatTerm ? void 0 : a,
      id: l,
      props: i[l],
      top: r.indexOf(l) > -1,
      error: l == 0,
      skipped: e.skippedNodes && e.skippedNodes.indexOf(l) > -1
    }))), e.propSources && (this.nodeSet = this.nodeSet.extend(...e.propSources)), this.strict = false, this.bufferLength = rT;
    let s = jl(e.tokenData);
    this.context = e.context, this.specializerSpecs = e.specialized || [], this.specialized = new Uint16Array(this.specializerSpecs.length);
    for (let a = 0; a < this.specializerSpecs.length; a++)
      this.specialized[a] = this.specializerSpecs[a].term;
    this.specializers = this.specializerSpecs.map(IS), this.states = jl(e.states, Uint32Array), this.data = jl(e.stateData), this.goto = jl(e.goto), this.maxTerm = e.maxTerm, this.tokenizers = e.tokenizers.map((a) => typeof a == "number" ? new ha(s, a) : a), this.topRules = e.topRules, this.dialects = e.dialects || {}, this.dynamicPrecedences = e.dynamicPrecedences || null, this.tokenPrecTable = e.tokenPrec, this.termNames = e.termNames || null, this.maxNode = this.nodeSet.types.length - 1, this.dialect = this.parseDialect(), this.top = this.topRules[Object.keys(this.topRules)[0]];
  }
  createParse(e, n, r) {
    let i = new wL(this, e, n, r);
    for (let o of this.wrappers)
      i = o(i, e, n, r);
    return i;
  }
  /**
  Get a goto table entry @internal
  */
  getGoto(e, n, r = false) {
    let i = this.goto;
    if (n >= i[0])
      return -1;
    for (let o = i[n + 1]; ; ) {
      let s = i[o++], a = s & 1, l = i[o++];
      if (a && r)
        return l;
      for (let c = o + (s >> 1); o < c; o++)
        if (i[o] == e)
          return l;
      if (a)
        return -1;
    }
  }
  /**
  Check if this state has an action for a given terminal @internal
  */
  hasAction(e, n) {
    let r = this.data;
    for (let i = 0; i < 2; i++)
      for (let o = this.stateSlot(
        e,
        i ? 2 : 1
        /* ParseState.Actions */
      ), s; ; o += 3) {
        if ((s = r[o]) == 65535)
          if (r[o + 1] == 1)
            s = r[o = Vi(r, o + 2)];
          else {
            if (r[o + 1] == 2)
              return Vi(r, o + 2);
            break;
          }
        if (s == n || s == 0)
          return Vi(r, o + 1);
      }
    return 0;
  }
  /**
  @internal
  */
  stateSlot(e, n) {
    return this.states[e * 6 + n];
  }
  /**
  @internal
  */
  stateFlag(e, n) {
    return (this.stateSlot(
      e,
      0
      /* ParseState.Flags */
    ) & n) > 0;
  }
  /**
  @internal
  */
  validAction(e, n) {
    return !!this.allActions(e, (r) => r == n ? true : null);
  }
  /**
  @internal
  */
  allActions(e, n) {
    let r = this.stateSlot(
      e,
      4
      /* ParseState.DefaultReduce */
    ), i = r ? n(r) : void 0;
    for (let o = this.stateSlot(
      e,
      1
      /* ParseState.Actions */
    ); i == null; o += 3) {
      if (this.data[o] == 65535)
        if (this.data[o + 1] == 1)
          o = Vi(this.data, o + 2);
        else
          break;
      i = n(Vi(this.data, o + 1));
    }
    return i;
  }
  /**
  Get the states that can follow this one through shift actions or
  goto jumps. @internal
  */
  nextStates(e) {
    let n = [];
    for (let r = this.stateSlot(
      e,
      1
      /* ParseState.Actions */
    ); ; r += 3) {
      if (this.data[r] == 65535)
        if (this.data[r + 1] == 1)
          r = Vi(this.data, r + 2);
        else
          break;
      if (!(this.data[r + 2] & 1)) {
        let i = this.data[r + 1];
        n.some((o, s) => s & 1 && o == i) || n.push(this.data[r], i);
      }
    }
    return n;
  }
  /**
  Configure the parser. Returns a new parser instance that has the
  given settings modified. Settings not provided in `config` are
  kept from the original parser.
  */
  configure(e) {
    let n = Object.assign(Object.create(Bo.prototype), this);
    if (e.props && (n.nodeSet = this.nodeSet.extend(...e.props)), e.top) {
      let r = this.topRules[e.top];
      if (!r)
        throw new RangeError(`Invalid top rule name ${e.top}`);
      n.top = r;
    }
    return e.tokenizers && (n.tokenizers = this.tokenizers.map((r) => {
      let i = e.tokenizers.find((o) => o.from == r);
      return i ? i.to : r;
    })), e.specializers && (n.specializers = this.specializers.slice(), n.specializerSpecs = this.specializerSpecs.map((r, i) => {
      let o = e.specializers.find((a) => a.from == r.external);
      if (!o)
        return r;
      let s = Object.assign(Object.assign({}, r), { external: o.to });
      return n.specializers[i] = IS(s), s;
    })), e.contextTracker && (n.context = e.contextTracker), e.dialect && (n.dialect = this.parseDialect(e.dialect)), e.strict != null && (n.strict = e.strict), e.wrap && (n.wrappers = n.wrappers.concat(e.wrap)), e.bufferLength != null && (n.bufferLength = e.bufferLength), n;
  }
  /**
  Tells you whether any [parse wrappers](#lr.ParserConfig.wrap)
  are registered for this parser.
  */
  hasWrappers() {
    return this.wrappers.length > 0;
  }
  /**
  Returns the name associated with a given term. This will only
  work for all terms when the parser was generated with the
  `--names` option. By default, only the names of tagged terms are
  stored.
  */
  getName(e) {
    return this.termNames ? this.termNames[e] : String(e <= this.maxNode && this.nodeSet.types[e].name || e);
  }
  /**
  The eof term id is always allocated directly after the node
  types. @internal
  */
  get eofTerm() {
    return this.maxNode + 1;
  }
  /**
  The type of top node produced by the parser.
  */
  get topNode() {
    return this.nodeSet.types[this.top[1]];
  }
  /**
  @internal
  */
  dynamicPrecedence(e) {
    let n = this.dynamicPrecedences;
    return n == null ? 0 : n[e] || 0;
  }
  /**
  @internal
  */
  parseDialect(e) {
    let n = Object.keys(this.dialects), r = n.map(() => false);
    if (e)
      for (let o of e.split(" ")) {
        let s = n.indexOf(o);
        s >= 0 && (r[s] = true);
      }
    let i = null;
    for (let o = 0; o < n.length; o++)
      if (!r[o])
        for (let s = this.dialects[n[o]], a; (a = this.data[s++]) != 65535; )
          (i || (i = new Uint8Array(this.maxTerm + 1)))[a] = 1;
    return new CL(e, r, i);
  }
  /**
  Used by the output of the parser generator. Not available to
  user code. @hide
  */
  static deserialize(e) {
    return new Bo(e);
  }
};
function Vi(t4, e) {
  return t4[e] | t4[e + 1] << 16;
}
function kL(t4) {
  let e = null;
  for (let n of t4) {
    let r = n.p.stoppedAt;
    (n.pos == n.p.stream.end || r != null && n.pos > r) && n.p.parser.stateFlag(
      n.state,
      2
      /* StateFlag.Accepting */
    ) && (!e || e.score < n.score) && (e = n);
  }
  return e;
}
function IS(t4) {
  if (t4.external) {
    let e = t4.extend ? 1 : 0;
    return (n, r) => t4.external(n, r) << 1 | e;
  }
  return t4.get;
}
var AL = Ua({
  String: P.string,
  Number: P.number,
  "True False": P.bool,
  PropertyName: P.propertyName,
  Null: P.null,
  ",": P.separator,
  "[ ]": P.squareBracket,
  "{ }": P.brace
});
var PL = Bo.deserialize({
  version: 14,
  states: "$bOVQPOOOOQO'#Cb'#CbOnQPO'#CeOvQPO'#CjOOQO'#Cp'#CpQOQPOOOOQO'#Cg'#CgO}QPO'#CfO!SQPO'#CrOOQO,59P,59PO![QPO,59PO!aQPO'#CuOOQO,59U,59UO!iQPO,59UOVQPO,59QOqQPO'#CkO!nQPO,59^OOQO1G.k1G.kOVQPO'#ClO!vQPO,59aOOQO1G.p1G.pOOQO1G.l1G.lOOQO,59V,59VOOQO-E6i-E6iOOQO,59W,59WOOQO-E6j-E6j",
  stateData: "#O~OcOS~OQSORSOSSOTSOWQO]ROePO~OVXOeUO~O[[O~PVOg^O~Oh_OVfX~OVaO~OhbO[iX~O[dO~Oh_OVfa~OhbO[ia~O",
  goto: "!kjPPPPPPkPPkqwPPk{!RPPP!XP!ePP!hXSOR^bQWQRf_TVQ_Q`WRg`QcZRicQTOQZRQe^RhbRYQR]R",
  nodeNames: "\u26A0 JsonText True False Null Number String } { Object Property PropertyName ] [ Array",
  maxTerm: 25,
  nodeProps: [
    ["openedBy", 7, "{", 12, "["],
    ["closedBy", 8, "}", 13, "]"]
  ],
  propSources: [AL],
  skippedNodes: [0],
  repeatNodeCount: 2,
  tokenData: "(|~RaXY!WYZ!W]^!Wpq!Wrs!]|}$u}!O$z!Q!R%T!R![&c![!]&t!}#O&y#P#Q'O#Y#Z'T#b#c'r#h#i(Z#o#p(r#q#r(w~!]Oc~~!`Wpq!]qr!]rs!xs#O!]#O#P!}#P;'S!];'S;=`$o<%lO!]~!}Oe~~#QXrs!]!P!Q!]#O#P!]#U#V!]#Y#Z!]#b#c!]#f#g!]#h#i!]#i#j#m~#pR!Q![#y!c!i#y#T#Z#y~#|R!Q![$V!c!i$V#T#Z$V~$YR!Q![$c!c!i$c#T#Z$c~$fR!Q![!]!c!i!]#T#Z!]~$rP;=`<%l!]~$zOh~~$}Q!Q!R%T!R![&c~%YRT~!O!P%c!g!h%w#X#Y%w~%fP!Q![%i~%nRT~!Q![%i!g!h%w#X#Y%w~%zR{|&T}!O&T!Q![&Z~&WP!Q![&Z~&`PT~!Q![&Z~&hST~!O!P%c!Q![&c!g!h%w#X#Y%w~&yOg~~'OO]~~'TO[~~'WP#T#U'Z~'^P#`#a'a~'dP#g#h'g~'jP#X#Y'm~'rOR~~'uP#i#j'x~'{P#`#a(O~(RP#`#a(U~(ZOS~~(^P#f#g(a~(dP#i#j(g~(jP#X#Y(m~(rOQ~~(wOW~~(|OV~",
  tokenizers: [0],
  topRules: { JsonText: [0, 1] },
  tokenPrec: 0
});
var _I = /* @__PURE__ */ Do.define({
  name: "json",
  parser: /* @__PURE__ */ PL.configure({
    props: [
      /* @__PURE__ */ Ha.add({
        Object: /* @__PURE__ */ ua({ except: /^\s*\}/ }),
        Array: /* @__PURE__ */ ua({ except: /^\s*\]/ })
      }),
      /* @__PURE__ */ Ja.add({
        "Object Array": Bx
      })
    ]
  }),
  languageData: {
    closeBrackets: { brackets: ["[", "{", '"'] },
    indentOnInput: /^\s*[\}\]]$/
  }
});
function EL() {
  return new Bc(_I);
}
var TL = 54;
var IL = 1;
var $L = 55;
var jL = 2;
var RL = 56;
var DL = 3;
var $S = 4;
var QL = 5;
var Ad = 6;
var MI = 7;
var NI = 8;
var FI = 9;
var ZI = 10;
var BL = 11;
var _L = 12;
var ML = 13;
var Hp = 57;
var NL = 14;
var jS = 58;
var WI = 20;
var FL = 22;
var VI = 23;
var ZL = 24;
var Zm = 26;
var zI = 27;
var WL = 28;
var VL = 31;
var zL = 34;
var LL = 36;
var XL = 37;
var GL = 0;
var YL = 1;
var qL = {
  area: true,
  base: true,
  br: true,
  col: true,
  command: true,
  embed: true,
  frame: true,
  hr: true,
  img: true,
  input: true,
  keygen: true,
  link: true,
  meta: true,
  param: true,
  source: true,
  track: true,
  wbr: true,
  menuitem: true
};
var UL = {
  dd: true,
  li: true,
  optgroup: true,
  option: true,
  p: true,
  rp: true,
  rt: true,
  tbody: true,
  td: true,
  tfoot: true,
  th: true,
  tr: true
};
var RS = {
  dd: { dd: true, dt: true },
  dt: { dd: true, dt: true },
  li: { li: true },
  option: { option: true, optgroup: true },
  optgroup: { optgroup: true },
  p: {
    address: true,
    article: true,
    aside: true,
    blockquote: true,
    dir: true,
    div: true,
    dl: true,
    fieldset: true,
    footer: true,
    form: true,
    h1: true,
    h2: true,
    h3: true,
    h4: true,
    h5: true,
    h6: true,
    header: true,
    hgroup: true,
    hr: true,
    menu: true,
    nav: true,
    ol: true,
    p: true,
    pre: true,
    section: true,
    table: true,
    ul: true
  },
  rp: { rp: true, rt: true },
  rt: { rp: true, rt: true },
  tbody: { tbody: true, tfoot: true },
  td: { td: true, th: true },
  tfoot: { tbody: true },
  th: { td: true, th: true },
  thead: { tbody: true, tfoot: true },
  tr: { tr: true }
};
function HL(t4) {
  return t4 == 45 || t4 == 46 || t4 == 58 || t4 >= 65 && t4 <= 90 || t4 == 95 || t4 >= 97 && t4 <= 122 || t4 >= 161;
}
function LI(t4) {
  return t4 == 9 || t4 == 10 || t4 == 13 || t4 == 32;
}
var DS = null;
var QS = null;
var BS = 0;
function Wm(t4, e) {
  let n = t4.pos + e;
  if (BS == n && QS == t4)
    return DS;
  let r = t4.peek(e);
  for (; LI(r); )
    r = t4.peek(++e);
  let i = "";
  for (; HL(r); )
    i += String.fromCharCode(r), r = t4.peek(++e);
  return QS = t4, BS = n, DS = i ? i.toLowerCase() : r == JL || r == KL ? void 0 : null;
}
var XI = 60;
var Pd = 62;
var nv = 47;
var JL = 63;
var KL = 33;
var eX = 45;
function _S(t4, e) {
  this.name = t4, this.parent = e, this.hash = e ? e.hash : 0;
  for (let n = 0; n < t4.length; n++)
    this.hash += (this.hash << 4) + t4.charCodeAt(n) + (t4.charCodeAt(n) << 8);
}
var tX = [Ad, ZI, MI, NI, FI];
var nX = new tv({
  start: null,
  shift(t4, e, n, r) {
    return tX.indexOf(e) > -1 ? new _S(Wm(r, 1) || "", t4) : t4;
  },
  reduce(t4, e) {
    return e == WI && t4 ? t4.parent : t4;
  },
  reuse(t4, e, n, r) {
    let i = e.type.id;
    return i == Ad || i == LL ? new _S(Wm(r, 1) || "", t4) : t4;
  },
  hash(t4) {
    return t4 ? t4.hash : 0;
  },
  strict: false
});
var rX = new Cr((t4, e) => {
  if (t4.next != XI) {
    t4.next < 0 && e.context && t4.acceptToken(Hp);
    return;
  }
  t4.advance();
  let n = t4.next == nv;
  n && t4.advance();
  let r = Wm(t4, 0);
  if (r === void 0)
    return;
  if (!r)
    return t4.acceptToken(n ? NL : Ad);
  let i = e.context ? e.context.name : null;
  if (n) {
    if (r == i)
      return t4.acceptToken(BL);
    if (i && UL[i])
      return t4.acceptToken(Hp, -2);
    if (e.dialectEnabled(GL))
      return t4.acceptToken(_L);
    for (let o = e.context; o; o = o.parent)
      if (o.name == r)
        return;
    t4.acceptToken(ML);
  } else {
    if (r == "script")
      return t4.acceptToken(MI);
    if (r == "style")
      return t4.acceptToken(NI);
    if (r == "textarea")
      return t4.acceptToken(FI);
    if (qL.hasOwnProperty(r))
      return t4.acceptToken(ZI);
    i && RS[i] && RS[i][r] ? t4.acceptToken(Hp, -1) : t4.acceptToken(Ad);
  }
}, { contextual: true });
var iX = new Cr((t4) => {
  for (let e = 0, n = 0; ; n++) {
    if (t4.next < 0) {
      n && t4.acceptToken(jS);
      break;
    }
    if (t4.next == eX)
      e++;
    else if (t4.next == Pd && e >= 2) {
      n >= 3 && t4.acceptToken(jS, -2);
      break;
    } else
      e = 0;
    t4.advance();
  }
});
function oX(t4) {
  for (; t4; t4 = t4.parent)
    if (t4.name == "svg" || t4.name == "math")
      return true;
  return false;
}
var sX = new Cr((t4, e) => {
  if (t4.next == nv && t4.peek(1) == Pd) {
    let n = e.dialectEnabled(YL) || oX(e.context);
    t4.acceptToken(n ? QL : $S, 2);
  } else
    t4.next == Pd && t4.acceptToken($S, 1);
});
function rv(t4, e, n) {
  let r = 2 + t4.length;
  return new Cr((i) => {
    for (let o = 0, s = 0, a = 0; ; a++) {
      if (i.next < 0) {
        a && i.acceptToken(e);
        break;
      }
      if (o == 0 && i.next == XI || o == 1 && i.next == nv || o >= 2 && o < r && i.next == t4.charCodeAt(o - 2))
        o++, s++;
      else if ((o == 2 || o == r) && LI(i.next))
        s++;
      else if (o == r && i.next == Pd) {
        a > s ? i.acceptToken(e, -s) : i.acceptToken(n, -(s - 2));
        break;
      } else if ((i.next == 10 || i.next == 13) && a) {
        i.acceptToken(e, 1);
        break;
      } else
        o = s = 0;
      i.advance();
    }
  });
}
var aX = rv("script", TL, IL);
var lX = rv("style", $L, jL);
var cX = rv("textarea", RL, DL);
var uX = Ua({
  "Text RawText": P.content,
  "StartTag StartCloseTag SelfClosingEndTag EndTag": P.angleBracket,
  TagName: P.tagName,
  "MismatchedCloseTag/TagName": [P.tagName, P.invalid],
  AttributeName: P.attributeName,
  "AttributeValue UnquotedAttributeValue": P.attributeValue,
  Is: P.definitionOperator,
  "EntityReference CharacterReference": P.character,
  Comment: P.blockComment,
  ProcessingInst: P.processingInstruction,
  DoctypeDecl: P.documentMeta
});
var fX = Bo.deserialize({
  version: 14,
  states: ",xOVO!rOOO!WQ#tO'#CqO!]Q#tO'#CzO!bQ#tO'#C}O!gQ#tO'#DQO!lQ#tO'#DSO!qOaO'#CpO!|ObO'#CpO#XOdO'#CpO$eO!rO'#CpOOO`'#Cp'#CpO$lO$fO'#DTO$tQ#tO'#DVO$yQ#tO'#DWOOO`'#Dk'#DkOOO`'#DY'#DYQVO!rOOO%OQ&rO,59]O%ZQ&rO,59fO%fQ&rO,59iO%qQ&rO,59lO%|Q&rO,59nOOOa'#D^'#D^O&XOaO'#CxO&dOaO,59[OOOb'#D_'#D_O&lObO'#C{O&wObO,59[OOOd'#D`'#D`O'POdO'#DOO'[OdO,59[OOO`'#Da'#DaO'dO!rO,59[O'kQ#tO'#DROOO`,59[,59[OOOp'#Db'#DbO'pO$fO,59oOOO`,59o,59oO'xQ#|O,59qO'}Q#|O,59rOOO`-E7W-E7WO(SQ&rO'#CsOOQW'#DZ'#DZO(bQ&rO1G.wOOOa1G.w1G.wOOO`1G/Y1G/YO(mQ&rO1G/QOOOb1G/Q1G/QO(xQ&rO1G/TOOOd1G/T1G/TO)TQ&rO1G/WOOO`1G/W1G/WO)`Q&rO1G/YOOOa-E7[-E7[O)kQ#tO'#CyOOO`1G.v1G.vOOOb-E7]-E7]O)pQ#tO'#C|OOOd-E7^-E7^O)uQ#tO'#DPOOO`-E7_-E7_O)zQ#|O,59mOOOp-E7`-E7`OOO`1G/Z1G/ZOOO`1G/]1G/]OOO`1G/^1G/^O*PQ,UO,59_OOQW-E7X-E7XOOOa7+$c7+$cOOO`7+$t7+$tOOOb7+$l7+$lOOOd7+$o7+$oOOO`7+$r7+$rO*[Q#|O,59eO*aQ#|O,59hO*fQ#|O,59kOOO`1G/X1G/XO*kO7[O'#CvO*|OMhO'#CvOOQW1G.y1G.yOOO`1G/P1G/POOO`1G/S1G/SOOO`1G/V1G/VOOOO'#D['#D[O+_O7[O,59bOOQW,59b,59bOOOO'#D]'#D]O+pOMhO,59bOOOO-E7Y-E7YOOQW1G.|1G.|OOOO-E7Z-E7Z",
  stateData: ",]~O!^OS~OUSOVPOWQOXROYTO[]O][O^^O`^Oa^Ob^Oc^Ox^O{_O!dZO~OfaO~OfbO~OfcO~OfdO~OfeO~O!WfOPlP!ZlP~O!XiOQoP!ZoP~O!YlORrP!ZrP~OUSOVPOWQOXROYTOZqO[]O][O^^O`^Oa^Ob^Oc^Ox^O!dZO~O!ZrO~P#dO![sO!euO~OfvO~OfwO~OS|OT}OhyO~OS!POT}OhyO~OS!ROT}OhyO~OS!TOT}OhyO~OS}OT}OhyO~O!WfOPlX!ZlX~OP!WO!Z!XO~O!XiOQoX!ZoX~OQ!ZO!Z!XO~O!YlORrX!ZrX~OR!]O!Z!XO~O!Z!XO~P#dOf!_O~O![sO!e!aO~OS!bO~OS!cO~Oi!dOSgXTgXhgX~OS!fOT!gOhyO~OS!hOT!gOhyO~OS!iOT!gOhyO~OS!jOT!gOhyO~OS!gOT!gOhyO~Of!kO~Of!lO~Of!mO~OS!nO~Ok!qO!`!oO!b!pO~OS!rO~OS!sO~OS!tO~Oa!uOb!uOc!uO!`!wO!a!uO~Oa!xOb!xOc!xO!b!wO!c!xO~Oa!uOb!uOc!uO!`!{O!a!uO~Oa!xOb!xOc!xO!b!{O!c!xO~OT~bac!dx{!d~",
  goto: "%p!`PPPPPPPPPPPPPPPPPPPP!a!gP!mPP!yP!|#P#S#Y#]#`#f#i#l#r#x!aP!a!aP$O$U$l$r$x%O%U%[%bPPPPPPPP%hX^OX`pXUOX`pezabcde{!O!Q!S!UR!q!dRhUR!XhXVOX`pRkVR!XkXWOX`pRnWR!XnXXOX`pQrXR!XpXYOX`pQ`ORx`Q{aQ!ObQ!QcQ!SdQ!UeZ!e{!O!Q!S!UQ!v!oR!z!vQ!y!pR!|!yQgUR!VgQjVR!YjQmWR![mQpXR!^pQtZR!`tS_O`ToXp",
  nodeNames: "\u26A0 StartCloseTag StartCloseTag StartCloseTag EndTag SelfClosingEndTag StartTag StartTag StartTag StartTag StartTag StartCloseTag StartCloseTag StartCloseTag IncompleteCloseTag Document Text EntityReference CharacterReference InvalidEntity Element OpenTag TagName Attribute AttributeName Is AttributeValue UnquotedAttributeValue ScriptText CloseTag OpenTag StyleText CloseTag OpenTag TextareaText CloseTag OpenTag CloseTag SelfClosingTag Comment ProcessingInst MismatchedCloseTag CloseTag DoctypeDecl",
  maxTerm: 67,
  context: nX,
  nodeProps: [
    ["closedBy", -10, 1, 2, 3, 7, 8, 9, 10, 11, 12, 13, "EndTag", 6, "EndTag SelfClosingEndTag", -4, 21, 30, 33, 36, "CloseTag"],
    ["openedBy", 4, "StartTag StartCloseTag", 5, "StartTag", -4, 29, 32, 35, 37, "OpenTag"],
    ["group", -9, 14, 17, 18, 19, 20, 39, 40, 41, 42, "Entity", 16, "Entity TextContent", -3, 28, 31, 34, "TextContent Entity"],
    ["isolate", -11, 21, 29, 30, 32, 33, 35, 36, 37, 38, 41, 42, "ltr", -3, 26, 27, 39, ""]
  ],
  propSources: [uX],
  skippedNodes: [0],
  repeatNodeCount: 9,
  tokenData: "!<p!aR!YOX$qXY,QYZ,QZ[$q[]&X]^,Q^p$qpq,Qqr-_rs3_sv-_vw3}wxHYx}-_}!OH{!O!P-_!P!Q$q!Q![-_![!]Mz!]!^-_!^!_!$S!_!`!;x!`!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4U-_4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!Z$|c`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr$qrs&}sv$qvw+Pwx(tx!^$q!^!_*V!_!a&X!a#S$q#S#T&X#T;'S$q;'S;=`+z<%lO$q!R&bX`P!a`!cpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&Xq'UV`P!cpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}P'pT`POv'kw!^'k!_;'S'k;'S;=`(P<%lO'kP(SP;=`<%l'kp([S!cpOv(Vx;'S(V;'S;=`(h<%lO(Vp(kP;=`<%l(Vq(qP;=`<%l&}a({W`P!a`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t`)jT!a`Or)esv)ew;'S)e;'S;=`)y<%lO)e`)|P;=`<%l)ea*SP;=`<%l(t!Q*^V!a`!cpOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!Q*vP;=`<%l*V!R*|P;=`<%l&XW+UYkWOX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+PW+wP;=`<%l+P!Z+}P;=`<%l$q!a,]``P!a`!cp!^^OX&XXY,QYZ,QZ]&X]^,Q^p&Xpq,Qqr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!_-ljhS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q[/ebhSkWOX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+PS0rXhSqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0mS1bP;=`<%l0m[1hP;=`<%l/^!V1vchS`P!a`!cpOq&Xqr1krs&}sv1kvw0mwx(tx!P1k!P!Q&X!Q!^1k!^!_*V!_!a&X!a#s1k#s$f&X$f;'S1k;'S;=`3R<%l?Ah1k?Ah?BY&X?BY?Mn1k?MnO&X!V3UP;=`<%l1k!_3[P;=`<%l-_!Z3hV!`h`P!cpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}!_4WihSkWc!ROX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst>]tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^/^!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!Z5zbkWOX5uXZ7SZ[5u[^7S^p5uqr5urs7Sst+Ptw5uwx7Sx!]5u!]!^7w!^!a7S!a#S5u#S#T7S#T;'S5u;'S;=`8n<%lO5u!R7VVOp7Sqs7St!]7S!]!^7l!^;'S7S;'S;=`7q<%lO7S!R7qOa!R!R7tP;=`<%l7S!Z8OYkWa!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!Z8qP;=`<%l5u!_8{ihSkWOX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst/^tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^:j!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!_:sbhSkWa!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!V<QchSOp7Sqr;{rs7Sst0mtw;{wx7Sx!P;{!P!Q7S!Q!];{!]!^=]!^!a7S!a#s;{#s$f7S$f;'S;{;'S;=`>P<%l?Ah;{?Ah?BY7S?BY?Mn;{?MnO7S!V=dXhSa!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!V>SP;=`<%l;{!_>YP;=`<%l8t!_>dhhSkWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^/^!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!Z@TakWOX@OXZAYZ[@O[^AY^p@Oqr@OrsAYsw@OwxAYx!]@O!]!^Az!^!aAY!a#S@O#S#TAY#T;'S@O;'S;=`Bq<%lO@O!RA]UOpAYq!]AY!]!^Ao!^;'SAY;'S;=`At<%lOAY!RAtOb!R!RAwP;=`<%lAY!ZBRYkWb!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!ZBtP;=`<%l@O!_COhhSkWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^Dj!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!_DsbhSkWb!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!VFQbhSOpAYqrE{rsAYswE{wxAYx!PE{!P!QAY!Q!]E{!]!^GY!^!aAY!a#sE{#s$fAY$f;'SE{;'S;=`G|<%l?AhE{?Ah?BYAY?BY?MnE{?MnOAY!VGaXhSb!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!VHPP;=`<%lE{!_HVP;=`<%lBw!ZHcW!bx`P!a`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t!aIYlhS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OKQ!O!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!aK_khS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!`&X!`!aMS!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!TM_X`P!a`!cp!eQOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!aNZ!ZhSfQ`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OMz!O!PMz!P!Q$q!Q![Mz![!]Mz!]!^-_!^!_*V!_!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f$}-_$}%OMz%O%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4UMz4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Je-_$Je$JgMz$Jg$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!a!$PP;=`<%lMz!R!$ZY!a`!cpOq*Vqr!$yrs(Vsv*Vwx)ex!a*V!a!b!4t!b;'S*V;'S;=`*s<%lO*V!R!%Q]!a`!cpOr*Vrs(Vsv*Vwx)ex}*V}!O!%y!O!f*V!f!g!']!g#W*V#W#X!0`#X;'S*V;'S;=`*s<%lO*V!R!&QX!a`!cpOr*Vrs(Vsv*Vwx)ex}*V}!O!&m!O;'S*V;'S;=`*s<%lO*V!R!&vV!a`!cp!dPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!'dX!a`!cpOr*Vrs(Vsv*Vwx)ex!q*V!q!r!(P!r;'S*V;'S;=`*s<%lO*V!R!(WX!a`!cpOr*Vrs(Vsv*Vwx)ex!e*V!e!f!(s!f;'S*V;'S;=`*s<%lO*V!R!(zX!a`!cpOr*Vrs(Vsv*Vwx)ex!v*V!v!w!)g!w;'S*V;'S;=`*s<%lO*V!R!)nX!a`!cpOr*Vrs(Vsv*Vwx)ex!{*V!{!|!*Z!|;'S*V;'S;=`*s<%lO*V!R!*bX!a`!cpOr*Vrs(Vsv*Vwx)ex!r*V!r!s!*}!s;'S*V;'S;=`*s<%lO*V!R!+UX!a`!cpOr*Vrs(Vsv*Vwx)ex!g*V!g!h!+q!h;'S*V;'S;=`*s<%lO*V!R!+xY!a`!cpOr!+qrs!,hsv!+qvw!-Swx!.[x!`!+q!`!a!/j!a;'S!+q;'S;=`!0Y<%lO!+qq!,mV!cpOv!,hvx!-Sx!`!,h!`!a!-q!a;'S!,h;'S;=`!.U<%lO!,hP!-VTO!`!-S!`!a!-f!a;'S!-S;'S;=`!-k<%lO!-SP!-kO{PP!-nP;=`<%l!-Sq!-xS!cp{POv(Vx;'S(V;'S;=`(h<%lO(Vq!.XP;=`<%l!,ha!.aX!a`Or!.[rs!-Ssv!.[vw!-Sw!`!.[!`!a!.|!a;'S!.[;'S;=`!/d<%lO!.[a!/TT!a`{POr)esv)ew;'S)e;'S;=`)y<%lO)ea!/gP;=`<%l!.[!R!/sV!a`!cp{POr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!0]P;=`<%l!+q!R!0gX!a`!cpOr*Vrs(Vsv*Vwx)ex#c*V#c#d!1S#d;'S*V;'S;=`*s<%lO*V!R!1ZX!a`!cpOr*Vrs(Vsv*Vwx)ex#V*V#V#W!1v#W;'S*V;'S;=`*s<%lO*V!R!1}X!a`!cpOr*Vrs(Vsv*Vwx)ex#h*V#h#i!2j#i;'S*V;'S;=`*s<%lO*V!R!2qX!a`!cpOr*Vrs(Vsv*Vwx)ex#m*V#m#n!3^#n;'S*V;'S;=`*s<%lO*V!R!3eX!a`!cpOr*Vrs(Vsv*Vwx)ex#d*V#d#e!4Q#e;'S*V;'S;=`*s<%lO*V!R!4XX!a`!cpOr*Vrs(Vsv*Vwx)ex#X*V#X#Y!+q#Y;'S*V;'S;=`*s<%lO*V!R!4{Y!a`!cpOr!4trs!5ksv!4tvw!6Vwx!8]x!a!4t!a!b!:]!b;'S!4t;'S;=`!;r<%lO!4tq!5pV!cpOv!5kvx!6Vx!a!5k!a!b!7W!b;'S!5k;'S;=`!8V<%lO!5kP!6YTO!a!6V!a!b!6i!b;'S!6V;'S;=`!7Q<%lO!6VP!6lTO!`!6V!`!a!6{!a;'S!6V;'S;=`!7Q<%lO!6VP!7QOxPP!7TP;=`<%l!6Vq!7]V!cpOv!5kvx!6Vx!`!5k!`!a!7r!a;'S!5k;'S;=`!8V<%lO!5kq!7yS!cpxPOv(Vx;'S(V;'S;=`(h<%lO(Vq!8YP;=`<%l!5ka!8bX!a`Or!8]rs!6Vsv!8]vw!6Vw!a!8]!a!b!8}!b;'S!8];'S;=`!:V<%lO!8]a!9SX!a`Or!8]rs!6Vsv!8]vw!6Vw!`!8]!`!a!9o!a;'S!8];'S;=`!:V<%lO!8]a!9vT!a`xPOr)esv)ew;'S)e;'S;=`)y<%lO)ea!:YP;=`<%l!8]!R!:dY!a`!cpOr!4trs!5ksv!4tvw!6Vwx!8]x!`!4t!`!a!;S!a;'S!4t;'S;=`!;r<%lO!4t!R!;]V!a`!cpxPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!;uP;=`<%l!4t!V!<TXiS`P!a`!cpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X",
  tokenizers: [aX, lX, cX, sX, rX, iX, 0, 1, 2, 3, 4, 5],
  topRules: { Document: [0, 15] },
  dialects: { noMatch: 0, selfClosing: 509 },
  tokenPrec: 511
});
function GI(t4, e) {
  let n = /* @__PURE__ */ Object.create(null);
  for (let r of t4.getChildren(VI)) {
    let i = r.getChild(ZL), o = r.getChild(Zm) || r.getChild(zI);
    i && (n[e.read(i.from, i.to)] = o ? o.type.id == Zm ? e.read(o.from + 1, o.to - 1) : e.read(o.from, o.to) : "");
  }
  return n;
}
function MS(t4, e) {
  let n = t4.getChild(FL);
  return n ? e.read(n.from, n.to) : " ";
}
function Jp(t4, e, n) {
  let r;
  for (let i of n)
    if (!i.attrs || i.attrs(r || (r = GI(t4.node.parent.firstChild, e))))
      return { parser: i.parser };
  return null;
}
function YI(t4 = [], e = []) {
  let n = [], r = [], i = [], o = [];
  for (let a of t4)
    (a.tag == "script" ? n : a.tag == "style" ? r : a.tag == "textarea" ? i : o).push(a);
  let s = e.length ? /* @__PURE__ */ Object.create(null) : null;
  for (let a of e)
    (s[a.name] || (s[a.name] = [])).push(a);
  return K6((a, l) => {
    let c = a.type.id;
    if (c == WL)
      return Jp(a, l, n);
    if (c == VL)
      return Jp(a, l, r);
    if (c == zL)
      return Jp(a, l, i);
    if (c == WI && o.length) {
      let u = a.node, f = u.firstChild, d = f && MS(f, l), h;
      if (d) {
        for (let p of o)
          if (p.tag == d && (!p.attrs || p.attrs(h || (h = GI(u, l))))) {
            let O = u.lastChild, m = O.type.id == XL ? O.from : u.to;
            if (m > f.to)
              return { parser: p.parser, overlay: [{ from: f.to, to: m }] };
          }
      }
    }
    if (s && c == VI) {
      let u = a.node, f;
      if (f = u.firstChild) {
        let d = s[l.read(f.from, f.to)];
        if (d)
          for (let h of d) {
            if (h.tagName && h.tagName != MS(u.parent, l))
              continue;
            let p = u.lastChild;
            if (p.type.id == Zm) {
              let O = p.from + 1, m = p.lastChild, x = p.to - (m && m.isError ? 0 : 1);
              if (x > O)
                return { parser: h.parser, overlay: [{ from: O, to: x }] };
            } else if (p.type.id == zI)
              return { parser: h.parser, overlay: [{ from: p.from, to: p.to }] };
          }
      }
    }
    return null;
  });
}
var dX = 99;
var NS = 1;
var hX = 100;
var pX = 101;
var FS = 2;
var qI = [
  9,
  10,
  11,
  12,
  13,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
];
var gX = 58;
var mX = 40;
var UI = 95;
var OX = 91;
var vf = 45;
var xX = 46;
var vX = 35;
var yX = 37;
var bX = 38;
var SX = 92;
var wX = 10;
function gc(t4) {
  return t4 >= 65 && t4 <= 90 || t4 >= 97 && t4 <= 122 || t4 >= 161;
}
function HI(t4) {
  return t4 >= 48 && t4 <= 57;
}
var CX = new Cr((t4, e) => {
  for (let n = false, r = 0, i = 0; ; i++) {
    let { next: o } = t4;
    if (gc(o) || o == vf || o == UI || n && HI(o))
      !n && (o != vf || i > 0) && (n = true), r === i && o == vf && r++, t4.advance();
    else if (o == SX && t4.peek(1) != wX)
      t4.advance(), t4.next > -1 && t4.advance(), n = true;
    else {
      n && t4.acceptToken(o == mX ? hX : r == 2 && e.canShift(FS) ? FS : pX);
      break;
    }
  }
});
var kX = new Cr((t4) => {
  if (qI.includes(t4.peek(-1))) {
    let { next: e } = t4;
    (gc(e) || e == UI || e == vX || e == xX || e == OX || e == gX && gc(t4.peek(1)) || e == vf || e == bX) && t4.acceptToken(dX);
  }
});
var AX = new Cr((t4) => {
  if (!qI.includes(t4.peek(-1))) {
    let { next: e } = t4;
    if (e == yX && (t4.advance(), t4.acceptToken(NS)), gc(e)) {
      do
        t4.advance();
      while (gc(t4.next) || HI(t4.next));
      t4.acceptToken(NS);
    }
  }
});
var PX = Ua({
  "AtKeyword import charset namespace keyframes media supports": P.definitionKeyword,
  "from to selector": P.keyword,
  NamespaceName: P.namespace,
  KeyframeName: P.labelName,
  KeyframeRangeName: P.operatorKeyword,
  TagName: P.tagName,
  ClassName: P.className,
  PseudoClassName: P.constant(P.className),
  IdName: P.labelName,
  "FeatureName PropertyName": P.propertyName,
  AttributeName: P.attributeName,
  NumberLiteral: P.number,
  KeywordQuery: P.keyword,
  UnaryQueryOp: P.operatorKeyword,
  "CallTag ValueName": P.atom,
  VariableName: P.variableName,
  Callee: P.operatorKeyword,
  Unit: P.unit,
  "UniversalSelector NestingSelector": P.definitionOperator,
  MatchOp: P.compareOperator,
  "ChildOp SiblingOp, LogicOp": P.logicOperator,
  BinOp: P.arithmeticOperator,
  Important: P.modifier,
  Comment: P.blockComment,
  ColorLiteral: P.color,
  "ParenthesizedContent StringLiteral": P.string,
  ":": P.punctuation,
  "PseudoOp #": P.derefOperator,
  "; ,": P.separator,
  "( )": P.paren,
  "[ ]": P.squareBracket,
  "{ }": P.brace
});
var EX = { __proto__: null, lang: 32, "nth-child": 32, "nth-last-child": 32, "nth-of-type": 32, "nth-last-of-type": 32, dir: 32, "host-context": 32, url: 60, "url-prefix": 60, domain: 60, regexp: 60, selector: 138 };
var TX = { __proto__: null, "@import": 118, "@media": 142, "@charset": 146, "@namespace": 150, "@keyframes": 156, "@supports": 168 };
var IX = { __proto__: null, not: 132, only: 132 };
var $X = Bo.deserialize({
  version: 14,
  states: ":^QYQ[OOO#_Q[OOP#fOWOOOOQP'#Cd'#CdOOQP'#Cc'#CcO#kQ[O'#CfO$_QXO'#CaO$fQ[O'#ChO$qQ[O'#DTO$vQ[O'#DWOOQP'#Em'#EmO${QdO'#DgO%jQ[O'#DtO${QdO'#DvO%{Q[O'#DxO&WQ[O'#D{O&`Q[O'#ERO&nQ[O'#ETOOQS'#El'#ElOOQS'#EW'#EWQYQ[OOO&uQXO'#CdO'jQWO'#DcO'oQWO'#EsO'zQ[O'#EsQOQWOOP(UO#tO'#C_POOO)C@[)C@[OOQP'#Cg'#CgOOQP,59Q,59QO#kQ[O,59QO(aQ[O'#E[O({QWO,58{O)TQ[O,59SO$qQ[O,59oO$vQ[O,59rO(aQ[O,59uO(aQ[O,59wO(aQ[O,59xO)`Q[O'#DbOOQS,58{,58{OOQP'#Ck'#CkOOQO'#DR'#DROOQP,59S,59SO)gQWO,59SO)lQWO,59SOOQP'#DV'#DVOOQP,59o,59oOOQO'#DX'#DXO)qQ`O,59rOOQS'#Cp'#CpO${QdO'#CqO)yQvO'#CsO+ZQtO,5:ROOQO'#Cx'#CxO)lQWO'#CwO+oQWO'#CyO+tQ[O'#DOOOQS'#Ep'#EpOOQO'#Dj'#DjO+|Q[O'#DqO,[QWO'#EtO&`Q[O'#DoO,jQWO'#DrOOQO'#Eu'#EuO)OQWO,5:`O,oQpO,5:bOOQS'#Dz'#DzO,wQWO,5:dO,|Q[O,5:dOOQO'#D}'#D}O-UQWO,5:gO-ZQWO,5:mO-cQWO,5:oOOQS-E8U-E8UO${QdO,59}O-kQ[O'#E^O-xQWO,5;_O-xQWO,5;_POOO'#EV'#EVP.TO#tO,58yPOOO,58y,58yOOQP1G.l1G.lO.zQXO,5:vOOQO-E8Y-E8YOOQS1G.g1G.gOOQP1G.n1G.nO)gQWO1G.nO)lQWO1G.nOOQP1G/Z1G/ZO/XQ`O1G/^O/rQXO1G/aO0YQXO1G/cO0pQXO1G/dO1WQWO,59|O1]Q[O'#DSO1dQdO'#CoOOQP1G/^1G/^O${QdO1G/^O1kQpO,59]OOQS,59_,59_O${QdO,59aO1sQWO1G/mOOQS,59c,59cO1xQ!bO,59eOOQS'#DP'#DPOOQS'#EY'#EYO2QQ[O,59jOOQS,59j,59jO2YQWO'#DjO2eQWO,5:VO2jQWO,5:]O&`Q[O,5:XO&`Q[O'#E_O2rQWO,5;`O2}QWO,5:ZO(aQ[O,5:^OOQS1G/z1G/zOOQS1G/|1G/|OOQS1G0O1G0OO3`QWO1G0OO3eQdO'#EOOOQS1G0R1G0ROOQS1G0X1G0XOOQS1G0Z1G0ZO3pQtO1G/iOOQO,5:x,5:xO4WQ[O,5:xOOQO-E8[-E8[O4eQWO1G0yPOOO-E8T-E8TPOOO1G.e1G.eOOQP7+$Y7+$YOOQP7+$x7+$xO${QdO7+$xOOQS1G/h1G/hO4pQXO'#ErO4wQWO,59nO4|QtO'#EXO5tQdO'#EoO6OQWO,59ZO6TQpO7+$xOOQS1G.w1G.wOOQS1G.{1G.{OOQS7+%X7+%XO6]QWO1G/POOQS-E8W-E8WOOQS1G/U1G/UO${QdO1G/qOOQO1G/w1G/wOOQO1G/s1G/sO6bQWO,5:yOOQO-E8]-E8]O6pQXO1G/xOOQS7+%j7+%jO6wQYO'#CsOOQO'#EQ'#EQO7SQ`O'#EPOOQO'#EP'#EPO7_QWO'#E`O7gQdO,5:jOOQS,5:j,5:jO7rQtO'#E]O${QdO'#E]O8sQdO7+%TOOQO7+%T7+%TOOQO1G0d1G0dO9WQpO<<HdO9`QWO,5;^OOQP1G/Y1G/YOOQS-E8V-E8VO${QdO'#EZO9hQWO,5;ZOOQT1G.u1G.uOOQP<<Hd<<HdOOQS7+$k7+$kO9pQdO7+%]OOQO7+%d7+%dOOQO,5:k,5:kO3hQdO'#EaO7_QWO,5:zOOQS,5:z,5:zOOQS-E8^-E8^OOQS1G0U1G0UO9wQtO,5:wOOQS-E8Z-E8ZOOQO<<Ho<<HoOOQPAN>OAN>OO:xQdO,5:uOOQO-E8X-E8XOOQO<<Hw<<HwOOQO,5:{,5:{OOQO-E8_-E8_OOQS1G0f1G0f",
  stateData: ";[~O#ZOS#[QQ~OUYOXYO]VO^VOqXOxWO![aO!]ZO!i[O!k]O!m^O!p_O!v`O#XRO#bTO~OQfOUYOXYO]VO^VOqXOxWO![aO!]ZO!i[O!k]O!m^O!p_O!v`O#XeO#bTO~O#U#gP~P!ZO#[jO~O#XlO~O]qO^qOqsOtoOxrO!OtO!RvO#VuO#bnO~O!TwO~P#pO`}O#WzO#XyO~O#X!OO~O#X!QO~OQ![Ob!TOf![Oh![On!YOq!ZO#W!WO#X!SO#e!UO~Ob!^O!d!`O!g!aO#X!]O!T#hP~Oh!fOn!YO#X!eO~Oh!hO#X!hO~Ob!^O!d!`O!g!aO#X!]O~O!Y#hP~P%jO]WX]!WX^WXqWXtWXxWX!OWX!RWX!TWX#VWX#bWX~O]!mO~O!Y!nO#U#gX!S#gX~O#U#gX!S#gX~P!ZO#]!qO#^!qO#_!sO~OUYOXYO]VO^VOqXOxWO#XRO#bTO~OtoO!TwO~O`!zO#WzO#XyO~O!S#gP~P!ZOb#RO~Ob#SO~Op#TO|#UO~OP#WObgXjgX!YgX!dgX!ggX#XgXagXQgXfgXhgXngXqgXtgX!XgX#UgX#WgX#egXpgX!SgX~Ob!^Oj#XO!d!`O!g!aO#X!]O!Y#hP~Ob#[O~Op#`O#X#]O~Ob!^O!d!`O!g!aO#X#aO~Ot#eO!b#dO!T#hX!Y#hX~Ob#hO~Oj#XO!Y#jO~O!Y#kO~Oh#lOn!YO~O!T#mO~O!TwO!b#dO~O!TwO!Y#pO~O!Y#QX#U#QX!S#QX~P!ZO!Y!nO#U#ga!S#ga~O#]!qO#^!qO#_#wO~O]qO^qOqsOxrO!OtO!RvO#VuO#bnO~Ot#Oa!T#Oaa#Oa~P.`Op#yO|#zO~O]qO^qOqsOxrO#bnO~Ot}i!O}i!R}i!T}i#V}ia}i~P/aOt!Pi!O!Pi!R!Pi!T!Pi#V!Pia!Pi~P/aOt!Qi!O!Qi!R!Qi!T!Qi#V!Qia!Qi~P/aO!S#{O~Oa#fP~P(aOa#cP~P${Oa$SOj#XO~O!Y$UO~Oh$VOo$VO~Op$XO#X#]O~O]!`Xa!^X!b!^X~O]$YO~Oa$ZO!b#dO~Ot#eO!T#ha!Y#ha~O!b#dOt!ca!T!ca!Y!caa!ca~O!Y$`O~O!S$gO#X$bO#e$aO~Oj#XOt$iO!X$kO!Y!Vi#U!Vi!S!Vi~P${O!Y#Qa#U#Qa!S#Qa~P!ZO!Y!nO#U#gi!S#gi~Oa#fX~P#pOa$oO~Oj#XOQ!{Xa!{Xb!{Xf!{Xh!{Xn!{Xq!{Xt!{X#W!{X#X!{X#e!{X~Ot$qOa#cX~P${Oa$sO~Oj#XOp$tO~Oa$uO~O!b#dOt#Ra!T#Ra!Y#Ra~Oa$wO~P.`OP#WOtgX!TgX~O#e$aOt!sX!T!sX~Ot$yO!TwO~O!S$}O#X$bO#e$aO~Oj#XOQ#PXb#PXf#PXh#PXn#PXq#PXt#PX!X#PX!Y#PX#U#PX#W#PX#X#PX#e#PX!S#PX~Ot$iO!X%QO!Y!Vq#U!Vq!S!Vq~P${Oj#XOp%RO~OtoOa#fa~Ot$qOa#ca~Oa%UO~P${Oj#XOQ#Pab#Paf#Pah#Pan#Paq#Pat#Pa!X#Pa!Y#Pa#U#Pa#W#Pa#X#Pa#e#Pa!S#Pa~Oa!}at!}a~P${O#Zo#[#ej!R#e~",
  goto: "-g#jPPP#kP#nP#w$WP#w$g#wPP$mPPP$s$|$|P%`P$|P$|%z&^PPPP$|&vP&z'Q#wP'W#w'^P#wP#w#wPPP'd'y(WPP#nPP(_(_(i(_P(_P(_(_P#nP#nP#nP(l#nP(o(r(u(|#nP#nP)R)X)h)v)|*S*^*d*n*t*zPPPPPPPPPP+Q+ZP+v+yP,o,r,x-RRkQ_bOPdhw!n#skYOPdhotuvw!n#R#h#skSOPdhotuvw!n#R#h#sQmTR!tnQ{VR!xqQ!x}Q#Z!XR#x!zq![Z]!T!m#S#U#X#q#z$P$Y$i$j$q$v%Sp![Z]!T!m#S#U#X#q#z$P$Y$i$j$q$v%SU$d#m$f$yR$x$cq!XZ]!T!m#S#U#X#q#z$P$Y$i$j$q$v%Sp![Z]!T!m#S#U#X#q#z$P$Y$i$j$q$v%SQ!f^R#l!gT#^!Z#_Q|VR!yqQ!x|R#x!yQ!PWR!{rQ!RXR!|sQxUQ!wpQ#i!cQ#o!jQ#p!kQ${$eR%X$zSgPwQ!phQ#r!nR$l#sZfPhw!n#sa!b[`a!V!^!`#d#eR#b!^R!g^R!i_R#n!iS$e#m$fR%V$yV$c#m$f$yQ!rjR#v!rQdOShPwU!ldh#sR#s!nQ$P#SU$p$P$v%SQ$v$YR%S$qQ#_!ZR$W#_Q$r$PR%T$rQpUS!vp$nR$n#|Q$j#qR%P$jQ!ogS#t!o#uR#u!pQ#f!_R$^#fQ$f#mR$|$fQ$z$eR%W$z_cOPdhw!n#s^UOPdhw!n#sQ!uoQ!}tQ#OuQ#PvQ#|#RR$_#hR$Q#SQ!VZQ!d]Q#V!TQ#q!m[$O#S$P$Y$q$v%SQ$R#UQ$T#XS$h#q$jQ$m#zR%O$iR#}#RQiPR#QwQ!c[Q!kaR#Y!VU!_[a!VQ!j`Q#c!^Q#g!`Q$[#dR$]#e",
  nodeNames: "\u26A0 Unit VariableName Comment StyleSheet RuleSet UniversalSelector TagSelector TagName NestingSelector ClassSelector ClassName PseudoClassSelector : :: PseudoClassName PseudoClassName ) ( ArgList ValueName ParenthesizedValue ColorLiteral NumberLiteral StringLiteral BinaryExpression BinOp CallExpression Callee CallLiteral CallTag ParenthesizedContent ] [ LineNames LineName , PseudoClassName ArgList IdSelector # IdName AttributeSelector AttributeName MatchOp ChildSelector ChildOp DescendantSelector SiblingSelector SiblingOp } { Block Declaration PropertyName Important ; ImportStatement AtKeyword import KeywordQuery FeatureQuery FeatureName BinaryQuery LogicOp UnaryQuery UnaryQueryOp ParenthesizedQuery SelectorQuery selector MediaStatement media CharsetStatement charset NamespaceStatement namespace NamespaceName KeyframesStatement keyframes KeyframeName KeyframeList KeyframeSelector KeyframeRangeName SupportsStatement supports AtRule Styles",
  maxTerm: 117,
  nodeProps: [
    ["isolate", -2, 3, 24, ""],
    ["openedBy", 17, "(", 32, "[", 50, "{"],
    ["closedBy", 18, ")", 33, "]", 51, "}"]
  ],
  propSources: [PX],
  skippedNodes: [0, 3, 87],
  repeatNodeCount: 11,
  tokenData: "J^~R!^OX$}X^%u^p$}pq%uqr)Xrs.Rst/utu6duv$}vw7^wx7oxy9^yz9oz{9t{|:_|}?Q}!O?c!O!P@Q!P!Q@i!Q![Ab![!]B]!]!^CX!^!_$}!_!`Cj!`!aC{!a!b$}!b!cDw!c!}$}!}#OFa#O#P$}#P#QFr#Q#R6d#R#T$}#T#UGT#U#c$}#c#dHf#d#o$}#o#pH{#p#q6d#q#rI^#r#sIo#s#y$}#y#z%u#z$f$}$f$g%u$g#BY$}#BY#BZ%u#BZ$IS$}$IS$I_%u$I_$I|$}$I|$JO%u$JO$JT$}$JT$JU%u$JU$KV$}$KV$KW%u$KW&FU$}&FU&FV%u&FV;'S$};'S;=`JW<%lO$}`%QSOy%^z;'S%^;'S;=`%o<%lO%^`%cSo`Oy%^z;'S%^;'S;=`%o<%lO%^`%rP;=`<%l%^~%zh#Z~OX%^X^'f^p%^pq'fqy%^z#y%^#y#z'f#z$f%^$f$g'f$g#BY%^#BY#BZ'f#BZ$IS%^$IS$I_'f$I_$I|%^$I|$JO'f$JO$JT%^$JT$JU'f$JU$KV%^$KV$KW'f$KW&FU%^&FU&FV'f&FV;'S%^;'S;=`%o<%lO%^~'mh#Z~o`OX%^X^'f^p%^pq'fqy%^z#y%^#y#z'f#z$f%^$f$g'f$g#BY%^#BY#BZ'f#BZ$IS%^$IS$I_'f$I_$I|%^$I|$JO'f$JO$JT%^$JT$JU'f$JU$KV%^$KV$KW'f$KW&FU%^&FU&FV'f&FV;'S%^;'S;=`%o<%lO%^l)[UOy%^z#]%^#]#^)n#^;'S%^;'S;=`%o<%lO%^l)sUo`Oy%^z#a%^#a#b*V#b;'S%^;'S;=`%o<%lO%^l*[Uo`Oy%^z#d%^#d#e*n#e;'S%^;'S;=`%o<%lO%^l*sUo`Oy%^z#c%^#c#d+V#d;'S%^;'S;=`%o<%lO%^l+[Uo`Oy%^z#f%^#f#g+n#g;'S%^;'S;=`%o<%lO%^l+sUo`Oy%^z#h%^#h#i,V#i;'S%^;'S;=`%o<%lO%^l,[Uo`Oy%^z#T%^#T#U,n#U;'S%^;'S;=`%o<%lO%^l,sUo`Oy%^z#b%^#b#c-V#c;'S%^;'S;=`%o<%lO%^l-[Uo`Oy%^z#h%^#h#i-n#i;'S%^;'S;=`%o<%lO%^l-uS!X[o`Oy%^z;'S%^;'S;=`%o<%lO%^~.UWOY.RZr.Rrs.ns#O.R#O#P.s#P;'S.R;'S;=`/o<%lO.R~.sOh~~.vRO;'S.R;'S;=`/P;=`O.R~/SXOY.RZr.Rrs.ns#O.R#O#P.s#P;'S.R;'S;=`/o;=`<%l.R<%lO.R~/rP;=`<%l.Rn/zYxQOy%^z!Q%^!Q![0j![!c%^!c!i0j!i#T%^#T#Z0j#Z;'S%^;'S;=`%o<%lO%^l0oYo`Oy%^z!Q%^!Q![1_![!c%^!c!i1_!i#T%^#T#Z1_#Z;'S%^;'S;=`%o<%lO%^l1dYo`Oy%^z!Q%^!Q![2S![!c%^!c!i2S!i#T%^#T#Z2S#Z;'S%^;'S;=`%o<%lO%^l2ZYf[o`Oy%^z!Q%^!Q![2y![!c%^!c!i2y!i#T%^#T#Z2y#Z;'S%^;'S;=`%o<%lO%^l3QYf[o`Oy%^z!Q%^!Q![3p![!c%^!c!i3p!i#T%^#T#Z3p#Z;'S%^;'S;=`%o<%lO%^l3uYo`Oy%^z!Q%^!Q![4e![!c%^!c!i4e!i#T%^#T#Z4e#Z;'S%^;'S;=`%o<%lO%^l4lYf[o`Oy%^z!Q%^!Q![5[![!c%^!c!i5[!i#T%^#T#Z5[#Z;'S%^;'S;=`%o<%lO%^l5aYo`Oy%^z!Q%^!Q![6P![!c%^!c!i6P!i#T%^#T#Z6P#Z;'S%^;'S;=`%o<%lO%^l6WSf[o`Oy%^z;'S%^;'S;=`%o<%lO%^d6gUOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^d7QS|So`Oy%^z;'S%^;'S;=`%o<%lO%^b7cSXQOy%^z;'S%^;'S;=`%o<%lO%^~7rWOY7oZw7owx.nx#O7o#O#P8[#P;'S7o;'S;=`9W<%lO7o~8_RO;'S7o;'S;=`8h;=`O7o~8kXOY7oZw7owx.nx#O7o#O#P8[#P;'S7o;'S;=`9W;=`<%l7o<%lO7o~9ZP;=`<%l7on9cSb^Oy%^z;'S%^;'S;=`%o<%lO%^~9tOa~n9{UUQjWOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^n:fWjW!RQOy%^z!O%^!O!P;O!P!Q%^!Q![>T![;'S%^;'S;=`%o<%lO%^l;TUo`Oy%^z!Q%^!Q![;g![;'S%^;'S;=`%o<%lO%^l;nYo`#e[Oy%^z!Q%^!Q![;g![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^l<cYo`Oy%^z{%^{|=R|}%^}!O=R!O!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l=WUo`Oy%^z!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l=qUo`#e[Oy%^z!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l>[[o`#e[Oy%^z!O%^!O!P;g!P!Q%^!Q![>T![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^n?VSt^Oy%^z;'S%^;'S;=`%o<%lO%^l?hWjWOy%^z!O%^!O!P;O!P!Q%^!Q![>T![;'S%^;'S;=`%o<%lO%^n@VU#bQOy%^z!Q%^!Q![;g![;'S%^;'S;=`%o<%lO%^~@nTjWOy%^z{@}{;'S%^;'S;=`%o<%lO%^~AUSo`#[~Oy%^z;'S%^;'S;=`%o<%lO%^lAg[#e[Oy%^z!O%^!O!P;g!P!Q%^!Q![>T![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^bBbU]QOy%^z![%^![!]Bt!];'S%^;'S;=`%o<%lO%^bB{S^Qo`Oy%^z;'S%^;'S;=`%o<%lO%^nC^S!Y^Oy%^z;'S%^;'S;=`%o<%lO%^dCoS|SOy%^z;'S%^;'S;=`%o<%lO%^bDQU!OQOy%^z!`%^!`!aDd!a;'S%^;'S;=`%o<%lO%^bDkS!OQo`Oy%^z;'S%^;'S;=`%o<%lO%^bDzWOy%^z!c%^!c!}Ed!}#T%^#T#oEd#o;'S%^;'S;=`%o<%lO%^bEk[![Qo`Oy%^z}%^}!OEd!O!Q%^!Q![Ed![!c%^!c!}Ed!}#T%^#T#oEd#o;'S%^;'S;=`%o<%lO%^nFfSq^Oy%^z;'S%^;'S;=`%o<%lO%^nFwSp^Oy%^z;'S%^;'S;=`%o<%lO%^bGWUOy%^z#b%^#b#cGj#c;'S%^;'S;=`%o<%lO%^bGoUo`Oy%^z#W%^#W#XHR#X;'S%^;'S;=`%o<%lO%^bHYS!bQo`Oy%^z;'S%^;'S;=`%o<%lO%^bHiUOy%^z#f%^#f#gHR#g;'S%^;'S;=`%o<%lO%^fIQS!TUOy%^z;'S%^;'S;=`%o<%lO%^nIcS!S^Oy%^z;'S%^;'S;=`%o<%lO%^fItU!RQOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^`JZP;=`<%l$}",
  tokenizers: [kX, AX, CX, 1, 2, 3, 4, new kd("m~RRYZ[z{a~~g~aO#^~~dP!P!Qg~lO#_~~", 28, 105)],
  topRules: { StyleSheet: [0, 4], Styles: [1, 86] },
  specialized: [{ term: 100, get: (t4) => EX[t4] || -1 }, { term: 58, get: (t4) => TX[t4] || -1 }, { term: 101, get: (t4) => IX[t4] || -1 }],
  tokenPrec: 1200
});
var Kp = null;
function e0() {
  if (!Kp && typeof document == "object" && document.body) {
    let { style: t4 } = document.body, e = [], n = /* @__PURE__ */ new Set();
    for (let r in t4)
      r != "cssText" && r != "cssFloat" && typeof t4[r] == "string" && (/[A-Z]/.test(r) && (r = r.replace(/[A-Z]/g, (i) => "-" + i.toLowerCase())), n.has(r) || (e.push(r), n.add(r)));
    Kp = e.sort().map((r) => ({ type: "property", label: r }));
  }
  return Kp || [];
}
var ZS = /* @__PURE__ */ [
  "active",
  "after",
  "any-link",
  "autofill",
  "backdrop",
  "before",
  "checked",
  "cue",
  "default",
  "defined",
  "disabled",
  "empty",
  "enabled",
  "file-selector-button",
  "first",
  "first-child",
  "first-letter",
  "first-line",
  "first-of-type",
  "focus",
  "focus-visible",
  "focus-within",
  "fullscreen",
  "has",
  "host",
  "host-context",
  "hover",
  "in-range",
  "indeterminate",
  "invalid",
  "is",
  "lang",
  "last-child",
  "last-of-type",
  "left",
  "link",
  "marker",
  "modal",
  "not",
  "nth-child",
  "nth-last-child",
  "nth-last-of-type",
  "nth-of-type",
  "only-child",
  "only-of-type",
  "optional",
  "out-of-range",
  "part",
  "placeholder",
  "placeholder-shown",
  "read-only",
  "read-write",
  "required",
  "right",
  "root",
  "scope",
  "selection",
  "slotted",
  "target",
  "target-text",
  "valid",
  "visited",
  "where"
].map((t4) => ({ type: "class", label: t4 }));
var WS = /* @__PURE__ */ [
  "above",
  "absolute",
  "activeborder",
  "additive",
  "activecaption",
  "after-white-space",
  "ahead",
  "alias",
  "all",
  "all-scroll",
  "alphabetic",
  "alternate",
  "always",
  "antialiased",
  "appworkspace",
  "asterisks",
  "attr",
  "auto",
  "auto-flow",
  "avoid",
  "avoid-column",
  "avoid-page",
  "avoid-region",
  "axis-pan",
  "background",
  "backwards",
  "baseline",
  "below",
  "bidi-override",
  "blink",
  "block",
  "block-axis",
  "bold",
  "bolder",
  "border",
  "border-box",
  "both",
  "bottom",
  "break",
  "break-all",
  "break-word",
  "bullets",
  "button",
  "button-bevel",
  "buttonface",
  "buttonhighlight",
  "buttonshadow",
  "buttontext",
  "calc",
  "capitalize",
  "caps-lock-indicator",
  "caption",
  "captiontext",
  "caret",
  "cell",
  "center",
  "checkbox",
  "circle",
  "cjk-decimal",
  "clear",
  "clip",
  "close-quote",
  "col-resize",
  "collapse",
  "color",
  "color-burn",
  "color-dodge",
  "column",
  "column-reverse",
  "compact",
  "condensed",
  "contain",
  "content",
  "contents",
  "content-box",
  "context-menu",
  "continuous",
  "copy",
  "counter",
  "counters",
  "cover",
  "crop",
  "cross",
  "crosshair",
  "currentcolor",
  "cursive",
  "cyclic",
  "darken",
  "dashed",
  "decimal",
  "decimal-leading-zero",
  "default",
  "default-button",
  "dense",
  "destination-atop",
  "destination-in",
  "destination-out",
  "destination-over",
  "difference",
  "disc",
  "discard",
  "disclosure-closed",
  "disclosure-open",
  "document",
  "dot-dash",
  "dot-dot-dash",
  "dotted",
  "double",
  "down",
  "e-resize",
  "ease",
  "ease-in",
  "ease-in-out",
  "ease-out",
  "element",
  "ellipse",
  "ellipsis",
  "embed",
  "end",
  "ethiopic-abegede-gez",
  "ethiopic-halehame-aa-er",
  "ethiopic-halehame-gez",
  "ew-resize",
  "exclusion",
  "expanded",
  "extends",
  "extra-condensed",
  "extra-expanded",
  "fantasy",
  "fast",
  "fill",
  "fill-box",
  "fixed",
  "flat",
  "flex",
  "flex-end",
  "flex-start",
  "footnotes",
  "forwards",
  "from",
  "geometricPrecision",
  "graytext",
  "grid",
  "groove",
  "hand",
  "hard-light",
  "help",
  "hidden",
  "hide",
  "higher",
  "highlight",
  "highlighttext",
  "horizontal",
  "hsl",
  "hsla",
  "hue",
  "icon",
  "ignore",
  "inactiveborder",
  "inactivecaption",
  "inactivecaptiontext",
  "infinite",
  "infobackground",
  "infotext",
  "inherit",
  "initial",
  "inline",
  "inline-axis",
  "inline-block",
  "inline-flex",
  "inline-grid",
  "inline-table",
  "inset",
  "inside",
  "intrinsic",
  "invert",
  "italic",
  "justify",
  "keep-all",
  "landscape",
  "large",
  "larger",
  "left",
  "level",
  "lighter",
  "lighten",
  "line-through",
  "linear",
  "linear-gradient",
  "lines",
  "list-item",
  "listbox",
  "listitem",
  "local",
  "logical",
  "loud",
  "lower",
  "lower-hexadecimal",
  "lower-latin",
  "lower-norwegian",
  "lowercase",
  "ltr",
  "luminosity",
  "manipulation",
  "match",
  "matrix",
  "matrix3d",
  "medium",
  "menu",
  "menutext",
  "message-box",
  "middle",
  "min-intrinsic",
  "mix",
  "monospace",
  "move",
  "multiple",
  "multiple_mask_images",
  "multiply",
  "n-resize",
  "narrower",
  "ne-resize",
  "nesw-resize",
  "no-close-quote",
  "no-drop",
  "no-open-quote",
  "no-repeat",
  "none",
  "normal",
  "not-allowed",
  "nowrap",
  "ns-resize",
  "numbers",
  "numeric",
  "nw-resize",
  "nwse-resize",
  "oblique",
  "opacity",
  "open-quote",
  "optimizeLegibility",
  "optimizeSpeed",
  "outset",
  "outside",
  "outside-shape",
  "overlay",
  "overline",
  "padding",
  "padding-box",
  "painted",
  "page",
  "paused",
  "perspective",
  "pinch-zoom",
  "plus-darker",
  "plus-lighter",
  "pointer",
  "polygon",
  "portrait",
  "pre",
  "pre-line",
  "pre-wrap",
  "preserve-3d",
  "progress",
  "push-button",
  "radial-gradient",
  "radio",
  "read-only",
  "read-write",
  "read-write-plaintext-only",
  "rectangle",
  "region",
  "relative",
  "repeat",
  "repeating-linear-gradient",
  "repeating-radial-gradient",
  "repeat-x",
  "repeat-y",
  "reset",
  "reverse",
  "rgb",
  "rgba",
  "ridge",
  "right",
  "rotate",
  "rotate3d",
  "rotateX",
  "rotateY",
  "rotateZ",
  "round",
  "row",
  "row-resize",
  "row-reverse",
  "rtl",
  "run-in",
  "running",
  "s-resize",
  "sans-serif",
  "saturation",
  "scale",
  "scale3d",
  "scaleX",
  "scaleY",
  "scaleZ",
  "screen",
  "scroll",
  "scrollbar",
  "scroll-position",
  "se-resize",
  "self-start",
  "self-end",
  "semi-condensed",
  "semi-expanded",
  "separate",
  "serif",
  "show",
  "single",
  "skew",
  "skewX",
  "skewY",
  "skip-white-space",
  "slide",
  "slider-horizontal",
  "slider-vertical",
  "sliderthumb-horizontal",
  "sliderthumb-vertical",
  "slow",
  "small",
  "small-caps",
  "small-caption",
  "smaller",
  "soft-light",
  "solid",
  "source-atop",
  "source-in",
  "source-out",
  "source-over",
  "space",
  "space-around",
  "space-between",
  "space-evenly",
  "spell-out",
  "square",
  "start",
  "static",
  "status-bar",
  "stretch",
  "stroke",
  "stroke-box",
  "sub",
  "subpixel-antialiased",
  "svg_masks",
  "super",
  "sw-resize",
  "symbolic",
  "symbols",
  "system-ui",
  "table",
  "table-caption",
  "table-cell",
  "table-column",
  "table-column-group",
  "table-footer-group",
  "table-header-group",
  "table-row",
  "table-row-group",
  "text",
  "text-bottom",
  "text-top",
  "textarea",
  "textfield",
  "thick",
  "thin",
  "threeddarkshadow",
  "threedface",
  "threedhighlight",
  "threedlightshadow",
  "threedshadow",
  "to",
  "top",
  "transform",
  "translate",
  "translate3d",
  "translateX",
  "translateY",
  "translateZ",
  "transparent",
  "ultra-condensed",
  "ultra-expanded",
  "underline",
  "unidirectional-pan",
  "unset",
  "up",
  "upper-latin",
  "uppercase",
  "url",
  "var",
  "vertical",
  "vertical-text",
  "view-box",
  "visible",
  "visibleFill",
  "visiblePainted",
  "visibleStroke",
  "visual",
  "w-resize",
  "wait",
  "wave",
  "wider",
  "window",
  "windowframe",
  "windowtext",
  "words",
  "wrap",
  "wrap-reverse",
  "x-large",
  "x-small",
  "xor",
  "xx-large",
  "xx-small"
].map((t4) => ({ type: "keyword", label: t4 })).concat(/* @__PURE__ */ [
  "aliceblue",
  "antiquewhite",
  "aqua",
  "aquamarine",
  "azure",
  "beige",
  "bisque",
  "black",
  "blanchedalmond",
  "blue",
  "blueviolet",
  "brown",
  "burlywood",
  "cadetblue",
  "chartreuse",
  "chocolate",
  "coral",
  "cornflowerblue",
  "cornsilk",
  "crimson",
  "cyan",
  "darkblue",
  "darkcyan",
  "darkgoldenrod",
  "darkgray",
  "darkgreen",
  "darkkhaki",
  "darkmagenta",
  "darkolivegreen",
  "darkorange",
  "darkorchid",
  "darkred",
  "darksalmon",
  "darkseagreen",
  "darkslateblue",
  "darkslategray",
  "darkturquoise",
  "darkviolet",
  "deeppink",
  "deepskyblue",
  "dimgray",
  "dodgerblue",
  "firebrick",
  "floralwhite",
  "forestgreen",
  "fuchsia",
  "gainsboro",
  "ghostwhite",
  "gold",
  "goldenrod",
  "gray",
  "grey",
  "green",
  "greenyellow",
  "honeydew",
  "hotpink",
  "indianred",
  "indigo",
  "ivory",
  "khaki",
  "lavender",
  "lavenderblush",
  "lawngreen",
  "lemonchiffon",
  "lightblue",
  "lightcoral",
  "lightcyan",
  "lightgoldenrodyellow",
  "lightgray",
  "lightgreen",
  "lightpink",
  "lightsalmon",
  "lightseagreen",
  "lightskyblue",
  "lightslategray",
  "lightsteelblue",
  "lightyellow",
  "lime",
  "limegreen",
  "linen",
  "magenta",
  "maroon",
  "mediumaquamarine",
  "mediumblue",
  "mediumorchid",
  "mediumpurple",
  "mediumseagreen",
  "mediumslateblue",
  "mediumspringgreen",
  "mediumturquoise",
  "mediumvioletred",
  "midnightblue",
  "mintcream",
  "mistyrose",
  "moccasin",
  "navajowhite",
  "navy",
  "oldlace",
  "olive",
  "olivedrab",
  "orange",
  "orangered",
  "orchid",
  "palegoldenrod",
  "palegreen",
  "paleturquoise",
  "palevioletred",
  "papayawhip",
  "peachpuff",
  "peru",
  "pink",
  "plum",
  "powderblue",
  "purple",
  "rebeccapurple",
  "red",
  "rosybrown",
  "royalblue",
  "saddlebrown",
  "salmon",
  "sandybrown",
  "seagreen",
  "seashell",
  "sienna",
  "silver",
  "skyblue",
  "slateblue",
  "slategray",
  "snow",
  "springgreen",
  "steelblue",
  "tan",
  "teal",
  "thistle",
  "tomato",
  "turquoise",
  "violet",
  "wheat",
  "white",
  "whitesmoke",
  "yellow",
  "yellowgreen"
].map((t4) => ({ type: "constant", label: t4 })));
var jX = /* @__PURE__ */ [
  "a",
  "abbr",
  "address",
  "article",
  "aside",
  "b",
  "bdi",
  "bdo",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "figcaption",
  "figure",
  "footer",
  "form",
  "header",
  "hgroup",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "main",
  "meter",
  "nav",
  "ol",
  "output",
  "p",
  "pre",
  "ruby",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "template",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "tr",
  "u",
  "ul"
].map((t4) => ({ type: "type", label: t4 }));
var lo = /^(\w[\w-]*|-\w[\w-]*|)$/;
var RX = /^-(-[\w-]*)?$/;
function DX(t4, e) {
  var n;
  if ((t4.name == "(" || t4.type.isError) && (t4 = t4.parent || t4), t4.name != "ArgList")
    return false;
  let r = (n = t4.parent) === null || n === void 0 ? void 0 : n.firstChild;
  return (r == null ? void 0 : r.name) != "Callee" ? false : e.sliceString(r.from, r.to) == "var";
}
var VS = /* @__PURE__ */ new aT();
var QX = ["Declaration"];
function BX(t4) {
  for (let e = t4; ; ) {
    if (e.type.isTop)
      return e;
    if (!(e = e.parent))
      return t4;
  }
}
function JI(t4, e, n) {
  if (e.to - e.from > 4096) {
    let r = VS.get(e);
    if (r)
      return r;
    let i = [], o = /* @__PURE__ */ new Set(), s = e.cursor(Rt.IncludeAnonymous);
    if (s.firstChild())
      do
        for (let a of JI(t4, s.node, n))
          o.has(a.label) || (o.add(a.label), i.push(a));
      while (s.nextSibling());
    return VS.set(e, i), i;
  } else {
    let r = [], i = /* @__PURE__ */ new Set();
    return e.cursor().iterate((o) => {
      var s;
      if (n(o) && o.matchContext(QX) && ((s = o.node.nextSibling) === null || s === void 0 ? void 0 : s.name) == ":") {
        let a = t4.sliceString(o.from, o.to);
        i.has(a) || (i.add(a), r.push({ label: a, type: "variable" }));
      }
    }), r;
  }
}
var _X = (t4) => (e) => {
  let { state: n, pos: r } = e, i = Ft(n).resolveInner(r, -1), o = i.type.isError && i.from == i.to - 1 && n.doc.sliceString(i.from, i.to) == "-";
  if (i.name == "PropertyName" || (o || i.name == "TagName") && /^(Block|Styles)$/.test(i.resolve(i.to).name))
    return { from: i.from, options: e0(), validFor: lo };
  if (i.name == "ValueName")
    return { from: i.from, options: WS, validFor: lo };
  if (i.name == "PseudoClassName")
    return { from: i.from, options: ZS, validFor: lo };
  if (t4(i) || (e.explicit || o) && DX(i, n.doc))
    return {
      from: t4(i) || o ? i.from : r,
      options: JI(n.doc, BX(i), t4),
      validFor: RX
    };
  if (i.name == "TagName") {
    for (let { parent: l } = i; l; l = l.parent)
      if (l.name == "Block")
        return { from: i.from, options: e0(), validFor: lo };
    return { from: i.from, options: jX, validFor: lo };
  }
  if (!e.explicit)
    return null;
  let s = i.resolve(r), a = s.childBefore(r);
  return a && a.name == ":" && s.name == "PseudoClassSelector" ? { from: r, options: ZS, validFor: lo } : a && a.name == ":" && s.name == "Declaration" || s.name == "ArgList" ? { from: r, options: WS, validFor: lo } : s.name == "Block" || s.name == "Styles" ? { from: r, options: e0(), validFor: lo } : null;
};
var MX = /* @__PURE__ */ _X((t4) => t4.name == "VariableName");
var Ed = /* @__PURE__ */ Do.define({
  name: "css",
  parser: /* @__PURE__ */ $X.configure({
    props: [
      /* @__PURE__ */ Ha.add({
        Declaration: /* @__PURE__ */ ua()
      }),
      /* @__PURE__ */ Ja.add({
        "Block KeyframeList": Bx
      })
    ]
  }),
  languageData: {
    commentTokens: { block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*\}$/,
    wordChars: "-"
  }
});
function NX() {
  return new Bc(Ed, Ed.data.of({ autocomplete: MX }));
}
var FX = 310;
var zS = 1;
var ZX = 2;
var WX = 3;
var VX = 311;
var zX = 313;
var LX = 314;
var XX = 4;
var GX = 5;
var YX = 0;
var Vm = [
  9,
  10,
  11,
  12,
  13,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
];
var KI = 125;
var qX = 59;
var zm = 47;
var UX = 42;
var HX = 43;
var JX = 45;
var KX = 60;
var eG = 44;
var tG = new tv({
  start: false,
  shift(t4, e) {
    return e == XX || e == GX || e == zX ? t4 : e == LX;
  },
  strict: false
});
var nG = new Cr((t4, e) => {
  let { next: n } = t4;
  (n == KI || n == -1 || e.context) && t4.acceptToken(VX);
}, { contextual: true, fallback: true });
var rG = new Cr((t4, e) => {
  let { next: n } = t4, r;
  Vm.indexOf(n) > -1 || n == zm && ((r = t4.peek(1)) == zm || r == UX) || n != KI && n != qX && n != -1 && !e.context && t4.acceptToken(FX);
}, { contextual: true });
var iG = new Cr((t4, e) => {
  let { next: n } = t4;
  if ((n == HX || n == JX) && (t4.advance(), n == t4.next)) {
    t4.advance();
    let r = !e.context && e.canShift(zS);
    t4.acceptToken(r ? zS : ZX);
  }
}, { contextual: true });
function t0(t4, e) {
  return t4 >= 65 && t4 <= 90 || t4 >= 97 && t4 <= 122 || t4 == 95 || t4 >= 192 || !e && t4 >= 48 && t4 <= 57;
}
var oG = new Cr((t4, e) => {
  if (t4.next != KX || !e.dialectEnabled(YX) || (t4.advance(), t4.next == zm))
    return;
  let n = 0;
  for (; Vm.indexOf(t4.next) > -1; )
    t4.advance(), n++;
  if (t0(t4.next, true)) {
    for (t4.advance(), n++; t0(t4.next, false); )
      t4.advance(), n++;
    for (; Vm.indexOf(t4.next) > -1; )
      t4.advance(), n++;
    if (t4.next == eG)
      return;
    for (let r = 0; ; r++) {
      if (r == 7) {
        if (!t0(t4.next, true))
          return;
        break;
      }
      if (t4.next != "extends".charCodeAt(r))
        break;
      t4.advance(), n++;
    }
  }
  t4.acceptToken(WX, -n);
});
var sG = Ua({
  "get set async static": P.modifier,
  "for while do if else switch try catch finally return throw break continue default case": P.controlKeyword,
  "in of await yield void typeof delete instanceof": P.operatorKeyword,
  "let var const using function class extends": P.definitionKeyword,
  "import export from": P.moduleKeyword,
  "with debugger as new": P.keyword,
  TemplateString: P.special(P.string),
  super: P.atom,
  BooleanLiteral: P.bool,
  this: P.self,
  null: P.null,
  Star: P.modifier,
  VariableName: P.variableName,
  "CallExpression/VariableName TaggedTemplateExpression/VariableName": P.function(P.variableName),
  VariableDefinition: P.definition(P.variableName),
  Label: P.labelName,
  PropertyName: P.propertyName,
  PrivatePropertyName: P.special(P.propertyName),
  "CallExpression/MemberExpression/PropertyName": P.function(P.propertyName),
  "FunctionDeclaration/VariableDefinition": P.function(P.definition(P.variableName)),
  "ClassDeclaration/VariableDefinition": P.definition(P.className),
  PropertyDefinition: P.definition(P.propertyName),
  PrivatePropertyDefinition: P.definition(P.special(P.propertyName)),
  UpdateOp: P.updateOperator,
  "LineComment Hashbang": P.lineComment,
  BlockComment: P.blockComment,
  Number: P.number,
  String: P.string,
  Escape: P.escape,
  ArithOp: P.arithmeticOperator,
  LogicOp: P.logicOperator,
  BitOp: P.bitwiseOperator,
  CompareOp: P.compareOperator,
  RegExp: P.regexp,
  Equals: P.definitionOperator,
  Arrow: P.function(P.punctuation),
  ": Spread": P.punctuation,
  "( )": P.paren,
  "[ ]": P.squareBracket,
  "{ }": P.brace,
  "InterpolationStart InterpolationEnd": P.special(P.brace),
  ".": P.derefOperator,
  ", ;": P.separator,
  "@": P.meta,
  TypeName: P.typeName,
  TypeDefinition: P.definition(P.typeName),
  "type enum interface implements namespace module declare": P.definitionKeyword,
  "abstract global Privacy readonly override": P.modifier,
  "is keyof unique infer": P.operatorKeyword,
  JSXAttributeValue: P.attributeValue,
  JSXText: P.content,
  "JSXStartTag JSXStartCloseTag JSXSelfCloseEndTag JSXEndTag": P.angleBracket,
  "JSXIdentifier JSXNameSpacedName": P.tagName,
  "JSXAttribute/JSXIdentifier JSXAttribute/JSXNameSpacedName": P.attributeName,
  "JSXBuiltin/JSXIdentifier": P.standard(P.tagName)
});
var aG = { __proto__: null, export: 18, as: 23, from: 31, default: 34, async: 39, function: 40, extends: 52, this: 56, true: 64, false: 64, null: 76, void: 80, typeof: 84, super: 102, new: 136, delete: 154, yield: 163, await: 167, class: 172, public: 229, private: 229, protected: 229, readonly: 231, instanceof: 250, satisfies: 253, in: 254, const: 256, import: 288, keyof: 341, unique: 345, infer: 351, is: 387, abstract: 407, implements: 409, type: 411, let: 414, var: 416, using: 419, interface: 425, enum: 429, namespace: 435, module: 437, declare: 441, global: 445, for: 464, of: 473, while: 476, with: 480, do: 484, if: 488, else: 490, switch: 494, case: 500, try: 506, catch: 510, finally: 514, return: 518, throw: 522, break: 526, continue: 530, debugger: 534 };
var lG = { __proto__: null, async: 123, get: 125, set: 127, declare: 189, public: 191, private: 191, protected: 191, static: 193, abstract: 195, override: 197, readonly: 203, accessor: 205, new: 391 };
var cG = { __proto__: null, "<": 145 };
var uG = Bo.deserialize({
  version: 14,
  states: "$=dO%TQ^OOO%[Q^OOO'_Q`OOP(lOWOOO*zQ?NdO'#ChO+RO!bO'#CiO+aO#tO'#CiO+oO!0LbO'#D^O.QQ^O'#DdO.bQ^O'#DoO%[Q^O'#DzO0fQ^O'#ESOOQ?Mr'#E['#E[O1PQWO'#EXOOQO'#Em'#EmOOQO'#If'#IfO1XQWO'#GnO1dQWO'#ElO1iQWO'#ElO3kQ?NdO'#JjO6[Q?NdO'#JkO6xQWO'#F[O6}Q&jO'#FrOOQ?Mr'#Fd'#FdO7YO,YO'#FdO7hQ7[O'#FyO9UQWO'#FxOOQ?Mr'#Jk'#JkOOQ?Mp'#Jj'#JjO9ZQWO'#GrOOQU'#KW'#KWO9fQWO'#ISO9kQ?MxO'#ITOOQU'#JX'#JXOOQU'#IX'#IXQ`Q^OOO`Q^OOO9sQMnO'#DsO9zQ^O'#EOO:RQ^O'#EQO9aQWO'#GnO:YQ7[O'#CnO:hQWO'#EkO:sQWO'#EvO:xQ7[O'#FcO;gQWO'#GnOOQO'#KX'#KXO;lQWO'#KXO;zQWO'#GvO;zQWO'#GwO;zQWO'#GyO9aQWO'#G|O<qQWO'#HPO>YQWO'#CdO>jQWO'#H]O>rQWO'#HcO>rQWO'#HeO`Q^O'#HgO>rQWO'#HiO>rQWO'#HlO>wQWO'#HrO>|Q?MyO'#HxO%[Q^O'#HzO?XQ?MyO'#H|O?dQ?MyO'#IOO9kQ?MxO'#IQO?oQ?NdO'#ChO@qQ`O'#DiQOQWOOO%[Q^O'#EQOAXQWO'#ETO:YQ7[O'#EkOAdQWO'#EkOAoQpO'#FcOOQU'#Cf'#CfOOQ?Mp'#Dn'#DnOOQ?Mp'#Jn'#JnO%[Q^O'#JnOOQO'#Jr'#JrOOQO'#Ic'#IcOBoQ`O'#EdOOQ?Mp'#Ec'#EcOOQ?Mp'#Ju'#JuOCkQ?NQO'#EdOCuQ`O'#EWOOQO'#Jq'#JqODZQ`O'#JrOEhQ`O'#EWOCuQ`O'#EdPEuO#@ItO'#CaPOOO)CDv)CDvOOOO'#IY'#IYOFQO!bO,59TOOQ?Mr,59T,59TOOOO'#IZ'#IZOF`O#tO,59TO%[Q^O'#D`OOOO'#I]'#I]OFnO!0LbO,59xOOQ?Mr,59x,59xOF|Q^O'#I^OGaQWO'#JlOIcQrO'#JlO+}Q^O'#JlOIjQWO,5:OOJQQWO'#EmOJ_QWO'#J{OJjQWO'#JzOJjQWO'#JzOJrQWO,5;ZOJwQWO'#JyOOQ?Mv,5:Z,5:ZOKOQ^O,5:ZOMPQ?NdO,5:fOMpQWO,5:nONZQ?MxO'#JxONbQWO'#JwO9ZQWO'#JwONvQWO'#JwO! OQWO,5;YO! TQWO'#JwO!#]QrO'#JkOOQ?Mr'#Ch'#ChO%[Q^O'#ESO!#{QpO,5:sOOQO'#Js'#JsOOQO-E<d-E<dO9aQWO,5=YO!$cQWO,5=YO!$hQ^O,5;WO!&kQ7[O'#EhO!(UQWO,5;WO!)tQ7[O'#DtO!){Q^O'#DyO!*VQ`O,5;aO!*_Q`O,5;aO%[Q^O,5;aOOQU'#FS'#FSOOQU'#FU'#FUO%[Q^O,5;bO%[Q^O,5;bO%[Q^O,5;bO%[Q^O,5;bO%[Q^O,5;bO%[Q^O,5;bO%[Q^O,5;bO%[Q^O,5;bO%[Q^O,5;bO%[Q^O,5;bO%[Q^O,5;bOOQU'#FY'#FYO!*mQ^O,5;sOOQ?Mr,5;x,5;xOOQ?Mr,5;y,5;yO!,pQWO,5;yOOQ?Mr,5;z,5;zO%[Q^O'#IjO!,xQ?MxO,5<fO!&kQ7[O,5;bO!-gQ7[O,5;bO%[Q^O,5;vO!-nQ&jO'#FhO!.kQ&jO'#KPO!.VQ&jO'#KPO!.rQ&jO'#KPOOQO'#KP'#KPO!/WQ&jO,5<QOOOS,5<^,5<^O!/iQ^O'#FtOOOS'#Ii'#IiO7YO,YO,5<OO!/pQ&jO'#FvOOQ?Mr,5<O,5<OO!0aQ!LQO'#CuOOQ?Mr'#Cy'#CyO!0tQWO'#CyO!0yO!0LbO'#C}O!1gQ7[O,5<cO!1nQWO,5<eO!3ZQ$ISO'#GTO!3hQWO'#GUO!3mQWO'#GUO!5]Q$ISO'#GYO!6XQ`O'#G^OOQO'#Gi'#GiO!(ZQ7[O'#GhOOQO'#Gk'#GkO!(ZQ7[O'#GjO!6zQ!LQO'#JeOOQ?Mr'#Je'#JeO!7UQWO'#JdO!7dQWO'#JcO!7lQWO'#CtOOQ?Mr'#Cw'#CwOOQ?Mr'#DR'#DROOQ?Mr'#DT'#DTO1SQWO'#DVO!(ZQ7[O'#F{O!(ZQ7[O'#F}O!7tQWO'#GPO!7yQWO'#GQO!3mQWO'#GWO!(ZQ7[O'#G]O!8OQWO'#EnO!8mQWO,5<dOOQ?Mp'#Cq'#CqO!8uQWO'#EoO!9oQ`O'#EpOOQ?Mp'#Jy'#JyO!9vQ?MxO'#KYO9kQ?MxO,5=^O`Q^O,5>nOOQU'#Ja'#JaOOQU,5>o,5>oOOQU-E<V-E<VO!;xQ?NdO,5:_O!9jQ`O,5:]O!>fQ?NdO,5:jO%[Q^O,5:jO!APQ?NdO,5:lOOQO,5@s,5@sO!ApQ7[O,5=YO!BOQ?MxO'#JbO9UQWO'#JbO!BaQ?MxO,59YO!BlQ`O,59YO!BtQ7[O,59YO:YQ7[O,59YO!CPQWO,5;WO!CXQWO'#H[O!CmQWO'#K]O%[Q^O,5;{O!9jQ`O,5;}O!CuQWO,5=uO!CzQWO,5=uO!DPQWO,5=uO9kQ?MxO,5=uO;zQWO,5=eOOQO'#Cu'#CuO!D_Q`O,5=bO!DgQ7[O,5=cO!DrQWO,5=eO!DwQpO,5=hO!EPQWO'#KXO>wQWO'#HRO9aQWO'#HTO!EUQWO'#HTO:YQ7[O'#HVO!EZQWO'#HVOOQU,5=k,5=kO!E`QWO'#HWO!EqQWO'#CnO!EvQWO,59OO!FQQWO,59OO!HVQ^O,59OOOQU,59O,59OO!HgQ?MxO,59OO%[Q^O,59OO!JrQ^O'#H_OOQU'#H`'#H`OOQU'#Ha'#HaO`Q^O,5=wO!KYQWO,5=wO`Q^O,5=}O`Q^O,5>PO!K_QWO,5>RO`Q^O,5>TO!KdQWO,5>WO!KiQ^O,5>^OOQU,5>d,5>dO%[Q^O,5>dO9kQ?MxO,5>fOOQU,5>h,5>hO# sQWO,5>hOOQU,5>j,5>jO# sQWO,5>jOOQU,5>l,5>lO#!aQ`O'#D[O%[Q^O'#JnO#!kQ`O'#JnO##YQ`O'#DjO##kQ`O'#DjO#%|Q^O'#DjO#&TQWO'#JmO#&]QWO,5:TO#&bQWO'#EqO#&pQWO'#J|O#&xQWO,5;[O#&}Q`O'#DjO#'[Q`O'#EVOOQ?Mr,5:o,5:oO%[Q^O,5:oO#'cQWO,5:oO>wQWO,5;VO!BlQ`O,5;VO!BtQ7[O,5;VO:YQ7[O,5;VO#'kQWO,5@YO#'pQ(CWO,5:sOOQO-E<a-E<aO#(vQ?NQO,5;OOCuQ`O,5:rO#)QQ`O,5:rOCuQ`O,5;OO!BaQ?MxO,5:rOOQ?Mp'#Eg'#EgOOQO,5;O,5;OO%[Q^O,5;OO#)_Q?MxO,5;OO#)jQ?MxO,5;OO!BlQ`O,5:rOOQO,5;U,5;UO#)xQ?MxO,5;OPOOO'#IW'#IWP#*^O#@ItO,58{POOO,58{,58{OOOO-E<W-E<WOOQ?Mr1G.o1G.oOOOO-E<X-E<XO#*iQpO,59zOOOO-E<Z-E<ZOOQ?Mr1G/d1G/dO#*nQrO,5>xO+}Q^O,5>xOOQO,5?O,5?OO#*xQ^O'#I^OOQO-E<[-E<[O#+VQWO,5@WO#+_QrO,5@WO#+fQWO,5@fOOQ?Mr1G/j1G/jO%[Q^O,5@gO#+nQWO'#IdOOQO-E<b-E<bO#+fQWO,5@fOOQ?Mp1G0u1G0uOOQ?Mv1G/u1G/uOOQ?Mv1G0Y1G0YO%[Q^O,5@dO#,SQ?MxO,5@dO#,eQ?MxO,5@dO#,lQWO,5@cO9ZQWO,5@cO#,tQWO,5@cO#-SQWO'#IgO#,lQWO,5@cOOQ?Mp1G0t1G0tO!*VQ`O,5:uO!*bQ`O,5:uOOQO,5:w,5:wO#-tQWO,5:wO#-|Q7[O1G2tO9aQWO1G2tOOQ?Mr1G0r1G0rO#.[Q?NdO1G0rO#/aQ?NbO,5;SOOQ?Mr'#GS'#GSO#/}Q?NdO'#JeO!$hQ^O1G0rO#2VQ7[O'#JoO#2aQWO,5:`O#2fQrO'#JpO%[Q^O'#JpO#2pQWO,5:eOOQ?Mr'#D['#D[OOQ?Mr1G0{1G0{O%[Q^O1G0{OOQ?Mr1G1e1G1eO#2uQWO1G0{O#5^Q?NdO1G0|O#5eQ?NdO1G0|O#8OQ?NdO1G0|O#8VQ?NdO1G0|O#:aQ?NdO1G0|O#:wQ?NdO1G0|O#=qQ?NdO1G0|O#=xQ?NdO1G0|O#@]Q?NdO1G0|O#@jQ?NdO1G0|O#BhQ?NdO1G0|O#EhQ07bO'#ChO#GfQ07bO1G1_O#GmQ07bO'#JkO!,sQWO1G1eO#G}Q?NdO,5?UOOQ?Mp-E<h-E<hO#HqQ?NdO1G0|OOQ?Mr1G0|1G0|O#J|Q?NdO1G1bO#KpQ&jO,5<UO#KxQ&jO,5<VO#LQQ&jO'#FmO#LiQWO'#FlOOQO'#KQ'#KQOOQO'#Ih'#IhO#LnQ&jO1G1lOOQ?Mr1G1l1G1lOOOS1G1w1G1wO#MPQ07bO'#JjO#MZQWO,5<`O!*mQ^O,5<`OOOS-E<g-E<gOOQ?Mr1G1j1G1jO#M`Q`O'#KPOOQ?Mr,5<b,5<bO#MhQ`O,5<bOOQ?Mr,59e,59eO!&kQ7[O'#DPOOOO'#I['#I[O#MmO!0LbO,59iOOQ?Mr,59i,59iO%[Q^O1G1}O!7yQWO'#IlO#MxQ7[O,5<vOOQ?Mr,5<s,5<sO!(ZQ7[O'#IoO#NhQ7[O,5=SO!(ZQ7[O'#IqO$ ZQ7[O,5=UO!&kQ7[O,5=WOOQO1G2P1G2PO$ eQpO'#CqO$ xQ$ISO'#EoO$!wQ`O'#G^O$#eQpO,5<oO$#lQWO'#KTO9ZQWO'#KTO$#zQWO,5<qO!(ZQ7[O,5<pO$$PQWO'#GVO$$bQWO,5<pO$$gQpO'#GSO$$tQpO'#KUO$%OQWO'#KUO!&kQ7[O'#KUO$%TQWO,5<tO$%YQ`O'#G_O!6SQ`O'#G_O$%kQWO'#GaO$%pQWO'#GcO!3mQWO'#GfO$%uQ?MxO'#InO$&QQ`O,5<xOOQ?Mv,5<x,5<xO$&XQ`O'#G_O$&gQ`O'#G`O$&oQ`O'#G`O$&tQ7[O,5=SO$'UQ7[O,5=UOOQ?Mr,5=X,5=XO!(ZQ7[O,5@OO!(ZQ7[O,5@OO$'fQWO'#IsO$'qQWO,5?}O$'yQWO,59`O$(jQ7[O,59qOOQ?Mr,59q,59qO$)]Q7[O,5<gO$*OQ7[O,5<iO@iQWO,5<kOOQ?Mr,5<l,5<lO$*YQWO,5<rO$*_Q7[O,5<wO$*oQWO'#JwO!$hQ^O1G2OO$*tQWO1G2OO9ZQWO'#JzO9ZQWO'#EqO%[Q^O'#EqO9ZQWO'#IuO$*yQ?MxO,5@tOOQU1G2x1G2xOOQU1G4Y1G4YOOQ?Mr1G/y1G/yO!,pQWO1G/yOOQ?Mr1G/w1G/wO$-OQ?NdO1G0UOOQU1G2t1G2tO!&kQ7[O1G2tO%[Q^O1G2tO#.PQWO1G2tO$/SQ7[O'#EhOOQ?Mp,5?|,5?|O$/^Q?MxO,5?|OOQU1G.t1G.tO!BaQ?MxO1G.tO!BlQ`O1G.tO!BtQ7[O1G.tO$/oQWO1G0rO$/tQWO'#ChO$0PQWO'#K^O$0XQWO,5=vO$0^QWO'#K^O$0cQWO'#K^O$0qQWO'#I{O$1PQWO,5@wO$1XQrO1G1gOOQ?Mr1G1i1G1iO9aQWO1G3aO@iQWO1G3aO$1`QWO1G3aO$1eQWO1G3aOOQU1G3a1G3aO!DrQWO1G3PO!&kQ7[O1G2|O$1jQWO1G2|OOQU1G2}1G2}O!&kQ7[O1G2}O$1oQWO1G2}O$1wQ`O'#G{OOQU1G3P1G3PO!6SQ`O'#IwO!DwQpO1G3SOOQU1G3S1G3SOOQU,5=m,5=mO$2PQ7[O,5=oO9aQWO,5=oO$%pQWO,5=qO9UQWO,5=qO!BlQ`O,5=qO!BtQ7[O,5=qO:YQ7[O,5=qO$2_QWO'#K[O$2jQWO,5=rOOQU1G.j1G.jO$2oQ?MxO1G.jO@iQWO1G.jO$2zQWO1G.jO9kQ?MxO1G.jO$5PQrO,5@yO$5aQWO,5@yO9ZQWO,5@yO$5lQ^O,5=yO$5sQWO,5=yOOQU1G3c1G3cO`Q^O1G3cOOQU1G3i1G3iOOQU1G3k1G3kO>rQWO1G3mO$5xQ^O1G3oO$9|Q^O'#HnOOQU1G3r1G3rO$:ZQWO'#HtO>wQWO'#HvOOQU1G3x1G3xO$:cQ^O1G3xO9kQ?MxO1G4OOOQU1G4Q1G4QOOQ?Mp'#GZ'#GZO9kQ?MxO1G4SO9kQ?MxO1G4UO$>jQWO,5@YO!*mQ^O,5;]O9ZQWO,5;]O>wQWO,5:UO!*mQ^O,5:UO!BlQ`O,5:UO$>oQ07bO,5:UOOQO,5;],5;]O$>yQ`O'#I_O$?aQWO,5@XOOQ?Mr1G/o1G/oO$?iQ`O'#IeO$?sQWO,5@hOOQ?Mp1G0v1G0vO##kQ`O,5:UOOQO'#Ib'#IbO$?{Q`O,5:qOOQ?Mv,5:q,5:qO#'fQWO1G0ZOOQ?Mr1G0Z1G0ZO%[Q^O1G0ZOOQ?Mr1G0q1G0qO>wQWO1G0qO!BlQ`O1G0qO!BtQ7[O1G0qOOQ?Mp1G5t1G5tO!BaQ?MxO1G0^OOQO1G0j1G0jO%[Q^O1G0jO$@SQ?MxO1G0jO$@_Q?MxO1G0jO!BlQ`O1G0^OCuQ`O1G0^O$@mQ?MxO1G0jOOQO1G0^1G0^O$ARQ?NdO1G0jPOOO-E<U-E<UPOOO1G.g1G.gOOOO1G/f1G/fO$A]QpO,5<fO$AeQrO1G4dOOQO1G4j1G4jO%[Q^O,5>xO$AoQWO1G5rO$AwQWO1G6QO$BPQrO1G6RO9ZQWO,5?OO$BZQ?NdO1G6OO%[Q^O1G6OO$BkQ?MxO1G6OO$B|QWO1G5}O$B|QWO1G5}O9ZQWO1G5}O$CUQWO,5?RO9ZQWO,5?ROOQO,5?R,5?RO$CjQWO,5?RO$*oQWO,5?ROOQO-E<e-E<eOOQO1G0a1G0aOOQO1G0c1G0cO!,sQWO1G0cOOQU7+(`7+(`O!&kQ7[O7+(`O%[Q^O7+(`O$CxQWO7+(`O$DTQ7[O7+(`O$DcQ?NdO,5=SO$FnQ?NdO,5=UO$HyQ?NdO,5=SO$K[Q?NdO,5=UO$MmQ?NdO,59qO% uQ?NdO,5<gO%$QQ?NdO,5<iO%&]Q?NdO,5<wOOQ?Mr7+&^7+&^O%(nQ?NdO7+&^O%)bQ7[O'#I`O%)lQWO,5@ZOOQ?Mr1G/z1G/zO%)tQ^O'#IaO%*RQWO,5@[O%*ZQrO,5@[OOQ?Mr1G0P1G0PO%*eQWO7+&gOOQ?Mr7+&g7+&gO%*jQ07bO,5:fO%[Q^O7+&yO%*tQ07bO,5:_O%+RQ07bO,5:jO%+]Q07bO,5:lOOQ?Mr7+'P7+'POOQO1G1p1G1pOOQO1G1q1G1qO%+gQtO,5<XO!*mQ^O,5<WOOQO-E<f-E<fOOQ?Mr7+'W7+'WOOOS7+'c7+'cOOOS1G1z1G1zO%+rQWO1G1zOOQ?Mr1G1|1G1|O%+wQpO,59kOOOO-E<Y-E<YOOQ?Mr1G/T1G/TO%,OQ?NdO7+'iOOQ?Mr,5?W,5?WO%,rQpO,5?WOOQ?Mr1G2b1G2bP!&kQ7[O'#IlPOQ?Mr-E<j-E<jO%-bQ7[O,5?ZOOQ?Mr-E<m-E<mO%.TQ7[O,5?]OOQ?Mr-E<o-E<oO%._QpO1G2rO%.fQpO'#CqO%.|Q7[O'#JzO%/TQ^O'#EqOOQ?Mr1G2Z1G2ZO%/_QWO'#IkO%/sQWO,5@oO%/sQWO,5@oO%/{QWO,5@oO%0WQWO,5@oOOQO1G2]1G2]O%0fQ7[O1G2[O!(ZQ7[O1G2[O%0vQ$ISO'#ImO%1TQWO,5@pO!&kQ7[O,5@pO%1]QpO,5@pOOQ?Mr1G2`1G2`OOQ?Mp,5<y,5<yOOQ?Mp,5<z,5<zO$*oQWO,5<zOCfQWO,5<zO!BlQ`O,5<yOOQO'#Gb'#GbO%1gQWO,5<{OOQ?Mp,5<},5<}O$*oQWO,5=QOOQO,5?Y,5?YOOQO-E<l-E<lOOQ?Mv1G2d1G2dO!6SQ`O,5<yO%1oQWO,5<zO$%kQWO,5<{O!6SQ`O,5<zO!(ZQ7[O'#IoO%2cQ7[O1G2nO!(ZQ7[O'#IqO%3UQ7[O1G2pO%3`Q7[O1G5jO%3jQ7[O1G5jOOQO,5?_,5?_OOQO-E<q-E<qOOQO1G.z1G.zO!9jQ`O,59sO%[Q^O,59sO%3wQWO1G2VO!(ZQ7[O1G2^O%3|Q?NdO7+'jOOQ?Mr7+'j7+'jO!$hQ^O7+'jO%4pQWO,5;]OOQ?Mp,5?a,5?aOOQ?Mp-E<s-E<sOOQ?Mr7+%e7+%eO%4uQpO'#KVO#'fQWO7+(`O%5PQrO7+(`O$C{QWO7+(`O%5WQ?NbO'#ChO%5kQ?NbO,5=OO%6]QWO,5=OOOQ?Mp1G5h1G5hOOQU7+$`7+$`O!BaQ?MxO7+$`O!BlQ`O7+$`O!$hQ^O7+&^O%6bQWO'#IzO%6yQWO,5@xOOQO1G3b1G3bO9aQWO,5@xO%6yQWO,5@xO%7RQWO,5@xOOQO,5?g,5?gOOQO-E<y-E<yOOQ?Mr7+'R7+'RO%7WQWO7+({O9kQ?MxO7+({O9aQWO7+({O@iQWO7+({OOQU7+(k7+(kO%7]Q?NbO7+(hO!&kQ7[O7+(hO%7gQpO7+(iOOQU7+(i7+(iO!&kQ7[O7+(iO%7nQWO'#KZO%7yQWO,5=gOOQO,5?c,5?cOOQO-E<u-E<uOOQU7+(n7+(nO%9YQ`O'#HUOOQU1G3Z1G3ZO!&kQ7[O1G3ZO%[Q^O1G3ZO%9aQWO1G3ZO%9lQ7[O1G3ZO9kQ?MxO1G3]O$%pQWO1G3]O9UQWO1G3]O!BlQ`O1G3]O!BtQ7[O1G3]O%9zQWO'#IyO%:`QWO,5@vO%:hQ`O,5@vOOQ?Mp1G3^1G3^OOQU7+$U7+$UO@iQWO7+$UO9kQ?MxO7+$UO%:sQWO7+$UO%[Q^O1G6eO%[Q^O1G6fO%:xQ?MxO1G6eO%;SQ^O1G3eO%;ZQWO1G3eO%;`Q^O1G3eOOQU7+(}7+(}O9kQ?MxO7+)XO`Q^O7+)ZOOQU'#Ka'#KaOOQU'#I|'#I|O%;gQ^O,5>YOOQU,5>Y,5>YO%[Q^O'#HoO%;tQWO'#HqOOQU,5>`,5>`O9ZQWO,5>`OOQU,5>b,5>bOOQU7+)d7+)dOOQU7+)j7+)jOOQU7+)n7+)nOOQU7+)p7+)pO%;yQ`O1G5tO%<_Q07bO1G0wO%<iQWO1G0wOOQO1G/p1G/pO%<tQ07bO1G/pO>wQWO1G/pO!*mQ^O'#DjOOQO,5>y,5>yOOQO-E<]-E<]OOQO,5?P,5?POOQO-E<c-E<cO!BlQ`O1G/pOOQO-E<`-E<`OOQ?Mv1G0]1G0]OOQ?Mr7+%u7+%uO#'fQWO7+%uOOQ?Mr7+&]7+&]O>wQWO7+&]O!BlQ`O7+&]OOQO7+%x7+%xO$ARQ?NdO7+&UOOQO7+&U7+&UO%[Q^O7+&UO%=OQ?MxO7+&UO!BaQ?MxO7+%xO!BlQ`O7+%xO%=ZQ?MxO7+&UO%=iQ?NdO7++jO%[Q^O7++jO%=yQWO7++iO%=yQWO7++iOOQO1G4m1G4mO9ZQWO1G4mO%>RQWO1G4mOOQO7+%}7+%}O#'fQWO<<KzO%5PQrO<<KzO%>aQWO<<KzOOQU<<Kz<<KzO!&kQ7[O<<KzO%[Q^O<<KzO%>iQWO<<KzO%>tQ?NdO,5?ZO%APQ?NdO,5?]O%C[Q?NdO1G2[O%EmQ?NdO1G2nO%GxQ?NdO1G2pO%JTQ7[O,5>zOOQO-E<^-E<^O%J_QrO,5>{O%[Q^O,5>{OOQO-E<_-E<_O%JiQWO1G5vOOQ?Mr<<JR<<JRO%JqQ07bO1G0rO%L{Q07bO1G0|O%MSQ07bO1G0|O& WQ07bO1G0|O& _Q07bO1G0|O&#SQ07bO1G0|O&#jQ07bO1G0|O&%}Q07bO1G0|O&&UQ07bO1G0|O&(SQ07bO1G0|O&(aQ07bO1G0|O&*_Q07bO1G0|O&*rQ?NdO<<JeO&+wQ07bO1G0|O&-mQ07bO'#JeO&/pQ07bO1G1bO&/}Q07bO1G0UO!*mQ^O'#FoOOQO'#KR'#KROOQO1G1s1G1sO&0XQWO1G1rO&0^Q07bO,5?UOOOS7+'f7+'fOOOO1G/V1G/VOOQ?Mr1G4r1G4rO!(ZQ7[O7+(^O&2nQrO'#ChO&2xQWO,5?VO9ZQWO,5?VOOQO-E<i-E<iO&3WQWO1G6ZO&3WQWO1G6ZO&3`QWO1G6ZO&3kQ7[O7+'vO&3{QpO,5?XO&4VQWO,5?XO!&kQ7[O,5?XOOQO-E<k-E<kO&4[QpO1G6[O&4fQWO1G6[OOQ?Mp1G2f1G2fO$*oQWO1G2fOOQ?Mp1G2e1G2eO&4nQWO1G2gO!&kQ7[O1G2gOOQ?Mp1G2l1G2lO!BlQ`O1G2eOCfQWO1G2fO&4sQWO1G2gO&4{QWO1G2fO&5oQ7[O,5?ZOOQ?Mr-E<n-E<nO&6bQ7[O,5?]OOQ?Mr-E<p-E<pO!(ZQ7[O7++UOOQ?Mr1G/_1G/_O&6lQWO1G/_OOQ?Mr7+'q7+'qO&6qQ7[O7+'xO&7RQ?NdO<<KUOOQ?Mr<<KU<<KUO&7uQWO1G0wO!&kQ7[O'#ItO&7zQWO,5@qO!&kQ7[O1G2jOOQU<<Gz<<GzO!BaQ?MxO<<GzO&8SQ?NdO<<IxOOQ?Mr<<Ix<<IxOOQO,5?f,5?fO&8vQWO,5?fO&8{QWO,5?fOOQO-E<x-E<xO&9ZQWO1G6dO&9ZQWO1G6dO9aQWO1G6dO@iQWO<<LgOOQU<<Lg<<LgO&9cQWO<<LgO9kQ?MxO<<LgOOQU<<LS<<LSO%7]Q?NbO<<LSOOQU<<LT<<LTO%7gQpO<<LTO&9hQ`O'#IvO&9sQWO,5@uO!*mQ^O,5@uOOQU1G3R1G3RO%/TQ^O'#JnOOQO'#Ix'#IxO9kQ?MxO'#IxO&9{Q`O,5=pOOQU,5=p,5=pO&:SQ`O'#EdO&:hQWO7+(uO&:mQWO7+(uOOQU7+(u7+(uO!&kQ7[O7+(uO%[Q^O7+(uO&:uQWO7+(uOOQU7+(w7+(wO9kQ?MxO7+(wO$%pQWO7+(wO9UQWO7+(wO!BlQ`O7+(wO&;QQWO,5?eOOQO-E<w-E<wOOQO'#HX'#HXO&;]QWO1G6bO9kQ?MxO<<GpOOQU<<Gp<<GpO@iQWO<<GpO&;eQWO7+,PO&;jQWO7+,QO%[Q^O7+,PO%[Q^O7+,QOOQU7+)P7+)PO&;oQWO7+)PO&;tQ^O7+)PO&;{QWO7+)POOQU<<Ls<<LsOOQU<<Lu<<LuOOQU-E<z-E<zOOQU1G3t1G3tO&<QQWO,5>ZOOQU,5>],5>]O&<VQWO1G3zO9ZQWO7+&cO!*mQ^O7+&cOOQO7+%[7+%[O&<[Q07bO1G6RO>wQWO7+%[OOQ?Mr<<Ia<<IaOOQ?Mr<<Iw<<IwO>wQWO<<IwOOQO<<Ip<<IpO$ARQ?NdO<<IpO%[Q^O<<IpOOQO<<Id<<IdO!BaQ?MxO<<IdO&<fQ?MxO<<IpO&<qQ?NdO<= UO&=RQWO<= TOOQO7+*X7+*XO9ZQWO7+*XOOQUANAfANAfO&=ZQWOANAfO!&kQ7[OANAfO#'fQWOANAfO%5PQrOANAfO%[Q^OANAfO&=cQ?NdO7+'vO&?tQ?NdO,5?ZO&BPQ?NdO,5?]O&D[Q?NdO7+'xO&FmQrO1G4gO&FwQ07bO7+&^O&H{Q07bO,5=SO&KSQ07bO,5=UO&KdQ07bO,5=SO&KtQ07bO,5=UO&LUQ07bO,59qO&NXQ07bO,5<gO'![Q07bO,5<iO'$_Q07bO,5<wO'&TQ07bO7+'iO'&bQ07bO7+'jO'&oQWO,5<ZOOQO7+'^7+'^O'&tQ7[O<<KxOOQO1G4q1G4qO'&{QWO1G4qO''WQWO1G4qO''fQWO7++uO''fQWO7++uO!&kQ7[O1G4sO''nQpO1G4sO''xQWO7++vOOQ?Mp7+(Q7+(QO$*oQWO7+(RO'(QQpO7+(ROOQ?Mp7+(P7+(PO$*oQWO7+(QO'(XQWO7+(RO!&kQ7[O7+(ROCfQWO7+(QO'(^Q7[O<<NpOOQ?Mr7+$y7+$yO'(hQpO,5?`OOQO-E<r-E<rO'(rQ?NbO7+(UOOQUAN=fAN=fO9aQWO1G5QOOQO1G5Q1G5QO')SQWO1G5QO')XQWO7+,OO')XQWO7+,OO9kQ?MxOANBRO@iQWOANBROOQUANBRANBROOQUANAnANAnOOQUANAoANAoO')aQWO,5?bOOQO-E<t-E<tO')lQ07bO1G6aOOQO,5?d,5?dOOQO-E<v-E<vOOQU1G3[1G3[O%/TQ^O,5<{OOQU<<La<<LaO!&kQ7[O<<LaO&:hQWO<<LaO')vQWO<<LaO%[Q^O<<LaOOQU<<Lc<<LcO9kQ?MxO<<LcO$%pQWO<<LcO9UQWO<<LcO'*OQ`O1G5PO'*ZQWO7++|OOQUAN=[AN=[O9kQ?MxOAN=[OOQU<= k<= kOOQU<= l<= lO'*cQWO<= kO'*hQWO<= lOOQU<<Lk<<LkO'*mQWO<<LkO'*rQ^O<<LkOOQU1G3u1G3uO>wQWO7+)fO'*yQWO<<I}O'+UQ07bO<<I}OOQO<<Hv<<HvOOQ?MrAN?cAN?cOOQOAN?[AN?[O$ARQ?NdOAN?[OOQOAN?OAN?OO%[Q^OAN?[OOQO<<Ms<<MsOOQUG27QG27QO!&kQ7[OG27QO#'fQWOG27QO'+`QWOG27QO%5PQrOG27QO'+hQ07bO<<JeO'+uQ07bO1G2[O'-kQ07bO,5?ZO'/nQ07bO,5?]O'1qQ07bO1G2nO'3tQ07bO1G2pO'5wQ07bO<<KUO'6UQ07bO<<IxOOQO1G1u1G1uO!(ZQ7[OANAdOOQO7+*]7+*]O'6cQWO7+*]O'6nQWO<= aO'6vQpO7+*_OOQ?Mp<<Km<<KmO$*oQWO<<KmOOQ?Mp<<Kl<<KlO'7QQpO<<KmO$*oQWO<<KlOOQO7+*l7+*lO9aQWO7+*lO'7XQWO<= jOOQUG27mG27mO9kQ?MxOG27mO!*mQ^O1G4|O'7aQWO7++{O&:hQWOANA{OOQUANA{ANA{O!&kQ7[OANA{O'7iQWOANA{OOQUANA}ANA}O9kQ?MxOANA}O$%pQWOANA}OOQO'#HY'#HYOOQO7+*k7+*kOOQUG22vG22vOOQUANEVANEVOOQUANEWANEWOOQUANBVANBVO'7qQWOANBVOOQU<<MQ<<MQO!*mQ^OAN?iOOQOG24vG24vO$ARQ?NdOG24vO#'fQWOLD,lOOQULD,lLD,lO!&kQ7[OLD,lO'7vQWOLD,lO'8OQ07bO7+'vO'9tQ07bO,5?ZO';wQ07bO,5?]O'=zQ07bO7+'xO'?pQ7[OG27OOOQO<<Mw<<MwOOQ?MpANAXANAXO$*oQWOANAXOOQ?MpANAWANAWOOQO<<NW<<NWOOQULD-XLD-XO'@QQ07bO7+*hOOQUG27gG27gO&:hQWOG27gO!&kQ7[OG27gOOQUG27iG27iO9kQ?MxOG27iOOQUG27qG27qO'@[Q07bOG25TOOQOLD*bLD*bOOQU!$(!W!$(!WO#'fQWO!$(!WO!&kQ7[O!$(!WO'@fQ?NdOG27OOOQ?MpG26sG26sOOQULD-RLD-RO&:hQWOLD-ROOQULD-TLD-TOOQU!)9Er!)9ErO#'fQWO!)9ErOOQU!$(!m!$(!mOOQU!.K;^!.K;^O'BwQ07bOG27OO!*mQ^O'#DzO1PQWO'#EXO'DmQrO'#JjO'DtQMnO'#DsO'D{Q^O'#EOO'ESQrO'#ChO'GjQrO'#ChO!*mQ^O'#EQO'GzQ^O,5;WO!*mQ^O,5;bO!*mQ^O,5;bO!*mQ^O,5;bO!*mQ^O,5;bO!*mQ^O,5;bO!*mQ^O,5;bO!*mQ^O,5;bO!*mQ^O,5;bO!*mQ^O,5;bO!*mQ^O,5;bO!*mQ^O,5;bO!*mQ^O'#IjO'I}QWO,5<fO'JVQ7[O,5;bO'KpQ7[O,5;bO!*mQ^O,5;vO!&kQ7[O'#GhO'JVQ7[O'#GhO!&kQ7[O'#GjO'JVQ7[O'#GjO1SQWO'#DVO1SQWO'#DVO!&kQ7[O'#F{O'JVQ7[O'#F{O!&kQ7[O'#F}O'JVQ7[O'#F}O!&kQ7[O'#G]O'JVQ7[O'#G]O!*mQ^O,5:jO'KwQ`O'#D[O!*mQ^O,5@gO'GzQ^O1G0rO'LRQ07bO'#ChO!*mQ^O1G1}O!&kQ7[O'#IoO'JVQ7[O'#IoO!&kQ7[O'#IqO'JVQ7[O'#IqO'L]QpO'#CqO!&kQ7[O,5<pO'JVQ7[O,5<pO'GzQ^O1G2OO!*mQ^O7+&yO!&kQ7[O1G2[O'JVQ7[O1G2[O!&kQ7[O'#IoO'JVQ7[O'#IoO!&kQ7[O'#IqO'JVQ7[O'#IqO!&kQ7[O1G2^O'JVQ7[O1G2^O'GzQ^O7+'jO'GzQ^O7+&^O!&kQ7[OANAdO'JVQ7[OANAdO'LpQWO'#ElO'LuQWO'#ElO'L}QWO'#F[O'MSQWO'#EvO'MXQWO'#J{O'MdQWO'#JyO'MoQWO,5;WO'MtQ7[O,5<cO'M{QWO'#GUO'NQQWO'#GUO'NVQWO,5<dO'N_QWO,5;WO'NgQ07bO1G1_O'NnQWO,5<pO'NsQWO,5<pO'NxQWO,5<rO'N}QWO,5<rO( SQWO1G2OO( XQWO1G0rO( ^Q7[O<<KxO( eQ7[O<<KxO7hQ7[O'#FyO9UQWO'#FxOAdQWO'#EkO!*mQ^O,5;sO!3mQWO'#GUO!3mQWO'#GUO!3mQWO'#GWO!3mQWO'#GWO!(ZQ7[O7+(^O!(ZQ7[O7+(^O%._QpO1G2rO%._QpO1G2rO!&kQ7[O,5=WO!&kQ7[O,5=W",
  stateData: "(!i~O'uOS'vOSSOS'wRQ~OPYOQYORfOX!VO`qOczOdyOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![XO!fuO!lZO!oYO!pYO!qYO!svO!uwO!xxO!|]O#t!PO$U|O%c}O%e!QO%g!OO%h!OO%i!OO%l!RO%n!SO%q!TO%r!TO%t!UO&Q!WO&W!XO&Y!YO&[!ZO&^![O&a!]O&g!^O&m!_O&o!`O&q!aO&s!bO&u!cO'|SO(OTO(RUO(YVO(h[O(viO~OVtO~P`OPYOQYORfOc!jOd!iOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![!eO!fuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$U!kO'|!dO(OTO(RUO(YVO(h[O(viO~O`!wOo!nO!P!oO!_!yO!`!vO!a!vO!|:lO#Q!pO#R!pO#S!xO#T!pO#U!pO#X!zO#Y!zO'}!lO(OTO(RUO(]!mO(h!sO~O'w!{O~OP[XZ[X`[Xn[X|[X}[X!P[X!Y[X!i[X!j[X!l[X!p[X#][X#heX#k[X#l[X#m[X#n[X#o[X#p[X#q[X#r[X#s[X#u[X#w[X#y[X#z[X$P[X's[X(Y[X(j[X(q[X(r[X~O!d$}X~P(qO^!}O(O#PO(P!}O(Q#PO~O^#QO(Q#PO(R#PO(S#QO~Ot#SO!R#TO(Z#TO([#VO~OPYOQYORfOc!jOd!iOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![!eO!fuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$U!kO'|:pO(OTO(RUO(YVO(h[O(viO~O!X#ZO!Y#WO!V(`P!V(nP~P+}O!Z#cO~P`OPYOQYORfOc!jOd!iOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![!eO!fuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$U!kO(OTO(RUO(YVO(h[O(viO~Ol#mO!X#iO!|]O#f#lO#g#iO'|:qO!k(kP~P.iO!l#oO'|#nO~O!x#sO!|]O%c#tO~O#h#uO~O!d#vO#h#uO~OP$^OZ$eOn$RO|#zO}#{O!P#|O!Y$bO!i$TO!j#xO!l#yO!p$^O#k$PO#l$QO#m$QO#n$QO#o$SO#p$TO#q$TO#r$dO#s$TO#u$UO#w$WO#y$YO#z$ZO(YVO(j$[O(q#}O(r$OO~O`(^X's(^X'q(^X!k(^X!V(^X![(^X%d(^X!d(^X~P1qO#]$fO$P$fOP(_XZ(_Xn(_X|(_X}(_X!P(_X!Y(_X!i(_X!l(_X!p(_X#k(_X#l(_X#m(_X#n(_X#o(_X#p(_X#q(_X#r(_X#s(_X#u(_X#w(_X#y(_X#z(_X(Y(_X(j(_X(q(_X(r(_X![(_X%d(_X~O`(_X!j(_X's(_X'q(_X!V(_X!k(_Xr(_X!d(_X~P4XO#]$fO~O$Z$hO$]$gO$d$mO~ORfO![$nO$g$oO$i$qO~Og%WOl%XOn$uOo$tOp$tOv%YOx%ZOz%[O!P$|O![$}O!f%aO!l$yO#g%bO$U%_O$p%]O$r%^O$u%`O'|$sO(OTO(RUO(Y$vO(q%OO(r%QOf(VP~O!l%cO~O!P%fO![%gO'|%eO~O!d%kO~O`%lO's%lO~O|%pO~P%[O'}!lO~P%[O%i%tO~P%[Og%WO!l%cO'|%eO'}!lO~Od%{O!l%cO'|%eO~O#s$TO~O|&QO![%}O!l&PO%e&TO'|%eO'}!lO(OTO(RUO_)PP~O!x#sO~O%n&VO!P({X![({X'|({X~O'|&WO~O!u&]O#t!PO%e!QO%g!OO%h!OO%i!OO%l!RO%n!SO%q!TO%r!TO~Oc&bOd&aO!x&_O%c&`O%v&^O~P<POc&eOdyO![&dO!u&]O!xxO!|]O#t!PO%c}O%g!OO%h!OO%i!OO%l!RO%n!SO%q!TO%r!TO%t!UO~Oa&hO#]&kO%e&fO'}!lO~P=UO!l&lO!u&pO~O!l#oO~O![XO~O`%lO'r&xO's%lO~O`%lO'r&{O's%lO~O`%lO'r&}O's%lO~O'q[X!V[Xr[X!k[X&U[X![[X%d[X!d[X~P(qO!_'[O!`'TO!a'TO'}!lO(OTO(RUO~Oo'RO!P'QO!X'UO(]'PO!Z(aP!Z(pP~P@]Oj'_O![']O'|%eO~Od'dO!l%cO'|%eO~O|&QO!l&PO~Oo!nO!P!oO!|:lO#Q!pO#R!pO#T!pO#U!pO'}!lO(OTO(RUO(]!mO(h!sO~O!_'jO!`'iO!a'iO#S!pO#X'kO#Y'kO~PAwO`%lOg%WO!d#vO!l%cO's%lO(j'mO~O!p'qO#]'oO~PCVOo!nO!P!oO(OTO(RUO(]!mO(h!sO~O![XOo(fX!P(fX!_(fX!`(fX!a(fX!|(fX#Q(fX#R(fX#S(fX#T(fX#U(fX#X(fX#Y(fX'}(fX(O(fX(R(fX(](fX(h(fX~O!`'iO!a'iO'}!lO~PCuO'x'uO'y'uO'z'wO~O^!}O(O'yO(P!}O(Q'yO~O^#QO(Q'yO(R'yO(S#QO~Ot#SO!R#TO(Z#TO(['}O~O!X(PO!V'QX!V'WX!Y'QX!Y'WX~P+}O!Y(RO!V(`X~OP$^OZ$eOn$RO|#zO}#{O!P#|O!Y(RO!i$TO!j#xO!l#yO!p$^O#k$PO#l$QO#m$QO#n$QO#o$SO#p$TO#q$TO#r$dO#s$TO#u$UO#w$WO#y$YO#z$ZO(YVO(j$[O(q#}O(r$OO~O!V(`X~PGiO!V(WO~O!V(mX!Y(mX!d(mX!k(mX(j(mX~O#](mX#h#aX!Z(mX~PIoO#](XO!V(oX!Y(oX~O!Y(YO!V(nX~O!V(]O~O#]$fO~PIoO!Z(^O~P`O|#zO}#{O!P#|O!j#xO!l#yO(YVOP!naZ!nan!na!Y!na!i!na!p!na#k!na#l!na#m!na#n!na#o!na#p!na#q!na#r!na#s!na#u!na#w!na#y!na#z!na(j!na(q!na(r!na~O`!na's!na'q!na!V!na!k!nar!na![!na%d!na!d!na~PKVO!k(_O~O!d#vO#](`O(j'mO!Y(lX`(lX's(lX~O!k(lX~PMuO!P%fO![%gO!|]O#f(eO#g(dO'|%eO~O!Y(fO!k(kX~O!k(hO~O!P%fO![%gO#g(dO'|%eO~OP(_XZ(_Xn(_X|(_X}(_X!P(_X!Y(_X!i(_X!j(_X!l(_X!p(_X#k(_X#l(_X#m(_X#n(_X#o(_X#p(_X#q(_X#r(_X#s(_X#u(_X#w(_X#y(_X#z(_X(Y(_X(j(_X(q(_X(r(_X~O!d#vO!k(_X~P! cO|(iO}(jO!j#xO!l#yO!|!{a!P!{a~O!x!{a%c!{a![!{a#f!{a#g!{a'|!{a~P!#gO!x(nO~OPYOQYORfOc!jOd!iOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![XO!fuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$U!kO'|!dO(OTO(RUO(YVO(h[O(viO~Og%WOl%XOn$uOo$tOp$tOv%YOx%ZOz;YO!P$|O![$}O!f<jO!l$yO#g;`O$U%_O$p;[O$r;^O$u%`O'|(rO(OTO(RUO(Y$vO(q%OO(r%QO~O#h(tO~Og%WOl%XOn$uOo$tOp$tOv%YOx%ZOz%[O!P$|O![$}O!f%aO!l$yO#g%bO$U%_O$p%]O$r%^O$u%`O'|(rO(OTO(RUO(Y$vO(q%OO(r%QO~Of(cP~P!(ZO!X(xO!k(dP~P%[O(](zO(h[O~O!P(|O!l#yO(](zO(h[O~OP:kOQ:kORfOc<fOd!iOlkOn:kOokOpkOvkOx:kOz:kO!PWO!TkO!UkO![!eO!f:nO!lZO!o:kO!p:kO!q:kO!s:oO!u:rO!x!hO$U!kO'|)[O(OTO(RUO(YVO(h[O(v<dO~O})_O!l#yO~O!Y$bO`$na's$na'q$na!k$na!V$na![$na%d$na!d$na~O#t)cO~P!&kO|)fO!d)eO![$[X$X$[X$Z$[X$]$[X$d$[X~O!d)eO![(sX$X(sX$Z(sX$](sX$d(sX~O|)fO~P!.VO|)fO![(sX$X(sX$Z(sX$](sX$d(sX~O![)hO$X)lO$Z)gO$])gO$d)mO~O!X)pO~P!*mO$Z$hO$]$gO$d)tO~Oj$vX|$vX!P$vX!j$vX(q$vX(r$vX~OfiXf$vXjiX!YiX#]iX~P!/{Oo)vO~Ot)wO(Z)xO([)zO~Oj*TO|)|O!P)}O(q%OO(r%QO~Of){O~P!1UOf*UO~Og%WOl%XOn$uOo$tOp$tOv%YOx%ZOz;YO!P*WO![*XO!f<jO!l$yO#g;`O$U%_O$p;[O$r;^O$u%`O(OTO(RUO(Y$vO(q%OO(r%QO~O!X*[O'|*VO!k(wP~P!1sO#h*^O~O!l*_O~Og%WOl%XOn$uOo$tOp$tOv%YOx%ZOz;YO!P$|O![$}O!f<jO!l$yO#g;`O$U%_O$p;[O$r;^O$u%`O'|*aO(OTO(RUO(Y$vO(q%OO(r%QO~O!X*dO!V(xP~P!3rOn*pO!P*hO!_*nO!`*gO!a*gO!l*_O#X*oO%Z*jO'}!lO(]!mO~O!Z*mO~P!5gO!j#xOj(XX|(XX!P(XX(q(XX(r(XX!Y(XX#](XX~Of(XX#}(XX~P!6`Oj*uO#]*tOf(WX!Y(WX~O!Y*vOf(VX~O'|&WOf(VP~O!l*}O~O'|(rO~Ol+RO!P%fO!X#iO![%gO!|]O#f#lO#g#iO'|%eO!k(kP~O!d#vO#h+SO~O!P%fO!X+UO!Y(YO![%gO'|%eO!V(nP~Oo'XO!P+WO!X+VO(OTO(RUO(](zO~O!Z(pP~P!9ZO!Y+XO`(|X's(|X~OP$^OZ$eOn$RO|#zO}#{O!P#|O!i$TO!j#xO!l#yO!p$^O#k$PO#l$QO#m$QO#n$QO#o$SO#p$TO#q$TO#r$dO#s$TO#u$UO#w$WO#y$YO#z$ZO(YVO(j$[O(q#}O(r$OO~O`!ga!Y!ga's!ga'q!ga!V!ga!k!gar!ga![!ga%d!ga!d!ga~P!:RO|#zO}#{O!P#|O!j#xO!l#yO(YVOP!raZ!ran!ra!Y!ra!i!ra!p!ra#k!ra#l!ra#m!ra#n!ra#o!ra#p!ra#q!ra#r!ra#s!ra#u!ra#w!ra#y!ra#z!ra(j!ra(q!ra(r!ra~O`!ra's!ra'q!ra!V!ra!k!rar!ra![!ra%d!ra!d!ra~P!<lO|#zO}#{O!P#|O!j#xO!l#yO(YVOP!taZ!tan!ta!Y!ta!i!ta!p!ta#k!ta#l!ta#m!ta#n!ta#o!ta#p!ta#q!ta#r!ta#s!ta#u!ta#w!ta#y!ta#z!ta(j!ta(q!ta(r!ta~O`!ta's!ta'q!ta!V!ta!k!tar!ta![!ta%d!ta!d!ta~P!?VOg%WOj+cO![']O%d+bO~O!d+eO`(UX![(UX's(UX!Y(UX~O`%lO![XO's%lO~Og%WO!l%cO~Og%WO!l%cO'|%eO~O!d#vO#h(tO~Oa+pO%e+qO'|+mO(OTO(RUO!Z)QP~O!Y+rO_)PX~OZ+vO~O_+wO~O![%}O'|%eO'}!lO_)PP~Og%WO#]+|O~Og%WOj,PO![$}O~O![,RO~O|,TO![XO~O%i%tO~O!x,YO~Od,_O~Oa,`O'|#nO(OTO(RUO!Z)OP~Od%{O~O%e!QO'|&WO~P=UOZ,eO_,dO~OPYOQYORfOczOdyOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO!fuO!lZO!oYO!pYO!qYO!svO!xxO!|]O%c}O(OTO(RUO(YVO(h[O(viO~O![!eO!u!gO$U!kO'|!dO~P!FYO_,dO`%lO's%lO~OPYOQYORfOc!jOd!iOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![!eO!fuO!lZO!oYO!pYO!qYO!svO!x!hO$U!kO'|!dO(OTO(RUO(YVO(h[O(viO~O`,jO!uwO#t!OO%g!OO%h!OO%i!OO~P!HrO!l&lO~O&W,pO~O![,rO~O&i,tO&k,uOP&faQ&faR&faX&fa`&fac&fad&fal&fan&fao&fap&fav&fax&faz&fa!P&fa!T&fa!U&fa![&fa!f&fa!l&fa!o&fa!p&fa!q&fa!s&fa!u&fa!x&fa!|&fa#t&fa$U&fa%c&fa%e&fa%g&fa%h&fa%i&fa%l&fa%n&fa%q&fa%r&fa%t&fa&Q&fa&W&fa&Y&fa&[&fa&^&fa&a&fa&g&fa&m&fa&o&fa&q&fa&s&fa&u&fa'q&fa'|&fa(O&fa(R&fa(Y&fa(h&fa(v&fa!Z&fa&_&faa&fa&d&fa~O'|,zO~Og!bX!Y!OX!Z!OX!d!OX!d!bX!l!bX#]!OX~O!Y!bX!Z!bX~P# xO!d-PO#]-OOg(bX!Y#eX!Y(bX!Z#eX!Z(bX!d(bX!l(bX~Og%WO!d-RO!l%cO!Y!^X!Z!^X~Oo!nO!P!oO(OTO(RUO(]!mO~OP:kOQ:kORfOc<fOd!iOlkOn:kOokOpkOvkOx:kOz:kO!PWO!TkO!UkO![!eO!f:nO!lZO!o:kO!p:kO!q:kO!s:oO!u:rO!x!hO$U!kO(OTO(RUO(YVO(h[O(v<dO~O'|;fO~P##|O!Y-VO!Z(aX~O!Z-XO~O!d-PO#]-OO!Y#eX!Z#eX~O!Y-YO!Z(pX~O!Z-[O~O!`-]O!a-]O'}!lO~P##kO!Z-`O~P'_Oj-cO![']O~O!V-hO~Oo!{a!_!{a!`!{a!a!{a#Q!{a#R!{a#S!{a#T!{a#U!{a#X!{a#Y!{a'}!{a(O!{a(R!{a(]!{a(h!{a~P!#gO!p-mO#]-kO~PCVO!`-oO!a-oO'}!lO~PCuO`%lO#]-kO's%lO~O`%lO!d#vO#]-kO's%lO~O`%lO!d#vO!p-mO#]-kO's%lO(j'mO~O'x'uO'y'uO'z-tO~Or-uO~O!V'Qa!Y'Qa~P!:RO!X-yO!V'QX!Y'QX~P%[O!Y(RO!V(`a~O!V(`a~PGiO!Y(YO!V(na~O!P%fO!X-}O![%gO'|%eO!V'WX!Y'WX~O#].PO!Y(la!k(la`(la's(la~O!d#vO~P#,SO!Y(fO!k(ka~O!P%fO![%gO#g.TO'|%eO~Ol.YO!P%fO!X.VO![%gO!|]O#f.XO#g.VO'|%eO!Y'ZX!k'ZX~O}.^O!l#yO~Og%WOj.aO![']O%d.`O~O`#`i!Y#`i's#`i'q#`i!V#`i!k#`ir#`i![#`i%d#`i!d#`i~P!:ROj<pO|)|O!P)}O(q%OO(r%QO~O#h#[a`#[a#]#[a's#[a!Y#[a!k#[a![#[a!V#[a~P#/OO#h(XXP(XXZ(XX`(XXn(XX}(XX!i(XX!l(XX!p(XX#k(XX#l(XX#m(XX#n(XX#o(XX#p(XX#q(XX#r(XX#s(XX#u(XX#w(XX#y(XX#z(XX's(XX(Y(XX(j(XX!k(XX!V(XX'q(XXr(XX![(XX%d(XX!d(XX~P!6`O!Y.nOf(cX~P!1UOf.pO~O!Y.qO!k(dX~P!:RO!k.tO~O!V.vO~OP$^O|#zO}#{O!P#|O!j#xO!l#yO!p$^O(YVOZ#ji`#jin#ji!Y#ji!i#ji#l#ji#m#ji#n#ji#o#ji#p#ji#q#ji#r#ji#s#ji#u#ji#w#ji#y#ji#z#ji's#ji(j#ji(q#ji(r#ji'q#ji!V#ji!k#jir#ji![#ji%d#ji!d#ji~O#k#ji~P#2zO#k$PO~P#2zOP$^O|#zO}#{O!P#|O!j#xO!l#yO!p$^O#k$PO#l$QO#m$QO#n$QO(YVOZ#ji`#ji!Y#ji!i#ji#o#ji#p#ji#q#ji#r#ji#s#ji#u#ji#w#ji#y#ji#z#ji's#ji(j#ji(q#ji(r#ji'q#ji!V#ji!k#jir#ji![#ji%d#ji!d#ji~On#ji~P#5lOn$RO~P#5lOP$^On$RO|#zO}#{O!P#|O!j#xO!l#yO!p$^O#k$PO#l$QO#m$QO#n$QO#o$SO(YVO`#ji!Y#ji#u#ji#w#ji#y#ji#z#ji's#ji(j#ji(q#ji(r#ji'q#ji!V#ji!k#jir#ji![#ji%d#ji!d#ji~OZ#ji!i#ji#p#ji#q#ji#r#ji#s#ji~P#8^OZ$eO!i$TO#p$TO#q$TO#r$dO#s$TO~P#8^OP$^OZ$eOn$RO|#zO}#{O!P#|O!i$TO!j#xO!l#yO!p$^O#k$PO#l$QO#m$QO#n$QO#o$SO#p$TO#q$TO#r$dO#s$TO#u$UO(YVO(r$OO`#ji!Y#ji#y#ji#z#ji's#ji(j#ji(q#ji'q#ji!V#ji!k#jir#ji![#ji%d#ji!d#ji~O#w$WO~P#;_O#w#ji~P#;_OP$^OZ$eOn$RO|#zO}#{O!P#|O!i$TO!j#xO!l#yO!p$^O#k$PO#l$QO#m$QO#n$QO#o$SO#p$TO#q$TO#r$dO#s$TO#u$UO(YVO`#ji!Y#ji#y#ji#z#ji's#ji(j#ji'q#ji!V#ji!k#jir#ji![#ji%d#ji!d#ji~O#w#ji(q#ji(r#ji~P#>PO#w$WO(q#}O(r$OO~P#>POP$^OZ$eOn$RO|#zO}#{O!P#|O!i$TO!j#xO!l#yO!p$^O#k$PO#l$QO#m$QO#n$QO#o$SO#p$TO#q$TO#r$dO#s$TO#u$UO#w$WO#y$YO(YVO(q#}O(r$OO~O`#ji!Y#ji#z#ji's#ji(j#ji'q#ji!V#ji!k#jir#ji![#ji%d#ji!d#ji~P#@wOP[XZ[Xn[X|[X}[X!P[X!i[X!j[X!l[X!p[X#][X#heX#k[X#l[X#m[X#n[X#o[X#p[X#q[X#r[X#s[X#u[X#w[X#y[X#z[X$P[X(Y[X(j[X(q[X(r[X!Y[X!Z[X~O#}[X~P#CbOP$^OZ;SOn:vO|#zO}#{O!P#|O!i:xO!j#xO!l#yO!p$^O#k:tO#l:uO#m:uO#n:uO#o:wO#p:xO#q:xO#r;RO#s:xO#u:yO#w:{O#y:}O#z;OO(YVO(j$[O(q#}O(r$OO~O#}.xO~P#EoO#];TO$P;TO#}(_X!Z(_X~P! cO`'^a!Y'^a's'^a'q'^a!k'^a!V'^ar'^a!['^a%d'^a!d'^a~P!:ROP#jiZ#ji`#jin#ji}#ji!Y#ji!i#ji!j#ji!l#ji!p#ji#k#ji#l#ji#m#ji#n#ji#o#ji#p#ji#q#ji#r#ji#s#ji#u#ji#w#ji#y#ji#z#ji's#ji(Y#ji(j#ji'q#ji!V#ji!k#jir#ji![#ji%d#ji!d#ji~P#/OO`$Oi!Y$Oi's$Oi'q$Oi!V$Oi!k$Oir$Oi![$Oi%d$Oi!d$Oi~P!:RO$Z.}O$].}O~O$Z/OO$]/OO~O!d)eO#]/PO![$aX$X$aX$Z$aX$]$aX$d$aX~O!X/QO~O![)hO$X/SO$Z)gO$])gO$d/TO~O!Y;PO!Z(^X~P#EoO!Z/UO~O!d)eO$d(sX~O$d/WO~Ot)wO(Z)xO([/ZO~O!V/_O~P!&kO(q%OOj%[a|%[a!P%[a(r%[a!Y%[a#]%[a~Of%[a#}%[a~P#NPO(r%QOj%^a|%^a!P%^a(q%^a!Y%^a#]%^a~Of%^a#}%^a~P#NrO!YeX!deX!keX!k$vX(jeX~P!/{O!X/hO!Y(YO'|/gO!V(nP!V(xP~P!1sOn*pO!_*nO!`*gO!a*gO!l*_O#X*oO%Z*jO'}!lO~Oo'XO!P/iO!X+VO!Z*mO(OTO(RUO(];cO!Z(pP~P$!]O!k/jO~P#/OO!Y/kO!d#vO(j'mO!k(wX~O!k/pO~O!P%fO!X*[O![%gO'|%eO!k(wP~O#h/rO~O!V$vX!Y$vX!d$}X~P!/{O!Y/sO!V(xX~P#/OO!d/uO~O!V/wO~Og%WOn/{O!d#vO!l%cO(j'mO~O'|/}O~O!d+eO~O`%lO!Y0RO's%lO~O!Z0TO~P!5gO!`0UO!a0UO'}!lO(]!mO~O!P0WO(]!mO~O#X0XO~Of%[a!Y%[a#]%[a#}%[a~P!1UOf%^a!Y%^a#]%^a#}%^a~P!1UO'|&WOf'gX!Y'gX~O!Y*vOf(Va~Of0bO~O|0cO}0cO!P0dOjya(qya(rya!Yya#]ya~Ofya#}ya~P$(OO|)|O!P)}Oj$oa(q$oa(r$oa!Y$oa#]$oa~Of$oa#}$oa~P$(tO|)|O!P)}Oj$qa(q$qa(r$qa!Y$qa#]$qa~Of$qa#}$qa~P$)gO#h0fO~Of%Pa!Y%Pa#]%Pa#}%Pa~P!1UO!d#vO~O#h0iO~O!Y+XO`(|a's(|a~O|#zO}#{O!P#|O!j#xO!l#yO(YVOP!riZ!rin!ri!Y!ri!i!ri!p!ri#k!ri#l!ri#m!ri#n!ri#o!ri#p!ri#q!ri#r!ri#s!ri#u!ri#w!ri#y!ri#z!ri(j!ri(q!ri(r!ri~O`!ri's!ri'q!ri!V!ri!k!rir!ri![!ri%d!ri!d!ri~P$+UOg%WOn$uOo$tOp$tOv%YOx%ZOz;YO!P$|O![$}O!f<jO!l$yO#g;`O$U%_O$p;[O$r;^O$u%`O(OTO(RUO(Y$vO(q%OO(r%QO~Ol0sO'|0rO~P$-oO!d+eO`(Ua![(Ua's(Ua!Y(Ua~O#h0yO~OZ[X!YeX!ZeX~O!Y0zO!Z)QX~O!Z0|O~OZ0}O~Oa1PO'|+mO(OTO(RUO~O![%}O'|%eO_'oX!Y'oX~O!Y+rO_)Pa~O!k1SO~P!:ROZ1VO~O_1WO~O#]1ZO~Oj1^O![$}O~O(](zO!Z(}P~Og%WOj1gO![1dO%d1fO~OZ1qO!Y1oO!Z)OX~O!Z1rO~O_1tO`%lO's%lO~O'|#nO(OTO(RUO~O#]$fO$P$fOP(_XZ(_Xn(_X|(_X}(_X!P(_X!Y(_X!i(_X!l(_X!p(_X#k(_X#l(_X#m(_X#n(_X#o(_X#p(_X#q(_X#r(_X#u(_X#w(_X#y(_X#z(_X(Y(_X(j(_X(q(_X(r(_X~O#s1wO&U1xO`(_X!j(_X~P$3VO#]$fO#s1wO&U1xO~O`1zO~P%[O`1|O~O&_2POP&]iQ&]iR&]iX&]i`&]ic&]id&]il&]in&]io&]ip&]iv&]ix&]iz&]i!P&]i!T&]i!U&]i![&]i!f&]i!l&]i!o&]i!p&]i!q&]i!s&]i!u&]i!x&]i!|&]i#t&]i$U&]i%c&]i%e&]i%g&]i%h&]i%i&]i%l&]i%n&]i%q&]i%r&]i%t&]i&Q&]i&W&]i&Y&]i&[&]i&^&]i&a&]i&g&]i&m&]i&o&]i&q&]i&s&]i&u&]i'q&]i'|&]i(O&]i(R&]i(Y&]i(h&]i(v&]i!Z&]ia&]i&d&]i~Oa2VO!Z2TO&d2UO~P`O![XO!l2XO~O&k,uOP&fiQ&fiR&fiX&fi`&fic&fid&fil&fin&fio&fip&fiv&fix&fiz&fi!P&fi!T&fi!U&fi![&fi!f&fi!l&fi!o&fi!p&fi!q&fi!s&fi!u&fi!x&fi!|&fi#t&fi$U&fi%c&fi%e&fi%g&fi%h&fi%i&fi%l&fi%n&fi%q&fi%r&fi%t&fi&Q&fi&W&fi&Y&fi&[&fi&^&fi&a&fi&g&fi&m&fi&o&fi&q&fi&s&fi&u&fi'q&fi'|&fi(O&fi(R&fi(Y&fi(h&fi(v&fi!Z&fi&_&fia&fi&d&fi~O!V2_O~O!Y!^a!Z!^a~P#EoOo!nO!P!oO!X2eO(]!mO!Y'RX!Z'RX~P@]O!Y-VO!Z(aa~O!Y'XX!Z'XX~P!9ZO!Y-YO!Z(pa~O!Z2lO~P'_O`%lO#]2uO's%lO~O`%lO!d#vO#]2uO's%lO~O`%lO!d#vO!p2yO#]2uO's%lO(j'mO~O`%lO's%lO~P!:RO!Y$bOr$na~O!V'Qi!Y'Qi~P!:RO!Y(RO!V(`i~O!Y(YO!V(ni~O!V(oi!Y(oi~P!:RO!Y(li!k(li`(li's(li~P!:RO#]2{O!Y(li!k(li`(li's(li~O!Y(fO!k(ki~O!P%fO![%gO!|]O#f3QO#g3PO'|%eO~O!P%fO![%gO#g3PO'|%eO~Oj3XO![']O%d3WO~Og%WOj3XO![']O%d3WO~O#h%[aP%[aZ%[a`%[an%[a}%[a!i%[a!j%[a!l%[a!p%[a#k%[a#l%[a#m%[a#n%[a#o%[a#p%[a#q%[a#r%[a#s%[a#u%[a#w%[a#y%[a#z%[a's%[a(Y%[a(j%[a!k%[a!V%[a'q%[ar%[a![%[a%d%[a!d%[a~P#NPO#h%^aP%^aZ%^a`%^an%^a}%^a!i%^a!j%^a!l%^a!p%^a#k%^a#l%^a#m%^a#n%^a#o%^a#p%^a#q%^a#r%^a#s%^a#u%^a#w%^a#y%^a#z%^a's%^a(Y%^a(j%^a!k%^a!V%^a'q%^ar%^a![%^a%d%^a!d%^a~P#NrO#h%[aP%[aZ%[a`%[an%[a}%[a!Y%[a!i%[a!j%[a!l%[a!p%[a#k%[a#l%[a#m%[a#n%[a#o%[a#p%[a#q%[a#r%[a#s%[a#u%[a#w%[a#y%[a#z%[a's%[a(Y%[a(j%[a!k%[a!V%[a'q%[a#]%[ar%[a![%[a%d%[a!d%[a~P#/OO#h%^aP%^aZ%^a`%^an%^a}%^a!Y%^a!i%^a!j%^a!l%^a!p%^a#k%^a#l%^a#m%^a#n%^a#o%^a#p%^a#q%^a#r%^a#s%^a#u%^a#w%^a#y%^a#z%^a's%^a(Y%^a(j%^a!k%^a!V%^a'q%^a#]%^ar%^a![%^a%d%^a!d%^a~P#/OO#hyaPyaZya`yanya!iya!jya!lya!pya#kya#lya#mya#nya#oya#pya#qya#rya#sya#uya#wya#yya#zya'sya(Yya(jya!kya!Vya'qyarya![ya%dya!dya~P$(OO#h$oaP$oaZ$oa`$oan$oa}$oa!i$oa!j$oa!l$oa!p$oa#k$oa#l$oa#m$oa#n$oa#o$oa#p$oa#q$oa#r$oa#s$oa#u$oa#w$oa#y$oa#z$oa's$oa(Y$oa(j$oa!k$oa!V$oa'q$oar$oa![$oa%d$oa!d$oa~P$(tO#h$qaP$qaZ$qa`$qan$qa}$qa!i$qa!j$qa!l$qa!p$qa#k$qa#l$qa#m$qa#n$qa#o$qa#p$qa#q$qa#r$qa#s$qa#u$qa#w$qa#y$qa#z$qa's$qa(Y$qa(j$qa!k$qa!V$qa'q$qar$qa![$qa%d$qa!d$qa~P$)gO#h%PaP%PaZ%Pa`%Pan%Pa}%Pa!Y%Pa!i%Pa!j%Pa!l%Pa!p%Pa#k%Pa#l%Pa#m%Pa#n%Pa#o%Pa#p%Pa#q%Pa#r%Pa#s%Pa#u%Pa#w%Pa#y%Pa#z%Pa's%Pa(Y%Pa(j%Pa!k%Pa!V%Pa'q%Pa#]%Par%Pa![%Pa%d%Pa!d%Pa~P#/OO`#`q!Y#`q's#`q'q#`q!V#`q!k#`qr#`q![#`q%d#`q!d#`q~P!:ROf'SX!Y'SX~P!(ZO!Y.nOf(ca~O!X3cO!Y'TX!k'TX~P%[O!Y.qO!k(da~O!Y.qO!k(da~P!:RO!V3fO~O#}!na!Z!na~PKVO#}!ga!Y!ga!Z!ga~P#EoO#}!ra!Z!ra~P!<lO#}!ta!Z!ta~P!?VORfO![3xO$b3yO~O!Z3}O~Or4OO~P#/OO`$kq!Y$kq's$kq'q$kq!V$kq!k$kqr$kq![$kq%d$kq!d$kq~P!:RO!V4PO~P#/OO|)|O!P)}O(r%QOj'ca(q'ca!Y'ca#]'ca~Of'ca#}'ca~P%,yO|)|O!P)}Oj'ea(q'ea(r'ea!Y'ea#]'ea~Of'ea#}'ea~P%-lO(j$[O~P#/OO!VeX!V$vX!YeX!Y$vX!d$}X#]eX~P!/{O'|;lO~P!1sOlkO'|4RO~P.iO!P%fO!X4TO![%gO'|%eO!Y'_X!k'_X~O!Y/kO!k(wa~O!Y/kO!d#vO!k(wa~O!Y/kO!d#vO(j'mO!k(wa~Of$xi!Y$xi#]$xi#}$xi~P!1UO!X4]O!V'aX!Y'aX~P!3rO!Y/sO!V(xa~O!Y/sO!V(xa~P#/OO!d#vO#s4eO~On4hO!d#vO(j'mO~O(q%OOj%[i|%[i!P%[i(r%[i!Y%[i#]%[i~Of%[i#}%[i~P%1zO(r%QOj%^i|%^i!P%^i(q%^i!Y%^i#]%^i~Of%^i#}%^i~P%2mOf(Wi!Y(Wi~P!1UO#]4oOf(Wi!Y(Wi~P!1UO!k4rO~O`$lq!Y$lq's$lq'q$lq!V$lq!k$lqr$lq![$lq%d$lq!d$lq~P!:RO!V4vO~O!Y4wO![(yX~P#/OO!j#xO~P4XO`$vX![$vX%X[X's$vX!Y$vX~P!/{O%X4yO`kXjkX|kX!PkX![kX'skX(qkX(rkX!YkX~O%X4yO~Oa5PO%e5QO'|+mO(OTO(RUO!Y'nX!Z'nX~O!Y0zO!Z)Qa~OZ5UO~O_5VO~O`%lO's%lO~P#/OO![$}O~P#/OO!Y5_O#]5aO!Z(}X~O!Z5bO~Oo!nO!P5cO!_!yO!`!vO!a!vO!|:lO#Q!pO#R!pO#S!pO#T!pO#U!pO#X5hO#Y!zO'}!lO(OTO(RUO(]!mO(h!sO~O!Z5gO~P%8OOj5mO![1dO%d5lO~Og%WOj5mO![1dO%d5lO~Oa5tO'|#nO(OTO(RUO!Y'mX!Z'mX~O!Y1oO!Z)Oa~O(OTO(RUO(]5vO~O_5zO~O#s5}O&U6OO~PMuO!k6PO~P%[O`6RO~O`6RO~P%[Oa2VO!Z6WO&d2UO~P`O!d6YO~O!d6[Og(bi!Y(bi!Z(bi!d(bi!l(bi~O!Y#ei!Z#ei~P#EoO#]6]O!Y#ei!Z#ei~O!Y!^i!Z!^i~P#EoO`%lO#]6fO's%lO~O`%lO!d#vO#]6fO's%lO~O!Y(lq!k(lq`(lq's(lq~P!:RO!Y(fO!k(kq~O!P%fO![%gO#g6mO'|%eO~O![']O%d6pO~Oj6sO![']O%d6pO~O#h'caP'caZ'ca`'can'ca}'ca!i'ca!j'ca!l'ca!p'ca#k'ca#l'ca#m'ca#n'ca#o'ca#p'ca#q'ca#r'ca#s'ca#u'ca#w'ca#y'ca#z'ca's'ca(Y'ca(j'ca!k'ca!V'ca'q'car'ca!['ca%d'ca!d'ca~P%,yO#h'eaP'eaZ'ea`'ean'ea}'ea!i'ea!j'ea!l'ea!p'ea#k'ea#l'ea#m'ea#n'ea#o'ea#p'ea#q'ea#r'ea#s'ea#u'ea#w'ea#y'ea#z'ea's'ea(Y'ea(j'ea!k'ea!V'ea'q'ear'ea!['ea%d'ea!d'ea~P%-lO#h$xiP$xiZ$xi`$xin$xi}$xi!Y$xi!i$xi!j$xi!l$xi!p$xi#k$xi#l$xi#m$xi#n$xi#o$xi#p$xi#q$xi#r$xi#s$xi#u$xi#w$xi#y$xi#z$xi's$xi(Y$xi(j$xi!k$xi!V$xi'q$xi#]$xir$xi![$xi%d$xi!d$xi~P#/OO#h%[iP%[iZ%[i`%[in%[i}%[i!i%[i!j%[i!l%[i!p%[i#k%[i#l%[i#m%[i#n%[i#o%[i#p%[i#q%[i#r%[i#s%[i#u%[i#w%[i#y%[i#z%[i's%[i(Y%[i(j%[i!k%[i!V%[i'q%[ir%[i![%[i%d%[i!d%[i~P%1zO#h%^iP%^iZ%^i`%^in%^i}%^i!i%^i!j%^i!l%^i!p%^i#k%^i#l%^i#m%^i#n%^i#o%^i#p%^i#q%^i#r%^i#s%^i#u%^i#w%^i#y%^i#z%^i's%^i(Y%^i(j%^i!k%^i!V%^i'q%^ir%^i![%^i%d%^i!d%^i~P%2mOf'Sa!Y'Sa~P!1UO!Y'Ta!k'Ta~P!:RO!Y.qO!k(di~O#}#`i!Y#`i!Z#`i~P#EoOP$^O|#zO}#{O!P#|O!j#xO!l#yO!p$^O(YVOZ#jin#ji!i#ji#l#ji#m#ji#n#ji#o#ji#p#ji#q#ji#r#ji#s#ji#u#ji#w#ji#y#ji#z#ji#}#ji(j#ji(q#ji(r#ji!Y#ji!Z#ji~O#k#ji~P%KOO#k:tO~P%KOOP$^O|#zO}#{O!P#|O!j#xO!l#yO!p$^O#k:tO#l:uO#m:uO#n:uO(YVOZ#ji!i#ji#o#ji#p#ji#q#ji#r#ji#s#ji#u#ji#w#ji#y#ji#z#ji#}#ji(j#ji(q#ji(r#ji!Y#ji!Z#ji~On#ji~P%MZOn:vO~P%MZOP$^On:vO|#zO}#{O!P#|O!j#xO!l#yO!p$^O#k:tO#l:uO#m:uO#n:uO#o:wO(YVO#u#ji#w#ji#y#ji#z#ji#}#ji(j#ji(q#ji(r#ji!Y#ji!Z#ji~OZ#ji!i#ji#p#ji#q#ji#r#ji#s#ji~P& fOZ;SO!i:xO#p:xO#q:xO#r;RO#s:xO~P& fOP$^OZ;SOn:vO|#zO}#{O!P#|O!i:xO!j#xO!l#yO!p$^O#k:tO#l:uO#m:uO#n:uO#o:wO#p:xO#q:xO#r;RO#s:xO#u:yO(YVO(r$OO#y#ji#z#ji#}#ji(j#ji(q#ji!Y#ji!Z#ji~O#w:{O~P&$QO#w#ji~P&$QOP$^OZ;SOn:vO|#zO}#{O!P#|O!i:xO!j#xO!l#yO!p$^O#k:tO#l:uO#m:uO#n:uO#o:wO#p:xO#q:xO#r;RO#s:xO#u:yO(YVO#y#ji#z#ji#}#ji(j#ji!Y#ji!Z#ji~O#w#ji(q#ji(r#ji~P&&]O#w:{O(q#}O(r$OO~P&&]OP$^OZ;SOn:vO|#zO}#{O!P#|O!i:xO!j#xO!l#yO!p$^O#k:tO#l:uO#m:uO#n:uO#o:wO#p:xO#q:xO#r;RO#s:xO#u:yO#w:{O#y:}O(YVO(q#}O(r$OO~O#z#ji#}#ji(j#ji!Y#ji!Z#ji~P&(nO`#{y!Y#{y's#{y'q#{y!V#{y!k#{yr#{y![#{y%d#{y!d#{y~P!:ROj<qO|)|O!P)}O(q%OO(r%QO~OP#jiZ#jin#ji}#ji!i#ji!j#ji!l#ji!p#ji#k#ji#l#ji#m#ji#n#ji#o#ji#p#ji#q#ji#r#ji#s#ji#u#ji#w#ji#y#ji#z#ji#}#ji(Y#ji(j#ji!Y#ji!Z#ji~P&+fO!j#xOP(XXZ(XXj(XXn(XX|(XX}(XX!P(XX!i(XX!l(XX!p(XX#k(XX#l(XX#m(XX#n(XX#o(XX#p(XX#q(XX#r(XX#s(XX#u(XX#w(XX#y(XX#z(XX#}(XX(Y(XX(j(XX(q(XX(r(XX!Y(XX!Z(XX~O#}$Oi!Y$Oi!Z$Oi~P#EoO#}!ri!Z!ri~P$+UO!Z7VO~O!Y'^a!Z'^a~P#EoOP[XZ[Xn[X|[X}[X!P[X!V[X!Y[X!i[X!j[X!l[X!p[X#][X#heX#k[X#l[X#m[X#n[X#o[X#p[X#q[X#r[X#s[X#u[X#w[X#y[X#z[X$P[X(Y[X(j[X(q[X(r[X~O!d%UX#s%UX~P&0hO!d#vO(j'mO!Y'_a!k'_a~O!Y/kO!k(wi~O!Y/kO!d#vO!k(wi~Of$xq!Y$xq#]$xq#}$xq~P!1UO!V'aa!Y'aa~P#/OO!d7^O~O!Y/sO!V(xi~P#/OO!Y/sO!V(xi~O!V7bO~O!d#vO#s7gO~On7hO!d#vO(j'mO~O|)|O!P)}O(r%QOj'da(q'da!Y'da#]'da~Of'da#}'da~P&5WO|)|O!P)}Oj'fa(q'fa(r'fa!Y'fa#]'fa~Of'fa#}'fa~P&5yO!V7jO~Of$zq!Y$zq#]$zq#}$zq~P!1UO`$ly!Y$ly's$ly'q$ly!V$ly!k$lyr$ly![$ly%d$ly!d$ly~P!:RO!d6[O~O!Y4wO![(ya~O`#`y!Y#`y's#`y'q#`y!V#`y!k#`yr#`y![#`y%d#`y!d#`y~P!:ROZ7oO~Oa7qO'|+mO(OTO(RUO~O!Y0zO!Z)Qi~O_7uO~O(](zO!Y'jX!Z'jX~O!Y5_O!Z(}a~O!Z8OO~P%8OOo!nO!P8PO(OTO(RUO(]!mO(h!sO~O![1dO~O![1dO%d8RO~Oj8UO![1dO%d8RO~OZ8ZO!Y'ma!Z'ma~O!Y1oO!Z)Oi~O!k8_O~O!k8`O~O!k8cO~O!k8cO~P%[O`8eO~O!d8fO~O!k8gO~O!Y(oi!Z(oi~P#EoO`%lO#]8oO's%lO~O!Y(ly!k(ly`(ly's(ly~P!:RO!Y(fO!k(ky~O![']O%d8rO~O#h$xqP$xqZ$xq`$xqn$xq}$xq!Y$xq!i$xq!j$xq!l$xq!p$xq#k$xq#l$xq#m$xq#n$xq#o$xq#p$xq#q$xq#r$xq#s$xq#u$xq#w$xq#y$xq#z$xq's$xq(Y$xq(j$xq!k$xq!V$xq'q$xq#]$xqr$xq![$xq%d$xq!d$xq~P#/OO#h'daP'daZ'da`'dan'da}'da!i'da!j'da!l'da!p'da#k'da#l'da#m'da#n'da#o'da#p'da#q'da#r'da#s'da#u'da#w'da#y'da#z'da's'da(Y'da(j'da!k'da!V'da'q'dar'da!['da%d'da!d'da~P&5WO#h'faP'faZ'fa`'fan'fa}'fa!i'fa!j'fa!l'fa!p'fa#k'fa#l'fa#m'fa#n'fa#o'fa#p'fa#q'fa#r'fa#s'fa#u'fa#w'fa#y'fa#z'fa's'fa(Y'fa(j'fa!k'fa!V'fa'q'far'fa!['fa%d'fa!d'fa~P&5yO#h$zqP$zqZ$zq`$zqn$zq}$zq!Y$zq!i$zq!j$zq!l$zq!p$zq#k$zq#l$zq#m$zq#n$zq#o$zq#p$zq#q$zq#r$zq#s$zq#u$zq#w$zq#y$zq#z$zq's$zq(Y$zq(j$zq!k$zq!V$zq'q$zq#]$zqr$zq![$zq%d$zq!d$zq~P#/OO!Y'Ti!k'Ti~P!:RO#}#`q!Y#`q!Z#`q~P#EoO(q%OOP%[aZ%[an%[a}%[a!i%[a!j%[a!l%[a!p%[a#k%[a#l%[a#m%[a#n%[a#o%[a#p%[a#q%[a#r%[a#s%[a#u%[a#w%[a#y%[a#z%[a#}%[a(Y%[a(j%[a!Y%[a!Z%[a~Oj%[a|%[a!P%[a(r%[a~P&GUO(r%QOP%^aZ%^an%^a}%^a!i%^a!j%^a!l%^a!p%^a#k%^a#l%^a#m%^a#n%^a#o%^a#p%^a#q%^a#r%^a#s%^a#u%^a#w%^a#y%^a#z%^a#}%^a(Y%^a(j%^a!Y%^a!Z%^a~Oj%^a|%^a!P%^a(q%^a~P&I]Oj<qO|)|O!P)}O(r%QO~P&GUOj<qO|)|O!P)}O(q%OO~P&I]O|0cO}0cO!P0dOPyaZyajyanya!iya!jya!lya!pya#kya#lya#mya#nya#oya#pya#qya#rya#sya#uya#wya#yya#zya#}ya(Yya(jya(qya(rya!Yya!Zya~O|)|O!P)}OP$oaZ$oaj$oan$oa}$oa!i$oa!j$oa!l$oa!p$oa#k$oa#l$oa#m$oa#n$oa#o$oa#p$oa#q$oa#r$oa#s$oa#u$oa#w$oa#y$oa#z$oa#}$oa(Y$oa(j$oa(q$oa(r$oa!Y$oa!Z$oa~O|)|O!P)}OP$qaZ$qaj$qan$qa}$qa!i$qa!j$qa!l$qa!p$qa#k$qa#l$qa#m$qa#n$qa#o$qa#p$qa#q$qa#r$qa#s$qa#u$qa#w$qa#y$qa#z$qa#}$qa(Y$qa(j$qa(q$qa(r$qa!Y$qa!Z$qa~OP%PaZ%Pan%Pa}%Pa!i%Pa!j%Pa!l%Pa!p%Pa#k%Pa#l%Pa#m%Pa#n%Pa#o%Pa#p%Pa#q%Pa#r%Pa#s%Pa#u%Pa#w%Pa#y%Pa#z%Pa#}%Pa(Y%Pa(j%Pa!Y%Pa!Z%Pa~P&+fO#}$kq!Y$kq!Z$kq~P#EoO#}$lq!Y$lq!Z$lq~P#EoO!Z9OO~O#}9PO~P!1UO!d#vO!Y'_i!k'_i~O!d#vO(j'mO!Y'_i!k'_i~O!Y/kO!k(wq~O!V'ai!Y'ai~P#/OO!Y/sO!V(xq~O!V9VO~P#/OO!V9VO~Of(Wy!Y(Wy~P!1UO!Y'ha!['ha~P#/OO`%Wq![%Wq's%Wq!Y%Wq~P#/OOZ9[O~O!Y0zO!Z)Qq~O#]9`O!Y'ja!Z'ja~O!Y5_O!Z(}i~P#EoO![1dO%d9dO~O(OTO(RUO(]9iO~O!Y1oO!Z)Oq~O!k9lO~O!k9mO~O!k9nO~O!k9nO~P%[O#]9qO!Y#ey!Z#ey~O!Y#ey!Z#ey~P#EoO![']O%d9vO~O#}#{y!Y#{y!Z#{y~P#EoOP$xiZ$xin$xi}$xi!i$xi!j$xi!l$xi!p$xi#k$xi#l$xi#m$xi#n$xi#o$xi#p$xi#q$xi#r$xi#s$xi#u$xi#w$xi#y$xi#z$xi#}$xi(Y$xi(j$xi!Y$xi!Z$xi~P&+fO|)|O!P)}O(r%QOP'caZ'caj'can'ca}'ca!i'ca!j'ca!l'ca!p'ca#k'ca#l'ca#m'ca#n'ca#o'ca#p'ca#q'ca#r'ca#s'ca#u'ca#w'ca#y'ca#z'ca#}'ca(Y'ca(j'ca(q'ca!Y'ca!Z'ca~O|)|O!P)}OP'eaZ'eaj'ean'ea}'ea!i'ea!j'ea!l'ea!p'ea#k'ea#l'ea#m'ea#n'ea#o'ea#p'ea#q'ea#r'ea#s'ea#u'ea#w'ea#y'ea#z'ea#}'ea(Y'ea(j'ea(q'ea(r'ea!Y'ea!Z'ea~O(q%OOP%[iZ%[ij%[in%[i|%[i}%[i!P%[i!i%[i!j%[i!l%[i!p%[i#k%[i#l%[i#m%[i#n%[i#o%[i#p%[i#q%[i#r%[i#s%[i#u%[i#w%[i#y%[i#z%[i#}%[i(Y%[i(j%[i(r%[i!Y%[i!Z%[i~O(r%QOP%^iZ%^ij%^in%^i|%^i}%^i!P%^i!i%^i!j%^i!l%^i!p%^i#k%^i#l%^i#m%^i#n%^i#o%^i#p%^i#q%^i#r%^i#s%^i#u%^i#w%^i#y%^i#z%^i#}%^i(Y%^i(j%^i(q%^i!Y%^i!Z%^i~O#}$ly!Y$ly!Z$ly~P#EoO#}#`y!Y#`y!Z#`y~P#EoO!d#vO!Y'_q!k'_q~O!Y/kO!k(wy~O!V'aq!Y'aq~P#/OO!V:PO~P#/OO!Y0zO!Z)Qy~O!Y5_O!Z(}q~O![1dO%d:WO~O!k:ZO~O![']O%d:`O~OP$xqZ$xqn$xq}$xq!i$xq!j$xq!l$xq!p$xq#k$xq#l$xq#m$xq#n$xq#o$xq#p$xq#q$xq#r$xq#s$xq#u$xq#w$xq#y$xq#z$xq#}$xq(Y$xq(j$xq!Y$xq!Z$xq~P&+fO|)|O!P)}O(r%QOP'daZ'daj'dan'da}'da!i'da!j'da!l'da!p'da#k'da#l'da#m'da#n'da#o'da#p'da#q'da#r'da#s'da#u'da#w'da#y'da#z'da#}'da(Y'da(j'da(q'da!Y'da!Z'da~O|)|O!P)}OP'faZ'faj'fan'fa}'fa!i'fa!j'fa!l'fa!p'fa#k'fa#l'fa#m'fa#n'fa#o'fa#p'fa#q'fa#r'fa#s'fa#u'fa#w'fa#y'fa#z'fa#}'fa(Y'fa(j'fa(q'fa(r'fa!Y'fa!Z'fa~OP$zqZ$zqn$zq}$zq!i$zq!j$zq!l$zq!p$zq#k$zq#l$zq#m$zq#n$zq#o$zq#p$zq#q$zq#r$zq#s$zq#u$zq#w$zq#y$zq#z$zq#}$zq(Y$zq(j$zq!Y$zq!Z$zq~P&+fOf%`!Z!Y%`!Z#]%`!Z#}%`!Z~P!1UO!Y'jq!Z'jq~P#EoO!Y#e!Z!Z#e!Z~P#EoO#h%`!ZP%`!ZZ%`!Z`%`!Zn%`!Z}%`!Z!Y%`!Z!i%`!Z!j%`!Z!l%`!Z!p%`!Z#k%`!Z#l%`!Z#m%`!Z#n%`!Z#o%`!Z#p%`!Z#q%`!Z#r%`!Z#s%`!Z#u%`!Z#w%`!Z#y%`!Z#z%`!Z's%`!Z(Y%`!Z(j%`!Z!k%`!Z!V%`!Z'q%`!Z#]%`!Zr%`!Z![%`!Z%d%`!Z!d%`!Z~P#/OOP%`!ZZ%`!Zn%`!Z}%`!Z!i%`!Z!j%`!Z!l%`!Z!p%`!Z#k%`!Z#l%`!Z#m%`!Z#n%`!Z#o%`!Z#p%`!Z#q%`!Z#r%`!Z#s%`!Z#u%`!Z#w%`!Z#y%`!Z#z%`!Z#}%`!Z(Y%`!Z(j%`!Z!Y%`!Z!Z%`!Z~P&+fOr(^X~P1qO|%pO~P!*mO'}!lO~P!*mO!VeX!YeX#]eX~P&0hOP[XZ[Xn[X|[X}[X!P[X!Y[X!YeX!i[X!j[X!l[X!p[X#][X#]eX#heX#k[X#l[X#m[X#n[X#o[X#p[X#q[X#r[X#s[X#u[X#w[X#y[X#z[X$P[X(Y[X(j[X(q[X(r[X~O!deX!k[X!keX(jeX~P'EaOP:kOQ:kORfOc<fOd!iOlkOn:kOokOpkOvkOx:kOz:kO!PWO!TkO!UkO![XO!f:nO!lZO!o:kO!p:kO!q:kO!s:oO!u:rO!x!hO$U!kO'|)[O(OTO(RUO(YVO(h[O(v<dO~O!Y;PO!Z$na~Og%WOl%XOn$uOo$tOp$tOv%YOx%ZOz;ZO!P$|O![$}O!f<kO!l$yO#g;aO$U%_O$p;]O$r;_O$u%`O'|(rO(OTO(RUO(Y$vO(q%OO(r%QO~O#t)cO~P'JVOn!bX(j!bX~P# xO!Z[X!ZeX~P'EaO!VeX!V$vX!YeX!Y$vX#]eX~P!/{O#h:sO~O!d#vO#h:sO~O#];TO~O#s:xO~O#];dO!Y(oX!Z(oX~O#];TO!Y(mX!Z(mX~O#h;eO~Of;gO~P!1UO#h;mO~O#h;nO~O!d#vO#h;oO~O!d#vO#h;eO~O#};pO~P#EoO#h;qO~O#h;rO~O#h;wO~O#h;xO~O#h;yO~O#h;zO~O#};{O~P!1UO#};|O~P!1UO!j#Q#R#T#U#X#f#g#r(v$p$r$u%X%c%d%e%l%n%q%r%t%v~'wS#l!U'u'}#mo#k#nn|'v$Z'v'|$](]~",
  goto: "$4d)UPPPPP)VPP)YP)kP*{/QPPPP5xPP6`PP<V?lP@PP@PPPP@PPBPP@PP@PP@PPBTPPBYPBwPGpPPPGtPPPPGtJvPPPJ|KxPGtPGtNWPPPP!!fGtPPPGtPGtP!$tGtP!(Z!)]!)fP!*Y!*^!*YPPPPP!-j!)]PP!-z!.tP!1hGtGt!1m!4x!9`!9`!=^PPP!=fGtPPPPPPPPPPP!@tP!BRPPGt!CdPGtPGtGtGtGtPGt!DvP!HPP!KUP!KY!Kd!Kh!KhP!G|P!Kl!KlP!NqP!NuGtGt!N{#$P@PP@PP@P@PP#%]@P@P#'g@P#*V@P#,Z@P@P#,y#/V#/V#/[#/e#/V#/nP#/VP@P#0W@P#3w@P@P5xPPP#7nPPP#8X#8XP#8XP#8o#8XPP#8uP#8lP#8l#9Y#8l#9t#9z5u)Y#9})YP#:U#:U#:UP)YP)YP)YP)YPP)YP#:[#:_P#:_)YP#:cP#:fP)YP)YP)YP)YP)YP)Y)YPP#:l#:r#:}#;T#;Z#;a#;g#;u#;{#<R#<]#<c#<m#<}#=T#=u#>X#>_#>e#>s#?Y#@w#AV#A^#Br#CQ#Dl#Dz#EQ#EW#E^#Eh#En#Et#FO#Fb#FhPPPPPPPPPP#FnPPPPPPP#Gc#Jj#Ky#LQ#LYPPPP$#`$&W$,p$,s$,v$-c$-f$-i$-p$-xP$.OP$.l$.p$/h$0v$0{$1cPP$1h$1n$1rP$1u$1y$1}$2s$3[$3s$3w$3z$3}$4T$4W$4[$4`R!|RoqOXst!Z#d%k&o&q&r&t,m,r2P2SY!vQ']-_1d5fQ%rvQ%zyQ&R|Q&g!VS'T!e-VQ'c!iS'i!r!yU*g$}*X*lQ+k%{Q+x&TQ,^&aQ-]'[Q-g'dQ-o'jQ0U*nQ1n,_R;b:o%QdOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#y#|$P$Q$R$S$T$U$V$W$X$Y$Z$b$f%k%r&P&h&k&o&q&r&t&x'Q'_'o(P(R(X(`(t(x(|){+S+W,j,m,r-c-k-y.P.q.x/i0d0i0y1g1w1x1z1|2P2S2U2u2{3c5c5m5}6O6R6f8P8U8e8oS#q]:l!r)^$]$n'U)p-O-R/Q2e3x5a6]9`9q:k:n:o:r:s:t:u:v:w:x:y:z:{:|:};O;P;T;b;d;e;g;o;p;y;z<gQ*y%[Q+p%}Q,`&dQ,g&lQ.h;YQ0p+cQ0t+eQ1P+qQ1v,eQ3T.aQ5P0zQ5t1oQ6r3XQ7O;ZQ7q5QR8u6s'OkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#y#|$P$Q$R$S$T$U$V$W$X$Y$Z$]$b$f$n%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(P(R(X(`(t(x(|)p){+S+W+c,j,m,r-O-R-c-k-y.P.a.q.x/Q/i0d0i0y1g1w1x1z1|2P2S2U2e2u2{3X3c3x5a5c5m5}6O6R6]6f6s8P8U8e8o9`9q:k:n:o:r:s:t:u:v:w:x:y:z:{:|:};O;P;T;b;d;e;g;o;p;y;z<gt!nQ!r!v!y!z'T'[']'i'j'k-V-]-_-o1d5f5h$z$ti#v#x$d$e$y$|%P%R%]%^%b)w)}*P*R*T*W*^*d*t*u+b+e+|,P.`.n/`/h/r/s/u0Y0[0f1Z1^1f3W4Q4]4e4o4w4y5l6p7^7g8R8r9P9d9v:W:`;R;S;U;V;W;X;[;];^;_;`;a;h;i;j;k;m;n;q;r;s;t;u;v;w;x;{;|<d<l<m<p<qQ&U|Q'R!eU'X%g*X-YQ+p%}Q,`&dQ0e*}Q1P+qQ1U+wQ1u,dQ1v,eQ5P0zQ5Y1WQ5t1oQ5w1qQ5x1tQ7q5QQ7t5VQ8^5zQ9_7uR9j8ZrnOXst!V!Z#d%k&f&o&q&r&t,m,r2P2SR,b&h&x^OPXYstuvwz!Z!`!g!j!o#S#d#o#u#y#|$P$Q$R$S$T$U$V$W$X$Y$Z$]$b$f$n%k%r&P&h&k&l&o&q&r&t&x'Q'_'o(R(X(`(t(x(|)p){+S+W+c,j,m,r-O-R-c-k-y.P.a.q.x/Q/i0d0i0y1g1w1x1z1|2P2S2U2e2u2{3X3c3x5a5c5m5}6O6R6]6f6s8P8U8e8o9`9q:k:n:o:r:s:t:u:v:w:x:y:z:{:|:};O;P;T;b;d;e;g;o;p;y;z<f<g[#]WZ#W#Z'U(P!b%hm#h#i#l$y%c%f(Y(d(e(f*W*[*_+U+V+X,i-P-}.T.U.V.X/h/k2X3P3Q4T6[6mQ%uxQ%yyS&O|&TQ&[!TQ'`!hQ'b!iQ(m#sS+j%z%{Q+n%}Q,X&_Q,]&aS-f'c'dQ.c(nQ0x+kQ1O+qQ1Q+rQ1T+vQ1i,YS1m,^,_Q2q-gQ5O0zQ5S0}Q5X1VQ5s1nQ7p5QQ7s5UQ9Z7oR:R9[!O${i#x%P%R%]%^%b*P*R*^*t*u.n/r0Y0[0f4Q4o9P<d<l<m!S%wy!i!u%y%z%{'S'b'c'd'h'r*f+j+k-S-f-g-n/|0x2j2q2x4gQ+d%uQ+}&XQ,Q&YQ,[&aQ.b(mQ1h,XU1l,],^,_Q3Y.cQ5n1iS5r1m1nQ8Y5s#[<h#v$d$e$y$|)w)}*T*W*d+b+e+|,P.`/`/h/s/u1Z1^1f3W4]4e4w4y5l6p7^7g8R8r9d9v:W:`;U;W;[;^;`;h;j;m;q;s;u;w;{<p<qo<i;R;S;V;X;];_;a;i;k;n;r;t;v;x;|W%Ui%W*v<dS&X!Q&fQ&Y!RQ&Z!SR+{&V${%Ti#v#x$d$e$y$|%P%R%]%^%b)w)}*P*R*T*W*^*d*t*u+b+e+|,P.`.n/`/h/r/s/u0Y0[0f1Z1^1f3W4Q4]4e4o4w4y5l6p7^7g8R8r9P9d9v:W:`;R;S;U;V;W;X;[;];^;_;`;a;h;i;j;k;m;n;q;r;s;t;u;v;w;x;{;|<d<l<m<p<qT)x$v)yV*z%[;Y;ZW'X!e%g*X-YS({#z#{Q+_%pQ+u&QS.[(i(jQ1_,RQ4p0cR7y5_'OkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#y#|$P$Q$R$S$T$U$V$W$X$Y$Z$]$b$f$n%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(P(R(X(`(t(x(|)p){+S+W+c,j,m,r-O-R-c-k-y.P.a.q.x/Q/i0d0i0y1g1w1x1z1|2P2S2U2e2u2{3X3c3x5a5c5m5}6O6R6]6f6s8P8U8e8o9`9q:k:n:o:r:s:t:u:v:w:x:y:z:{:|:};O;P;T;b;d;e;g;o;p;y;z<g$i$ac#Y#e%o%q%s(O(U(p(w)P)Q)R)S)T)U)V)W)X)Y)Z)])`)d)n+`+t-T-r-w-|.O.m.s.w.y.z.{/[0g2`2c2s2z3b3g3h3i3j3k3l3m3n3o3p3q3r3s3v3w3|4t4|6_6e6j6x6y7S7T7{8i8m8v8|8}9s:T:[:m<ZT#TV#U'PkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#y#|$P$Q$R$S$T$U$V$W$X$Y$Z$]$b$f$n%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(P(R(X(`(t(x(|)p){+S+W+c,j,m,r-O-R-c-k-y.P.a.q.x/Q/i0d0i0y1g1w1x1z1|2P2S2U2e2u2{3X3c3x5a5c5m5}6O6R6]6f6s8P8U8e8o9`9q:k:n:o:r:s:t:u:v:w:x:y:z:{:|:};O;P;T;b;d;e;g;o;p;y;z<gQ'V!eR2f-Vv!nQ!e!r!v!y!z'T'[']'i'j'k-V-]-_-o1d5f5hU*f$}*X*lS/|*g*nQ0V*oQ1a,TQ4g0UR4j0XnqOXst!Z#d%k&o&q&r&t,m,r2P2SQ&v!^Q's!xS(o#u:sQ+h%xQ,V&[Q,W&^Q-d'aQ-q'lS.l(t;eS0h+S;oQ0v+iQ1c,UQ2W,tQ2Y,uQ2b-QQ2o-eQ2r-iS4u0i;yQ4z0wS4}0y;zQ6^2dQ6b2pQ6g2wQ7n4{Q8j6`Q8k6cQ8n6hR9p8g$d$`c#Y#e%q%s(O(U(p(w)P)Q)R)S)T)U)V)W)X)Y)Z)])`)d)n+`+t-T-r-w-|.O.m.s.w.z.{/[0g2`2c2s2z3b3g3h3i3j3k3l3m3n3o3p3q3r3s3v3w3|4t4|6_6e6j6x6y7S7T7{8i8m8v8|8}9s:T:[:m<ZS(l#p'fU*s%S(s3uS+^%o.yQ3U0pQ6o3TQ8t6rR9w8u$d$_c#Y#e%q%s(O(U(p(w)P)Q)R)S)T)U)V)W)X)Y)Z)])`)d)n+`+t-T-r-w-|.O.m.s.w.z.{/[0g2`2c2s2z3b3g3h3i3j3k3l3m3n3o3p3q3r3s3v3w3|4t4|6_6e6j6x6y7S7T7{8i8m8v8|8}9s:T:[:m<ZS(k#p'fS(}#{$`S+]%o.yS.](j(lQ.|)_Q0m+^R3R.^'OkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#y#|$P$Q$R$S$T$U$V$W$X$Y$Z$]$b$f$n%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(P(R(X(`(t(x(|)p){+S+W+c,j,m,r-O-R-c-k-y.P.a.q.x/Q/i0d0i0y1g1w1x1z1|2P2S2U2e2u2{3X3c3x5a5c5m5}6O6R6]6f6s8P8U8e8o9`9q:k:n:o:r:s:t:u:v:w:x:y:z:{:|:};O;P;T;b;d;e;g;o;p;y;z<gS#q]:lQ&q!XQ&r!YQ&t![Q&u!]R2O,pQ'^!hQ+a%uQ-b'`S._(m+dQ2m-aW3V.b.c0o0qQ6a2nU6n3S3U3YS8q6o6qS9u8s8tS:^9t9wQ:f:_R:i:gU!wQ']-_T5d1d5f!Q_OXZ`st!V!Z#d#h%c%k&f&h&o&q&r&t(f,m,r.U2P2S]!pQ!r']-_1d5fT#q]:l%[{OPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#y#|$P$Q$R$S$T$U$V$W$X$Y$Z$b$f%k%r&P&h&k&l&o&q&r&t&x'Q'_'o(P(R(X(`(t(x(|){+S+W+c,j,m,r-c-k-y.P.a.q.x/i0d0i0y1g1w1x1z1|2P2S2U2u2{3X3c5c5m5}6O6R6f6s8P8U8e8oS({#z#{S.[(i(j!s<Q$]$n'U)p-O-R/Q2e3x5a6]9`9q:k:n:o:r:s:t:u:v:w:x:y:z:{:|:};O;P;T;b;d;e;g;o;p;y;z<gm!tQ!r!v!y!z']'i'j'k-_-o1d5f5hQ'q!uS(b#g1yS-m'h'tQ/n*ZQ/z*fQ2y-pQ4X/oS4b/{0VQ7Y4SS7e4h4jQ9R7ZR9Y7hQ#wbQ'p!uS(a#g1yS(c#m+RQ+T%dQ+f%vQ+l%|U-l'h'q'tQ.Q(bQ/m*ZQ/y*fQ0P*iQ0u+gQ1j,ZS2v-m-pQ3O.YS4W/n/oS4a/z0VQ4d0OQ4f0QQ5p1kQ6i2yQ7X4SQ7]4XS7a4b4jQ7f4iQ8W5qS9Q7Y7ZQ9U7bQ9W7eQ9g8XQ9}9RQ:O9VQ:Q9YQ:Y9hQ:b:PQ<T<OQ<`<XR<a<YV!wQ']-_%[aOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#y#|$P$Q$R$S$T$U$V$W$X$Y$Z$b$f%k%r&P&h&k&l&o&q&r&t&x'Q'_'o(P(R(X(`(t(x(|){+S+W+c,j,m,r-c-k-y.P.a.q.x/i0d0i0y1g1w1x1z1|2P2S2U2u2{3X3c5c5m5}6O6R6f6s8P8U8e8oS#wz!j!r;}$]$n'U)p-O-R/Q2e3x5a6]9`9q:k:n:o:r:s:t:u:v:w:x:y:z:{:|:};O;P;T;b;d;e;g;o;p;y;z<gR<T<f%[bOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#y#|$P$Q$R$S$T$U$V$W$X$Y$Z$b$f%k%r&P&h&k&l&o&q&r&t&x'Q'_'o(P(R(X(`(t(x(|){+S+W+c,j,m,r-c-k-y.P.a.q.x/i0d0i0y1g1w1x1z1|2P2S2U2u2{3X3c5c5m5}6O6R6f6s8P8U8e8oQ%dj!S%vy!i!u%y%z%{'S'b'c'd'h'r*f+j+k-S-f-g-n/|0x2j2q2x4gS%|z!jQ+g%wQ,Z&aW1k,[,],^,_U5q1l1m1nS8X5r5sQ9h8Y!r<O$]$n'U)p-O-R/Q2e3x5a6]9`9q:k:n:o:r:s:t:u:v:w:x:y:z:{:|:};O;P;T;b;d;e;g;o;p;y;z<gQ<X<eR<Y<f%OeOPXYstuvw!Z!`!g!o#S#d#o#u#y#|$P$Q$R$S$T$U$V$W$X$Y$Z$b$f%k%r&P&h&k&o&q&r&t&x'Q'_'o(R(X(`(t(x(|){+S+W+c,j,m,r-c-k-y.P.a.q.x/i0d0i0y1g1w1x1z1|2P2S2U2u2{3X3c5c5m5}6O6R6f6s8P8U8e8oY#bWZ#W#Z(P!b%hm#h#i#l$y%c%f(Y(d(e(f*W*[*_+U+V+X,i-P-}.T.U.V.X/h/k2X3P3Q4T6[6mQ,h&l!p<P$]$n)p-O-R/Q2e3x5a6]9`9q:k:n:o:r:s:t:u:v:w:x:y:z:{:|:};O;P;T;b;d;e;g;o;p;y;z<gR<S'UU'Y!e%g*XR2h-Y%QdOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#y#|$P$Q$R$S$T$U$V$W$X$Y$Z$b$f%k%r&P&h&k&o&q&r&t&x'Q'_'o(P(R(X(`(t(x(|){+S+W,j,m,r-c-k-y.P.q.x/i0d0i0y1g1w1x1z1|2P2S2U2u2{3c5c5m5}6O6R6f8P8U8e8o!r)^$]$n'U)p-O-R/Q2e3x5a6]9`9q:k:n:o:r:s:t:u:v:w:x:y:z:{:|:};O;P;T;b;d;e;g;o;p;y;z<gQ,g&lQ0p+cQ3T.aQ6r3XR8u6s!b$Vc#Y%o(O(U(p(w)Y)Z)`)d+t-r-w-|.O.m.s/[0g2s2z3b3s4t4|6e6j6x8m9s:m!P:z)])n-T.y2`2c3g3q3r3v3|6_6y7S7T7{8i8v8|8}:T:[<Z!f$Xc#Y%o(O(U(p(w)V)W)Y)Z)`)d+t-r-w-|.O.m.s/[0g2s2z3b3s4t4|6e6j6x8m9s:m!T:|)])n-T.y2`2c3g3n3o3q3r3v3|6_6y7S7T7{8i8v8|8}:T:[<Z!^$]c#Y%o(O(U(p(w)`)d+t-r-w-|.O.m.s/[0g2s2z3b3s4t4|6e6j6x8m9s:mQ4Q/fz<g)])n-T.y2`2c3g3v3|6_6y7S7T7{8i8v8|8}:T:[<ZQ<l<nR<m<o'OkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#y#|$P$Q$R$S$T$U$V$W$X$Y$Z$]$b$f$n%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(P(R(X(`(t(x(|)p){+S+W+c,j,m,r-O-R-c-k-y.P.a.q.x/Q/i0d0i0y1g1w1x1z1|2P2S2U2e2u2{3X3c3x5a5c5m5}6O6R6]6f6s8P8U8e8o9`9q:k:n:o:r:s:t:u:v:w:x:y:z:{:|:};O;P;T;b;d;e;g;o;p;y;z<gS$oh$pR3y/P'VgOPWXYZhstuvw!Z!`!g!o#S#W#Z#d#o#u#y#|$P$Q$R$S$T$U$V$W$X$Y$Z$]$b$f$n$p%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(P(R(X(`(t(x(|)p){+S+W+c,j,m,r-O-R-c-k-y.P.a.q.x/P/Q/i0d0i0y1g1w1x1z1|2P2S2U2e2u2{3X3c3x5a5c5m5}6O6R6]6f6s8P8U8e8o9`9q:k:n:o:r:s:t:u:v:w:x:y:z:{:|:};O;P;T;b;d;e;g;o;p;y;z<gT$kf$qQ$ifS)g$l)kR)s$qT$jf$qT)i$l)k'VhOPWXYZhstuvw!Z!`!g!o#S#W#Z#d#o#u#y#|$P$Q$R$S$T$U$V$W$X$Y$Z$]$b$f$n$p%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(P(R(X(`(t(x(|)p){+S+W+c,j,m,r-O-R-c-k-y.P.a.q.x/P/Q/i0d0i0y1g1w1x1z1|2P2S2U2e2u2{3X3c3x5a5c5m5}6O6R6]6f6s8P8U8e8o9`9q:k:n:o:r:s:t:u:v:w:x:y:z:{:|:};O;P;T;b;d;e;g;o;p;y;z<gT$oh$pQ$rhR)r$p%[jOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#y#|$P$Q$R$S$T$U$V$W$X$Y$Z$b$f%k%r&P&h&k&l&o&q&r&t&x'Q'_'o(P(R(X(`(t(x(|){+S+W+c,j,m,r-c-k-y.P.a.q.x/i0d0i0y1g1w1x1z1|2P2S2U2u2{3X3c5c5m5}6O6R6f6s8P8U8e8o!s<e$]$n'U)p-O-R/Q2e3x5a6]9`9q:k:n:o:r:s:t:u:v:w:x:y:z:{:|:};O;P;T;b;d;e;g;o;p;y;z<g#elOPXZst!Z!`!o#S#d#o#|$n%k&h&k&l&o&q&r&t&x'Q'_(|)p+W+c,j,m,r-c.a/Q/i0d1g1w1x1z1|2P2S2U3X3x5c5m5}6O6R6s8P8U8e!O%Si#x%P%R%]%^%b*P*R*^*t*u.n/r0Y0[0f4Q4o9P<d<l<m#[(s#v$d$e$y$|)w)}*T*W*d+b+e+|,P.`/`/h/s/u1Z1^1f3W4]4e4w4y5l6p7^7g8R8r9d9v:W:`;U;W;[;^;`;h;j;m;q;s;u;w;{<p<qQ+O%`Q/])|o3u;R;S;V;X;];_;a;i;k;n;r;t;v;x;|!O$zi#x%P%R%]%^%b*P*R*^*t*u.n/r0Y0[0f4Q4o9P<d<l<mQ*`${U*i$}*X*lQ+P%aQ0Q*j#[<V#v$d$e$y$|)w)}*T*W*d+b+e+|,P.`/`/h/s/u1Z1^1f3W4]4e4w4y5l6p7^7g8R8r9d9v:W:`;U;W;[;^;`;h;j;m;q;s;u;w;{<p<qn<W;R;S;V;X;];_;a;i;k;n;r;t;v;x;|Q<[<hQ<]<iQ<^<jR<_<k!O%Si#x%P%R%]%^%b*P*R*^*t*u.n/r0Y0[0f4Q4o9P<d<l<m#[(s#v$d$e$y$|)w)}*T*W*d+b+e+|,P.`/`/h/s/u1Z1^1f3W4]4e4w4y5l6p7^7g8R8r9d9v:W:`;U;W;[;^;`;h;j;m;q;s;u;w;{<p<qo3u;R;S;V;X;];_;a;i;k;n;r;t;v;x;|noOXst!Z#d%k&o&q&r&t,m,r2P2SS*c$|*WQ,{&{Q,|&}R4[/s$z%Ti#v#x$d$e$y$|%P%R%]%^%b)w)}*P*R*T*W*^*d*t*u+b+e+|,P.`.n/`/h/r/s/u0Y0[0f1Z1^1f3W4Q4]4e4o4w4y5l6p7^7g8R8r9P9d9v:W:`;R;S;U;V;W;X;[;];^;_;`;a;h;i;j;k;m;n;q;r;s;t;u;v;w;x;{;|<d<l<m<p<qQ,O&YQ1],QQ5]1[R7x5^V*k$}*X*lU*k$}*X*lT5e1d5fU0O*h/i5cT4i0W8PQ+f%vQ0P*iQ0u+gQ1j,ZQ5p1kQ8W5qQ9g8XR:Y9h!O%Pi#x%P%R%]%^%b*P*R*^*t*u.n/r0Y0[0f4Q4o9P<d<l<mr*P$w(u*Q*r+Q/q0^0_3`4Y4s7W7i9|<U<b<cS0Y*q0Z#[;U#v$d$e$y$|)w)}*T*W*d+b+e+|,P.`/`/h/s/u1Z1^1f3W4]4e4w4y5l6p7^7g8R8r9d9v:W:`;U;W;[;^;`;h;j;m;q;s;u;w;{<p<qn;V;R;S;V;X;];_;a;i;k;n;r;t;v;x;|!^;h(q)b*Y*b.d.g.k/X/^/f/v0n1Y1[3]4Z4_5[5^6t6w7_7c7k7m9T9X:a<n<o`;i3t6z6}7R8w9x9{:jS;s.f3^T;t6|8z!O%Ri#x%P%R%]%^%b*P*R*^*t*u.n/r0Y0[0f4Q4o9P<d<l<mv*R$w(u*S*q+Q/b/q0^0_3`4Y4k4s7W7i9|<U<b<cS0[*r0]#[;W#v$d$e$y$|)w)}*T*W*d+b+e+|,P.`/`/h/s/u1Z1^1f3W4]4e4w4y5l6p7^7g8R8r9d9v:W:`;U;W;[;^;`;h;j;m;q;s;u;w;{<p<qn;X;R;S;V;X;];_;a;i;k;n;r;t;v;x;|!b;j(q)b*Y*b.e.f.k/X/^/f/v0n1Y1[3Z3]4Z4_5[5^6t6u6w7_7c7k7m9T9X:a<n<od;k3t6{6|7R8w8x9x9y9{:jS;u.g3_T;v6}8{rnOXst!V!Z#d%k&f&o&q&r&t,m,r2P2SQ&c!UR,j&lrnOXst!V!Z#d%k&f&o&q&r&t,m,r2P2SR&c!UQ,S&ZR1X+{snOXst!V!Z#d%k&f&o&q&r&t,m,r2P2SQ1e,XS5k1h1iU8Q5i5j5nS9c8S8TS:U9b9eQ:c:VR:h:dQ&j!VR,c&fR5w1qS&O|&TR1Q+rQ&o!WR,m&pR,s&uT2Q,r2SR,w&vQ,v&vR2Z,wQ'v!{R-s'vSsOtQ#dXT%ns#dQ#OTR'x#OQ#RUR'z#RQ)y$vR/Y)yQ#UVR'|#UQ#XWU(S#X(T-zQ(T#YR-z(UQ-W'VR2g-WQ.o(uR3a.oQ.r(wS3d.r3eR3e.sQ-_']R2k-_Y!rQ']-_1d5fR'g!rU#_W%f*WU(Z#_([-{Q([#`R-{(VQ-Z'YR2i-Zt`OXst!V!Z#d%k&f&h&o&q&r&t,m,r2P2SS#hZ%cU#r`#h.UR.U(fQ(g#jQ.R(cW.Z(g.R2|6kQ2|.SR6k2}Q)k$lR/R)kQ$phR)q$pQ$ccU)a$c-v;QQ-v:mR;Q)nQ/l*ZW4U/l4V7[9SU4V/m/n/oS7[4W4XR9S7]$X*O$w(q(u)b*Y*b*q*r*{*|+Q.f.g.i.j.k/X/^/b/d/f/q/v0^0_0n1Y1[3Z3[3]3`3t4Y4Z4_4k4m4s5[5^6t6u6v6w6|6}7P7Q7R7W7_7c7i7k7m8w8x8y9T9X9x9y9z9{9|:a:j<U<b<c<n<oQ/t*bU4^/t4`7`Q4`/vR7`4_S*l$}*XR0S*lr*Q$w(u*q*r+Q/q0^0_3`4Y4s7W7i9|<U<b<c!^.d(q)b*Y*b.f.g.k/X/^/f/v0n1Y1[3]4Z4_5[5^6t6w7_7c7k7m9T9X:a<n<oU/c*Q.d6za6z3t6|6}7R8w9x9{:jQ0Z*qQ3^.fU4l0Z3^8zR8z6|v*S$w(u*q*r+Q/b/q0^0_3`4Y4k4s7W7i9|<U<b<c!b.e(q)b*Y*b.f.g.k/X/^/f/v0n1Y1[3Z3]4Z4_5[5^6t6u6w7_7c7k7m9T9X:a<n<oU/e*S.e6{e6{3t6|6}7R8w8x9x9y9{:jQ0]*rQ3_.gU4n0]3_8{R8{6}Q*w%VR0a*wQ4x0nR7l4xQ+Y%iR0l+YQ5`1_S7z5`9aR9a7{Q,U&[R1b,UQ5f1dR7}5fQ1p,`S5u1p8[R8[5wQ0{+nW5R0{5T7r9]Q5T1OQ7r5SR9]7sQ+s&OR1R+sQ2S,rR6V2SYrOXst#dQ&s!ZQ+[%kQ,l&oQ,n&qQ,o&rQ,q&tQ1},mS2Q,r2SR6U2PQ%mpQ&w!_Q&z!aQ&|!bQ'O!cQ'n!uQ+Z%jQ+h%xQ+z&UQ,b&jQ,y&yW-j'h'p'q'tQ-q'lQ0R*kQ0v+iS1s,c,fQ2[,xQ2],{Q2^,|Q2r-iW2t-l-m-p-rQ4z0wQ5W1UQ5Z1YQ5o1jQ5y1uQ6T2OU6d2s2v2yQ6g2wQ7n4{Q7v5YQ7w5[Q7|5eQ8V5pQ8]5xS8l6e6iQ8n6hQ9^7tQ9f8WQ9k8^Q9r8mQ:S9_Q:X9gQ:]9sR:e:YQ%xyQ'a!iQ'l!uU+i%y%z%{Q-Q'SU-e'b'c'dS-i'h'rQ/x*fS0w+j+kQ2d-SS2p-f-gQ2w-nQ4c/|Q4{0xQ6`2jQ6c2qQ6h2xR7d4gS$xi<dR*x%WU%Vi%W<dR0`*vQ$wiS(q#v+eQ(u#xS)b$d$eQ*Y$yS*b$|*WQ*q%PQ*r%RQ*{%]Q*|%^Q+Q%bQ.f;UQ.g;WQ.i;[Q.j;^Q.k;`Q/X)wS/^)}/`Q/b*PQ/d*RQ/f*TQ/q*^S/v*d/hQ0^*tQ0_*uh0n+b.`1f3W5l6p8R8r9d9v:W:`Q1Y+|Q1[,PQ3Z;hQ3[;jQ3];mQ3`.nS3t;R;SQ4Y/rQ4Z/sQ4_/uQ4k0YQ4m0[Q4s0fQ5[1ZQ5^1^Q6t;qQ6u;sQ6v;uQ6w;wQ6|;VQ6};XQ7P;]Q7Q;_Q7R;aQ7W4QQ7_4]Q7c4eQ7i4oQ7k4wQ7m4yQ8w;nQ8x;iQ8y;kQ9T7^Q9X7gQ9x;rQ9y;tQ9z;vQ9{;xQ9|9PQ:a;{Q:j;|Q<U<dQ<b<lQ<c<mQ<n<pR<o<qnpOXst!Z#d%k&o&q&r&t,m,r2P2SQ!fPS#fZ#oQ&y!`U'e!o5c8PQ'{#SQ)O#|Q)o$nS,f&h&kQ,k&lQ,x&xQ,}'QQ-a'_Q.u(|Q/V)pS0j+W/iQ0q+cQ1{,jQ2n-cQ3U.aQ3{/QQ4q0dQ5j1gQ5{1wQ5|1xQ6Q1zQ6S1|Q6X2UQ6o3XQ7U3xQ8T5mQ8a5}Q8b6OQ8d6RQ8t6sQ9e8UR9o8e#YcOPXZst!Z!`!o#d#o#|%k&h&k&l&o&q&r&t&x'Q'_(|+W+c,j,m,r-c.a/i0d1g1w1x1z1|2P2S2U3X5c5m5}6O6R6s8P8U8eQ#YWQ#eYQ%ouQ%qvS%sw!gS(O#W(RQ(U#ZQ(p#uQ(w#yQ)P$PQ)Q$QQ)R$RQ)S$SQ)T$TQ)U$UQ)V$VQ)W$WQ)X$XQ)Y$YQ)Z$ZQ)]$]Q)`$bQ)d$fW)n$n)p/Q3xQ+`%rQ+t&PS-T'U2eQ-r'oS-w(P-yQ-|(XQ.O(`Q.m(tQ.s(xQ.w:kQ.y:nQ.z:oQ.{:rQ/[){Q0g+SQ2`-OQ2c-RQ2s-kQ2z.PQ3b.qQ3g:sQ3h:tQ3i:uQ3j:vQ3k:wQ3l:xQ3m:yQ3n:zQ3o:{Q3p:|Q3q:}Q3r;OQ3s.xQ3v;TQ3w;bQ3|;PQ4t0iQ4|0yQ6_;dQ6e2uQ6j2{Q6x3cQ6y;eQ7S;gQ7T;oQ7{5aQ8i6]Q8m6fQ8v;pQ8|;yQ8};zQ9s8oQ:T9`Q:[9qQ:m#SR<Z<gR#[WR'W!el!tQ!r!v!y!z']'i'j'k-_-o1d5f5hS'S!e-VS-S'T'[R2j-]R(v#xR(y#yQ!fQT-^']-_]!qQ!r']-_1d5fQ#p]R'f:lY!uQ']-_1d5fQ'h!rS'r!v!yS't!z5hS-n'i'jQ-p'kR2x-oT#kZ%cS#jZ%cS%im,iU(c#h#i#lS.S(d(eQ.W(fQ0k+XQ2}.TU3O.U.V.XS6l3P3QR8p6md#^W#W#Z%f(P(Y*W+U-}/hr#gZm#h#i#l%c(d(e(f+X.T.U.V.X3P3Q6mS*Z$y*_Q/o*[Q1y,iQ2a-PQ4S/kQ6Z2XQ7Z4TQ8h6[T<R'U+VV#aW%f*WU#`W%f*WS(Q#W(YU(V#Z+U/hS-U'U+VT-x(P-}V'Z!e%g*XQ$lfR)u$qT)j$l)kR3z/PT*]$y*_T*e$|*WQ0o+bQ3S.`Q5i1fQ6q3WQ8S5lQ8s6pQ9b8RQ9t8rQ:V9dQ:_9vQ:d:WR:g:`nqOXst!Z#d%k&o&q&r&t,m,r2P2SQ&i!VR,b&ftmOXst!U!V!Z#d%k&f&o&q&r&t,m,r2P2SR,i&lT%jm,iR1`,RR,a&dQ&S|R+y&TR+o%}T&m!W&pT&n!W&pT2R,r2S",
  nodeNames: "\u26A0 ArithOp ArithOp JSXStartTag LineComment BlockComment Script Hashbang ExportDeclaration export Star as VariableName String Escape from ; default FunctionDeclaration async function VariableDefinition > < TypeParamList TypeDefinition extends ThisType this LiteralType ArithOp Number BooleanLiteral TemplateType InterpolationEnd Interpolation InterpolationStart NullType null VoidType void TypeofType typeof MemberExpression . ?. PropertyName [ TemplateString Escape Interpolation super RegExp ] ArrayExpression Spread , } { ObjectExpression Property async get set PropertyDefinition Block : NewTarget new NewExpression TypeArgList CompareOp < ) ( ArgList UnaryExpression delete LogicOp BitOp YieldExpression yield AwaitExpression await ParenthesizedExpression ClassExpression class ClassBody MethodDeclaration Decorator @ MemberExpression PrivatePropertyName CallExpression declare Privacy static abstract override PrivatePropertyDefinition PropertyDeclaration readonly accessor Optional TypeAnnotation Equals StaticBlock FunctionExpression ArrowFunction ParamList ParamList ArrayPattern ObjectPattern PatternProperty Privacy readonly Arrow MemberExpression BinaryExpression ArithOp ArithOp ArithOp ArithOp BitOp CompareOp instanceof satisfies in const CompareOp BitOp BitOp BitOp LogicOp LogicOp ConditionalExpression LogicOp LogicOp AssignmentExpression UpdateOp PostfixExpression CallExpression TaggedTemplateExpression DynamicImport import ImportMeta JSXElement JSXSelfCloseEndTag JSXSelfClosingTag JSXIdentifier JSXBuiltin JSXIdentifier JSXNamespacedName JSXMemberExpression JSXSpreadAttribute JSXAttribute JSXAttributeValue JSXEscape JSXEndTag JSXOpenTag JSXFragmentTag JSXText JSXEscape JSXStartCloseTag JSXCloseTag PrefixCast ArrowFunction TypeParamList SequenceExpression KeyofType keyof UniqueType unique ImportType InferredType infer TypeName ParenthesizedType FunctionSignature ParamList NewSignature IndexedType TupleType Label ArrayType ReadonlyType ObjectType MethodType PropertyType IndexSignature PropertyDefinition CallSignature TypePredicate is NewSignature new UnionType LogicOp IntersectionType LogicOp ConditionalType ParameterizedType ClassDeclaration abstract implements type VariableDeclaration let var using TypeAliasDeclaration InterfaceDeclaration interface EnumDeclaration enum EnumBody NamespaceDeclaration namespace module AmbientDeclaration declare GlobalDeclaration global ClassDeclaration ClassBody AmbientFunctionDeclaration ExportGroup VariableName VariableName ImportDeclaration ImportGroup ForStatement for ForSpec ForInSpec ForOfSpec of WhileStatement while WithStatement with DoStatement do IfStatement if else SwitchStatement switch SwitchBody CaseLabel case DefaultLabel TryStatement try CatchClause catch FinallyClause finally ReturnStatement return ThrowStatement throw BreakStatement break ContinueStatement continue DebuggerStatement debugger LabeledStatement ExpressionStatement SingleExpression SingleClassItem",
  maxTerm: 373,
  context: tG,
  nodeProps: [
    ["isolate", -8, 4, 5, 13, 33, 35, 48, 50, 52, ""],
    ["group", -26, 8, 16, 18, 65, 202, 206, 210, 211, 213, 216, 219, 229, 231, 237, 239, 241, 243, 246, 252, 258, 260, 262, 264, 266, 268, 269, "Statement", -33, 12, 13, 28, 31, 32, 38, 48, 51, 52, 54, 59, 67, 69, 76, 80, 82, 84, 85, 107, 108, 117, 118, 135, 138, 140, 141, 142, 143, 145, 146, 165, 166, 168, "Expression", -23, 27, 29, 33, 37, 39, 41, 169, 171, 173, 174, 176, 177, 178, 180, 181, 182, 184, 185, 186, 196, 198, 200, 201, "Type", -3, 88, 100, 106, "ClassItem"],
    ["openedBy", 22, "<", 34, "InterpolationStart", 53, "[", 57, "{", 73, "(", 158, "JSXStartCloseTag"],
    ["closedBy", 23, ">", 36, "InterpolationEnd", 47, "]", 58, "}", 74, ")", 163, "JSXEndTag"]
  ],
  propSources: [sG],
  skippedNodes: [0, 4, 5, 272],
  repeatNodeCount: 37,
  tokenData: "$HR07[R!bOX%ZXY+gYZ-yZ[+g[]%Z]^.c^p%Zpq+gqr/mrs3cst:_tuEruvJSvwLkwx! Yxy!'iyz!(sz{!)}{|!,q|}!.O}!O!,q!O!P!/Y!P!Q!9j!Q!R#:O!R![#<_![!]#I_!]!^#Jk!^!_#Ku!_!`$![!`!a$$v!a!b$*T!b!c$.S!c!}Er!}#O$/^#O#P$0h#P#Q$6P#Q#R$7Z#R#SEr#S#T$8h#T#o$9r#o#p$>S#p#q$>x#q#r$@Y#r#s$Af#s$f%Z$f$g+g$g#BYEr#BY#BZ$Bp#BZ$ISEr$IS$I_$Bp$I_$I|Er$I|$I}$E{$I}$JO$E{$JO$JTEr$JT$JU$Bp$JU$KVEr$KV$KW$Bp$KW&FUEr&FU&FV$Bp&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$Bp?HUOEr(n%d_$g&j(Pp(S!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&j&hT$g&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c&j&zP;=`<%l&c'|'U]$g&j(S!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!b(SU(S!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!b(iP;=`<%l'}'|(oP;=`<%l&}'[(y]$g&j(PpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rp)wU(PpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)rp*^P;=`<%l)r'[*dP;=`<%l(r#S*nX(Pp(S!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g#S+^P;=`<%l*g(n+dP;=`<%l%Z07[+rq$g&j(Pp(S!b'u0/lOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p$f%Z$f$g+g$g#BY%Z#BY#BZ+g#BZ$IS%Z$IS$I_+g$I_$JT%Z$JT$JU+g$JU$KV%Z$KV$KW+g$KW&FU%Z&FU&FV+g&FV;'S%Z;'S;=`+a<%l?HT%Z?HT?HU+g?HUO%Z07[.ST(Q#S$g&j'v0/lO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c07[.n_$g&j(Pp(S!b'v0/lOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)3p/x`$g&j!p),Q(Pp(S!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW1V`#u(Ch$g&j(Pp(S!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`2X!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW2d_#u(Ch$g&j(Pp(S!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'At3l_(O':f$g&j(S!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k(^4r_$g&j(S!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k&z5vX$g&jOr5qrs6cs!^5q!^!_6y!_#o5q#o#p6y#p;'S5q;'S;=`7h<%lO5q&z6jT$b`$g&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c`6|TOr6yrs7]s;'S6y;'S;=`7b<%lO6y`7bO$b``7eP;=`<%l6y&z7kP;=`<%l5q(^7w]$b`$g&j(S!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!r8uZ(S!bOY8pYZ6yZr8prs9hsw8pwx6yx#O8p#O#P6y#P;'S8p;'S;=`:R<%lO8p!r9oU$b`(S!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!r:UP;=`<%l8p(^:[P;=`<%l4k%9[:hh$g&j(Pp(S!bOY%ZYZ&cZq%Zqr<Srs&}st%ZtuCruw%Zwx(rx!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr(r<__VS$g&j(Pp(S!bOY<SYZ&cZr<Srs=^sw<Swx@nx!^<S!^!_Bm!_#O<S#O#P>`#P#o<S#o#pBm#p;'S<S;'S;=`Cl<%lO<S(Q=g]VS$g&j(S!bOY=^YZ&cZw=^wx>`x!^=^!^!_?q!_#O=^#O#P>`#P#o=^#o#p?q#p;'S=^;'S;=`@h<%lO=^&n>gXVS$g&jOY>`YZ&cZ!^>`!^!_?S!_#o>`#o#p?S#p;'S>`;'S;=`?k<%lO>`S?XSVSOY?SZ;'S?S;'S;=`?e<%lO?SS?hP;=`<%l?S&n?nP;=`<%l>`!f?xWVS(S!bOY?qZw?qwx?Sx#O?q#O#P?S#P;'S?q;'S;=`@b<%lO?q!f@eP;=`<%l?q(Q@kP;=`<%l=^'`@w]VS$g&j(PpOY@nYZ&cZr@nrs>`s!^@n!^!_Ap!_#O@n#O#P>`#P#o@n#o#pAp#p;'S@n;'S;=`Bg<%lO@ntAwWVS(PpOYApZrAprs?Ss#OAp#O#P?S#P;'SAp;'S;=`Ba<%lOAptBdP;=`<%lAp'`BjP;=`<%l@n#WBvYVS(Pp(S!bOYBmZrBmrs?qswBmwxApx#OBm#O#P?S#P;'SBm;'S;=`Cf<%lOBm#WCiP;=`<%lBm(rCoP;=`<%l<S%9[C}i$g&j(h%1l(Pp(S!bOY%ZYZ&cZr%Zrs&}st%ZtuCruw%Zwx(rx!Q%Z!Q![Cr![!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr%9[EoP;=`<%lCr07[FRk$g&j(Pp(S!b$Z#t'|,2j(]$I[OY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr+dHRk$g&j(Pp(S!b$Z#tOY%ZYZ&cZr%Zrs&}st%ZtuGvuw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Gv![!^%Z!^!_*g!_!c%Z!c!}Gv!}#O%Z#O#P&c#P#R%Z#R#SGv#S#T%Z#T#oGv#o#p*g#p$g%Z$g;'SGv;'S;=`Iv<%lOGv+dIyP;=`<%lGv07[JPP;=`<%lEr(KWJ_`$g&j(Pp(S!b#m(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KWKl_$g&j$P(Ch(Pp(S!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z,#xLva(r+JY$g&j(Pp(S!bOY%ZYZ&cZr%Zrs&}sv%ZvwM{wx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KWNW`$g&j#y(Ch(Pp(S!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'At! c_(R';W$g&j(PpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b'l!!i_$g&j(PpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b&z!#mX$g&jOw!#hwx6cx!^!#h!^!_!$Y!_#o!#h#o#p!$Y#p;'S!#h;'S;=`!$r<%lO!#h`!$]TOw!$Ywx7]x;'S!$Y;'S;=`!$l<%lO!$Y`!$oP;=`<%l!$Y&z!$uP;=`<%l!#h'l!%R]$b`$g&j(PpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r!Q!&PZ(PpOY!%zYZ!$YZr!%zrs!$Ysw!%zwx!&rx#O!%z#O#P!$Y#P;'S!%z;'S;=`!']<%lO!%z!Q!&yU$b`(PpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)r!Q!'`P;=`<%l!%z'l!'fP;=`<%l!!b/5|!'t_!l/.^$g&j(Pp(S!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#&U!)O_!k!Lf$g&j(Pp(S!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z-!n!*[b$g&j(Pp(S!b'}%&f#n(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rxz%Zz{!+d{!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW!+o`$g&j(Pp(S!b#k(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z+;x!,|`$g&j(Pp(S!bn+4YOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z,$U!.Z_!Y+Jf$g&j(Pp(S!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[!/ec$g&j(Pp(S!b|.2^OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!0p!P!Q%Z!Q![!3Y![!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#%|!0ya$g&j(Pp(S!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!2O!P!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#%|!2Z_!X!L^$g&j(Pp(S!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!3eg$g&j(Pp(S!bo'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!3Y![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S!3Y#S#X%Z#X#Y!4|#Y#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!5Vg$g&j(Pp(S!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx{%Z{|!6n|}%Z}!O!6n!O!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!6wc$g&j(Pp(S!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!8_c$g&j(Pp(S!bo'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[!9uf$g&j(Pp(S!b#l(ChOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcxz!;Zz{#-}{!P!;Z!P!Q#/d!Q!^!;Z!^!_#(i!_!`#7S!`!a#8i!a!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z?O!;fb$g&j(Pp(S!b!U7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z>^!<w`$g&j(S!b!U7`OY!<nYZ&cZw!<nwx!=yx!P!<n!P!Q!Eq!Q!^!<n!^!_!Gr!_!}!<n!}#O!KS#O#P!Dy#P#o!<n#o#p!Gr#p;'S!<n;'S;=`!L]<%lO!<n<z!>Q^$g&j!U7`OY!=yYZ&cZ!P!=y!P!Q!>|!Q!^!=y!^!_!@c!_!}!=y!}#O!CW#O#P!Dy#P#o!=y#o#p!@c#p;'S!=y;'S;=`!Ek<%lO!=y<z!?Td$g&j!U7`O!^&c!_#W&c#W#X!>|#X#Z&c#Z#[!>|#[#]&c#]#^!>|#^#a&c#a#b!>|#b#g&c#g#h!>|#h#i&c#i#j!>|#j#k!>|#k#m&c#m#n!>|#n#o&c#p;'S&c;'S;=`&w<%lO&c7`!@hX!U7`OY!@cZ!P!@c!P!Q!AT!Q!}!@c!}#O!Ar#O#P!Bq#P;'S!@c;'S;=`!CQ<%lO!@c7`!AYW!U7`#W#X!AT#Z#[!AT#]#^!AT#a#b!AT#g#h!AT#i#j!AT#j#k!AT#m#n!AT7`!AuVOY!ArZ#O!Ar#O#P!B[#P#Q!@c#Q;'S!Ar;'S;=`!Bk<%lO!Ar7`!B_SOY!ArZ;'S!Ar;'S;=`!Bk<%lO!Ar7`!BnP;=`<%l!Ar7`!BtSOY!@cZ;'S!@c;'S;=`!CQ<%lO!@c7`!CTP;=`<%l!@c<z!C][$g&jOY!CWYZ&cZ!^!CW!^!_!Ar!_#O!CW#O#P!DR#P#Q!=y#Q#o!CW#o#p!Ar#p;'S!CW;'S;=`!Ds<%lO!CW<z!DWX$g&jOY!CWYZ&cZ!^!CW!^!_!Ar!_#o!CW#o#p!Ar#p;'S!CW;'S;=`!Ds<%lO!CW<z!DvP;=`<%l!CW<z!EOX$g&jOY!=yYZ&cZ!^!=y!^!_!@c!_#o!=y#o#p!@c#p;'S!=y;'S;=`!Ek<%lO!=y<z!EnP;=`<%l!=y>^!Ezl$g&j(S!b!U7`OY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#W&}#W#X!Eq#X#Z&}#Z#[!Eq#[#]&}#]#^!Eq#^#a&}#a#b!Eq#b#g&}#g#h!Eq#h#i&}#i#j!Eq#j#k!Eq#k#m&}#m#n!Eq#n#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}8r!GyZ(S!b!U7`OY!GrZw!Grwx!@cx!P!Gr!P!Q!Hl!Q!}!Gr!}#O!JU#O#P!Bq#P;'S!Gr;'S;=`!J|<%lO!Gr8r!Hse(S!b!U7`OY'}Zw'}x#O'}#P#W'}#W#X!Hl#X#Z'}#Z#[!Hl#[#]'}#]#^!Hl#^#a'}#a#b!Hl#b#g'}#g#h!Hl#h#i'}#i#j!Hl#j#k!Hl#k#m'}#m#n!Hl#n;'S'};'S;=`(f<%lO'}8r!JZX(S!bOY!JUZw!JUwx!Arx#O!JU#O#P!B[#P#Q!Gr#Q;'S!JU;'S;=`!Jv<%lO!JU8r!JyP;=`<%l!JU8r!KPP;=`<%l!Gr>^!KZ^$g&j(S!bOY!KSYZ&cZw!KSwx!CWx!^!KS!^!_!JU!_#O!KS#O#P!DR#P#Q!<n#Q#o!KS#o#p!JU#p;'S!KS;'S;=`!LV<%lO!KS>^!LYP;=`<%l!KS>^!L`P;=`<%l!<n=l!Ll`$g&j(Pp!U7`OY!LcYZ&cZr!Lcrs!=ys!P!Lc!P!Q!Mn!Q!^!Lc!^!_# o!_!}!Lc!}#O#%P#O#P!Dy#P#o!Lc#o#p# o#p;'S!Lc;'S;=`#&Y<%lO!Lc=l!Mwl$g&j(Pp!U7`OY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#W(r#W#X!Mn#X#Z(r#Z#[!Mn#[#](r#]#^!Mn#^#a(r#a#b!Mn#b#g(r#g#h!Mn#h#i(r#i#j!Mn#j#k!Mn#k#m(r#m#n!Mn#n#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r8Q# vZ(Pp!U7`OY# oZr# ors!@cs!P# o!P!Q#!i!Q!}# o!}#O#$R#O#P!Bq#P;'S# o;'S;=`#$y<%lO# o8Q#!pe(Pp!U7`OY)rZr)rs#O)r#P#W)r#W#X#!i#X#Z)r#Z#[#!i#[#])r#]#^#!i#^#a)r#a#b#!i#b#g)r#g#h#!i#h#i)r#i#j#!i#j#k#!i#k#m)r#m#n#!i#n;'S)r;'S;=`*Z<%lO)r8Q#$WX(PpOY#$RZr#$Rrs!Ars#O#$R#O#P!B[#P#Q# o#Q;'S#$R;'S;=`#$s<%lO#$R8Q#$vP;=`<%l#$R8Q#$|P;=`<%l# o=l#%W^$g&j(PpOY#%PYZ&cZr#%Prs!CWs!^#%P!^!_#$R!_#O#%P#O#P!DR#P#Q!Lc#Q#o#%P#o#p#$R#p;'S#%P;'S;=`#&S<%lO#%P=l#&VP;=`<%l#%P=l#&]P;=`<%l!Lc?O#&kn$g&j(Pp(S!b!U7`OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#W%Z#W#X#&`#X#Z%Z#Z#[#&`#[#]%Z#]#^#&`#^#a%Z#a#b#&`#b#g%Z#g#h#&`#h#i%Z#i#j#&`#j#k#&`#k#m%Z#m#n#&`#n#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z9d#(r](Pp(S!b!U7`OY#(iZr#(irs!Grsw#(iwx# ox!P#(i!P!Q#)k!Q!}#(i!}#O#+`#O#P!Bq#P;'S#(i;'S;=`#,`<%lO#(i9d#)th(Pp(S!b!U7`OY*gZr*grs'}sw*gwx)rx#O*g#P#W*g#W#X#)k#X#Z*g#Z#[#)k#[#]*g#]#^#)k#^#a*g#a#b#)k#b#g*g#g#h#)k#h#i*g#i#j#)k#j#k#)k#k#m*g#m#n#)k#n;'S*g;'S;=`+Z<%lO*g9d#+gZ(Pp(S!bOY#+`Zr#+`rs!JUsw#+`wx#$Rx#O#+`#O#P!B[#P#Q#(i#Q;'S#+`;'S;=`#,Y<%lO#+`9d#,]P;=`<%l#+`9d#,cP;=`<%l#(i?O#,o`$g&j(Pp(S!bOY#,fYZ&cZr#,frs!KSsw#,fwx#%Px!^#,f!^!_#+`!_#O#,f#O#P!DR#P#Q!;Z#Q#o#,f#o#p#+`#p;'S#,f;'S;=`#-q<%lO#,f?O#-tP;=`<%l#,f?O#-zP;=`<%l!;Z07[#.[b$g&j(Pp(S!b'w0/l!U7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z07[#/o_$g&j(Pp(S!bS0/lOY#/dYZ&cZr#/drs#0nsw#/dwx#4Ox!^#/d!^!_#5}!_#O#/d#O#P#1p#P#o#/d#o#p#5}#p;'S#/d;'S;=`#6|<%lO#/d06j#0w]$g&j(S!bS0/lOY#0nYZ&cZw#0nwx#1px!^#0n!^!_#3R!_#O#0n#O#P#1p#P#o#0n#o#p#3R#p;'S#0n;'S;=`#3x<%lO#0n05W#1wX$g&jS0/lOY#1pYZ&cZ!^#1p!^!_#2d!_#o#1p#o#p#2d#p;'S#1p;'S;=`#2{<%lO#1p0/l#2iSS0/lOY#2dZ;'S#2d;'S;=`#2u<%lO#2d0/l#2xP;=`<%l#2d05W#3OP;=`<%l#1p01O#3YW(S!bS0/lOY#3RZw#3Rwx#2dx#O#3R#O#P#2d#P;'S#3R;'S;=`#3r<%lO#3R01O#3uP;=`<%l#3R06j#3{P;=`<%l#0n05x#4X]$g&j(PpS0/lOY#4OYZ&cZr#4Ors#1ps!^#4O!^!_#5Q!_#O#4O#O#P#1p#P#o#4O#o#p#5Q#p;'S#4O;'S;=`#5w<%lO#4O00^#5XW(PpS0/lOY#5QZr#5Qrs#2ds#O#5Q#O#P#2d#P;'S#5Q;'S;=`#5q<%lO#5Q00^#5tP;=`<%l#5Q05x#5zP;=`<%l#4O01p#6WY(Pp(S!bS0/lOY#5}Zr#5}rs#3Rsw#5}wx#5Qx#O#5}#O#P#2d#P;'S#5};'S;=`#6v<%lO#5}01p#6yP;=`<%l#5}07[#7PP;=`<%l#/d)3h#7ab$g&j$P(Ch(Pp(S!b!U7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;ZAt#8vb$X#t$g&j(Pp(S!b!U7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z'Ad#:Zp$g&j(Pp(S!bo'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#<_![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#<_#S#U%Z#U#V#?i#V#X%Z#X#Y!4|#Y#b%Z#b#c#>_#c#d#Bq#d#l%Z#l#m#Es#m#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#<jk$g&j(Pp(S!bo'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#<_![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#<_#S#X%Z#X#Y!4|#Y#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#>j_$g&j(Pp(S!bo'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#?rd$g&j(Pp(S!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#AQ!R!S#AQ!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#AQ#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#A]f$g&j(Pp(S!bo'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#AQ!R!S#AQ!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#AQ#S#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Bzc$g&j(Pp(S!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#DV!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#DV#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Dbe$g&j(Pp(S!bo'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#DV!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#DV#S#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#E|g$g&j(Pp(S!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#Ge![!^%Z!^!_*g!_!c%Z!c!i#Ge!i#O%Z#O#P&c#P#R%Z#R#S#Ge#S#T%Z#T#Z#Ge#Z#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Gpi$g&j(Pp(S!bo'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#Ge![!^%Z!^!_*g!_!c%Z!c!i#Ge!i#O%Z#O#P&c#P#R%Z#R#S#Ge#S#T%Z#T#Z#Ge#Z#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z*)x#Il_!d$b$g&j#})Lv(Pp(S!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)[#Jv_`l$g&j(Pp(S!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z04f#LS^g#)`!i-<U(Pp(S!b(v7`OY*gZr*grs'}sw*gwx)rx!P*g!P!Q#MO!Q!^*g!^!_#Mt!_!`$ f!`#O*g#P;'S*g;'S;=`+Z<%lO*g(n#MXX$i&j(Pp(S!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g(El#M}Z#o(Ch(Pp(S!bOY*gZr*grs'}sw*gwx)rx!_*g!_!`#Np!`#O*g#P;'S*g;'S;=`+Z<%lO*g(El#NyX$P(Ch(Pp(S!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g(El$ oX#p(Ch(Pp(S!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g*)x$!ga#]*!Y$g&j(Pp(S!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`!a$#l!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(K[$#w_#h(Cl$g&j(Pp(S!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z*)x$%Vaf!*r#p(Ch$d#|$g&j(Pp(S!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`$&[!`!a$'f!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$&g_#p(Ch$g&j(Pp(S!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$'qa#o(Ch$g&j(Pp(S!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`!a$(v!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$)R`#o(Ch$g&j(Pp(S!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z-!n$*`c(j(Ct$g&j(Pp(S!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P$+k!P!^%Z!^!_*g!_!a%Z!a!b$,u!b#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z-!f$+v_},Hv$g&j(Pp(S!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$-Q`$g&j#z(Ch(Pp(S!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#`$.__!|$Ip$g&j(Pp(S!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z04f$/i_!P0,v$g&j(Pp(S!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(n$0mZ$g&jO!^$1`!^!_$1v!_#i$1`#i#j$1{#j#l$1`#l#m$3n#m#o$1`#o#p$1v#p;'S$1`;'S;=`$5y<%lO$1`(n$1gT^#S$g&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c#S$1{O^#S(n$2Q[$g&jO!Q&c!Q![$2v![!^&c!_!c&c!c!i$2v!i#T&c#T#Z$2v#Z#o&c#o#p$5^#p;'S&c;'S;=`&w<%lO&c(n$2{Z$g&jO!Q&c!Q![$3n![!^&c!_!c&c!c!i$3n!i#T&c#T#Z$3n#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$3sZ$g&jO!Q&c!Q![$4f![!^&c!_!c&c!c!i$4f!i#T&c#T#Z$4f#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$4kZ$g&jO!Q&c!Q![$1`![!^&c!_!c&c!c!i$1`!i#T&c#T#Z$1`#Z#o&c#p;'S&c;'S;=`&w<%lO&c#S$5aR!Q![$5j!c!i$5j#T#Z$5j#S$5mS!Q![$5j!c!i$5j#T#Z$5j#q#r$1v(n$5|P;=`<%l$1`#1[$6[_!V#)l$g&j(Pp(S!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$7f`#w(Ch$g&j(Pp(S!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z+;p$8s_$g&j(Pp(S!b(Y+4QOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[$:Rk$g&j(Pp(S!b'|,2j$]#t(]$I[OY%ZYZ&cZr%Zrs&}st%Ztu$9ruw%Zwx(rx}%Z}!O$;v!O!Q%Z!Q![$9r![!^%Z!^!_*g!_!c%Z!c!}$9r!}#O%Z#O#P&c#P#R%Z#R#S$9r#S#T%Z#T#o$9r#o#p*g#p$g%Z$g;'S$9r;'S;=`$=|<%lO$9r+d$<Rk$g&j(Pp(S!b$]#tOY%ZYZ&cZr%Zrs&}st%Ztu$;vuw%Zwx(rx}%Z}!O$;v!O!Q%Z!Q![$;v![!^%Z!^!_*g!_!c%Z!c!}$;v!}#O%Z#O#P&c#P#R%Z#R#S$;v#S#T%Z#T#o$;v#o#p*g#p$g%Z$g;'S$;v;'S;=`$=v<%lO$;v+d$=yP;=`<%l$;v07[$>PP;=`<%l$9r#Jf$>]X![#Hb(Pp(S!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g,#x$?Ta(q+JY$g&j(Pp(S!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p#q$,u#q;'S%Z;'S;=`+a<%lO%Z(Kd$@g_!Z(Cdr`$g&j(Pp(S!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z?O$Aq_!q7`$g&j(Pp(S!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[$CR|$g&j(Pp(S!b'u0/l$Z#t'|,2j(]$I[OX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$f%Z$f$g+g$g#BYEr#BY#BZ$Bp#BZ$ISEr$IS$I_$Bp$I_$JTEr$JT$JU$Bp$JU$KVEr$KV$KW$Bp$KW&FUEr&FU&FV$Bp&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$Bp?HUOEr07[$F^k$g&j(Pp(S!b'v0/l$Z#t'|,2j(]$I[OY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr",
  tokenizers: [rG, iG, oG, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, nG, new kd("$S~RRtu[#O#Pg#S#T#|~_P#o#pb~gOt~~jVO#i!P#i#j!U#j#l!P#l#m!q#m;'S!P;'S;=`#v<%lO!P~!UO!R~~!XS!Q![!e!c!i!e#T#Z!e#o#p#Z~!hR!Q![!q!c!i!q#T#Z!q~!tR!Q![!}!c!i!}#T#Z!}~#QR!Q![!P!c!i!P#T#Z!P~#^R!Q![#g!c!i#g#T#Z#g~#jS!Q![#g!c!i#g#T#Z#g#q#r!P~#yP;=`<%l!P~$RO([~~", 141, 333), new kd("j~RQYZXz{^~^O'y~~aP!P!Qd~iO'z~~", 25, 316)],
  topRules: { Script: [0, 6], SingleExpression: [1, 270], SingleClassItem: [2, 271] },
  dialects: { jsx: 0, ts: 14840 },
  dynamicPrecedences: { 70: 1, 80: 1, 82: 1, 166: 1, 194: 1 },
  specialized: [{ term: 320, get: (t4) => aG[t4] || -1 }, { term: 335, get: (t4) => lG[t4] || -1 }, { term: 71, get: (t4) => cG[t4] || -1 }],
  tokenPrec: 14864
});
var e$ = [
  /* @__PURE__ */ nr("function ${name}(${params}) {\n	${}\n}", {
    label: "function",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ nr("for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\n	${}\n}", {
    label: "for",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ nr("for (let ${name} of ${collection}) {\n	${}\n}", {
    label: "for",
    detail: "of loop",
    type: "keyword"
  }),
  /* @__PURE__ */ nr("do {\n	${}\n} while (${})", {
    label: "do",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ nr("while (${}) {\n	${}\n}", {
    label: "while",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ nr(`try {
	\${}
} catch (\${error}) {
	\${}
}`, {
    label: "try",
    detail: "/ catch block",
    type: "keyword"
  }),
  /* @__PURE__ */ nr("if (${}) {\n	${}\n}", {
    label: "if",
    detail: "block",
    type: "keyword"
  }),
  /* @__PURE__ */ nr(`if (\${}) {
	\${}
} else {
	\${}
}`, {
    label: "if",
    detail: "/ else block",
    type: "keyword"
  }),
  /* @__PURE__ */ nr(`class \${name} {
	constructor(\${params}) {
		\${}
	}
}`, {
    label: "class",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ nr('import {${names}} from "${module}"\n${}', {
    label: "import",
    detail: "named",
    type: "keyword"
  }),
  /* @__PURE__ */ nr('import ${name} from "${module}"\n${}', {
    label: "import",
    detail: "default",
    type: "keyword"
  })
];
var fG = /* @__PURE__ */ e$.concat([
  /* @__PURE__ */ nr("interface ${name} {\n	${}\n}", {
    label: "interface",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ nr("type ${name} = ${type}", {
    label: "type",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ nr("enum ${name} {\n	${}\n}", {
    label: "enum",
    detail: "definition",
    type: "keyword"
  })
]);
var LS = /* @__PURE__ */ new aT();
var t$ = /* @__PURE__ */ new Set([
  "Script",
  "Block",
  "FunctionExpression",
  "FunctionDeclaration",
  "ArrowFunction",
  "MethodDeclaration",
  "ForStatement"
]);
function yl(t4) {
  return (e, n) => {
    let r = e.node.getChild("VariableDefinition");
    return r && n(r, t4), true;
  };
}
var dG = ["FunctionDeclaration"];
var hG = {
  FunctionDeclaration: /* @__PURE__ */ yl("function"),
  ClassDeclaration: /* @__PURE__ */ yl("class"),
  ClassExpression: () => true,
  EnumDeclaration: /* @__PURE__ */ yl("constant"),
  TypeAliasDeclaration: /* @__PURE__ */ yl("type"),
  NamespaceDeclaration: /* @__PURE__ */ yl("namespace"),
  VariableDefinition(t4, e) {
    t4.matchContext(dG) || e(t4, "variable");
  },
  TypeDefinition(t4, e) {
    e(t4, "type");
  },
  __proto__: null
};
function n$(t4, e) {
  let n = LS.get(e);
  if (n)
    return n;
  let r = [], i = true;
  function o(s, a) {
    let l = t4.sliceString(s.from, s.to);
    r.push({ label: l, type: a });
  }
  return e.cursor(Rt.IncludeAnonymous).iterate((s) => {
    if (i)
      i = false;
    else if (s.name) {
      let a = hG[s.name];
      if (a && a(s, o) || t$.has(s.name))
        return false;
    } else if (s.to - s.from > 8192) {
      for (let a of n$(t4, s.node))
        r.push(a);
      return false;
    }
  }), LS.set(e, r), r;
}
var XS = /^[\w$\xa1-\uffff][\w$\d\xa1-\uffff]*$/;
var r$ = [
  "TemplateString",
  "String",
  "RegExp",
  "LineComment",
  "BlockComment",
  "VariableDefinition",
  "TypeDefinition",
  "Label",
  "PropertyDefinition",
  "PropertyName",
  "PrivatePropertyDefinition",
  "PrivatePropertyName",
  ".",
  "?."
];
function pG(t4) {
  let e = Ft(t4.state).resolveInner(t4.pos, -1);
  if (r$.indexOf(e.name) > -1)
    return null;
  let n = e.name == "VariableName" || e.to - e.from < 20 && XS.test(t4.state.sliceDoc(e.from, e.to));
  if (!n && !t4.explicit)
    return null;
  let r = [];
  for (let i = e; i; i = i.parent)
    t$.has(i.name) && (r = r.concat(n$(t4.state.doc, i)));
  return {
    options: r,
    from: n ? e.from : t4.pos,
    validFor: XS
  };
}
var Ci = /* @__PURE__ */ Do.define({
  name: "javascript",
  parser: /* @__PURE__ */ uG.configure({
    props: [
      /* @__PURE__ */ Ha.add({
        IfStatement: /* @__PURE__ */ ua({ except: /^\s*({|else\b)/ }),
        TryStatement: /* @__PURE__ */ ua({ except: /^\s*({|catch\b|finally\b)/ }),
        LabeledStatement: CW,
        SwitchBody: (t4) => {
          let e = t4.textAfter, n = /^\s*\}/.test(e), r = /^\s*(case|default)\b/.test(e);
          return t4.baseIndent + (n ? 0 : r ? 1 : 2) * t4.unit;
        },
        Block: /* @__PURE__ */ wW({ closing: "}" }),
        ArrowFunction: (t4) => t4.baseIndent + t4.unit,
        "TemplateString BlockComment": () => null,
        "Statement Property": /* @__PURE__ */ ua({ except: /^{/ }),
        JSXElement(t4) {
          let e = /^\s*<\//.test(t4.textAfter);
          return t4.lineIndent(t4.node.from) + (e ? 0 : t4.unit);
        },
        JSXEscape(t4) {
          let e = /\s*\}/.test(t4.textAfter);
          return t4.lineIndent(t4.node.from) + (e ? 0 : t4.unit);
        },
        "JSXOpenTag JSXSelfClosingTag"(t4) {
          return t4.column(t4.node.from) + t4.unit;
        }
      }),
      /* @__PURE__ */ Ja.add({
        "Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression ObjectType": Bx,
        BlockComment(t4) {
          return { from: t4.from + 2, to: t4.to - 2 };
        }
      })
    ]
  }),
  languageData: {
    closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] },
    commentTokens: { line: "//", block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*(?:case |default:|\{|\}|<\/)$/,
    wordChars: "$"
  }
});
var i$ = {
  test: (t4) => /^JSX/.test(t4.name),
  facet: /* @__PURE__ */ dT({ commentTokens: { block: { open: "{/*", close: "*/}" } } })
};
var o$ = /* @__PURE__ */ Ci.configure({ dialect: "ts" }, "typescript");
var s$ = /* @__PURE__ */ Ci.configure({
  dialect: "jsx",
  props: [/* @__PURE__ */ Rx.add((t4) => t4.isTop ? [i$] : void 0)]
});
var a$ = /* @__PURE__ */ Ci.configure({
  dialect: "jsx ts",
  props: [/* @__PURE__ */ Rx.add((t4) => t4.isTop ? [i$] : void 0)]
}, "typescript");
var l$ = (t4) => ({ label: t4, type: "keyword" });
var c$ = /* @__PURE__ */ "break case const continue default delete export extends false finally in instanceof let new return static super switch this throw true typeof var yield".split(" ").map(l$);
var gG = /* @__PURE__ */ c$.concat(/* @__PURE__ */ ["declare", "implements", "private", "protected", "public"].map(l$));
function mG(t4 = {}) {
  let e = t4.jsx ? t4.typescript ? a$ : s$ : t4.typescript ? o$ : Ci, n = t4.typescript ? fG.concat(gG) : e$.concat(c$);
  return new Bc(e, [
    Ci.data.of({
      autocomplete: W7(r$, mI(n))
    }),
    Ci.data.of({
      autocomplete: pG
    }),
    t4.jsx ? vG : []
  ]);
}
function OG(t4) {
  for (; ; ) {
    if (t4.name == "JSXOpenTag" || t4.name == "JSXSelfClosingTag" || t4.name == "JSXFragmentTag")
      return t4;
    if (t4.name == "JSXEscape" || !t4.parent)
      return null;
    t4 = t4.parent;
  }
}
function GS(t4, e, n = t4.length) {
  for (let r = e == null ? void 0 : e.firstChild; r; r = r.nextSibling)
    if (r.name == "JSXIdentifier" || r.name == "JSXBuiltin" || r.name == "JSXNamespacedName" || r.name == "JSXMemberExpression")
      return t4.sliceString(r.from, Math.min(r.to, n));
  return "";
}
var xG = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent);
var vG = /* @__PURE__ */ ue.inputHandler.of((t4, e, n, r, i) => {
  if ((xG ? t4.composing : t4.compositionStarted) || t4.state.readOnly || e != n || r != ">" && r != "/" || !Ci.isActiveAt(t4.state, e, -1))
    return false;
  let o = i(), { state: s } = o, a = s.changeByRange((l) => {
    var c;
    let { head: u } = l, f = Ft(s).resolveInner(u - 1, -1), d;
    if (f.name == "JSXStartTag" && (f = f.parent), !(s.doc.sliceString(u - 1, u) != r || f.name == "JSXAttributeValue" && f.to > u)) {
      if (r == ">" && f.name == "JSXFragmentTag")
        return { range: l, changes: { from: u, insert: "</>" } };
      if (r == "/" && f.name == "JSXStartCloseTag") {
        let h = f.parent, p = h.parent;
        if (p && h.from == u - 2 && ((d = GS(s.doc, p.firstChild, u)) || ((c = p.firstChild) === null || c === void 0 ? void 0 : c.name) == "JSXFragmentTag")) {
          let O = `${d}>`;
          return { range: ne.cursor(u + O.length, -1), changes: { from: u, insert: O } };
        }
      } else if (r == ">") {
        let h = OG(f);
        if (h && h.name == "JSXOpenTag" && !/^\/?>|^<\//.test(s.doc.sliceString(u, u + 2)) && (d = GS(s.doc, h, u)))
          return { range: l, changes: { from: u, insert: `</${d}>` } };
      }
    }
    return { range: l };
  });
  return a.changes.empty ? false : (t4.dispatch([
    o,
    s.update(a, { userEvent: "input.complete", scrollIntoView: true })
  ]), true);
});
var bl = ["_blank", "_self", "_top", "_parent"];
var n0 = ["ascii", "utf-8", "utf-16", "latin1", "latin1"];
var r0 = ["get", "post", "put", "delete"];
var i0 = ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"];
var pr = ["true", "false"];
var Se = {};
var yG = {
  a: {
    attrs: {
      href: null,
      ping: null,
      type: null,
      media: null,
      target: bl,
      hreflang: null
    }
  },
  abbr: Se,
  address: Se,
  area: {
    attrs: {
      alt: null,
      coords: null,
      href: null,
      target: null,
      ping: null,
      media: null,
      hreflang: null,
      type: null,
      shape: ["default", "rect", "circle", "poly"]
    }
  },
  article: Se,
  aside: Se,
  audio: {
    attrs: {
      src: null,
      mediagroup: null,
      crossorigin: ["anonymous", "use-credentials"],
      preload: ["none", "metadata", "auto"],
      autoplay: ["autoplay"],
      loop: ["loop"],
      controls: ["controls"]
    }
  },
  b: Se,
  base: { attrs: { href: null, target: bl } },
  bdi: Se,
  bdo: Se,
  blockquote: { attrs: { cite: null } },
  body: Se,
  br: Se,
  button: {
    attrs: {
      form: null,
      formaction: null,
      name: null,
      value: null,
      autofocus: ["autofocus"],
      disabled: ["autofocus"],
      formenctype: i0,
      formmethod: r0,
      formnovalidate: ["novalidate"],
      formtarget: bl,
      type: ["submit", "reset", "button"]
    }
  },
  canvas: { attrs: { width: null, height: null } },
  caption: Se,
  center: Se,
  cite: Se,
  code: Se,
  col: { attrs: { span: null } },
  colgroup: { attrs: { span: null } },
  command: {
    attrs: {
      type: ["command", "checkbox", "radio"],
      label: null,
      icon: null,
      radiogroup: null,
      command: null,
      title: null,
      disabled: ["disabled"],
      checked: ["checked"]
    }
  },
  data: { attrs: { value: null } },
  datagrid: { attrs: { disabled: ["disabled"], multiple: ["multiple"] } },
  datalist: { attrs: { data: null } },
  dd: Se,
  del: { attrs: { cite: null, datetime: null } },
  details: { attrs: { open: ["open"] } },
  dfn: Se,
  div: Se,
  dl: Se,
  dt: Se,
  em: Se,
  embed: { attrs: { src: null, type: null, width: null, height: null } },
  eventsource: { attrs: { src: null } },
  fieldset: { attrs: { disabled: ["disabled"], form: null, name: null } },
  figcaption: Se,
  figure: Se,
  footer: Se,
  form: {
    attrs: {
      action: null,
      name: null,
      "accept-charset": n0,
      autocomplete: ["on", "off"],
      enctype: i0,
      method: r0,
      novalidate: ["novalidate"],
      target: bl
    }
  },
  h1: Se,
  h2: Se,
  h3: Se,
  h4: Se,
  h5: Se,
  h6: Se,
  head: {
    children: ["title", "base", "link", "style", "meta", "script", "noscript", "command"]
  },
  header: Se,
  hgroup: Se,
  hr: Se,
  html: {
    attrs: { manifest: null }
  },
  i: Se,
  iframe: {
    attrs: {
      src: null,
      srcdoc: null,
      name: null,
      width: null,
      height: null,
      sandbox: ["allow-top-navigation", "allow-same-origin", "allow-forms", "allow-scripts"],
      seamless: ["seamless"]
    }
  },
  img: {
    attrs: {
      alt: null,
      src: null,
      ismap: null,
      usemap: null,
      width: null,
      height: null,
      crossorigin: ["anonymous", "use-credentials"]
    }
  },
  input: {
    attrs: {
      alt: null,
      dirname: null,
      form: null,
      formaction: null,
      height: null,
      list: null,
      max: null,
      maxlength: null,
      min: null,
      name: null,
      pattern: null,
      placeholder: null,
      size: null,
      src: null,
      step: null,
      value: null,
      width: null,
      accept: ["audio/*", "video/*", "image/*"],
      autocomplete: ["on", "off"],
      autofocus: ["autofocus"],
      checked: ["checked"],
      disabled: ["disabled"],
      formenctype: i0,
      formmethod: r0,
      formnovalidate: ["novalidate"],
      formtarget: bl,
      multiple: ["multiple"],
      readonly: ["readonly"],
      required: ["required"],
      type: [
        "hidden",
        "text",
        "search",
        "tel",
        "url",
        "email",
        "password",
        "datetime",
        "date",
        "month",
        "week",
        "time",
        "datetime-local",
        "number",
        "range",
        "color",
        "checkbox",
        "radio",
        "file",
        "submit",
        "image",
        "reset",
        "button"
      ]
    }
  },
  ins: { attrs: { cite: null, datetime: null } },
  kbd: Se,
  keygen: {
    attrs: {
      challenge: null,
      form: null,
      name: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      keytype: ["RSA"]
    }
  },
  label: { attrs: { for: null, form: null } },
  legend: Se,
  li: { attrs: { value: null } },
  link: {
    attrs: {
      href: null,
      type: null,
      hreflang: null,
      media: null,
      sizes: ["all", "16x16", "16x16 32x32", "16x16 32x32 64x64"]
    }
  },
  map: { attrs: { name: null } },
  mark: Se,
  menu: { attrs: { label: null, type: ["list", "context", "toolbar"] } },
  meta: {
    attrs: {
      content: null,
      charset: n0,
      name: ["viewport", "application-name", "author", "description", "generator", "keywords"],
      "http-equiv": ["content-language", "content-type", "default-style", "refresh"]
    }
  },
  meter: { attrs: { value: null, min: null, low: null, high: null, max: null, optimum: null } },
  nav: Se,
  noscript: Se,
  object: {
    attrs: {
      data: null,
      type: null,
      name: null,
      usemap: null,
      form: null,
      width: null,
      height: null,
      typemustmatch: ["typemustmatch"]
    }
  },
  ol: {
    attrs: { reversed: ["reversed"], start: null, type: ["1", "a", "A", "i", "I"] },
    children: ["li", "script", "template", "ul", "ol"]
  },
  optgroup: { attrs: { disabled: ["disabled"], label: null } },
  option: { attrs: { disabled: ["disabled"], label: null, selected: ["selected"], value: null } },
  output: { attrs: { for: null, form: null, name: null } },
  p: Se,
  param: { attrs: { name: null, value: null } },
  pre: Se,
  progress: { attrs: { value: null, max: null } },
  q: { attrs: { cite: null } },
  rp: Se,
  rt: Se,
  ruby: Se,
  samp: Se,
  script: {
    attrs: {
      type: ["text/javascript"],
      src: null,
      async: ["async"],
      defer: ["defer"],
      charset: n0
    }
  },
  section: Se,
  select: {
    attrs: {
      form: null,
      name: null,
      size: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      multiple: ["multiple"]
    }
  },
  slot: { attrs: { name: null } },
  small: Se,
  source: { attrs: { src: null, type: null, media: null } },
  span: Se,
  strong: Se,
  style: {
    attrs: {
      type: ["text/css"],
      media: null,
      scoped: null
    }
  },
  sub: Se,
  summary: Se,
  sup: Se,
  table: Se,
  tbody: Se,
  td: { attrs: { colspan: null, rowspan: null, headers: null } },
  template: Se,
  textarea: {
    attrs: {
      dirname: null,
      form: null,
      maxlength: null,
      name: null,
      placeholder: null,
      rows: null,
      cols: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      readonly: ["readonly"],
      required: ["required"],
      wrap: ["soft", "hard"]
    }
  },
  tfoot: Se,
  th: { attrs: { colspan: null, rowspan: null, headers: null, scope: ["row", "col", "rowgroup", "colgroup"] } },
  thead: Se,
  time: { attrs: { datetime: null } },
  title: Se,
  tr: Se,
  track: {
    attrs: {
      src: null,
      label: null,
      default: null,
      kind: ["subtitles", "captions", "descriptions", "chapters", "metadata"],
      srclang: null
    }
  },
  ul: { children: ["li", "script", "template", "ul", "ol"] },
  var: Se,
  video: {
    attrs: {
      src: null,
      poster: null,
      width: null,
      height: null,
      crossorigin: ["anonymous", "use-credentials"],
      preload: ["auto", "metadata", "none"],
      autoplay: ["autoplay"],
      mediagroup: ["movie"],
      muted: ["muted"],
      controls: ["controls"]
    }
  },
  wbr: Se
};
var u$ = {
  accesskey: null,
  class: null,
  contenteditable: pr,
  contextmenu: null,
  dir: ["ltr", "rtl", "auto"],
  draggable: ["true", "false", "auto"],
  dropzone: ["copy", "move", "link", "string:", "file:"],
  hidden: ["hidden"],
  id: null,
  inert: ["inert"],
  itemid: null,
  itemprop: null,
  itemref: null,
  itemscope: ["itemscope"],
  itemtype: null,
  lang: ["ar", "bn", "de", "en-GB", "en-US", "es", "fr", "hi", "id", "ja", "pa", "pt", "ru", "tr", "zh"],
  spellcheck: pr,
  autocorrect: pr,
  autocapitalize: pr,
  style: null,
  tabindex: null,
  title: null,
  translate: ["yes", "no"],
  rel: ["stylesheet", "alternate", "author", "bookmark", "help", "license", "next", "nofollow", "noreferrer", "prefetch", "prev", "search", "tag"],
  role: /* @__PURE__ */ "alert application article banner button cell checkbox complementary contentinfo dialog document feed figure form grid gridcell heading img list listbox listitem main navigation region row rowgroup search switch tab table tabpanel textbox timer".split(" "),
  "aria-activedescendant": null,
  "aria-atomic": pr,
  "aria-autocomplete": ["inline", "list", "both", "none"],
  "aria-busy": pr,
  "aria-checked": ["true", "false", "mixed", "undefined"],
  "aria-controls": null,
  "aria-describedby": null,
  "aria-disabled": pr,
  "aria-dropeffect": null,
  "aria-expanded": ["true", "false", "undefined"],
  "aria-flowto": null,
  "aria-grabbed": ["true", "false", "undefined"],
  "aria-haspopup": pr,
  "aria-hidden": pr,
  "aria-invalid": ["true", "false", "grammar", "spelling"],
  "aria-label": null,
  "aria-labelledby": null,
  "aria-level": null,
  "aria-live": ["off", "polite", "assertive"],
  "aria-multiline": pr,
  "aria-multiselectable": pr,
  "aria-owns": null,
  "aria-posinset": null,
  "aria-pressed": ["true", "false", "mixed", "undefined"],
  "aria-readonly": pr,
  "aria-relevant": null,
  "aria-required": pr,
  "aria-selected": ["true", "false", "undefined"],
  "aria-setsize": null,
  "aria-sort": ["ascending", "descending", "none", "other"],
  "aria-valuemax": null,
  "aria-valuemin": null,
  "aria-valuenow": null,
  "aria-valuetext": null
};
var f$ = /* @__PURE__ */ "beforeunload copy cut dragstart dragover dragleave dragenter dragend drag paste focus blur change click load mousedown mouseenter mouseleave mouseup keydown keyup resize scroll unload".split(" ").map((t4) => "on" + t4);
for (let t4 of f$)
  u$[t4] = null;
var Td = class {
  constructor(e, n) {
    this.tags = Object.assign(Object.assign({}, yG), e), this.globalAttrs = Object.assign(Object.assign({}, u$), n), this.allTags = Object.keys(this.tags), this.globalAttrNames = Object.keys(this.globalAttrs);
  }
};
Td.default = /* @__PURE__ */ new Td();
function Ia(t4, e, n = t4.length) {
  if (!e)
    return "";
  let r = e.firstChild, i = r && r.getChild("TagName");
  return i ? t4.sliceString(i.from, Math.min(i.to, n)) : "";
}
function $a(t4, e = false) {
  for (; t4; t4 = t4.parent)
    if (t4.name == "Element")
      if (e)
        e = false;
      else
        return t4;
  return null;
}
function d$(t4, e, n) {
  let r = n.tags[Ia(t4, $a(e))];
  return (r == null ? void 0 : r.children) || n.allTags;
}
function iv(t4, e) {
  let n = [];
  for (let r = $a(e); r && !r.type.isTop; r = $a(r.parent)) {
    let i = Ia(t4, r);
    if (i && r.lastChild.name == "CloseTag")
      break;
    i && n.indexOf(i) < 0 && (e.name == "EndTag" || e.from >= r.firstChild.to) && n.push(i);
  }
  return n;
}
var h$ = /^[:\-\.\w\u00b7-\uffff]*$/;
function YS(t4, e, n, r, i) {
  let o = /\s*>/.test(t4.sliceDoc(i, i + 5)) ? "" : ">", s = $a(n, true);
  return {
    from: r,
    to: i,
    options: d$(t4.doc, s, e).map((a) => ({ label: a, type: "type" })).concat(iv(t4.doc, n).map((a, l) => ({
      label: "/" + a,
      apply: "/" + a + o,
      type: "type",
      boost: 99 - l
    }))),
    validFor: /^\/?[:\-\.\w\u00b7-\uffff]*$/
  };
}
function qS(t4, e, n, r) {
  let i = /\s*>/.test(t4.sliceDoc(r, r + 5)) ? "" : ">";
  return {
    from: n,
    to: r,
    options: iv(t4.doc, e).map((o, s) => ({ label: o, apply: o + i, type: "type", boost: 99 - s })),
    validFor: h$
  };
}
function bG(t4, e, n, r) {
  let i = [], o = 0;
  for (let s of d$(t4.doc, n, e))
    i.push({ label: "<" + s, type: "type" });
  for (let s of iv(t4.doc, n))
    i.push({ label: "</" + s + ">", type: "type", boost: 99 - o++ });
  return { from: r, to: r, options: i, validFor: /^<\/?[:\-\.\w\u00b7-\uffff]*$/ };
}
function SG(t4, e, n, r, i) {
  let o = $a(n), s = o ? e.tags[Ia(t4.doc, o)] : null, a = s && s.attrs ? Object.keys(s.attrs) : [], l = s && s.globalAttrs === false ? a : a.length ? a.concat(e.globalAttrNames) : e.globalAttrNames;
  return {
    from: r,
    to: i,
    options: l.map((c) => ({ label: c, type: "property" })),
    validFor: h$
  };
}
function wG(t4, e, n, r, i) {
  var o;
  let s = (o = n.parent) === null || o === void 0 ? void 0 : o.getChild("AttributeName"), a = [], l;
  if (s) {
    let c = t4.sliceDoc(s.from, s.to), u = e.globalAttrs[c];
    if (!u) {
      let f = $a(n), d = f ? e.tags[Ia(t4.doc, f)] : null;
      u = (d == null ? void 0 : d.attrs) && d.attrs[c];
    }
    if (u) {
      let f = t4.sliceDoc(r, i).toLowerCase(), d = '"', h = '"';
      /^['"]/.test(f) ? (l = f[0] == '"' ? /^[^"]*$/ : /^[^']*$/, d = "", h = t4.sliceDoc(i, i + 1) == f[0] ? "" : f[0], f = f.slice(1), r++) : l = /^[^\s<>='"]*$/;
      for (let p of u)
        a.push({ label: p, apply: d + p + h, type: "constant" });
    }
  }
  return { from: r, to: i, options: a, validFor: l };
}
function CG(t4, e) {
  let { state: n, pos: r } = e, i = Ft(n).resolveInner(r, -1), o = i.resolve(r);
  for (let s = r, a; o == i && (a = i.childBefore(s)); ) {
    let l = a.lastChild;
    if (!l || !l.type.isError || l.from < l.to)
      break;
    o = i = a, s = l.from;
  }
  return i.name == "TagName" ? i.parent && /CloseTag$/.test(i.parent.name) ? qS(n, i, i.from, r) : YS(n, t4, i, i.from, r) : i.name == "StartTag" ? YS(n, t4, i, r, r) : i.name == "StartCloseTag" || i.name == "IncompleteCloseTag" ? qS(n, i, r, r) : i.name == "OpenTag" || i.name == "SelfClosingTag" || i.name == "AttributeName" ? SG(n, t4, i, i.name == "AttributeName" ? i.from : r, r) : i.name == "Is" || i.name == "AttributeValue" || i.name == "UnquotedAttributeValue" ? wG(n, t4, i, i.name == "Is" ? r : i.from, r) : e.explicit && (o.name == "Element" || o.name == "Text" || o.name == "Document") ? bG(n, t4, i, r) : null;
}
function kG(t4) {
  let { extraTags: e, extraGlobalAttributes: n } = t4, r = n || e ? new Td(e, n) : Td.default;
  return (i) => CG(r, i);
}
var AG = /* @__PURE__ */ Ci.parser.configure({ top: "SingleExpression" });
var p$ = [
  {
    tag: "script",
    attrs: (t4) => t4.type == "text/typescript" || t4.lang == "ts",
    parser: o$.parser
  },
  {
    tag: "script",
    attrs: (t4) => t4.type == "text/babel" || t4.type == "text/jsx",
    parser: s$.parser
  },
  {
    tag: "script",
    attrs: (t4) => t4.type == "text/typescript-jsx",
    parser: a$.parser
  },
  {
    tag: "script",
    attrs(t4) {
      return /^(importmap|speculationrules|application\/(.+\+)?json)$/i.test(t4.type);
    },
    parser: AG
  },
  {
    tag: "script",
    attrs(t4) {
      return !t4.type || /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^module$|^$/i.test(t4.type);
    },
    parser: Ci.parser
  },
  {
    tag: "style",
    attrs(t4) {
      return (!t4.lang || t4.lang == "css") && (!t4.type || /^(text\/)?(x-)?(stylesheet|css)$/i.test(t4.type));
    },
    parser: Ed.parser
  }
];
var g$ = /* @__PURE__ */ [
  {
    name: "style",
    parser: /* @__PURE__ */ Ed.parser.configure({ top: "Styles" })
  }
].concat(/* @__PURE__ */ f$.map((t4) => ({ name: t4, parser: Ci.parser })));
var m$ = /* @__PURE__ */ Do.define({
  name: "html",
  parser: /* @__PURE__ */ fX.configure({
    props: [
      /* @__PURE__ */ Ha.add({
        Element(t4) {
          let e = /^(\s*)(<\/)?/.exec(t4.textAfter);
          return t4.node.to <= t4.pos + e[0].length ? t4.continue() : t4.lineIndent(t4.node.from) + (e[2] ? 0 : t4.unit);
        },
        "OpenTag CloseTag SelfClosingTag"(t4) {
          return t4.column(t4.node.from) + t4.unit;
        },
        Document(t4) {
          if (t4.pos + /\s*/.exec(t4.textAfter)[0].length < t4.node.to)
            return t4.continue();
          let e = null, n;
          for (let r = t4.node; ; ) {
            let i = r.lastChild;
            if (!i || i.name != "Element" || i.to != r.to)
              break;
            e = r = i;
          }
          return e && !((n = e.lastChild) && (n.name == "CloseTag" || n.name == "SelfClosingTag")) ? t4.lineIndent(e.from) + t4.unit : null;
        }
      }),
      /* @__PURE__ */ Ja.add({
        Element(t4) {
          let e = t4.firstChild, n = t4.lastChild;
          return !e || e.name != "OpenTag" ? null : { from: e.to, to: n.name == "CloseTag" ? n.from : t4.to };
        }
      }),
      /* @__PURE__ */ Mx.add({
        "OpenTag CloseTag": (t4) => t4.getChild("TagName")
      })
    ]
  }),
  languageData: {
    commentTokens: { block: { open: "<!--", close: "-->" } },
    indentOnInput: /^\s*<\/\w+\W$/,
    wordChars: "-._"
  }
});
var yf = /* @__PURE__ */ m$.configure({
  wrap: /* @__PURE__ */ YI(p$, g$)
});
function PG(t4 = {}) {
  let e = "", n;
  t4.matchClosingTags === false && (e = "noMatch"), t4.selfClosingTags === true && (e = (e ? e + " " : "") + "selfClosing"), (t4.nestedLanguages && t4.nestedLanguages.length || t4.nestedAttributes && t4.nestedAttributes.length) && (n = YI((t4.nestedLanguages || []).concat(p$), (t4.nestedAttributes || []).concat(g$)));
  let r = n ? m$.configure({ wrap: n, dialect: e }) : e ? yf.configure({ dialect: e }) : yf;
  return new Bc(r, [
    yf.data.of({ autocomplete: kG(t4) }),
    t4.autoCloseTags !== false ? EG : [],
    mG().support,
    NX().support
  ]);
}
var US = /* @__PURE__ */ new Set(/* @__PURE__ */ "area base br col command embed frame hr img input keygen link meta param source track wbr menuitem".split(" "));
var EG = /* @__PURE__ */ ue.inputHandler.of((t4, e, n, r, i) => {
  if (t4.composing || t4.state.readOnly || e != n || r != ">" && r != "/" || !yf.isActiveAt(t4.state, e, -1))
    return false;
  let o = i(), { state: s } = o, a = s.changeByRange((l) => {
    var c, u, f;
    let d = s.doc.sliceString(l.from - 1, l.to) == r, { head: h } = l, p = Ft(s).resolveInner(h, -1), O;
    if (d && r == ">" && p.name == "EndTag") {
      let m = p.parent;
      if (((u = (c = m.parent) === null || c === void 0 ? void 0 : c.lastChild) === null || u === void 0 ? void 0 : u.name) != "CloseTag" && (O = Ia(s.doc, m.parent, h)) && !US.has(O)) {
        let x = h + (s.doc.sliceString(h, h + 1) === ">" ? 1 : 0), v = `</${O}>`;
        return { range: l, changes: { from: h, to: x, insert: v } };
      }
    } else if (d && r == "/" && p.name == "IncompleteCloseTag") {
      let m = p.parent;
      if (p.from == h - 2 && ((f = m.lastChild) === null || f === void 0 ? void 0 : f.name) != "CloseTag" && (O = Ia(s.doc, m, h)) && !US.has(O)) {
        let x = h + (s.doc.sliceString(h, h + 1) === ">" ? 1 : 0), v = `${O}>`;
        return {
          range: ne.cursor(h + v.length, -1),
          changes: { from: h, to: x, insert: v }
        };
      }
    }
    return { range: l };
  });
  return a.changes.empty ? false : (t4.dispatch([
    o,
    s.update(a, {
      userEvent: "input.complete",
      scrollIntoView: true
    })
  ]), true);
});
var Lm = 1;
var TG = 2;
var IG = 3;
var $G = 4;
var jG = 5;
var RG = 35;
var DG = 36;
var QG = 37;
var BG = 11;
var _G = 13;
function MG(t4) {
  return t4 == 45 || t4 == 46 || t4 == 58 || t4 >= 65 && t4 <= 90 || t4 == 95 || t4 >= 97 && t4 <= 122 || t4 >= 161;
}
function NG(t4) {
  return t4 == 9 || t4 == 10 || t4 == 13 || t4 == 32;
}
var HS = null;
var JS = null;
var KS = 0;
function Xm(t4, e) {
  let n = t4.pos + e;
  if (JS == t4 && KS == n)
    return HS;
  for (; NG(t4.peek(e)); )
    e++;
  let r = "";
  for (; ; ) {
    let i = t4.peek(e);
    if (!MG(i))
      break;
    r += String.fromCharCode(i), e++;
  }
  return JS = t4, KS = n, HS = r || null;
}
function ew(t4, e) {
  this.name = t4, this.parent = e, this.hash = e ? e.hash : 0;
  for (let n = 0; n < t4.length; n++)
    this.hash += (this.hash << 4) + t4.charCodeAt(n) + (t4.charCodeAt(n) << 8);
}
var FG = new tv({
  start: null,
  shift(t4, e, n, r) {
    return e == Lm ? new ew(Xm(r, 1) || "", t4) : t4;
  },
  reduce(t4, e) {
    return e == BG && t4 ? t4.parent : t4;
  },
  reuse(t4, e, n, r) {
    let i = e.type.id;
    return i == Lm || i == _G ? new ew(Xm(r, 1) || "", t4) : t4;
  },
  hash(t4) {
    return t4 ? t4.hash : 0;
  },
  strict: false
});
var ZG = new Cr((t4, e) => {
  if (t4.next == 60) {
    if (t4.advance(), t4.next == 47) {
      t4.advance();
      let n = Xm(t4, 0);
      if (!n)
        return t4.acceptToken(jG);
      if (e.context && n == e.context.name)
        return t4.acceptToken(TG);
      for (let r = e.context; r; r = r.parent)
        if (r.name == n)
          return t4.acceptToken(IG, -2);
      t4.acceptToken($G);
    } else if (t4.next != 33 && t4.next != 63)
      return t4.acceptToken(Lm);
  }
}, { contextual: true });
function ov(t4, e) {
  return new Cr((n) => {
    let r = 0, i = e.charCodeAt(0);
    e:
      for (; !(n.next < 0); n.advance(), r++)
        if (n.next == i) {
          for (let o = 1; o < e.length; o++)
            if (n.peek(o) != e.charCodeAt(o))
              continue e;
          break;
        }
    r && n.acceptToken(t4);
  });
}
var WG = ov(RG, "-->");
var VG = ov(DG, "?>");
var zG = ov(QG, "]]>");
var LG = Ua({
  Text: P.content,
  "StartTag StartCloseTag EndTag SelfCloseEndTag": P.angleBracket,
  TagName: P.tagName,
  "MismatchedCloseTag/TagName": [P.tagName, P.invalid],
  AttributeName: P.attributeName,
  AttributeValue: P.attributeValue,
  Is: P.definitionOperator,
  "EntityReference CharacterReference": P.character,
  Comment: P.blockComment,
  ProcessingInst: P.processingInstruction,
  DoctypeDecl: P.documentMeta,
  Cdata: P.special(P.string)
});
var XG = Bo.deserialize({
  version: 14,
  states: ",SOQOaOOOrOxO'#CfOzOpO'#CiO!tOaO'#CgOOOP'#Cg'#CgO!{OrO'#CrO#TOtO'#CsO#]OpO'#CtOOOP'#DS'#DSOOOP'#Cv'#CvQQOaOOOOOW'#Cw'#CwO#eOxO,59QOOOP,59Q,59QOOOO'#Cx'#CxO#mOpO,59TO#uO!bO,59TOOOP'#C{'#C{O$TOaO,59RO$[OpO'#CoOOOP,59R,59ROOOQ'#C|'#C|O$dOrO,59^OOOP,59^,59^OOOS'#C}'#C}O$lOtO,59_OOOP,59_,59_O$tOpO,59`O$|OpO,59`OOOP-E6t-E6tOOOW-E6u-E6uOOOP1G.l1G.lOOOO-E6v-E6vO%UO!bO1G.oO%UO!bO1G.oO%dOpO'#CkO%lO!bO'#CyO%zO!bO1G.oOOOP1G.o1G.oOOOP1G.w1G.wOOOP-E6y-E6yOOOP1G.m1G.mO&VOpO,59ZO&_OpO,59ZOOOQ-E6z-E6zOOOP1G.x1G.xOOOS-E6{-E6{OOOP1G.y1G.yO&gOpO1G.zO&gOpO1G.zOOOP1G.z1G.zO&oO!bO7+$ZO&}O!bO7+$ZOOOP7+$Z7+$ZOOOP7+$c7+$cO'YOpO,59VO'bOpO,59VO'jO!bO,59eOOOO-E6w-E6wO'xOpO1G.uO'xOpO1G.uOOOP1G.u1G.uO(QOpO7+$fOOOP7+$f7+$fO(YO!bO<<GuOOOP<<Gu<<GuOOOP<<G}<<G}O'bOpO1G.qO'bOpO1G.qO(eO#tO'#CnOOOO1G.q1G.qO(sOpO7+$aOOOP7+$a7+$aOOOP<<HQ<<HQOOOPAN=aAN=aOOOPAN=iAN=iO'bOpO7+$]OOOO7+$]7+$]OOOO'#Cz'#CzO({O#tO,59YOOOO,59Y,59YOOOP<<G{<<G{OOOO<<Gw<<GwOOOO-E6x-E6xOOOO1G.t1G.t",
  stateData: ")Z~OPQOSVOTWOVWOWWOXWOiXOxPO}TO!PUO~OuZOw]O~O^`Oy^O~OPQOQcOSVOTWOVWOWWOXWOxPO}TO!PUO~ORdO~P!SOseO|gO~OthO!OjO~O^lOy^O~OuZOwoO~O^qOy^O~O[vO`sOdwOy^O~ORyO~P!SO^{Oy^O~OseO|}O~OthO!O!PO~O^!QOy^O~O[!SOy^O~O[!VO`sOd!WOy^O~Oa!YOy^O~Oy^O[mX`mXdmX~O[!VO`sOd!WO~O^!]Oy^O~O[!_Oy^O~O[!aOy^O~O[!cO`sOd!dOy^O~O[!cO`sOd!dO~Oa!eOy^O~Oy^Oz!gO~Oy^O[ma`madma~O[!jOy^O~O[!kOy^O~O[!lO`sOd!mO~OW!pOX!pOz!rO{!pO~O[!sOy^O~OW!pOX!pOz!vO{!pO~O",
  goto: "%[wPPPPPPPPPPxxP!OP!UPP!_!iP!oxxxP!u!{#R$Z$j$p$v$|PPPP%SXWORYbXRORYb_t`qru!T!U!bQ!h!YS!o!e!fR!t!nQdRRybXSORYbQYORmYQ[PRn[Q_QQkVjp_krz!R!T!X!Z!^!`!f!i!nQr`QzcQ!RlQ!TqQ!XsQ!ZtQ!^{Q!`!QQ!f!YQ!i!]R!n!eQu`S!UqrU![u!U!bR!b!TQ!q!gR!u!qQbRRxbQfTR|fQiUR!OiSXOYTaRb",
  nodeNames: "\u26A0 StartTag StartCloseTag MissingCloseTag StartCloseTag StartCloseTag Document Text EntityReference CharacterReference Cdata Element EndTag OpenTag TagName Attribute AttributeName Is AttributeValue CloseTag SelfCloseEndTag SelfClosingTag Comment ProcessingInst MismatchedCloseTag DoctypeDecl",
  maxTerm: 47,
  context: FG,
  nodeProps: [
    ["closedBy", 1, "SelfCloseEndTag EndTag", 13, "CloseTag MissingCloseTag"],
    ["openedBy", 12, "StartTag StartCloseTag", 19, "OpenTag", 20, "StartTag"],
    ["isolate", -6, 13, 18, 19, 21, 22, 24, ""]
  ],
  propSources: [LG],
  skippedNodes: [0],
  repeatNodeCount: 8,
  tokenData: "Jy~R!XOX$nXY&kYZ&kZ]$n]^&k^p$npq&kqr$nrs'ssv$nvw(Zw}$n}!O,^!O!P$n!P!Q.m!Q![$n![!]0V!]!^$n!^!_3h!_!`El!`!aF_!a!bGQ!b!c$n!c!}0V!}#P$n#P#QHj#Q#R$n#R#S0V#S#T$n#T#o0V#o%W$n%W%o0V%o%p$n%p&a0V&a&b$n&b1p0V1p4U$n4U4d0V4d4e$n4e$IS0V$IS$I`$n$I`$Ib0V$Ib$Kh$n$Kh%#t0V%#t&/x$n&/x&Et0V&Et&FV$n&FV;'S0V;'S;:j3b;:j;=`&e<%l?&r$n?&r?Ah0V?Ah?BY$n?BY?Mn0V?MnO$nX$uWVP{WOr$nrs%_sv$nw!^$n!^!_%y!_;'S$n;'S;=`&e<%lO$nP%dTVPOv%_w!^%_!_;'S%_;'S;=`%s<%lO%_P%vP;=`<%l%_W&OT{WOr%ysv%yw;'S%y;'S;=`&_<%lO%yW&bP;=`<%l%yX&hP;=`<%l$n_&t_VP{WyUOX$nXY&kYZ&kZ]$n]^&k^p$npq&kqr$nrs%_sv$nw!^$n!^!_%y!_;'S$n;'S;=`&e<%lO$nZ'zTzYVPOv%_w!^%_!_;'S%_;'S;=`%s<%lO%_~(^ast)c![!]*g!c!}*g#R#S*g#T#o*g%W%o*g%p&a*g&b1p*g4U4d*g4e$IS*g$I`$Ib*g$Kh%#t*g&/x&Et*g&FV;'S*g;'S;:j,W?&r?Ah*g?BY?Mn*g~)fQ!Q![)l#l#m)z~)oQ!Q![)l!]!^)u~)zOX~~)}R!Q![*W!c!i*W#T#Z*W~*ZS!Q![*W!]!^)u!c!i*W#T#Z*W~*jg}!O*g!O!P*g!Q![*g![!]*g!]!^,R!c!}*g#R#S*g#T#o*g$}%O*g%W%o*g%p&a*g&b1p*g1p4U*g4U4d*g4e$IS*g$I`$Ib*g$Je$Jg*g$Kh%#t*g&/x&Et*g&FV;'S*g;'S;:j,W?&r?Ah*g?BY?Mn*g~,WOW~~,ZP;=`<%l*gZ,eYVP{WOr$nrs%_sv$nw}$n}!O-T!O!^$n!^!_%y!_;'S$n;'S;=`&e<%lO$nZ-[YVP{WOr$nrs%_sv$nw!^$n!^!_%y!_!`$n!`!a-z!a;'S$n;'S;=`&e<%lO$nZ.TW|QVP{WOr$nrs%_sv$nw!^$n!^!_%y!_;'S$n;'S;=`&e<%lO$n].tYVP{WOr$nrs%_sv$nw!^$n!^!_%y!_!`$n!`!a/d!a;'S$n;'S;=`&e<%lO$n]/mWdSVP{WOr$nrs%_sv$nw!^$n!^!_%y!_;'S$n;'S;=`&e<%lO$n_0b!O`S^QVP{WOr$nrs%_sv$nw}$n}!O0V!O!P0V!P!Q$n!Q![0V![!]0V!]!^$n!^!_%y!_!c$n!c!}0V!}#R$n#R#S0V#S#T$n#T#o0V#o$}$n$}%O0V%O%W$n%W%o0V%o%p$n%p&a0V&a&b$n&b1p0V1p4U0V4U4d0V4d4e$n4e$IS0V$IS$I`$n$I`$Ib0V$Ib$Je$n$Je$Jg0V$Jg$Kh$n$Kh%#t0V%#t&/x$n&/x&Et0V&Et&FV$n&FV;'S0V;'S;:j3b;:j;=`&e<%l?&r$n?&r?Ah0V?Ah?BY$n?BY?Mn0V?MnO$n_3eP;=`<%l0VX3mW{WOq%yqr4Vsv%yw!a%y!a!bEU!b;'S%y;'S;=`&_<%lO%yX4[]{WOr%ysv%yw}%y}!O5T!O!f%y!f!g6V!g!}%y!}#O;f#O#W%y#W#XAr#X;'S%y;'S;=`&_<%lO%yX5YV{WOr%ysv%yw}%y}!O5o!O;'S%y;'S;=`&_<%lO%yX5vT}P{WOr%ysv%yw;'S%y;'S;=`&_<%lO%yX6[V{WOr%ysv%yw!q%y!q!r6q!r;'S%y;'S;=`&_<%lO%yX6vV{WOr%ysv%yw!e%y!e!f7]!f;'S%y;'S;=`&_<%lO%yX7bV{WOr%ysv%yw!v%y!v!w7w!w;'S%y;'S;=`&_<%lO%yX7|V{WOr%ysv%yw!{%y!{!|8c!|;'S%y;'S;=`&_<%lO%yX8hV{WOr%ysv%yw!r%y!r!s8}!s;'S%y;'S;=`&_<%lO%yX9SV{WOr%ysv%yw!g%y!g!h9i!h;'S%y;'S;=`&_<%lO%yX9nX{WOr9irs:Zsv9ivw:Zw!`9i!`!a:x!a;'S9i;'S;=`;`<%lO9iP:^TO!`:Z!`!a:m!a;'S:Z;'S;=`:r<%lO:ZP:rOiPP:uP;=`<%l:ZX;PTiP{WOr%ysv%yw;'S%y;'S;=`&_<%lO%yX;cP;=`<%l9iX;kX{WOr%ysv%yw!e%y!e!f<W!f#V%y#V#W?f#W;'S%y;'S;=`&_<%lO%yX<]V{WOr%ysv%yw!f%y!f!g<r!g;'S%y;'S;=`&_<%lO%yX<wV{WOr%ysv%yw!c%y!c!d=^!d;'S%y;'S;=`&_<%lO%yX=cV{WOr%ysv%yw!v%y!v!w=x!w;'S%y;'S;=`&_<%lO%yX=}V{WOr%ysv%yw!c%y!c!d>d!d;'S%y;'S;=`&_<%lO%yX>iV{WOr%ysv%yw!}%y!}#O?O#O;'S%y;'S;=`&_<%lO%yX?VT{WxPOr%ysv%yw;'S%y;'S;=`&_<%lO%yX?kV{WOr%ysv%yw#W%y#W#X@Q#X;'S%y;'S;=`&_<%lO%yX@VV{WOr%ysv%yw#T%y#T#U@l#U;'S%y;'S;=`&_<%lO%yX@qV{WOr%ysv%yw#h%y#h#iAW#i;'S%y;'S;=`&_<%lO%yXA]V{WOr%ysv%yw#T%y#T#U>d#U;'S%y;'S;=`&_<%lO%yXAwV{WOr%ysv%yw#c%y#c#dB^#d;'S%y;'S;=`&_<%lO%yXBcV{WOr%ysv%yw#V%y#V#WBx#W;'S%y;'S;=`&_<%lO%yXB}V{WOr%ysv%yw#h%y#h#iCd#i;'S%y;'S;=`&_<%lO%yXCiV{WOr%ysv%yw#m%y#m#nDO#n;'S%y;'S;=`&_<%lO%yXDTV{WOr%ysv%yw#d%y#d#eDj#e;'S%y;'S;=`&_<%lO%yXDoV{WOr%ysv%yw#X%y#X#Y9i#Y;'S%y;'S;=`&_<%lO%yXE]T!PP{WOr%ysv%yw;'S%y;'S;=`&_<%lO%yZEuWaQVP{WOr$nrs%_sv$nw!^$n!^!_%y!_;'S$n;'S;=`&e<%lO$n_FhW[UVP{WOr$nrs%_sv$nw!^$n!^!_%y!_;'S$n;'S;=`&e<%lO$nZGXYVP{WOr$nrs%_sv$nw!^$n!^!_%y!_!`$n!`!aGw!a;'S$n;'S;=`&e<%lO$nZHQW!OQVP{WOr$nrs%_sv$nw!^$n!^!_%y!_;'S$n;'S;=`&e<%lO$nZHqYVP{WOr$nrs%_sv$nw!^$n!^!_%y!_#P$n#P#QIa#Q;'S$n;'S;=`&e<%lO$nZIhYVP{WOr$nrs%_sv$nw!^$n!^!_%y!_!`$n!`!aJW!a;'S$n;'S;=`&e<%lO$nZJaWwQVP{WOr$nrs%_sv$nw!^$n!^!_%y!_;'S$n;'S;=`&e<%lO$n",
  tokenizers: [ZG, WG, VG, zG, 0, 1, 2, 3],
  topRules: { Document: [0, 6] },
  tokenPrec: 0
});
function bf(t4, e) {
  let n = e && e.getChild("TagName");
  return n ? t4.sliceString(n.from, n.to) : "";
}
function o0(t4, e) {
  let n = e && e.firstChild;
  return !n || n.name != "OpenTag" ? "" : bf(t4, n);
}
function GG(t4, e, n) {
  let r = e && e.getChildren("Attribute").find((o) => o.from <= n && o.to >= n), i = r && r.getChild("AttributeName");
  return i ? t4.sliceString(i.from, i.to) : "";
}
function s0(t4) {
  for (let e = t4 && t4.parent; e; e = e.parent)
    if (e.name == "Element")
      return e;
  return null;
}
function YG(t4, e) {
  var n;
  let r = Ft(t4).resolveInner(e, -1), i = null;
  for (let o = r; !i && o.parent; o = o.parent)
    (o.name == "OpenTag" || o.name == "CloseTag" || o.name == "SelfClosingTag" || o.name == "MismatchedCloseTag") && (i = o);
  if (i && (i.to > e || i.lastChild.type.isError)) {
    let o = i.parent;
    if (r.name == "TagName")
      return i.name == "CloseTag" || i.name == "MismatchedCloseTag" ? { type: "closeTag", from: r.from, context: o } : { type: "openTag", from: r.from, context: s0(o) };
    if (r.name == "AttributeName")
      return { type: "attrName", from: r.from, context: i };
    if (r.name == "AttributeValue")
      return { type: "attrValue", from: r.from, context: i };
    let s = r == i || r.name == "Attribute" ? r.childBefore(e) : r;
    return (s == null ? void 0 : s.name) == "StartTag" ? { type: "openTag", from: e, context: s0(o) } : (s == null ? void 0 : s.name) == "StartCloseTag" && s.to <= e ? { type: "closeTag", from: e, context: o } : (s == null ? void 0 : s.name) == "Is" ? { type: "attrValue", from: e, context: i } : s ? { type: "attrName", from: e, context: i } : null;
  } else if (r.name == "StartCloseTag")
    return { type: "closeTag", from: e, context: r.parent };
  for (; r.parent && r.to == e && !(!((n = r.lastChild) === null || n === void 0) && n.type.isError); )
    r = r.parent;
  return r.name == "Element" || r.name == "Text" || r.name == "Document" ? { type: "tag", from: e, context: r.name == "Element" ? r : s0(r) } : null;
}
var qG = class {
  constructor(e, n, r) {
    this.attrs = n, this.attrValues = r, this.children = [], this.name = e.name, this.completion = Object.assign(Object.assign({ type: "type" }, e.completion || {}), { label: this.name }), this.openCompletion = Object.assign(Object.assign({}, this.completion), { label: "<" + this.name }), this.closeCompletion = Object.assign(Object.assign({}, this.completion), { label: "</" + this.name + ">", boost: 2 }), this.closeNameCompletion = Object.assign(Object.assign({}, this.completion), { label: this.name + ">" }), this.text = e.textContent ? e.textContent.map((i) => ({ label: i, type: "text" })) : [];
  }
};
var a0 = /^[:\-\.\w\u00b7-\uffff]*$/;
function tw(t4) {
  return Object.assign(Object.assign({ type: "property" }, t4.completion || {}), { label: t4.name });
}
function nw(t4) {
  return typeof t4 == "string" ? { label: `"${t4}"`, type: "constant" } : /^"/.test(t4.label) ? t4 : Object.assign(Object.assign({}, t4), { label: `"${t4.label}"` });
}
function UG(t4, e) {
  let n = [], r = [], i = /* @__PURE__ */ Object.create(null);
  for (let l of e) {
    let c = tw(l);
    n.push(c), l.global && r.push(c), l.values && (i[l.name] = l.values.map(nw));
  }
  let o = [], s = [], a = /* @__PURE__ */ Object.create(null);
  for (let l of t4) {
    let c = r, u = i;
    l.attributes && (c = c.concat(l.attributes.map((d) => typeof d == "string" ? n.find((h) => h.label == d) || { label: d, type: "property" } : (d.values && (u == i && (u = Object.create(u)), u[d.name] = d.values.map(nw)), tw(d)))));
    let f = new qG(l, c, u);
    a[f.name] = f, o.push(f), l.top && s.push(f);
  }
  s.length || (s = o);
  for (let l = 0; l < o.length; l++) {
    let c = t4[l], u = o[l];
    if (c.children)
      for (let f of c.children)
        a[f] && u.children.push(a[f]);
    else
      u.children = o;
  }
  return (l) => {
    var c;
    let { doc: u } = l.state, f = YG(l.state, l.pos);
    if (!f || f.type == "tag" && !l.explicit)
      return null;
    let { type: d, from: h, context: p } = f;
    if (d == "openTag") {
      let O = s, m = o0(u, p);
      if (m) {
        let x = a[m];
        O = (x == null ? void 0 : x.children) || o;
      }
      return {
        from: h,
        options: O.map((x) => x.completion),
        validFor: a0
      };
    } else if (d == "closeTag") {
      let O = o0(u, p);
      return O ? {
        from: h,
        to: l.pos + (u.sliceString(l.pos, l.pos + 1) == ">" ? 1 : 0),
        options: [((c = a[O]) === null || c === void 0 ? void 0 : c.closeNameCompletion) || { label: O + ">", type: "type" }],
        validFor: a0
      } : null;
    } else if (d == "attrName") {
      let O = a[bf(u, p)];
      return {
        from: h,
        options: (O == null ? void 0 : O.attrs) || r,
        validFor: a0
      };
    } else if (d == "attrValue") {
      let O = GG(u, p, h);
      if (!O)
        return null;
      let m = a[bf(u, p)], x = ((m == null ? void 0 : m.attrValues) || i)[O];
      return !x || !x.length ? null : {
        from: h,
        to: l.pos + (u.sliceString(l.pos, l.pos + 1) == '"' ? 1 : 0),
        options: x,
        validFor: /^"[^"]*"?$/
      };
    } else if (d == "tag") {
      let O = o0(u, p), m = a[O], x = [], v = p && p.lastChild;
      O && (!v || v.name != "CloseTag" || bf(u, v) != O) && x.push(m ? m.closeCompletion : { label: "</" + O + ">", type: "type", boost: 2 });
      let y = x.concat(((m == null ? void 0 : m.children) || (p ? o : s)).map((S) => S.openCompletion));
      if (p && (m != null && m.text.length)) {
        let S = p.firstChild;
        S.to > l.pos - 20 && !/\S/.test(l.state.sliceDoc(S.to, l.pos)) && (y = y.concat(m.text));
      }
      return {
        from: h,
        options: y,
        validFor: /^<\/?[:\-\.\w\u00b7-\uffff]*$/
      };
    } else
      return null;
  };
}
var Gm = /* @__PURE__ */ Do.define({
  name: "xml",
  parser: /* @__PURE__ */ XG.configure({
    props: [
      /* @__PURE__ */ Ha.add({
        Element(t4) {
          let e = /^\s*<\//.test(t4.textAfter);
          return t4.lineIndent(t4.node.from) + (e ? 0 : t4.unit);
        },
        "OpenTag CloseTag SelfClosingTag"(t4) {
          return t4.column(t4.node.from) + t4.unit;
        }
      }),
      /* @__PURE__ */ Ja.add({
        Element(t4) {
          let e = t4.firstChild, n = t4.lastChild;
          return !e || e.name != "OpenTag" ? null : { from: e.to, to: n.name == "CloseTag" ? n.from : t4.to };
        }
      }),
      /* @__PURE__ */ Mx.add({
        "OpenTag CloseTag": (t4) => t4.getChild("TagName")
      })
    ]
  }),
  languageData: {
    commentTokens: { block: { open: "<!--", close: "-->" } },
    indentOnInput: /^\s*<\/$/
  }
});
function HG(t4 = {}) {
  let e = [Gm.data.of({
    autocomplete: UG(t4.elements || [], t4.attributes || [])
  })];
  return t4.autoCloseTags !== false && e.push(JG), new Bc(Gm, e);
}
function rw(t4, e, n = t4.length) {
  if (!e)
    return "";
  let r = e.firstChild, i = r && r.getChild("TagName");
  return i ? t4.sliceString(i.from, Math.min(i.to, n)) : "";
}
var JG = /* @__PURE__ */ ue.inputHandler.of((t4, e, n, r, i) => {
  if (t4.composing || t4.state.readOnly || e != n || r != ">" && r != "/" || !Gm.isActiveAt(t4.state, e, -1))
    return false;
  let o = i(), { state: s } = o, a = s.changeByRange((l) => {
    var c, u, f;
    let { head: d } = l, h = s.doc.sliceString(d - 1, d) == r, p = Ft(s).resolveInner(d, -1), O;
    if (h && r == ">" && p.name == "EndTag") {
      let m = p.parent;
      if (((u = (c = m.parent) === null || c === void 0 ? void 0 : c.lastChild) === null || u === void 0 ? void 0 : u.name) != "CloseTag" && (O = rw(s.doc, m.parent, d))) {
        let x = d + (s.doc.sliceString(d, d + 1) === ">" ? 1 : 0), v = `</${O}>`;
        return { range: l, changes: { from: d, to: x, insert: v } };
      }
    } else if (h && r == "/" && p.name == "StartCloseTag") {
      let m = p.parent;
      if (p.from == d - 2 && ((f = m.lastChild) === null || f === void 0 ? void 0 : f.name) != "CloseTag" && (O = rw(s.doc, m, d))) {
        let x = d + (s.doc.sliceString(d, d + 1) === ">" ? 1 : 0), v = `${O}>`;
        return {
          range: ne.cursor(d + v.length, -1),
          changes: { from: d, to: x, insert: v }
        };
      }
    }
    return { range: l };
  });
  return a.changes.empty ? false : (t4.dispatch([
    o,
    s.update(a, {
      userEvent: "input.complete",
      scrollIntoView: true
    })
  ]), true);
});
function sv(t4, e) {
  e === void 0 && (e = false);
  var n = t4.length, r = 0, i = "", o = 0, s = 16, a = 0, l = 0, c = 0, u = 0, f = 0;
  function d(y, S) {
    for (var b = 0, w = 0; b < y || !S; ) {
      var C = t4.charCodeAt(r);
      if (C >= 48 && C <= 57)
        w = w * 16 + C - 48;
      else if (C >= 65 && C <= 70)
        w = w * 16 + C - 65 + 10;
      else if (C >= 97 && C <= 102)
        w = w * 16 + C - 97 + 10;
      else
        break;
      r++, b++;
    }
    return b < y && (w = -1), w;
  }
  function h(y) {
    r = y, i = "", o = 0, s = 16, f = 0;
  }
  function p() {
    var y = r;
    if (t4.charCodeAt(r) === 48)
      r++;
    else
      for (r++; r < t4.length && Ms(t4.charCodeAt(r)); )
        r++;
    if (r < t4.length && t4.charCodeAt(r) === 46)
      if (r++, r < t4.length && Ms(t4.charCodeAt(r)))
        for (r++; r < t4.length && Ms(t4.charCodeAt(r)); )
          r++;
      else
        return f = 3, t4.substring(y, r);
    var S = r;
    if (r < t4.length && (t4.charCodeAt(r) === 69 || t4.charCodeAt(r) === 101))
      if (r++, (r < t4.length && t4.charCodeAt(r) === 43 || t4.charCodeAt(r) === 45) && r++, r < t4.length && Ms(t4.charCodeAt(r))) {
        for (r++; r < t4.length && Ms(t4.charCodeAt(r)); )
          r++;
        S = r;
      } else
        f = 3;
    return t4.substring(y, S);
  }
  function O() {
    for (var y = "", S = r; ; ) {
      if (r >= n) {
        y += t4.substring(S, r), f = 2;
        break;
      }
      var b = t4.charCodeAt(r);
      if (b === 34) {
        y += t4.substring(S, r), r++;
        break;
      }
      if (b === 92) {
        if (y += t4.substring(S, r), r++, r >= n) {
          f = 2;
          break;
        }
        var w = t4.charCodeAt(r++);
        switch (w) {
          case 34:
            y += '"';
            break;
          case 92:
            y += "\\";
            break;
          case 47:
            y += "/";
            break;
          case 98:
            y += "\b";
            break;
          case 102:
            y += "\f";
            break;
          case 110:
            y += `
`;
            break;
          case 114:
            y += "\r";
            break;
          case 116:
            y += "	";
            break;
          case 117:
            var C = d(4, true);
            C >= 0 ? y += String.fromCharCode(C) : f = 4;
            break;
          default:
            f = 5;
        }
        S = r;
        continue;
      }
      if (b >= 0 && b <= 31)
        if (Sl(b)) {
          y += t4.substring(S, r), f = 2;
          break;
        } else
          f = 6;
      r++;
    }
    return y;
  }
  function m() {
    if (i = "", f = 0, o = r, l = a, u = c, r >= n)
      return o = n, s = 17;
    var y = t4.charCodeAt(r);
    if (l0(y)) {
      do
        r++, i += String.fromCharCode(y), y = t4.charCodeAt(r);
      while (l0(y));
      return s = 15;
    }
    if (Sl(y))
      return r++, i += String.fromCharCode(y), y === 13 && t4.charCodeAt(r) === 10 && (r++, i += `
`), a++, c = r, s = 14;
    switch (y) {
      case 123:
        return r++, s = 1;
      case 125:
        return r++, s = 2;
      case 91:
        return r++, s = 3;
      case 93:
        return r++, s = 4;
      case 58:
        return r++, s = 6;
      case 44:
        return r++, s = 5;
      case 34:
        return r++, i = O(), s = 10;
      case 47:
        var S = r - 1;
        if (t4.charCodeAt(r + 1) === 47) {
          for (r += 2; r < n && !Sl(t4.charCodeAt(r)); )
            r++;
          return i = t4.substring(S, r), s = 12;
        }
        if (t4.charCodeAt(r + 1) === 42) {
          r += 2;
          for (var b = n - 1, w = false; r < b; ) {
            var C = t4.charCodeAt(r);
            if (C === 42 && t4.charCodeAt(r + 1) === 47) {
              r += 2, w = true;
              break;
            }
            r++, Sl(C) && (C === 13 && t4.charCodeAt(r) === 10 && r++, a++, c = r);
          }
          return w || (r++, f = 1), i = t4.substring(S, r), s = 13;
        }
        return i += String.fromCharCode(y), r++, s = 16;
      case 45:
        if (i += String.fromCharCode(y), r++, r === n || !Ms(t4.charCodeAt(r)))
          return s = 16;
      case 48:
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
        return i += p(), s = 11;
      default:
        for (; r < n && x(y); )
          r++, y = t4.charCodeAt(r);
        if (o !== r) {
          switch (i = t4.substring(o, r), i) {
            case "true":
              return s = 8;
            case "false":
              return s = 9;
            case "null":
              return s = 7;
          }
          return s = 16;
        }
        return i += String.fromCharCode(y), r++, s = 16;
    }
  }
  function x(y) {
    if (l0(y) || Sl(y))
      return false;
    switch (y) {
      case 125:
      case 93:
      case 123:
      case 91:
      case 34:
      case 58:
      case 44:
      case 47:
        return false;
    }
    return true;
  }
  function v() {
    var y;
    do
      y = m();
    while (y >= 12 && y <= 15);
    return y;
  }
  return {
    setPosition: h,
    getPosition: function() {
      return r;
    },
    scan: e ? v : m,
    getToken: function() {
      return s;
    },
    getTokenValue: function() {
      return i;
    },
    getTokenOffset: function() {
      return o;
    },
    getTokenLength: function() {
      return r - o;
    },
    getTokenStartLine: function() {
      return l;
    },
    getTokenStartCharacter: function() {
      return o - u;
    },
    getTokenError: function() {
      return f;
    }
  };
}
function l0(t4) {
  return t4 === 32 || t4 === 9 || t4 === 11 || t4 === 12 || t4 === 160 || t4 === 5760 || t4 >= 8192 && t4 <= 8203 || t4 === 8239 || t4 === 8287 || t4 === 12288 || t4 === 65279;
}
function Sl(t4) {
  return t4 === 10 || t4 === 13 || t4 === 8232 || t4 === 8233;
}
function Ms(t4) {
  return t4 >= 48 && t4 <= 57;
}
function KG(t4, e, n) {
  var r, i, o, s, a;
  if (e) {
    for (s = e.offset, a = s + e.length, o = s; o > 0 && !iw(t4, o - 1); )
      o--;
    for (var l = a; l < t4.length && !iw(t4, l); )
      l++;
    i = t4.substring(o, l), r = eY(i, n);
  } else
    i = t4, r = 0, o = 0, s = 0, a = t4.length;
  var c = tY(n, t4), u = false, f = 0, d;
  n.insertSpaces ? d = c0(" ", n.tabSize || 4) : d = "	";
  var h = sv(i, false), p = false;
  function O() {
    return c + c0(d, r + f);
  }
  function m() {
    var E = h.scan();
    for (u = false; E === 15 || E === 14; )
      u = u || E === 14, E = h.scan();
    return p = E === 16 || h.getTokenError() !== 0, E;
  }
  var x = [];
  function v(E, $, j) {
    !p && $ < a && j > s && t4.substring($, j) !== E && x.push({ offset: $, length: j - $, content: E });
  }
  var y = m();
  if (y !== 17) {
    var S = h.getTokenOffset() + o, b = c0(d, r);
    v(b, o, S);
  }
  for (; y !== 17; ) {
    for (var w = h.getTokenOffset() + h.getTokenLength() + o, C = m(), k = ""; !u && (C === 12 || C === 13); ) {
      var T = h.getTokenOffset() + o;
      v(" ", w, T), w = h.getTokenOffset() + h.getTokenLength() + o, k = C === 12 ? O() : "", C = m();
    }
    if (C === 2)
      y !== 1 && (f--, k = O());
    else if (C === 4)
      y !== 3 && (f--, k = O());
    else {
      switch (y) {
        case 3:
        case 1:
          f++, k = O();
          break;
        case 5:
        case 12:
          k = O();
          break;
        case 13:
          u ? k = O() : k = " ";
          break;
        case 6:
          k = " ";
          break;
        case 10:
          if (C === 6) {
            k = "";
            break;
          }
        case 7:
        case 8:
        case 9:
        case 11:
        case 2:
        case 4:
          C === 12 || C === 13 ? k = " " : C !== 5 && C !== 17 && (p = true);
          break;
        case 16:
          p = true;
          break;
      }
      u && (C === 12 || C === 13) && (k = O());
    }
    var A = h.getTokenOffset() + o;
    v(k, w, A), y = C;
  }
  return x;
}
function c0(t4, e) {
  for (var n = "", r = 0; r < e; r++)
    n += t4;
  return n;
}
function eY(t4, e) {
  for (var n = 0, r = 0, i = e.tabSize || 4; n < t4.length; ) {
    var o = t4.charAt(n);
    if (o === " ")
      r++;
    else if (o === "	")
      r += i;
    else
      break;
    n++;
  }
  return Math.floor(r / i);
}
function tY(t4, e) {
  for (var n = 0; n < e.length; n++) {
    var r = e.charAt(n);
    if (r === "\r")
      return n + 1 < e.length && e.charAt(n + 1) === `
` ? `\r
` : "\r";
    if (r === `
`)
      return `
`;
  }
  return t4 && t4.eol || `
`;
}
function iw(t4, e) {
  return `\r
`.indexOf(t4.charAt(e)) !== -1;
}
var Id;
(function(t4) {
  t4.DEFAULT = {
    allowTrailingComma: false
  };
})(Id || (Id = {}));
function nY(t4, e, n) {
  e === void 0 && (e = []), n === void 0 && (n = Id.DEFAULT);
  var r = null, i = [], o = [];
  function s(l) {
    Array.isArray(i) ? i.push(l) : r !== null && (i[r] = l);
  }
  var a = {
    onObjectBegin: function() {
      var l = {};
      s(l), o.push(i), i = l, r = null;
    },
    onObjectProperty: function(l) {
      r = l;
    },
    onObjectEnd: function() {
      i = o.pop();
    },
    onArrayBegin: function() {
      var l = [];
      s(l), o.push(i), i = l, r = null;
    },
    onArrayEnd: function() {
      i = o.pop();
    },
    onLiteralValue: s,
    onError: function(l, c, u) {
      e.push({ error: l, offset: c, length: u });
    }
  };
  return iY(t4, a, n), i[0];
}
function O$(t4) {
  if (!t4.parent || !t4.parent.children)
    return [];
  var e = O$(t4.parent);
  if (t4.parent.type === "property") {
    var n = t4.parent.children[0].value;
    e.push(n);
  } else if (t4.parent.type === "array") {
    var r = t4.parent.children.indexOf(t4);
    r !== -1 && e.push(r);
  }
  return e;
}
function Ym(t4) {
  switch (t4.type) {
    case "array":
      return t4.children.map(Ym);
    case "object":
      for (var e = /* @__PURE__ */ Object.create(null), n = 0, r = t4.children; n < r.length; n++) {
        var i = r[n], o = i.children[1];
        o && (e[i.children[0].value] = Ym(o));
      }
      return e;
    case "null":
    case "string":
    case "number":
    case "boolean":
      return t4.value;
    default:
      return;
  }
}
function rY(t4, e, n) {
  return n === void 0 && (n = false), e >= t4.offset && e < t4.offset + t4.length || n && e === t4.offset + t4.length;
}
function x$(t4, e, n) {
  if (n === void 0 && (n = false), rY(t4, e, n)) {
    var r = t4.children;
    if (Array.isArray(r))
      for (var i = 0; i < r.length && r[i].offset <= e; i++) {
        var o = x$(r[i], e, n);
        if (o)
          return o;
      }
    return t4;
  }
}
function iY(t4, e, n) {
  n === void 0 && (n = Id.DEFAULT);
  var r = sv(t4, false);
  function i(T) {
    return T ? function() {
      return T(r.getTokenOffset(), r.getTokenLength(), r.getTokenStartLine(), r.getTokenStartCharacter());
    } : function() {
      return true;
    };
  }
  function o(T) {
    return T ? function(A) {
      return T(A, r.getTokenOffset(), r.getTokenLength(), r.getTokenStartLine(), r.getTokenStartCharacter());
    } : function() {
      return true;
    };
  }
  var s = i(e.onObjectBegin), a = o(e.onObjectProperty), l = i(e.onObjectEnd), c = i(e.onArrayBegin), u = i(e.onArrayEnd), f = o(e.onLiteralValue), d = o(e.onSeparator), h = i(e.onComment), p = o(e.onError), O = n && n.disallowComments, m = n && n.allowTrailingComma;
  function x() {
    for (; ; ) {
      var T = r.scan();
      switch (r.getTokenError()) {
        case 4:
          v(
            14
            /* InvalidUnicode */
          );
          break;
        case 5:
          v(
            15
            /* InvalidEscapeCharacter */
          );
          break;
        case 3:
          v(
            13
            /* UnexpectedEndOfNumber */
          );
          break;
        case 1:
          O || v(
            11
            /* UnexpectedEndOfComment */
          );
          break;
        case 2:
          v(
            12
            /* UnexpectedEndOfString */
          );
          break;
        case 6:
          v(
            16
            /* InvalidCharacter */
          );
          break;
      }
      switch (T) {
        case 12:
        case 13:
          O ? v(
            10
            /* InvalidCommentToken */
          ) : h();
          break;
        case 16:
          v(
            1
            /* InvalidSymbol */
          );
          break;
        case 15:
        case 14:
          break;
        default:
          return T;
      }
    }
  }
  function v(T, A, E) {
    if (A === void 0 && (A = []), E === void 0 && (E = []), p(T), A.length + E.length > 0)
      for (var $ = r.getToken(); $ !== 17; ) {
        if (A.indexOf($) !== -1) {
          x();
          break;
        } else if (E.indexOf($) !== -1)
          break;
        $ = x();
      }
  }
  function y(T) {
    var A = r.getTokenValue();
    return T ? f(A) : a(A), x(), true;
  }
  function S() {
    switch (r.getToken()) {
      case 11:
        var T = r.getTokenValue(), A = Number(T);
        isNaN(A) && (v(
          2
          /* InvalidNumberFormat */
        ), A = 0), f(A);
        break;
      case 7:
        f(null);
        break;
      case 8:
        f(true);
        break;
      case 9:
        f(false);
        break;
      default:
        return false;
    }
    return x(), true;
  }
  function b() {
    return r.getToken() !== 10 ? (v(3, [], [
      2,
      5
      /* CommaToken */
    ]), false) : (y(false), r.getToken() === 6 ? (d(":"), x(), k() || v(4, [], [
      2,
      5
      /* CommaToken */
    ])) : v(5, [], [
      2,
      5
      /* CommaToken */
    ]), true);
  }
  function w() {
    s(), x();
    for (var T = false; r.getToken() !== 2 && r.getToken() !== 17; ) {
      if (r.getToken() === 5) {
        if (T || v(4, [], []), d(","), x(), r.getToken() === 2 && m)
          break;
      } else
        T && v(6, [], []);
      b() || v(4, [], [
        2,
        5
        /* CommaToken */
      ]), T = true;
    }
    return l(), r.getToken() !== 2 ? v(7, [
      2
      /* CloseBraceToken */
    ], []) : x(), true;
  }
  function C() {
    c(), x();
    for (var T = false; r.getToken() !== 4 && r.getToken() !== 17; ) {
      if (r.getToken() === 5) {
        if (T || v(4, [], []), d(","), x(), r.getToken() === 4 && m)
          break;
      } else
        T && v(6, [], []);
      k() || v(4, [], [
        4,
        5
        /* CommaToken */
      ]), T = true;
    }
    return u(), r.getToken() !== 4 ? v(8, [
      4
      /* CloseBracketToken */
    ], []) : x(), true;
  }
  function k() {
    switch (r.getToken()) {
      case 3:
        return C();
      case 1:
        return w();
      case 10:
        return y(true);
      default:
        return S();
    }
  }
  return x(), r.getToken() === 17 ? n.allowEmptyContent ? true : (v(4, [], []), false) : k() ? (r.getToken() !== 17 && v(9, [], []), true) : (v(4, [], []), false);
}
var pa = sv;
var oY = nY;
var sY = x$;
var aY = O$;
var lY = Ym;
function cY(t4, e, n) {
  return KG(t4, e, n);
}
function Ll(t4, e) {
  if (t4 === e)
    return true;
  if (t4 == null || e === null || e === void 0 || typeof t4 != typeof e || typeof t4 != "object" || Array.isArray(t4) !== Array.isArray(e))
    return false;
  var n, r;
  if (Array.isArray(t4)) {
    if (t4.length !== e.length)
      return false;
    for (n = 0; n < t4.length; n++)
      if (!Ll(t4[n], e[n]))
        return false;
  } else {
    var i = [];
    for (r in t4)
      i.push(r);
    i.sort();
    var o = [];
    for (r in e)
      o.push(r);
    if (o.sort(), !Ll(i, o))
      return false;
    for (n = 0; n < i.length; n++)
      if (!Ll(t4[i[n]], e[i[n]]))
        return false;
  }
  return true;
}
function gr(t4) {
  return typeof t4 == "number";
}
function Wi(t4) {
  return typeof t4 < "u";
}
function yi(t4) {
  return typeof t4 == "boolean";
}
function uY(t4) {
  return typeof t4 == "string";
}
var ow;
(function(t4) {
  function e(n) {
    return typeof n == "string";
  }
  t4.is = e;
})(ow || (ow = {}));
var qm;
(function(t4) {
  function e(n) {
    return typeof n == "string";
  }
  t4.is = e;
})(qm || (qm = {}));
var sw;
(function(t4) {
  t4.MIN_VALUE = -2147483648, t4.MAX_VALUE = 2147483647;
  function e(n) {
    return typeof n == "number" && t4.MIN_VALUE <= n && n <= t4.MAX_VALUE;
  }
  t4.is = e;
})(sw || (sw = {}));
var $d;
(function(t4) {
  t4.MIN_VALUE = 0, t4.MAX_VALUE = 2147483647;
  function e(n) {
    return typeof n == "number" && t4.MIN_VALUE <= n && n <= t4.MAX_VALUE;
  }
  t4.is = e;
})($d || ($d = {}));
var Ir;
(function(t4) {
  function e(r, i) {
    return r === Number.MAX_VALUE && (r = $d.MAX_VALUE), i === Number.MAX_VALUE && (i = $d.MAX_VALUE), { line: r, character: i };
  }
  t4.create = e;
  function n(r) {
    let i = r;
    return U.objectLiteral(i) && U.uinteger(i.line) && U.uinteger(i.character);
  }
  t4.is = n;
})(Ir || (Ir = {}));
var at;
(function(t4) {
  function e(r, i, o, s) {
    if (U.uinteger(r) && U.uinteger(i) && U.uinteger(o) && U.uinteger(s))
      return { start: Ir.create(r, i), end: Ir.create(o, s) };
    if (Ir.is(r) && Ir.is(i))
      return { start: r, end: i };
    throw new Error(`Range#create called with invalid arguments[${r}, ${i}, ${o}, ${s}]`);
  }
  t4.create = e;
  function n(r) {
    let i = r;
    return U.objectLiteral(i) && Ir.is(i.start) && Ir.is(i.end);
  }
  t4.is = n;
})(at || (at = {}));
var ja;
(function(t4) {
  function e(r, i) {
    return { uri: r, range: i };
  }
  t4.create = e;
  function n(r) {
    let i = r;
    return U.objectLiteral(i) && at.is(i.range) && (U.string(i.uri) || U.undefined(i.uri));
  }
  t4.is = n;
})(ja || (ja = {}));
var aw;
(function(t4) {
  function e(r, i, o, s) {
    return { targetUri: r, targetRange: i, targetSelectionRange: o, originSelectionRange: s };
  }
  t4.create = e;
  function n(r) {
    let i = r;
    return U.objectLiteral(i) && at.is(i.targetRange) && U.string(i.targetUri) && at.is(i.targetSelectionRange) && (at.is(i.originSelectionRange) || U.undefined(i.originSelectionRange));
  }
  t4.is = n;
})(aw || (aw = {}));
var Um;
(function(t4) {
  function e(r, i, o, s) {
    return {
      red: r,
      green: i,
      blue: o,
      alpha: s
    };
  }
  t4.create = e;
  function n(r) {
    const i = r;
    return U.objectLiteral(i) && U.numberRange(i.red, 0, 1) && U.numberRange(i.green, 0, 1) && U.numberRange(i.blue, 0, 1) && U.numberRange(i.alpha, 0, 1);
  }
  t4.is = n;
})(Um || (Um = {}));
var lw;
(function(t4) {
  function e(r, i) {
    return {
      range: r,
      color: i
    };
  }
  t4.create = e;
  function n(r) {
    const i = r;
    return U.objectLiteral(i) && at.is(i.range) && Um.is(i.color);
  }
  t4.is = n;
})(lw || (lw = {}));
var cw;
(function(t4) {
  function e(r, i, o) {
    return {
      label: r,
      textEdit: i,
      additionalTextEdits: o
    };
  }
  t4.create = e;
  function n(r) {
    const i = r;
    return U.objectLiteral(i) && U.string(i.label) && (U.undefined(i.textEdit) || Ki.is(i)) && (U.undefined(i.additionalTextEdits) || U.typedArray(i.additionalTextEdits, Ki.is));
  }
  t4.is = n;
})(cw || (cw = {}));
var Xl;
(function(t4) {
  t4.Comment = "comment", t4.Imports = "imports", t4.Region = "region";
})(Xl || (Xl = {}));
var uw;
(function(t4) {
  function e(r, i, o, s, a, l) {
    const c = {
      startLine: r,
      endLine: i
    };
    return U.defined(o) && (c.startCharacter = o), U.defined(s) && (c.endCharacter = s), U.defined(a) && (c.kind = a), U.defined(l) && (c.collapsedText = l), c;
  }
  t4.create = e;
  function n(r) {
    const i = r;
    return U.objectLiteral(i) && U.uinteger(i.startLine) && U.uinteger(i.startLine) && (U.undefined(i.startCharacter) || U.uinteger(i.startCharacter)) && (U.undefined(i.endCharacter) || U.uinteger(i.endCharacter)) && (U.undefined(i.kind) || U.string(i.kind));
  }
  t4.is = n;
})(uw || (uw = {}));
var Hm;
(function(t4) {
  function e(r, i) {
    return {
      location: r,
      message: i
    };
  }
  t4.create = e;
  function n(r) {
    let i = r;
    return U.defined(i) && ja.is(i.location) && U.string(i.message);
  }
  t4.is = n;
})(Hm || (Hm = {}));
var ze;
(function(t4) {
  t4.Error = 1, t4.Warning = 2, t4.Information = 3, t4.Hint = 4;
})(ze || (ze = {}));
var fw;
(function(t4) {
  t4.Unnecessary = 1, t4.Deprecated = 2;
})(fw || (fw = {}));
var dw;
(function(t4) {
  function e(n) {
    const r = n;
    return U.objectLiteral(r) && U.string(r.href);
  }
  t4.is = e;
})(dw || (dw = {}));
var Yi;
(function(t4) {
  function e(r, i, o, s, a, l) {
    let c = { range: r, message: i };
    return U.defined(o) && (c.severity = o), U.defined(s) && (c.code = s), U.defined(a) && (c.source = a), U.defined(l) && (c.relatedInformation = l), c;
  }
  t4.create = e;
  function n(r) {
    var i;
    let o = r;
    return U.defined(o) && at.is(o.range) && U.string(o.message) && (U.number(o.severity) || U.undefined(o.severity)) && (U.integer(o.code) || U.string(o.code) || U.undefined(o.code)) && (U.undefined(o.codeDescription) || U.string((i = o.codeDescription) === null || i === void 0 ? void 0 : i.href)) && (U.string(o.source) || U.undefined(o.source)) && (U.undefined(o.relatedInformation) || U.typedArray(o.relatedInformation, Hm.is));
  }
  t4.is = n;
})(Yi || (Yi = {}));
var Ra;
(function(t4) {
  function e(r, i, ...o) {
    let s = { title: r, command: i };
    return U.defined(o) && o.length > 0 && (s.arguments = o), s;
  }
  t4.create = e;
  function n(r) {
    let i = r;
    return U.defined(i) && U.string(i.title) && U.string(i.command);
  }
  t4.is = n;
})(Ra || (Ra = {}));
var Ki;
(function(t4) {
  function e(o, s) {
    return { range: o, newText: s };
  }
  t4.replace = e;
  function n(o, s) {
    return { range: { start: o, end: o }, newText: s };
  }
  t4.insert = n;
  function r(o) {
    return { range: o, newText: "" };
  }
  t4.del = r;
  function i(o) {
    const s = o;
    return U.objectLiteral(s) && U.string(s.newText) && at.is(s.range);
  }
  t4.is = i;
})(Ki || (Ki = {}));
var Jm;
(function(t4) {
  function e(r, i, o) {
    const s = { label: r };
    return i !== void 0 && (s.needsConfirmation = i), o !== void 0 && (s.description = o), s;
  }
  t4.create = e;
  function n(r) {
    const i = r;
    return U.objectLiteral(i) && U.string(i.label) && (U.boolean(i.needsConfirmation) || i.needsConfirmation === void 0) && (U.string(i.description) || i.description === void 0);
  }
  t4.is = n;
})(Jm || (Jm = {}));
var Da;
(function(t4) {
  function e(n) {
    const r = n;
    return U.string(r);
  }
  t4.is = e;
})(Da || (Da = {}));
var hw;
(function(t4) {
  function e(o, s, a) {
    return { range: o, newText: s, annotationId: a };
  }
  t4.replace = e;
  function n(o, s, a) {
    return { range: { start: o, end: o }, newText: s, annotationId: a };
  }
  t4.insert = n;
  function r(o, s) {
    return { range: o, newText: "", annotationId: s };
  }
  t4.del = r;
  function i(o) {
    const s = o;
    return Ki.is(s) && (Jm.is(s.annotationId) || Da.is(s.annotationId));
  }
  t4.is = i;
})(hw || (hw = {}));
var Km;
(function(t4) {
  function e(r, i) {
    return { textDocument: r, edits: i };
  }
  t4.create = e;
  function n(r) {
    let i = r;
    return U.defined(i) && iO.is(i.textDocument) && Array.isArray(i.edits);
  }
  t4.is = n;
})(Km || (Km = {}));
var eO;
(function(t4) {
  function e(r, i, o) {
    let s = {
      kind: "create",
      uri: r
    };
    return i !== void 0 && (i.overwrite !== void 0 || i.ignoreIfExists !== void 0) && (s.options = i), o !== void 0 && (s.annotationId = o), s;
  }
  t4.create = e;
  function n(r) {
    let i = r;
    return i && i.kind === "create" && U.string(i.uri) && (i.options === void 0 || (i.options.overwrite === void 0 || U.boolean(i.options.overwrite)) && (i.options.ignoreIfExists === void 0 || U.boolean(i.options.ignoreIfExists))) && (i.annotationId === void 0 || Da.is(i.annotationId));
  }
  t4.is = n;
})(eO || (eO = {}));
var tO;
(function(t4) {
  function e(r, i, o, s) {
    let a = {
      kind: "rename",
      oldUri: r,
      newUri: i
    };
    return o !== void 0 && (o.overwrite !== void 0 || o.ignoreIfExists !== void 0) && (a.options = o), s !== void 0 && (a.annotationId = s), a;
  }
  t4.create = e;
  function n(r) {
    let i = r;
    return i && i.kind === "rename" && U.string(i.oldUri) && U.string(i.newUri) && (i.options === void 0 || (i.options.overwrite === void 0 || U.boolean(i.options.overwrite)) && (i.options.ignoreIfExists === void 0 || U.boolean(i.options.ignoreIfExists))) && (i.annotationId === void 0 || Da.is(i.annotationId));
  }
  t4.is = n;
})(tO || (tO = {}));
var nO;
(function(t4) {
  function e(r, i, o) {
    let s = {
      kind: "delete",
      uri: r
    };
    return i !== void 0 && (i.recursive !== void 0 || i.ignoreIfNotExists !== void 0) && (s.options = i), o !== void 0 && (s.annotationId = o), s;
  }
  t4.create = e;
  function n(r) {
    let i = r;
    return i && i.kind === "delete" && U.string(i.uri) && (i.options === void 0 || (i.options.recursive === void 0 || U.boolean(i.options.recursive)) && (i.options.ignoreIfNotExists === void 0 || U.boolean(i.options.ignoreIfNotExists))) && (i.annotationId === void 0 || Da.is(i.annotationId));
  }
  t4.is = n;
})(nO || (nO = {}));
var rO;
(function(t4) {
  function e(n) {
    let r = n;
    return r && (r.changes !== void 0 || r.documentChanges !== void 0) && (r.documentChanges === void 0 || r.documentChanges.every((i) => U.string(i.kind) ? eO.is(i) || tO.is(i) || nO.is(i) : Km.is(i)));
  }
  t4.is = e;
})(rO || (rO = {}));
var pw;
(function(t4) {
  function e(r) {
    return { uri: r };
  }
  t4.create = e;
  function n(r) {
    let i = r;
    return U.defined(i) && U.string(i.uri);
  }
  t4.is = n;
})(pw || (pw = {}));
var gw;
(function(t4) {
  function e(r, i) {
    return { uri: r, version: i };
  }
  t4.create = e;
  function n(r) {
    let i = r;
    return U.defined(i) && U.string(i.uri) && U.integer(i.version);
  }
  t4.is = n;
})(gw || (gw = {}));
var iO;
(function(t4) {
  function e(r, i) {
    return { uri: r, version: i };
  }
  t4.create = e;
  function n(r) {
    let i = r;
    return U.defined(i) && U.string(i.uri) && (i.version === null || U.integer(i.version));
  }
  t4.is = n;
})(iO || (iO = {}));
var mw;
(function(t4) {
  function e(r, i, o, s) {
    return { uri: r, languageId: i, version: o, text: s };
  }
  t4.create = e;
  function n(r) {
    let i = r;
    return U.defined(i) && U.string(i.uri) && U.string(i.languageId) && U.integer(i.version) && U.string(i.text);
  }
  t4.is = n;
})(mw || (mw = {}));
var ms;
(function(t4) {
  t4.PlainText = "plaintext", t4.Markdown = "markdown";
  function e(n) {
    const r = n;
    return r === t4.PlainText || r === t4.Markdown;
  }
  t4.is = e;
})(ms || (ms = {}));
var mc;
(function(t4) {
  function e(n) {
    const r = n;
    return U.objectLiteral(n) && ms.is(r.kind) && U.string(r.value);
  }
  t4.is = e;
})(mc || (mc = {}));
var mr;
(function(t4) {
  t4.Text = 1, t4.Method = 2, t4.Function = 3, t4.Constructor = 4, t4.Field = 5, t4.Variable = 6, t4.Class = 7, t4.Interface = 8, t4.Module = 9, t4.Property = 10, t4.Unit = 11, t4.Value = 12, t4.Enum = 13, t4.Keyword = 14, t4.Snippet = 15, t4.Color = 16, t4.File = 17, t4.Reference = 18, t4.Folder = 19, t4.EnumMember = 20, t4.Constant = 21, t4.Struct = 22, t4.Event = 23, t4.Operator = 24, t4.TypeParameter = 25;
})(mr || (mr = {}));
var an;
(function(t4) {
  t4.PlainText = 1, t4.Snippet = 2;
})(an || (an = {}));
var Ow;
(function(t4) {
  t4.Deprecated = 1;
})(Ow || (Ow = {}));
var xw;
(function(t4) {
  function e(r, i, o) {
    return { newText: r, insert: i, replace: o };
  }
  t4.create = e;
  function n(r) {
    const i = r;
    return i && U.string(i.newText) && at.is(i.insert) && at.is(i.replace);
  }
  t4.is = n;
})(xw || (xw = {}));
var vw;
(function(t4) {
  t4.asIs = 1, t4.adjustIndentation = 2;
})(vw || (vw = {}));
var yw;
(function(t4) {
  function e(n) {
    const r = n;
    return r && (U.string(r.detail) || r.detail === void 0) && (U.string(r.description) || r.description === void 0);
  }
  t4.is = e;
})(yw || (yw = {}));
var oO;
(function(t4) {
  function e(n) {
    return { label: n };
  }
  t4.create = e;
})(oO || (oO = {}));
var bw;
(function(t4) {
  function e(n, r) {
    return { items: n || [], isIncomplete: !!r };
  }
  t4.create = e;
})(bw || (bw = {}));
var jd;
(function(t4) {
  function e(r) {
    return r.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&");
  }
  t4.fromPlainText = e;
  function n(r) {
    const i = r;
    return U.string(i) || U.objectLiteral(i) && U.string(i.language) && U.string(i.value);
  }
  t4.is = n;
})(jd || (jd = {}));
var Sw;
(function(t4) {
  function e(n) {
    let r = n;
    return !!r && U.objectLiteral(r) && (mc.is(r.contents) || jd.is(r.contents) || U.typedArray(r.contents, jd.is)) && (n.range === void 0 || at.is(n.range));
  }
  t4.is = e;
})(Sw || (Sw = {}));
var ww;
(function(t4) {
  function e(n, r) {
    return r ? { label: n, documentation: r } : { label: n };
  }
  t4.create = e;
})(ww || (ww = {}));
var Cw;
(function(t4) {
  function e(n, r, ...i) {
    let o = { label: n };
    return U.defined(r) && (o.documentation = r), U.defined(i) ? o.parameters = i : o.parameters = [], o;
  }
  t4.create = e;
})(Cw || (Cw = {}));
var kw;
(function(t4) {
  t4.Text = 1, t4.Read = 2, t4.Write = 3;
})(kw || (kw = {}));
var Aw;
(function(t4) {
  function e(n, r) {
    let i = { range: n };
    return U.number(r) && (i.kind = r), i;
  }
  t4.create = e;
})(Aw || (Aw = {}));
var di;
(function(t4) {
  t4.File = 1, t4.Module = 2, t4.Namespace = 3, t4.Package = 4, t4.Class = 5, t4.Method = 6, t4.Property = 7, t4.Field = 8, t4.Constructor = 9, t4.Enum = 10, t4.Interface = 11, t4.Function = 12, t4.Variable = 13, t4.Constant = 14, t4.String = 15, t4.Number = 16, t4.Boolean = 17, t4.Array = 18, t4.Object = 19, t4.Key = 20, t4.Null = 21, t4.EnumMember = 22, t4.Struct = 23, t4.Event = 24, t4.Operator = 25, t4.TypeParameter = 26;
})(di || (di = {}));
var Pw;
(function(t4) {
  t4.Deprecated = 1;
})(Pw || (Pw = {}));
var Ew;
(function(t4) {
  function e(n, r, i, o, s) {
    let a = {
      name: n,
      kind: r,
      location: { uri: o, range: i }
    };
    return s && (a.containerName = s), a;
  }
  t4.create = e;
})(Ew || (Ew = {}));
var Tw;
(function(t4) {
  function e(n, r, i, o) {
    return o !== void 0 ? { name: n, kind: r, location: { uri: i, range: o } } : { name: n, kind: r, location: { uri: i } };
  }
  t4.create = e;
})(Tw || (Tw = {}));
var Iw;
(function(t4) {
  function e(r, i, o, s, a, l) {
    let c = {
      name: r,
      detail: i,
      kind: o,
      range: s,
      selectionRange: a
    };
    return l !== void 0 && (c.children = l), c;
  }
  t4.create = e;
  function n(r) {
    let i = r;
    return i && U.string(i.name) && U.number(i.kind) && at.is(i.range) && at.is(i.selectionRange) && (i.detail === void 0 || U.string(i.detail)) && (i.deprecated === void 0 || U.boolean(i.deprecated)) && (i.children === void 0 || Array.isArray(i.children)) && (i.tags === void 0 || Array.isArray(i.tags));
  }
  t4.is = n;
})(Iw || (Iw = {}));
var $w;
(function(t4) {
  t4.Empty = "", t4.QuickFix = "quickfix", t4.Refactor = "refactor", t4.RefactorExtract = "refactor.extract", t4.RefactorInline = "refactor.inline", t4.RefactorRewrite = "refactor.rewrite", t4.Source = "source", t4.SourceOrganizeImports = "source.organizeImports", t4.SourceFixAll = "source.fixAll";
})($w || ($w = {}));
var Rd;
(function(t4) {
  t4.Invoked = 1, t4.Automatic = 2;
})(Rd || (Rd = {}));
var jw;
(function(t4) {
  function e(r, i, o) {
    let s = { diagnostics: r };
    return i != null && (s.only = i), o != null && (s.triggerKind = o), s;
  }
  t4.create = e;
  function n(r) {
    let i = r;
    return U.defined(i) && U.typedArray(i.diagnostics, Yi.is) && (i.only === void 0 || U.typedArray(i.only, U.string)) && (i.triggerKind === void 0 || i.triggerKind === Rd.Invoked || i.triggerKind === Rd.Automatic);
  }
  t4.is = n;
})(jw || (jw = {}));
var Rw;
(function(t4) {
  function e(r, i, o) {
    let s = { title: r }, a = true;
    return typeof i == "string" ? (a = false, s.kind = i) : Ra.is(i) ? s.command = i : s.edit = i, a && o !== void 0 && (s.kind = o), s;
  }
  t4.create = e;
  function n(r) {
    let i = r;
    return i && U.string(i.title) && (i.diagnostics === void 0 || U.typedArray(i.diagnostics, Yi.is)) && (i.kind === void 0 || U.string(i.kind)) && (i.edit !== void 0 || i.command !== void 0) && (i.command === void 0 || Ra.is(i.command)) && (i.isPreferred === void 0 || U.boolean(i.isPreferred)) && (i.edit === void 0 || rO.is(i.edit));
  }
  t4.is = n;
})(Rw || (Rw = {}));
var Dw;
(function(t4) {
  function e(r, i) {
    let o = { range: r };
    return U.defined(i) && (o.data = i), o;
  }
  t4.create = e;
  function n(r) {
    let i = r;
    return U.defined(i) && at.is(i.range) && (U.undefined(i.command) || Ra.is(i.command));
  }
  t4.is = n;
})(Dw || (Dw = {}));
var Qw;
(function(t4) {
  function e(r, i) {
    return { tabSize: r, insertSpaces: i };
  }
  t4.create = e;
  function n(r) {
    let i = r;
    return U.defined(i) && U.uinteger(i.tabSize) && U.boolean(i.insertSpaces);
  }
  t4.is = n;
})(Qw || (Qw = {}));
var Bw;
(function(t4) {
  function e(r, i, o) {
    return { range: r, target: i, data: o };
  }
  t4.create = e;
  function n(r) {
    let i = r;
    return U.defined(i) && at.is(i.range) && (U.undefined(i.target) || U.string(i.target));
  }
  t4.is = n;
})(Bw || (Bw = {}));
var Dd;
(function(t4) {
  function e(r, i) {
    return { range: r, parent: i };
  }
  t4.create = e;
  function n(r) {
    let i = r;
    return U.objectLiteral(i) && at.is(i.range) && (i.parent === void 0 || t4.is(i.parent));
  }
  t4.is = n;
})(Dd || (Dd = {}));
var _w;
(function(t4) {
  t4.namespace = "namespace", t4.type = "type", t4.class = "class", t4.enum = "enum", t4.interface = "interface", t4.struct = "struct", t4.typeParameter = "typeParameter", t4.parameter = "parameter", t4.variable = "variable", t4.property = "property", t4.enumMember = "enumMember", t4.event = "event", t4.function = "function", t4.method = "method", t4.macro = "macro", t4.keyword = "keyword", t4.modifier = "modifier", t4.comment = "comment", t4.string = "string", t4.number = "number", t4.regexp = "regexp", t4.operator = "operator", t4.decorator = "decorator";
})(_w || (_w = {}));
var Mw;
(function(t4) {
  t4.declaration = "declaration", t4.definition = "definition", t4.readonly = "readonly", t4.static = "static", t4.deprecated = "deprecated", t4.abstract = "abstract", t4.async = "async", t4.modification = "modification", t4.documentation = "documentation", t4.defaultLibrary = "defaultLibrary";
})(Mw || (Mw = {}));
var Nw;
(function(t4) {
  function e(n) {
    const r = n;
    return U.objectLiteral(r) && (r.resultId === void 0 || typeof r.resultId == "string") && Array.isArray(r.data) && (r.data.length === 0 || typeof r.data[0] == "number");
  }
  t4.is = e;
})(Nw || (Nw = {}));
var Fw;
(function(t4) {
  function e(r, i) {
    return { range: r, text: i };
  }
  t4.create = e;
  function n(r) {
    const i = r;
    return i != null && at.is(i.range) && U.string(i.text);
  }
  t4.is = n;
})(Fw || (Fw = {}));
var Zw;
(function(t4) {
  function e(r, i, o) {
    return { range: r, variableName: i, caseSensitiveLookup: o };
  }
  t4.create = e;
  function n(r) {
    const i = r;
    return i != null && at.is(i.range) && U.boolean(i.caseSensitiveLookup) && (U.string(i.variableName) || i.variableName === void 0);
  }
  t4.is = n;
})(Zw || (Zw = {}));
var Ww;
(function(t4) {
  function e(r, i) {
    return { range: r, expression: i };
  }
  t4.create = e;
  function n(r) {
    const i = r;
    return i != null && at.is(i.range) && (U.string(i.expression) || i.expression === void 0);
  }
  t4.is = n;
})(Ww || (Ww = {}));
var Vw;
(function(t4) {
  function e(r, i) {
    return { frameId: r, stoppedLocation: i };
  }
  t4.create = e;
  function n(r) {
    const i = r;
    return U.defined(i) && at.is(r.stoppedLocation);
  }
  t4.is = n;
})(Vw || (Vw = {}));
var sO;
(function(t4) {
  t4.Type = 1, t4.Parameter = 2;
  function e(n) {
    return n === 1 || n === 2;
  }
  t4.is = e;
})(sO || (sO = {}));
var aO;
(function(t4) {
  function e(r) {
    return { value: r };
  }
  t4.create = e;
  function n(r) {
    const i = r;
    return U.objectLiteral(i) && (i.tooltip === void 0 || U.string(i.tooltip) || mc.is(i.tooltip)) && (i.location === void 0 || ja.is(i.location)) && (i.command === void 0 || Ra.is(i.command));
  }
  t4.is = n;
})(aO || (aO = {}));
var zw;
(function(t4) {
  function e(r, i, o) {
    const s = { position: r, label: i };
    return o !== void 0 && (s.kind = o), s;
  }
  t4.create = e;
  function n(r) {
    const i = r;
    return U.objectLiteral(i) && Ir.is(i.position) && (U.string(i.label) || U.typedArray(i.label, aO.is)) && (i.kind === void 0 || sO.is(i.kind)) && i.textEdits === void 0 || U.typedArray(i.textEdits, Ki.is) && (i.tooltip === void 0 || U.string(i.tooltip) || mc.is(i.tooltip)) && (i.paddingLeft === void 0 || U.boolean(i.paddingLeft)) && (i.paddingRight === void 0 || U.boolean(i.paddingRight));
  }
  t4.is = n;
})(zw || (zw = {}));
var Lw;
(function(t4) {
  function e(n) {
    return { kind: "snippet", value: n };
  }
  t4.createSnippet = e;
})(Lw || (Lw = {}));
var Xw;
(function(t4) {
  function e(n, r, i, o) {
    return { insertText: n, filterText: r, range: i, command: o };
  }
  t4.create = e;
})(Xw || (Xw = {}));
var Gw;
(function(t4) {
  function e(n) {
    return { items: n };
  }
  t4.create = e;
})(Gw || (Gw = {}));
var Yw;
(function(t4) {
  t4.Invoked = 0, t4.Automatic = 1;
})(Yw || (Yw = {}));
var qw;
(function(t4) {
  function e(n, r) {
    return { range: n, text: r };
  }
  t4.create = e;
})(qw || (qw = {}));
var Uw;
(function(t4) {
  function e(n, r) {
    return { triggerKind: n, selectedCompletionInfo: r };
  }
  t4.create = e;
})(Uw || (Uw = {}));
var Hw;
(function(t4) {
  function e(n) {
    const r = n;
    return U.objectLiteral(r) && qm.is(r.uri) && U.string(r.name);
  }
  t4.is = e;
})(Hw || (Hw = {}));
var Jw;
(function(t4) {
  function e(o, s, a, l) {
    return new fY(o, s, a, l);
  }
  t4.create = e;
  function n(o) {
    let s = o;
    return !!(U.defined(s) && U.string(s.uri) && (U.undefined(s.languageId) || U.string(s.languageId)) && U.uinteger(s.lineCount) && U.func(s.getText) && U.func(s.positionAt) && U.func(s.offsetAt));
  }
  t4.is = n;
  function r(o, s) {
    let a = o.getText(), l = i(s, (u, f) => {
      let d = u.range.start.line - f.range.start.line;
      return d === 0 ? u.range.start.character - f.range.start.character : d;
    }), c = a.length;
    for (let u = l.length - 1; u >= 0; u--) {
      let f = l[u], d = o.offsetAt(f.range.start), h = o.offsetAt(f.range.end);
      if (h <= c)
        a = a.substring(0, d) + f.newText + a.substring(h, a.length);
      else
        throw new Error("Overlapping edit");
      c = d;
    }
    return a;
  }
  t4.applyEdits = r;
  function i(o, s) {
    if (o.length <= 1)
      return o;
    const a = o.length / 2 | 0, l = o.slice(0, a), c = o.slice(a);
    i(l, s), i(c, s);
    let u = 0, f = 0, d = 0;
    for (; u < l.length && f < c.length; )
      s(l[u], c[f]) <= 0 ? o[d++] = l[u++] : o[d++] = c[f++];
    for (; u < l.length; )
      o[d++] = l[u++];
    for (; f < c.length; )
      o[d++] = c[f++];
    return o;
  }
})(Jw || (Jw = {}));
var fY = class {
  constructor(e, n, r, i) {
    this._uri = e, this._languageId = n, this._version = r, this._content = i, this._lineOffsets = void 0;
  }
  get uri() {
    return this._uri;
  }
  get languageId() {
    return this._languageId;
  }
  get version() {
    return this._version;
  }
  getText(e) {
    if (e) {
      let n = this.offsetAt(e.start), r = this.offsetAt(e.end);
      return this._content.substring(n, r);
    }
    return this._content;
  }
  update(e, n) {
    this._content = e.text, this._version = n, this._lineOffsets = void 0;
  }
  getLineOffsets() {
    if (this._lineOffsets === void 0) {
      let e = [], n = this._content, r = true;
      for (let i = 0; i < n.length; i++) {
        r && (e.push(i), r = false);
        let o = n.charAt(i);
        r = o === "\r" || o === `
`, o === "\r" && i + 1 < n.length && n.charAt(i + 1) === `
` && i++;
      }
      r && n.length > 0 && e.push(n.length), this._lineOffsets = e;
    }
    return this._lineOffsets;
  }
  positionAt(e) {
    e = Math.max(Math.min(e, this._content.length), 0);
    let n = this.getLineOffsets(), r = 0, i = n.length;
    if (i === 0)
      return Ir.create(0, e);
    for (; r < i; ) {
      let s = Math.floor((r + i) / 2);
      n[s] > e ? i = s : r = s + 1;
    }
    let o = r - 1;
    return Ir.create(o, e - n[o]);
  }
  offsetAt(e) {
    let n = this.getLineOffsets();
    if (e.line >= n.length)
      return this._content.length;
    if (e.line < 0)
      return 0;
    let r = n[e.line], i = e.line + 1 < n.length ? n[e.line + 1] : this._content.length;
    return Math.max(Math.min(r + e.character, i), r);
  }
  get lineCount() {
    return this.getLineOffsets().length;
  }
};
var U;
(function(t4) {
  const e = Object.prototype.toString;
  function n(h) {
    return typeof h < "u";
  }
  t4.defined = n;
  function r(h) {
    return typeof h > "u";
  }
  t4.undefined = r;
  function i(h) {
    return h === true || h === false;
  }
  t4.boolean = i;
  function o(h) {
    return e.call(h) === "[object String]";
  }
  t4.string = o;
  function s(h) {
    return e.call(h) === "[object Number]";
  }
  t4.number = s;
  function a(h, p, O) {
    return e.call(h) === "[object Number]" && p <= h && h <= O;
  }
  t4.numberRange = a;
  function l(h) {
    return e.call(h) === "[object Number]" && -2147483648 <= h && h <= 2147483647;
  }
  t4.integer = l;
  function c(h) {
    return e.call(h) === "[object Number]" && 0 <= h && h <= 2147483647;
  }
  t4.uinteger = c;
  function u(h) {
    return e.call(h) === "[object Function]";
  }
  t4.func = u;
  function f(h) {
    return h !== null && typeof h == "object";
  }
  t4.objectLiteral = f;
  function d(h, p) {
    return Array.isArray(h) && h.every(p);
  }
  t4.typedArray = d;
})(U || (U = {}));
var Oc = class {
  constructor(e, n, r, i) {
    this._uri = e, this._languageId = n, this._version = r, this._content = i, this._lineOffsets = void 0;
  }
  get uri() {
    return this._uri;
  }
  get languageId() {
    return this._languageId;
  }
  get version() {
    return this._version;
  }
  getText(e) {
    if (e) {
      const n = this.offsetAt(e.start), r = this.offsetAt(e.end);
      return this._content.substring(n, r);
    }
    return this._content;
  }
  update(e, n) {
    for (let r of e)
      if (Oc.isIncremental(r)) {
        const i = v$(r.range), o = this.offsetAt(i.start), s = this.offsetAt(i.end);
        this._content = this._content.substring(0, o) + r.text + this._content.substring(s, this._content.length);
        const a = Math.max(i.start.line, 0), l = Math.max(i.end.line, 0);
        let c = this._lineOffsets;
        const u = Kw(r.text, false, o);
        if (l - a === u.length)
          for (let d = 0, h = u.length; d < h; d++)
            c[d + a + 1] = u[d];
        else
          u.length < 1e4 ? c.splice(a + 1, l - a, ...u) : this._lineOffsets = c = c.slice(0, a + 1).concat(u, c.slice(l + 1));
        const f = r.text.length - (s - o);
        if (f !== 0)
          for (let d = a + 1 + u.length, h = c.length; d < h; d++)
            c[d] = c[d] + f;
      } else if (Oc.isFull(r))
        this._content = r.text, this._lineOffsets = void 0;
      else
        throw new Error("Unknown change event received");
    this._version = n;
  }
  getLineOffsets() {
    return this._lineOffsets === void 0 && (this._lineOffsets = Kw(this._content, true)), this._lineOffsets;
  }
  positionAt(e) {
    e = Math.max(Math.min(e, this._content.length), 0);
    let n = this.getLineOffsets(), r = 0, i = n.length;
    if (i === 0)
      return { line: 0, character: e };
    for (; r < i; ) {
      let s = Math.floor((r + i) / 2);
      n[s] > e ? i = s : r = s + 1;
    }
    let o = r - 1;
    return { line: o, character: e - n[o] };
  }
  offsetAt(e) {
    let n = this.getLineOffsets();
    if (e.line >= n.length)
      return this._content.length;
    if (e.line < 0)
      return 0;
    let r = n[e.line], i = e.line + 1 < n.length ? n[e.line + 1] : this._content.length;
    return Math.max(Math.min(r + e.character, i), r);
  }
  get lineCount() {
    return this.getLineOffsets().length;
  }
  static isIncremental(e) {
    let n = e;
    return n != null && typeof n.text == "string" && n.range !== void 0 && (n.rangeLength === void 0 || typeof n.rangeLength == "number");
  }
  static isFull(e) {
    let n = e;
    return n != null && typeof n.text == "string" && n.range === void 0 && n.rangeLength === void 0;
  }
};
var lO;
(function(t4) {
  function e(i, o, s, a) {
    return new Oc(i, o, s, a);
  }
  t4.create = e;
  function n(i, o, s) {
    if (i instanceof Oc)
      return i.update(o, s), i;
    throw new Error("TextDocument.update: document must be created by TextDocument.create");
  }
  t4.update = n;
  function r(i, o) {
    let s = i.getText(), a = cO(o.map(dY), (u, f) => {
      let d = u.range.start.line - f.range.start.line;
      return d === 0 ? u.range.start.character - f.range.start.character : d;
    }), l = 0;
    const c = [];
    for (const u of a) {
      let f = i.offsetAt(u.range.start);
      if (f < l)
        throw new Error("Overlapping edit");
      f > l && c.push(s.substring(l, f)), u.newText.length && c.push(u.newText), l = i.offsetAt(u.range.end);
    }
    return c.push(s.substr(l)), c.join("");
  }
  t4.applyEdits = r;
})(lO || (lO = {}));
function cO(t4, e) {
  if (t4.length <= 1)
    return t4;
  const n = t4.length / 2 | 0, r = t4.slice(0, n), i = t4.slice(n);
  cO(r, e), cO(i, e);
  let o = 0, s = 0, a = 0;
  for (; o < r.length && s < i.length; )
    e(r[o], i[s]) <= 0 ? t4[a++] = r[o++] : t4[a++] = i[s++];
  for (; o < r.length; )
    t4[a++] = r[o++];
  for (; s < i.length; )
    t4[a++] = i[s++];
  return t4;
}
function Kw(t4, e, n = 0) {
  const r = e ? [n] : [];
  for (let i = 0; i < t4.length; i++) {
    let o = t4.charCodeAt(i);
    (o === 13 || o === 10) && (o === 13 && i + 1 < t4.length && t4.charCodeAt(i + 1) === 10 && i++, r.push(n + i + 1));
  }
  return r;
}
function v$(t4) {
  const e = t4.start, n = t4.end;
  return e.line > n.line || e.line === n.line && e.character > n.character ? { start: n, end: e } : t4;
}
function dY(t4) {
  const e = v$(t4.range);
  return e !== t4.range ? { newText: t4.newText, range: e } : t4;
}
var nt;
(function(t4) {
  t4[t4.Undefined = 0] = "Undefined", t4[t4.EnumValueMismatch = 1] = "EnumValueMismatch", t4[t4.UnexpectedEndOfComment = 257] = "UnexpectedEndOfComment", t4[t4.UnexpectedEndOfString = 258] = "UnexpectedEndOfString", t4[t4.UnexpectedEndOfNumber = 259] = "UnexpectedEndOfNumber", t4[t4.InvalidUnicode = 260] = "InvalidUnicode", t4[t4.InvalidEscapeCharacter = 261] = "InvalidEscapeCharacter", t4[t4.InvalidCharacter = 262] = "InvalidCharacter", t4[t4.PropertyExpected = 513] = "PropertyExpected", t4[t4.CommaExpected = 514] = "CommaExpected", t4[t4.ColonExpected = 515] = "ColonExpected", t4[t4.ValueExpected = 516] = "ValueExpected", t4[t4.CommaOrCloseBacketExpected = 517] = "CommaOrCloseBacketExpected", t4[t4.CommaOrCloseBraceExpected = 518] = "CommaOrCloseBraceExpected", t4[t4.TrailingComma = 519] = "TrailingComma", t4[t4.DuplicateKey = 520] = "DuplicateKey", t4[t4.CommentNotPermitted = 521] = "CommentNotPermitted", t4[t4.SchemaResolveError = 768] = "SchemaResolveError";
})(nt || (nt = {}));
var eC;
(function(t4) {
  t4.LATEST = {
    textDocument: {
      completion: {
        completionItem: {
          documentationFormat: [ms.Markdown, ms.PlainText],
          commitCharactersSupport: true
        }
      }
    }
  };
})(eC || (eC = {}));
var ws = /* @__PURE__ */ function() {
  var t4 = function(e, n) {
    return t4 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, i) {
      r.__proto__ = i;
    } || function(r, i) {
      for (var o in i)
        i.hasOwnProperty(o) && (r[o] = i[o]);
    }, t4(e, n);
  };
  return function(e, n) {
    t4(e, n);
    function r() {
      this.constructor = e;
    }
    e.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}();
var hY = {
  "color-hex": { errorMessage: "Invalid color format. Use #RGB, #RGBA, #RRGGBB or #RRGGBBAA.", pattern: /^#([0-9A-Fa-f]{3,4}|([0-9A-Fa-f]{2}){3,4})$/ },
  "date-time": { errorMessage: "String is not a RFC3339 date-time.", pattern: /^(\d{4})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])T([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)([01][0-9]|2[0-3]):([0-5][0-9]))$/i },
  date: { errorMessage: "String is not a RFC3339 date.", pattern: /^(\d{4})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/i },
  time: { errorMessage: "String is not a RFC3339 time.", pattern: /^([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)([01][0-9]|2[0-3]):([0-5][0-9]))$/i },
  email: { errorMessage: "String is not an e-mail address.", pattern: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/ }
};
var Cs = (
  /** @class */
  function() {
    function t4(e, n, r) {
      this.offset = n, this.length = r, this.parent = e;
    }
    return Object.defineProperty(t4.prototype, "children", {
      get: function() {
        return [];
      },
      enumerable: true,
      configurable: true
    }), t4.prototype.toString = function() {
      return "type: " + this.type + " (" + this.offset + "/" + this.length + ")" + (this.parent ? " parent: {" + this.parent.toString() + "}" : "");
    }, t4;
  }()
);
var pY = (
  /** @class */
  function(t4) {
    ws(e, t4);
    function e(n, r) {
      var i = t4.call(this, n, r) || this;
      return i.type = "null", i.value = null, i;
    }
    return e;
  }(Cs)
);
var tC = (
  /** @class */
  function(t4) {
    ws(e, t4);
    function e(n, r, i) {
      var o = t4.call(this, n, i) || this;
      return o.type = "boolean", o.value = r, o;
    }
    return e;
  }(Cs)
);
var gY = (
  /** @class */
  function(t4) {
    ws(e, t4);
    function e(n, r) {
      var i = t4.call(this, n, r) || this;
      return i.type = "array", i.items = [], i;
    }
    return Object.defineProperty(e.prototype, "children", {
      get: function() {
        return this.items;
      },
      enumerable: true,
      configurable: true
    }), e;
  }(Cs)
);
var mY = (
  /** @class */
  function(t4) {
    ws(e, t4);
    function e(n, r) {
      var i = t4.call(this, n, r) || this;
      return i.type = "number", i.isInteger = true, i.value = Number.NaN, i;
    }
    return e;
  }(Cs)
);
var nC = (
  /** @class */
  function(t4) {
    ws(e, t4);
    function e(n, r, i) {
      var o = t4.call(this, n, r, i) || this;
      return o.type = "string", o.value = "", o;
    }
    return e;
  }(Cs)
);
var OY = (
  /** @class */
  function(t4) {
    ws(e, t4);
    function e(n, r) {
      var i = t4.call(this, n, r) || this;
      return i.type = "property", i.colonOffset = -1, i;
    }
    return Object.defineProperty(e.prototype, "children", {
      get: function() {
        return this.valueNode ? [this.keyNode, this.valueNode] : [this.keyNode];
      },
      enumerable: true,
      configurable: true
    }), e;
  }(Cs)
);
var xY = (
  /** @class */
  function(t4) {
    ws(e, t4);
    function e(n, r) {
      var i = t4.call(this, n, r) || this;
      return i.type = "object", i.properties = [], i;
    }
    return Object.defineProperty(e.prototype, "children", {
      get: function() {
        return this.properties;
      },
      enumerable: true,
      configurable: true
    }), e;
  }(Cs)
);
function Kn(t4) {
  return yi(t4) ? t4 ? {} : { not: {} } : t4;
}
var rC;
(function(t4) {
  t4[t4.Key = 0] = "Key", t4[t4.Enum = 1] = "Enum";
})(rC || (rC = {}));
var vY = (
  /** @class */
  function() {
    function t4(e, n) {
      e === void 0 && (e = -1), n === void 0 && (n = null), this.focusOffset = e, this.exclude = n, this.schemas = [];
    }
    return t4.prototype.add = function(e) {
      this.schemas.push(e);
    }, t4.prototype.merge = function(e) {
      var n;
      (n = this.schemas).push.apply(n, e.schemas);
    }, t4.prototype.include = function(e) {
      return (this.focusOffset === -1 || y$(e, this.focusOffset)) && e !== this.exclude;
    }, t4.prototype.newSub = function() {
      return new t4(-1, this.exclude);
    }, t4;
  }()
);
var uO = (
  /** @class */
  function() {
    function t4() {
    }
    return Object.defineProperty(t4.prototype, "schemas", {
      get: function() {
        return [];
      },
      enumerable: true,
      configurable: true
    }), t4.prototype.add = function(e) {
    }, t4.prototype.merge = function(e) {
    }, t4.prototype.include = function(e) {
      return true;
    }, t4.prototype.newSub = function() {
      return this;
    }, t4.instance = new t4(), t4;
  }()
);
var tr = (
  /** @class */
  function() {
    function t4() {
      this.problems = [], this.propertiesMatches = 0, this.propertiesValueMatches = 0, this.primaryValueMatches = 0, this.enumValueMatch = false, this.enumValues = null;
    }
    return t4.prototype.hasProblems = function() {
      return !!this.problems.length;
    }, t4.prototype.mergeAll = function(e) {
      for (var n = 0, r = e; n < r.length; n++) {
        var i = r[n];
        this.merge(i);
      }
    }, t4.prototype.merge = function(e) {
      this.problems = this.problems.concat(e.problems);
    }, t4.prototype.mergeEnumValues = function(e) {
      if (!this.enumValueMatch && !e.enumValueMatch && this.enumValues && e.enumValues) {
        this.enumValues = this.enumValues.concat(e.enumValues);
        for (var n = 0, r = this.problems; n < r.length; n++) {
          var i = r[n];
          i.code === nt.EnumValueMismatch && (i.message = "Value is not accepted. Valid values: " + this.enumValues.map(function(o) {
            return JSON.stringify(o);
          }).join(", ") + ".");
        }
      }
    }, t4.prototype.mergePropertyMatch = function(e) {
      this.merge(e), this.propertiesMatches++, (e.enumValueMatch || !e.hasProblems() && e.propertiesMatches) && this.propertiesValueMatches++, e.enumValueMatch && e.enumValues && e.enumValues.length === 1 && this.primaryValueMatches++;
    }, t4.prototype.compare = function(e) {
      var n = this.hasProblems();
      return n !== e.hasProblems() ? n ? -1 : 1 : this.enumValueMatch !== e.enumValueMatch ? e.enumValueMatch ? -1 : 1 : this.primaryValueMatches !== e.primaryValueMatches ? this.primaryValueMatches - e.primaryValueMatches : this.propertiesValueMatches !== e.propertiesValueMatches ? this.propertiesValueMatches - e.propertiesValueMatches : this.propertiesMatches - e.propertiesMatches;
    }, t4;
  }()
);
function yY(t4, e) {
  return e === void 0 && (e = []), new b$(t4, e, []);
}
function Ao(t4) {
  return lY(t4);
}
function fO(t4) {
  return aY(t4);
}
function y$(t4, e, n) {
  return n === void 0 && (n = false), e >= t4.offset && e < t4.offset + t4.length || n && e === t4.offset + t4.length;
}
var b$ = (
  /** @class */
  function() {
    function t4(e, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = []), this.root = e, this.syntaxErrors = n, this.comments = r;
    }
    return t4.prototype.getNodeFromOffset = function(e, n) {
      if (n === void 0 && (n = false), this.root)
        return sY(this.root, e, n);
    }, t4.prototype.visit = function(e) {
      if (this.root) {
        var n = function(r) {
          var i = e(r), o = r.children;
          if (Array.isArray(o))
            for (var s = 0; s < o.length && i; s++)
              i = n(o[s]);
          return i;
        };
        n(this.root);
      }
    }, t4.prototype.validate = function(e, n) {
      if (this.root && n) {
        var r = new tr();
        return yn(this.root, n, r, uO.instance), r.problems.map(function(i) {
          var o = at.create(e.positionAt(i.location.offset), e.positionAt(i.location.offset + i.location.length));
          return Yi.create(o, i.message, i.severity, i.code);
        });
      }
      return null;
    }, t4.prototype.getMatchingSchemas = function(e, n, r) {
      n === void 0 && (n = -1), r === void 0 && (r = null);
      var i = new vY(n, r);
      return this.root && e && yn(this.root, e, new tr(), i), i.schemas;
    }, t4;
  }()
);
function yn(t4, e, n, r) {
  if (!t4 || !r.include(t4))
    return;
  switch (t4.type) {
    case "object":
      l(t4, e, n, r);
      break;
    case "array":
      a(t4, e, n, r);
      break;
    case "string":
      s(t4, e, n);
      break;
    case "number":
      o(t4, e, n);
      break;
    case "property":
      return yn(t4.valueNode, e, n, r);
  }
  i(), r.add({ node: t4, schema: e });
  function i() {
    function c($) {
      return t4.type === $ || $ === "integer" && t4.type === "number" && t4.isInteger || e.nullable && t4.value === null;
    }
    if (Array.isArray(e.type) ? e.type.some(c) || n.problems.push({
      location: { offset: t4.offset, length: t4.length },
      severity: ze.Warning,
      message: e.errorMessage || "Incorrect type. Expected one of " + e.type.join(", ") + "."
    }) : e.type && (c(e.type) || n.problems.push({
      location: { offset: t4.offset, length: t4.length },
      severity: ze.Warning,
      message: e.errorMessage || 'Incorrect type. Expected "' + e.type + '".'
    })), Array.isArray(e.allOf))
      for (var u = 0, f = e.allOf; u < f.length; u++) {
        var d = f[u];
        yn(t4, Kn(d), n, r);
      }
    var h = Kn(e.not);
    if (h) {
      var p = new tr(), O = r.newSub();
      yn(t4, h, p, O), p.hasProblems() || n.problems.push({
        location: { offset: t4.offset, length: t4.length },
        severity: ze.Warning,
        message: "Matches a schema that is not allowed."
      });
      for (var m = 0, x = O.schemas; m < x.length; m++) {
        var v = x[m];
        v.inverted = !v.inverted, r.add(v);
      }
    }
    var y = function($, j) {
      for (var B = [], D = null, N = 0, z = $; N < z.length; N++) {
        var Z = z[N], J = Kn(Z), L = new tr(), W = r.newSub();
        if (yn(t4, J, L, W), L.hasProblems() || B.push(J), !D)
          D = { schema: J, validationResult: L, matchingSchemas: W };
        else if (!j && !L.hasProblems() && !D.validationResult.hasProblems())
          D.matchingSchemas.merge(W), D.validationResult.propertiesMatches += L.propertiesMatches, D.validationResult.propertiesValueMatches += L.propertiesValueMatches;
        else {
          var R = L.compare(D.validationResult);
          R > 0 ? D = { schema: J, validationResult: L, matchingSchemas: W } : R === 0 && (D.matchingSchemas.merge(W), D.validationResult.mergeEnumValues(L));
        }
      }
      return B.length > 1 && j && n.problems.push({
        location: { offset: t4.offset, length: 1 },
        severity: ze.Warning,
        message: "Matches multiple schemas when only one must validate."
      }), D !== null && (n.merge(D.validationResult), n.propertiesMatches += D.validationResult.propertiesMatches, n.propertiesValueMatches += D.validationResult.propertiesValueMatches, r.merge(D.matchingSchemas)), B.length;
    };
    Array.isArray(e.anyOf) && y(e.anyOf, false), Array.isArray(e.oneOf) && y(e.oneOf, true);
    var S = function($) {
      var j = new tr(), B = r.newSub();
      yn(t4, Kn($), j, B), n.merge(j), n.propertiesMatches += j.propertiesMatches, n.propertiesValueMatches += j.propertiesValueMatches, r.merge(B);
    }, b = function($, j, B) {
      var D = Kn($), N = new tr(), z = r.newSub();
      yn(t4, D, N, z), r.merge(z), N.hasProblems() ? B && S(B) : j && S(j);
    }, w = Kn(e.if);
    if (w && b(w, Kn(e.then), Kn(e.else)), Array.isArray(e.enum)) {
      for (var C = Ao(t4), k = false, T = 0, A = e.enum; T < A.length; T++) {
        var E = A[T];
        if (Ll(C, E)) {
          k = true;
          break;
        }
      }
      n.enumValues = e.enum, n.enumValueMatch = k, k || n.problems.push({
        location: { offset: t4.offset, length: t4.length },
        severity: ze.Warning,
        code: nt.EnumValueMismatch,
        message: e.errorMessage || "Value is not accepted. Valid values: " + e.enum.map(function($) {
          return JSON.stringify($);
        }).join(", ") + "."
      });
    }
    if (Wi(e.const)) {
      var C = Ao(t4);
      Ll(C, e.const) ? n.enumValueMatch = true : (n.problems.push({
        location: { offset: t4.offset, length: t4.length },
        severity: ze.Warning,
        code: nt.EnumValueMismatch,
        message: e.errorMessage || "Value must be " + JSON.stringify(e.const) + "."
      }), n.enumValueMatch = false), n.enumValues = [e.const];
    }
    e.deprecationMessage && t4.parent && n.problems.push({
      location: { offset: t4.parent.offset, length: t4.parent.length },
      severity: ze.Warning,
      message: e.deprecationMessage
    });
  }
  function o(c, u, f, d) {
    var h = c.value;
    gr(u.multipleOf) && h % u.multipleOf !== 0 && f.problems.push({
      location: { offset: c.offset, length: c.length },
      severity: ze.Warning,
      message: "Value is not divisible by " + u.multipleOf + "."
    });
    function p(S, b) {
      if (gr(b))
        return b;
      if (yi(b) && b)
        return S;
    }
    function O(S, b) {
      if (!yi(b) || !b)
        return S;
    }
    var m = p(u.minimum, u.exclusiveMinimum);
    gr(m) && h <= m && f.problems.push({
      location: { offset: c.offset, length: c.length },
      severity: ze.Warning,
      message: "Value is below the exclusive minimum of " + m + "."
    });
    var x = p(u.maximum, u.exclusiveMaximum);
    gr(x) && h >= x && f.problems.push({
      location: { offset: c.offset, length: c.length },
      severity: ze.Warning,
      message: "Value is above the exclusive maximum of " + x + "."
    });
    var v = O(u.minimum, u.exclusiveMinimum);
    gr(v) && h < v && f.problems.push({
      location: { offset: c.offset, length: c.length },
      severity: ze.Warning,
      message: "Value is below the minimum of " + v + "."
    });
    var y = O(u.maximum, u.exclusiveMaximum);
    gr(y) && h > y && f.problems.push({
      location: { offset: c.offset, length: c.length },
      severity: ze.Warning,
      message: "Value is above the maximum of " + y + "."
    });
  }
  function s(c, u, f, d) {
    if (gr(u.minLength) && c.value.length < u.minLength && f.problems.push({
      location: { offset: c.offset, length: c.length },
      severity: ze.Warning,
      message: "String is shorter than the minimum length of " + u.minLength + "."
    }), gr(u.maxLength) && c.value.length > u.maxLength && f.problems.push({
      location: { offset: c.offset, length: c.length },
      severity: ze.Warning,
      message: "String is longer than the maximum length of " + u.maxLength + "."
    }), uY(u.pattern)) {
      var h = new RegExp(u.pattern);
      h.test(c.value) || f.problems.push({
        location: { offset: c.offset, length: c.length },
        severity: ze.Warning,
        message: u.patternErrorMessage || u.errorMessage || 'String does not match the pattern of "' + u.pattern + '".'
      });
    }
    if (u.format)
      switch (u.format) {
        case "uri":
        case "uri-reference":
          {
            var p = void 0;
            if (!c.value)
              p = "URI expected.";
            else {
              var O = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/.exec(c.value);
              O ? !O[2] && u.format === "uri" && (p = "URI with a scheme is expected.") : p = "URI is expected.";
            }
            p && f.problems.push({
              location: { offset: c.offset, length: c.length },
              severity: ze.Warning,
              message: u.patternErrorMessage || u.errorMessage || "String is not a URI: " + p
            });
          }
          break;
        case "color-hex":
        case "date-time":
        case "date":
        case "time":
        case "email":
          var m = hY[u.format];
          (!c.value || !m.pattern.exec(c.value)) && f.problems.push({
            location: { offset: c.offset, length: c.length },
            severity: ze.Warning,
            message: u.patternErrorMessage || u.errorMessage || m.errorMessage
          });
          break;
      }
  }
  function a(c, u, f, d) {
    if (Array.isArray(u.items)) {
      for (var h = u.items, p = 0; p < h.length; p++) {
        var O = h[p], m = Kn(O), x = new tr(), v = c.items[p];
        v ? (yn(v, m, x, d), f.mergePropertyMatch(x)) : c.items.length >= h.length && f.propertiesValueMatches++;
      }
      if (c.items.length > h.length)
        if (typeof u.additionalItems == "object")
          for (var y = h.length; y < c.items.length; y++) {
            var x = new tr();
            yn(c.items[y], u.additionalItems, x, d), f.mergePropertyMatch(x);
          }
        else
          u.additionalItems === false && f.problems.push({
            location: { offset: c.offset, length: c.length },
            severity: ze.Warning,
            message: "Array has too many items according to schema. Expected " + h.length + " or fewer."
          });
    } else {
      var S = Kn(u.items);
      if (S)
        for (var b = 0, w = c.items; b < w.length; b++) {
          var v = w[b], x = new tr();
          yn(v, S, x, d), f.mergePropertyMatch(x);
        }
    }
    var C = Kn(u.contains);
    if (C) {
      var k = c.items.some(function(E) {
        var $ = new tr();
        return yn(E, C, $, uO.instance), !$.hasProblems();
      });
      k || f.problems.push({
        location: { offset: c.offset, length: c.length },
        severity: ze.Warning,
        message: u.errorMessage || "Array does not contain required item."
      });
    }
    if (gr(u.minItems) && c.items.length < u.minItems && f.problems.push({
      location: { offset: c.offset, length: c.length },
      severity: ze.Warning,
      message: "Array has too few items. Expected " + u.minItems + " or more."
    }), gr(u.maxItems) && c.items.length > u.maxItems && f.problems.push({
      location: { offset: c.offset, length: c.length },
      severity: ze.Warning,
      message: "Array has too many items. Expected " + u.maxItems + " or fewer."
    }), u.uniqueItems === true) {
      var T = Ao(c), A = T.some(function(E, $) {
        return $ !== T.lastIndexOf(E);
      });
      A && f.problems.push({
        location: { offset: c.offset, length: c.length },
        severity: ze.Warning,
        message: "Array has duplicate items."
      });
    }
  }
  function l(c, u, f, d) {
    for (var h = /* @__PURE__ */ Object.create(null), p = [], O = 0, m = c.properties; O < m.length; O++) {
      var x = m[O], v = x.keyNode.value;
      h[v] = x.valueNode, p.push(v);
    }
    if (Array.isArray(u.required))
      for (var y = 0, S = u.required; y < S.length; y++) {
        var b = S[y];
        if (!h[b]) {
          var w = c.parent && c.parent.type === "property" && c.parent.keyNode, C = w ? { offset: w.offset, length: w.length } : { offset: c.offset, length: 1 };
          f.problems.push({
            location: C,
            severity: ze.Warning,
            message: 'Missing property "' + b + '".'
          });
        }
      }
    var k = function(ee) {
      for (var de = p.indexOf(ee); de >= 0; )
        p.splice(de, 1), de = p.indexOf(ee);
    };
    if (u.properties)
      for (var T = 0, A = Object.keys(u.properties); T < A.length; T++) {
        var b = A[T];
        k(b);
        var E = u.properties[b], $ = h[b];
        if ($)
          if (yi(E))
            if (E)
              f.propertiesMatches++, f.propertiesValueMatches++;
            else {
              var x = $.parent;
              f.problems.push({
                location: { offset: x.keyNode.offset, length: x.keyNode.length },
                severity: ze.Warning,
                message: u.errorMessage || "Property " + b + " is not allowed."
              });
            }
          else {
            var j = new tr();
            yn($, E, j, d), f.mergePropertyMatch(j);
          }
      }
    if (u.patternProperties)
      for (var B = 0, D = Object.keys(u.patternProperties); B < D.length; B++)
        for (var N = D[B], z = new RegExp(N), Z = 0, J = p.slice(0); Z < J.length; Z++) {
          var b = J[Z];
          if (z.test(b)) {
            k(b);
            var $ = h[b];
            if ($) {
              var E = u.patternProperties[N];
              if (yi(E))
                if (E)
                  f.propertiesMatches++, f.propertiesValueMatches++;
                else {
                  var x = $.parent;
                  f.problems.push({
                    location: { offset: x.keyNode.offset, length: x.keyNode.length },
                    severity: ze.Warning,
                    message: u.errorMessage || "Property " + b + " is not allowed."
                  });
                }
              else {
                var j = new tr();
                yn($, E, j, d), f.mergePropertyMatch(j);
              }
            }
          }
        }
    if (typeof u.additionalProperties == "object")
      for (var L = 0, W = p; L < W.length; L++) {
        var b = W[L], $ = h[b];
        if ($) {
          var j = new tr();
          yn($, u.additionalProperties, j, d), f.mergePropertyMatch(j);
        }
      }
    else if (u.additionalProperties === false && p.length > 0)
      for (var R = 0, Q = p; R < Q.length; R++) {
        var b = Q[R], $ = h[b];
        if ($) {
          var x = $.parent;
          f.problems.push({
            location: { offset: x.keyNode.offset, length: x.keyNode.length },
            severity: ze.Warning,
            message: u.errorMessage || "Property " + b + " is not allowed."
          });
        }
      }
    if (gr(u.maxProperties) && c.properties.length > u.maxProperties && f.problems.push({
      location: { offset: c.offset, length: c.length },
      severity: ze.Warning,
      message: "Object has more properties than limit of " + u.maxProperties + "."
    }), gr(u.minProperties) && c.properties.length < u.minProperties && f.problems.push({
      location: { offset: c.offset, length: c.length },
      severity: ze.Warning,
      message: "Object has fewer properties than the required number of " + u.minProperties
    }), u.dependencies)
      for (var _ = 0, G = Object.keys(u.dependencies); _ < G.length; _++) {
        var v = G[_], M = h[v];
        if (M) {
          var K = u.dependencies[v];
          if (Array.isArray(K))
            for (var V = 0, ae = K; V < ae.length; V++) {
              var te = ae[V];
              h[te] ? f.propertiesValueMatches++ : f.problems.push({
                location: { offset: c.offset, length: c.length },
                severity: ze.Warning,
                message: "Object is missing property " + te + " required by property {$key}."
              });
            }
          else {
            var E = Kn(K);
            if (E) {
              var j = new tr();
              yn(c, E, j, d), f.mergePropertyMatch(j);
            }
          }
        }
      }
    var oe = Kn(u.propertyNames);
    if (oe)
      for (var Y = 0, he = c.properties; Y < he.length; Y++) {
        var X = he[Y], v = X.keyNode;
        v && yn(v, oe, f, uO.instance);
      }
  }
}
function bY(t4, e) {
  var n = [], r = -1, i = t4.getText(), o = pa(i, false), s = e && e.collectComments ? [] : void 0;
  function a() {
    for (; ; ) {
      var b = o.scan();
      switch (u(), b) {
        case 12:
        case 13:
          Array.isArray(s) && s.push(at.create(t4.positionAt(o.getTokenOffset()), t4.positionAt(o.getTokenOffset() + o.getTokenLength())));
          break;
        case 15:
        case 14:
          break;
        default:
          return b;
      }
    }
  }
  function l(b, w, C, k, T) {
    if (T === void 0 && (T = ze.Error), n.length === 0 || C !== r) {
      var A = at.create(t4.positionAt(C), t4.positionAt(k));
      n.push(Yi.create(A, b, T, w, t4.languageId)), r = C;
    }
  }
  function c(b, w, C, k, T) {
    C === void 0 && (C = null), k === void 0 && (k = []), T === void 0 && (T = []);
    var A = o.getTokenOffset(), E = o.getTokenOffset() + o.getTokenLength();
    if (A === E && A > 0) {
      for (A--; A > 0 && /\s/.test(i.charAt(A)); )
        A--;
      E = A + 1;
    }
    if (l(b, w, A, E), C && f(C, false), k.length + T.length > 0)
      for (var $ = o.getToken(); $ !== 17; ) {
        if (k.indexOf($) !== -1) {
          a();
          break;
        } else if (T.indexOf($) !== -1)
          break;
        $ = a();
      }
    return C;
  }
  function u() {
    switch (o.getTokenError()) {
      case 4:
        return c("Invalid unicode sequence in string.", nt.InvalidUnicode), true;
      case 5:
        return c("Invalid escape character in string.", nt.InvalidEscapeCharacter), true;
      case 3:
        return c("Unexpected end of number.", nt.UnexpectedEndOfNumber), true;
      case 1:
        return c("Unexpected end of comment.", nt.UnexpectedEndOfComment), true;
      case 2:
        return c("Unexpected end of string.", nt.UnexpectedEndOfString), true;
      case 6:
        return c("Invalid characters in string. Control characters must be escaped.", nt.InvalidCharacter), true;
    }
    return false;
  }
  function f(b, w) {
    return b.length = o.getTokenOffset() + o.getTokenLength() - b.offset, w && a(), b;
  }
  function d(b) {
    if (o.getToken() !== 3)
      return null;
    var w = new gY(b, o.getTokenOffset());
    a();
    for (var C = false; o.getToken() !== 4 && o.getToken() !== 17; ) {
      if (o.getToken() === 5) {
        C || c("Value expected", nt.ValueExpected);
        var k = o.getTokenOffset();
        if (a(), o.getToken() === 4) {
          C && l("Trailing comma", nt.TrailingComma, k, k + 1);
          continue;
        }
      } else
        C && c("Expected comma", nt.CommaExpected);
      var T = v(w);
      T ? w.items.push(T) : c("Value expected", nt.ValueExpected, null, [], [
        4,
        5
        /* CommaToken */
      ]), C = true;
    }
    return o.getToken() !== 4 ? c("Expected comma or closing bracket", nt.CommaOrCloseBacketExpected, w) : f(w, true);
  }
  function h(b, w) {
    var C = new OY(b, o.getTokenOffset()), k = O(C);
    if (!k)
      if (o.getToken() === 16) {
        c("Property keys must be doublequoted", nt.Undefined);
        var T = new nC(C, o.getTokenOffset(), o.getTokenLength());
        T.value = o.getTokenValue(), k = T, a();
      } else
        return null;
    C.keyNode = k;
    var A = w[k.value];
    if (A ? (l("Duplicate object key", nt.DuplicateKey, C.keyNode.offset, C.keyNode.offset + C.keyNode.length, ze.Warning), typeof A == "object" && l("DuplicateKeyWarning", nt.DuplicateKey, A.keyNode.offset, A.keyNode.offset + A.keyNode.length, ze.Warning), w[k.value] = true) : w[k.value] = C, o.getToken() === 6)
      C.colonOffset = o.getTokenOffset(), a();
    else if (c("Colon expected", nt.ColonExpected), o.getToken() === 10 && t4.positionAt(k.offset + k.length).line < t4.positionAt(o.getTokenOffset()).line)
      return C.length = k.length, C;
    var E = v(C, k.value);
    return E ? (C.valueNode = E, C.length = E.offset + E.length - C.offset, C) : c("Value expected", nt.ValueExpected, C, [], [
      2,
      5
      /* CommaToken */
    ]);
  }
  function p(b) {
    if (o.getToken() !== 1)
      return null;
    var w = new xY(b, o.getTokenOffset()), C = /* @__PURE__ */ Object.create(null);
    a();
    for (var k = false; o.getToken() !== 2 && o.getToken() !== 17; ) {
      if (o.getToken() === 5) {
        k || c("Property expected", nt.PropertyExpected);
        var T = o.getTokenOffset();
        if (a(), o.getToken() === 2) {
          k && l("Trailing comma", nt.TrailingComma, T, T + 1);
          continue;
        }
      } else
        k && c("Expected comma", nt.CommaExpected);
      var A = h(w, C);
      A ? w.properties.push(A) : c("Property expected", nt.PropertyExpected, null, [], [
        2,
        5
        /* CommaToken */
      ]), k = true;
    }
    return o.getToken() !== 2 ? c("Expected comma or closing brace", nt.CommaOrCloseBraceExpected, w) : f(w, true);
  }
  function O(b) {
    if (o.getToken() !== 10)
      return null;
    var w = new nC(b, o.getTokenOffset());
    return w.value = o.getTokenValue(), f(w, true);
  }
  function m(b) {
    if (o.getToken() !== 11)
      return null;
    var w = new mY(b, o.getTokenOffset());
    if (o.getTokenError() === 0) {
      var C = o.getTokenValue();
      try {
        var k = JSON.parse(C);
        if (!gr(k))
          return c("Invalid number format.", nt.Undefined, w);
        w.value = k;
      } catch {
        return c("Invalid number format.", nt.Undefined, w);
      }
      w.isInteger = C.indexOf(".") === -1;
    }
    return f(w, true);
  }
  function x(b) {
    switch (o.getToken()) {
      case 7:
        return f(new pY(b, o.getTokenOffset()), true);
      case 8:
        return f(new tC(b, true, o.getTokenOffset()), true);
      case 9:
        return f(new tC(b, false, o.getTokenOffset()), true);
      default:
        return null;
    }
  }
  function v(b, w) {
    return d(b) || p(b) || O(b) || m(b) || x(b);
  }
  var y = null, S = a();
  return S !== 17 && (y = v(null), y ? o.getToken() !== 17 && c("End of file expected.", nt.Undefined) : c("Expected a JSON object, array or literal.", nt.Undefined)), new b$(y, n, s);
}
function dO(t4, e, n) {
  if (t4 !== null && typeof t4 == "object") {
    var r = e + "	";
    if (Array.isArray(t4)) {
      if (t4.length === 0)
        return "[]";
      for (var i = `[
`, o = 0; o < t4.length; o++)
        i += r + dO(t4[o], r, n), o < t4.length - 1 && (i += ","), i += `
`;
      return i += e + "]", i;
    } else {
      var s = Object.keys(t4);
      if (s.length === 0)
        return "{}";
      for (var i = `{
`, o = 0; o < s.length; o++) {
        var a = s[o];
        i += r + JSON.stringify(a) + ": " + dO(t4[a], r, n), o < s.length - 1 && (i += ","), i += `
`;
      }
      return i += e + "}", i;
    }
  }
  return n(t4);
}
function SY(t4, e) {
  if (t4.length < e.length)
    return false;
  for (var n = 0; n < e.length; n++)
    if (t4[n] !== e[n])
      return false;
  return true;
}
function hO(t4, e) {
  var n = t4.length - e.length;
  return n > 0 ? t4.lastIndexOf(e) === n : n === 0 ? t4 === e : false;
}
function wY(t4) {
  return t4.replace(/[\-\\\{\}\+\?\|\^\$\.\,\[\]\(\)\#\s]/g, "\\$&").replace(/[\*]/g, ".*");
}
var CY = [",", "}", "]"];
var kY = [":"];
var AY = (
  /** @class */
  function() {
    function t4(e, n, r, i) {
      n === void 0 && (n = []), r === void 0 && (r = Promise), i === void 0 && (i = {}), this.schemaService = e, this.contributions = n, this.promiseConstructor = r, this.clientCapabilities = i, this.templateVarIdCounter = 0;
    }
    return t4.prototype.doResolve = function(e) {
      for (var n = this.contributions.length - 1; n >= 0; n--)
        if (this.contributions[n].resolveCompletion) {
          var r = this.contributions[n].resolveCompletion(e);
          if (r)
            return r;
        }
      return this.promiseConstructor.resolve(e);
    }, t4.prototype.doComplete = function(e, n, r) {
      var i = this, o = {
        items: [],
        isIncomplete: false
      }, s = e.getText(), a = e.offsetAt(n), l = r.getNodeFromOffset(a, true);
      if (this.isInComment(e, l ? l.offset : 0, a))
        return Promise.resolve(o);
      if (l && a === l.offset + l.length && a > 0) {
        var c = s[a - 1];
        (l.type === "object" && c === "}" || l.type === "array" && c === "]") && (l = l.parent);
      }
      var u = this.getCurrentWord(e, a), f = null;
      if (l && (l.type === "string" || l.type === "number" || l.type === "boolean" || l.type === "null"))
        f = at.create(e.positionAt(l.offset), e.positionAt(l.offset + l.length));
      else {
        var d = a - u.length;
        d > 0 && s[d - 1] === '"' && d--, f = at.create(e.positionAt(d), n);
      }
      var h = this.doesSupportsCommitCharacters(), p = {}, O = {
        add: function(m) {
          var x = p[m.label];
          x ? x.documentation || (x.documentation = m.documentation) : (p[m.label] = m, f && (m.textEdit = Ki.replace(f, m.insertText)), h && (m.commitCharacters = m.kind === mr.Property ? kY : CY), o.items.push(m));
        },
        setAsIncomplete: function() {
          o.isIncomplete = true;
        },
        error: function(m) {
          console.error(m);
        },
        log: function(m) {
          console.log(m);
        },
        getNumberOfProposals: function() {
          return o.items.length;
        }
      };
      return this.schemaService.getSchemaForResource(e.uri, r).then(function(m) {
        var x = [], v = true, y = "", S = null;
        if (l && l.type === "string") {
          var b = l.parent;
          b && b.type === "property" && b.keyNode === l && (v = !b.valueNode, S = b, y = s.substr(l.offset + 1, l.length - 2), b && (l = b.parent));
        }
        if (l && l.type === "object") {
          if (l.offset === a)
            return o;
          var w = l.properties;
          w.forEach(function(A) {
            (!S || S !== A) && (p[A.keyNode.value] = oO.create("__"));
          });
          var C = "";
          v && (C = i.evaluateSeparatorAfter(e, e.offsetAt(f.end))), m ? i.getPropertyCompletions(m, r, l, v, C, O) : i.getSchemaLessPropertyCompletions(r, l, y, O);
          var k = fO(l);
          i.contributions.forEach(function(A) {
            var E = A.collectPropertyCompletions(e.uri, k, u, v, C === "", O);
            E && x.push(E);
          }), !m && u.length > 0 && s.charAt(a - u.length - 1) !== '"' && (O.add({
            kind: mr.Property,
            label: i.getLabelForValue(u),
            insertText: i.getInsertTextForProperty(u, null, false, C),
            insertTextFormat: an.Snippet,
            documentation: ""
          }), O.setAsIncomplete());
        }
        var T = {};
        return m ? i.getValueCompletions(m, r, l, a, e, O, T) : i.getSchemaLessValueCompletions(r, l, a, e, O), i.contributions.length > 0 && i.getContributedValueCompletions(r, l, a, e, O, x), i.promiseConstructor.all(x).then(function() {
          if (O.getNumberOfProposals() === 0) {
            var A = a;
            l && (l.type === "string" || l.type === "number" || l.type === "boolean" || l.type === "null") && (A = l.offset + l.length);
            var E = i.evaluateSeparatorAfter(e, A);
            i.addFillerValueCompletions(T, E, O);
          }
          return o;
        });
      });
    }, t4.prototype.getPropertyCompletions = function(e, n, r, i, o, s) {
      var a = this, l = n.getMatchingSchemas(e.schema, r.offset);
      l.forEach(function(c) {
        if (c.node === r && !c.inverted) {
          var u = c.schema.properties;
          u && Object.keys(u).forEach(function(f) {
            var d = u[f], h = false;
            if (typeof d == "object" && d.allOf)
              for (var p = 0, O = d.allOf; p < O.length; p++) {
                var m = O[p];
                if (m.readOnly) {
                  h = true;
                  break;
                }
              }
            if (typeof d == "object" && !d.deprecationMessage && !d.doNotSuggest && !h) {
              var x = {
                kind: mr.Property,
                label: a.sanitizeLabel(f),
                insertText: a.getInsertTextForProperty(f, d, i, o),
                insertTextFormat: an.Snippet,
                filterText: a.getFilterTextForValue(f),
                documentation: a.fromMarkup(d.markdownDescription) || d.description || ""
              };
              hO(x.insertText, "$1" + o) && (x.command = {
                title: "Suggest",
                command: "editor.action.triggerSuggest"
              }), s.add(x);
            }
          });
        }
      });
    }, t4.prototype.getSchemaLessPropertyCompletions = function(e, n, r, i) {
      var o = this, s = function(l) {
        l.properties.forEach(function(c) {
          var u = c.keyNode.value;
          i.add({
            kind: mr.Property,
            label: o.sanitizeLabel(u),
            insertText: o.getInsertTextForValue(u, ""),
            insertTextFormat: an.Snippet,
            filterText: o.getFilterTextForValue(u),
            documentation: ""
          });
        });
      };
      if (n.parent)
        if (n.parent.type === "property") {
          var a = n.parent.keyNode.value;
          e.visit(function(l) {
            return l.type === "property" && l !== n.parent && l.keyNode.value === a && l.valueNode && l.valueNode.type === "object" && s(l.valueNode), true;
          });
        } else
          n.parent.type === "array" && n.parent.items.forEach(function(l) {
            l.type === "object" && l !== n && s(l);
          });
      else
        n.type === "object" && i.add({
          kind: mr.Property,
          label: "$schema",
          insertText: this.getInsertTextForProperty("$schema", null, true, ""),
          insertTextFormat: an.Snippet,
          documentation: "",
          filterText: this.getFilterTextForValue("$schema")
        });
    }, t4.prototype.getSchemaLessValueCompletions = function(e, n, r, i, o) {
      var s = this, a = r;
      if (n && (n.type === "string" || n.type === "number" || n.type === "boolean" || n.type === "null") && (a = n.offset + n.length, n = n.parent), !n) {
        o.add({
          kind: this.getSuggestionKind("object"),
          label: "Empty object",
          insertText: this.getInsertTextForValue({}, ""),
          insertTextFormat: an.Snippet,
          documentation: ""
        }), o.add({
          kind: this.getSuggestionKind("array"),
          label: "Empty array",
          insertText: this.getInsertTextForValue([], ""),
          insertTextFormat: an.Snippet,
          documentation: ""
        });
        return;
      }
      var l = this.evaluateSeparatorAfter(i, a), c = function(h) {
        y$(h.parent, r, true) || o.add({
          kind: s.getSuggestionKind(h.type),
          label: s.getLabelTextForMatchingNode(h, i),
          insertText: s.getInsertTextForMatchingNode(h, i, l),
          insertTextFormat: an.Snippet,
          documentation: ""
        }), h.type === "boolean" && s.addBooleanValueCompletion(!h.value, l, o);
      };
      if (n.type === "property" && r > n.colonOffset) {
        var u = n.valueNode;
        if (u && (r > u.offset + u.length || u.type === "object" || u.type === "array"))
          return;
        var f = n.keyNode.value;
        e.visit(function(h) {
          return h.type === "property" && h.keyNode.value === f && h.valueNode && c(h.valueNode), true;
        }), f === "$schema" && n.parent && !n.parent.parent && this.addDollarSchemaCompletions(l, o);
      }
      if (n.type === "array")
        if (n.parent && n.parent.type === "property") {
          var d = n.parent.keyNode.value;
          e.visit(function(h) {
            return h.type === "property" && h.keyNode.value === d && h.valueNode && h.valueNode.type === "array" && h.valueNode.items.forEach(c), true;
          });
        } else
          n.items.forEach(c);
    }, t4.prototype.getValueCompletions = function(e, n, r, i, o, s, a) {
      var l = this, c = i, u = null, f = null;
      if (r && (r.type === "string" || r.type === "number" || r.type === "boolean" || r.type === "null") && (c = r.offset + r.length, f = r, r = r.parent), !r) {
        this.addSchemaValueCompletions(e.schema, "", s, a);
        return;
      }
      if (r.type === "property" && i > r.colonOffset) {
        var d = r.valueNode;
        if (d && i > d.offset + d.length)
          return;
        u = r.keyNode.value, r = r.parent;
      }
      if (r && (u !== null || r.type === "array")) {
        var h = this.evaluateSeparatorAfter(o, c), p = n.getMatchingSchemas(e.schema, r.offset, f);
        p.forEach(function(O) {
          if (O.node === r && !O.inverted && O.schema) {
            if (r.type === "array" && O.schema.items)
              if (Array.isArray(O.schema.items)) {
                var m = l.findItemAtOffset(r, o, i);
                m < O.schema.items.length && l.addSchemaValueCompletions(O.schema.items[m], h, s, a);
              } else
                l.addSchemaValueCompletions(O.schema.items, h, s, a);
            if (O.schema.properties) {
              var x = O.schema.properties[u];
              x && l.addSchemaValueCompletions(x, h, s, a);
            }
          }
        }), u === "$schema" && !r.parent && this.addDollarSchemaCompletions(h, s), a.boolean && (this.addBooleanValueCompletion(true, h, s), this.addBooleanValueCompletion(false, h, s)), a.null && this.addNullValueCompletion(h, s);
      }
    }, t4.prototype.getContributedValueCompletions = function(e, n, r, i, o, s) {
      if (!n)
        this.contributions.forEach(function(u) {
          var f = u.collectDefaultCompletions(i.uri, o);
          f && s.push(f);
        });
      else if ((n.type === "string" || n.type === "number" || n.type === "boolean" || n.type === "null") && (n = n.parent), n.type === "property" && r > n.colonOffset) {
        var a = n.keyNode.value, l = n.valueNode;
        if (!l || r <= l.offset + l.length) {
          var c = fO(n.parent);
          this.contributions.forEach(function(u) {
            var f = u.collectValueCompletions(i.uri, c, a, o);
            f && s.push(f);
          });
        }
      }
    }, t4.prototype.addSchemaValueCompletions = function(e, n, r, i) {
      var o = this;
      typeof e == "object" && (this.addEnumValueCompletions(e, n, r), this.addDefaultValueCompletions(e, n, r), this.collectTypes(e, i), Array.isArray(e.allOf) && e.allOf.forEach(function(s) {
        return o.addSchemaValueCompletions(s, n, r, i);
      }), Array.isArray(e.anyOf) && e.anyOf.forEach(function(s) {
        return o.addSchemaValueCompletions(s, n, r, i);
      }), Array.isArray(e.oneOf) && e.oneOf.forEach(function(s) {
        return o.addSchemaValueCompletions(s, n, r, i);
      }));
    }, t4.prototype.addDefaultValueCompletions = function(e, n, r, i) {
      var o = this;
      i === void 0 && (i = 0);
      var s = false;
      if (Wi(e.default)) {
        for (var a = e.type, l = e.default, c = i; c > 0; c--)
          l = [l], a = "array";
        r.add({
          kind: this.getSuggestionKind(a),
          label: this.getLabelForValue(l),
          insertText: this.getInsertTextForValue(l, n),
          insertTextFormat: an.Snippet
        }), s = true;
      }
      Array.isArray(e.examples) && e.examples.forEach(function(u) {
        for (var f = e.type, d = u, h = i; h > 0; h--)
          d = [d], f = "array";
        r.add({
          kind: o.getSuggestionKind(f),
          label: o.getLabelForValue(d),
          insertText: o.getInsertTextForValue(d, n),
          insertTextFormat: an.Snippet
        }), s = true;
      }), Array.isArray(e.defaultSnippets) && e.defaultSnippets.forEach(function(u) {
        var f = e.type, d = u.body, h = u.label, p, O;
        if (Wi(d)) {
          e.type;
          for (var m = i; m > 0; m--)
            d = [d];
          p = o.getInsertTextForSnippetValue(d, n), O = o.getFilterTextForSnippetValue(d), h = h || o.getLabelForSnippetValue(d);
        } else if (typeof u.bodyText == "string") {
          for (var x = "", v = "", y = "", m = i; m > 0; m--)
            x = x + y + `[
`, v = v + `
` + y + "]", y += "	", f = "array";
          p = x + y + u.bodyText.split(`
`).join(`
` + y) + v + n, h = h || o.sanitizeLabel(p), O = p.replace(/[\n]/g, "");
        }
        r.add({
          kind: o.getSuggestionKind(f),
          label: h,
          documentation: o.fromMarkup(u.markdownDescription) || u.description,
          insertText: p,
          insertTextFormat: an.Snippet,
          filterText: O
        }), s = true;
      }), !s && typeof e.items == "object" && !Array.isArray(e.items) && this.addDefaultValueCompletions(e.items, n, r, i + 1);
    }, t4.prototype.addEnumValueCompletions = function(e, n, r) {
      if (Wi(e.const) && r.add({
        kind: this.getSuggestionKind(e.type),
        label: this.getLabelForValue(e.const),
        insertText: this.getInsertTextForValue(e.const, n),
        insertTextFormat: an.Snippet,
        documentation: this.fromMarkup(e.markdownDescription) || e.description
      }), Array.isArray(e.enum))
        for (var i = 0, o = e.enum.length; i < o; i++) {
          var s = e.enum[i], a = this.fromMarkup(e.markdownDescription) || e.description;
          e.markdownEnumDescriptions && i < e.markdownEnumDescriptions.length && this.doesSupportMarkdown() ? a = this.fromMarkup(e.markdownEnumDescriptions[i]) : e.enumDescriptions && i < e.enumDescriptions.length && (a = e.enumDescriptions[i]), r.add({
            kind: this.getSuggestionKind(e.type),
            label: this.getLabelForValue(s),
            insertText: this.getInsertTextForValue(s, n),
            insertTextFormat: an.Snippet,
            documentation: a
          });
        }
    }, t4.prototype.collectTypes = function(e, n) {
      if (!(Array.isArray(e.enum) || Wi(e.const))) {
        var r = e.type;
        Array.isArray(r) ? r.forEach(function(i) {
          return n[i] = true;
        }) : n[r] = true;
      }
    }, t4.prototype.addFillerValueCompletions = function(e, n, r) {
      e.object && r.add({
        kind: this.getSuggestionKind("object"),
        label: "{}",
        insertText: this.getInsertTextForGuessedValue({}, n),
        insertTextFormat: an.Snippet,
        detail: "New object",
        documentation: ""
      }), e.array && r.add({
        kind: this.getSuggestionKind("array"),
        label: "[]",
        insertText: this.getInsertTextForGuessedValue([], n),
        insertTextFormat: an.Snippet,
        detail: "New array",
        documentation: ""
      });
    }, t4.prototype.addBooleanValueCompletion = function(e, n, r) {
      r.add({
        kind: this.getSuggestionKind("boolean"),
        label: e ? "true" : "false",
        insertText: this.getInsertTextForValue(e, n),
        insertTextFormat: an.Snippet,
        documentation: ""
      });
    }, t4.prototype.addNullValueCompletion = function(e, n) {
      n.add({
        kind: this.getSuggestionKind("null"),
        label: "null",
        insertText: "null" + e,
        insertTextFormat: an.Snippet,
        documentation: ""
      });
    }, t4.prototype.addDollarSchemaCompletions = function(e, n) {
      var r = this, i = this.schemaService.getRegisteredSchemaIds(function(o) {
        return o === "http" || o === "https";
      });
      i.forEach(function(o) {
        return n.add({
          kind: mr.Module,
          label: r.getLabelForValue(o),
          filterText: r.getFilterTextForValue(o),
          insertText: r.getInsertTextForValue(o, e),
          insertTextFormat: an.Snippet,
          documentation: ""
        });
      });
    }, t4.prototype.sanitizeLabel = function(e) {
      return e = e.replace(/[\n]/g, "\u21B5"), e.length > 57 && (e = e.substr(0, 57).trim() + "..."), e;
    }, t4.prototype.getLabelForValue = function(e) {
      return this.sanitizeLabel(JSON.stringify(e));
    }, t4.prototype.getFilterTextForValue = function(e) {
      return JSON.stringify(e);
    }, t4.prototype.getFilterTextForSnippetValue = function(e) {
      return JSON.stringify(e).replace(/\$\{\d+:([^}]+)\}|\$\d+/g, "$1");
    }, t4.prototype.getLabelForSnippetValue = function(e) {
      var n = JSON.stringify(e);
      return n = n.replace(/\$\{\d+:([^}]+)\}|\$\d+/g, "$1"), this.sanitizeLabel(n);
    }, t4.prototype.getInsertTextForPlainText = function(e) {
      return e.replace(/[\\\$\}]/g, "\\$&");
    }, t4.prototype.getInsertTextForValue = function(e, n) {
      var r = JSON.stringify(e, null, "	");
      return r === "{}" ? "{$1}" + n : r === "[]" ? "[$1]" + n : this.getInsertTextForPlainText(r + n);
    }, t4.prototype.getInsertTextForSnippetValue = function(e, n) {
      var r = function(i) {
        return typeof i == "string" && i[0] === "^" ? i.substr(1) : JSON.stringify(i);
      };
      return dO(e, "", r) + n;
    }, t4.prototype.getInsertTextForGuessedValue = function(e, n) {
      switch (typeof e) {
        case "object":
          return e === null ? "${1:null}" + n : this.getInsertTextForValue(e, n);
        case "string":
          var r = JSON.stringify(e);
          return r = r.substr(1, r.length - 2), r = this.getInsertTextForPlainText(r), '"${1:' + r + '}"' + n;
        case "number":
        case "boolean":
          return "${1:" + JSON.stringify(e) + "}" + n;
      }
      return this.getInsertTextForValue(e, n);
    }, t4.prototype.getSuggestionKind = function(e) {
      if (Array.isArray(e)) {
        var n = e;
        e = n.length > 0 ? n[0] : null;
      }
      if (!e)
        return mr.Value;
      switch (e) {
        case "string":
          return mr.Value;
        case "object":
          return mr.Module;
        case "property":
          return mr.Property;
        default:
          return mr.Value;
      }
    }, t4.prototype.getLabelTextForMatchingNode = function(e, n) {
      switch (e.type) {
        case "array":
          return "[]";
        case "object":
          return "{}";
        default:
          var r = n.getText().substr(e.offset, e.length);
          return r;
      }
    }, t4.prototype.getInsertTextForMatchingNode = function(e, n, r) {
      switch (e.type) {
        case "array":
          return this.getInsertTextForValue([], r);
        case "object":
          return this.getInsertTextForValue({}, r);
        default:
          var i = n.getText().substr(e.offset, e.length) + r;
          return this.getInsertTextForPlainText(i);
      }
    }, t4.prototype.getInsertTextForProperty = function(e, n, r, i) {
      var o = this.getInsertTextForValue(e, "");
      if (!r)
        return o;
      var s = o + ": ", a, l = 0;
      if (n) {
        if (Array.isArray(n.defaultSnippets)) {
          if (n.defaultSnippets.length === 1) {
            var c = n.defaultSnippets[0].body;
            Wi(c) && (a = this.getInsertTextForSnippetValue(c, ""));
          }
          l += n.defaultSnippets.length;
        }
        if (n.enum && (!a && n.enum.length === 1 && (a = this.getInsertTextForGuessedValue(n.enum[0], "")), l += n.enum.length), Wi(n.default) && (a || (a = this.getInsertTextForGuessedValue(n.default, "")), l++), l === 0) {
          var u = Array.isArray(n.type) ? n.type[0] : n.type;
          switch (u || (n.properties ? u = "object" : n.items && (u = "array")), u) {
            case "boolean":
              a = "$1";
              break;
            case "string":
              a = '"$1"';
              break;
            case "object":
              a = "{$1}";
              break;
            case "array":
              a = "[$1]";
              break;
            case "number":
            case "integer":
              a = "${1:0}";
              break;
            case "null":
              a = "${1:null}";
              break;
            default:
              return o;
          }
        }
      }
      return (!a || l > 1) && (a = "$1"), s + a + i;
    }, t4.prototype.getCurrentWord = function(e, n) {
      for (var r = n - 1, i = e.getText(); r >= 0 && ` 	
\r\v":{[,]}`.indexOf(i.charAt(r)) === -1; )
        r--;
      return i.substring(r + 1, n);
    }, t4.prototype.evaluateSeparatorAfter = function(e, n) {
      var r = pa(e.getText(), true);
      r.setPosition(n);
      var i = r.scan();
      switch (i) {
        case 5:
        case 2:
        case 4:
        case 17:
          return "";
        default:
          return ",";
      }
    }, t4.prototype.findItemAtOffset = function(e, n, r) {
      for (var i = pa(n.getText(), true), o = e.items, s = o.length - 1; s >= 0; s--) {
        var a = o[s];
        if (r > a.offset + a.length) {
          i.setPosition(a.offset + a.length);
          var l = i.scan();
          return l === 5 && r >= i.getTokenOffset() + i.getTokenLength() ? s + 1 : s;
        } else if (r >= a.offset)
          return s;
      }
      return 0;
    }, t4.prototype.isInComment = function(e, n, r) {
      var i = pa(e.getText(), false);
      i.setPosition(n);
      for (var o = i.scan(); o !== 17 && i.getTokenOffset() + i.getTokenLength() < r; )
        o = i.scan();
      return (o === 12 || o === 13) && i.getTokenOffset() <= r;
    }, t4.prototype.fromMarkup = function(e) {
      if (e && this.doesSupportMarkdown())
        return {
          kind: ms.Markdown,
          value: e
        };
    }, t4.prototype.doesSupportMarkdown = function() {
      if (!Wi(this.supportsMarkdown)) {
        var e = this.clientCapabilities.textDocument && this.clientCapabilities.textDocument.completion;
        this.supportsMarkdown = e && e.completionItem && Array.isArray(e.completionItem.documentationFormat) && e.completionItem.documentationFormat.indexOf(ms.Markdown) !== -1;
      }
      return this.supportsMarkdown;
    }, t4.prototype.doesSupportsCommitCharacters = function() {
      if (!Wi(this.supportsCommitCharacters)) {
        var e = this.clientCapabilities.textDocument && this.clientCapabilities.textDocument.completion;
        this.supportsCommitCharacters = e && e.completionItem && !!e.completionItem.commitCharactersSupport;
      }
      return this.supportsCommitCharacters;
    }, t4;
  }()
);
var PY = (
  /** @class */
  function() {
    function t4(e, n, r) {
      n === void 0 && (n = []), this.schemaService = e, this.contributions = n, this.promise = r || Promise;
    }
    return t4.prototype.doHover = function(e, n, r) {
      var i = e.offsetAt(n), o = r.getNodeFromOffset(i);
      if (!o || (o.type === "object" || o.type === "array") && i > o.offset + 1 && i < o.offset + o.length - 1)
        return this.promise.resolve(null);
      var s = o;
      if (o.type === "string") {
        var a = o.parent;
        if (a && a.type === "property" && a.keyNode === o && (o = a.valueNode, !o))
          return this.promise.resolve(null);
      }
      for (var l = at.create(e.positionAt(s.offset), e.positionAt(s.offset + s.length)), c = function(p) {
        var O = {
          contents: p,
          range: l
        };
        return O;
      }, u = fO(o), f = this.contributions.length - 1; f >= 0; f--) {
        var d = this.contributions[f], h = d.getInfoContribution(e.uri, u);
        if (h)
          return h.then(function(p) {
            return c(p);
          });
      }
      return this.schemaService.getSchemaForResource(e.uri, r).then(function(p) {
        if (p) {
          var O = r.getMatchingSchemas(p.schema, o.offset), m = null, x = null, v = null, y = null;
          O.every(function(b) {
            if (b.node === o && !b.inverted && b.schema && (m = m || b.schema.title, x = x || b.schema.markdownDescription || u0(b.schema.description), b.schema.enum)) {
              var w = b.schema.enum.indexOf(Ao(o));
              b.schema.markdownEnumDescriptions ? v = b.schema.markdownEnumDescriptions[w] : b.schema.enumDescriptions && (v = u0(b.schema.enumDescriptions[w])), v && (y = b.schema.enum[w], typeof y != "string" && (y = JSON.stringify(y)));
            }
            return true;
          });
          var S = "";
          return m && (S = u0(m)), x && (S.length > 0 && (S += `

`), S += x), v && (S.length > 0 && (S += `

`), S += "`" + EY(y) + "`: " + v), c([S]);
        }
        return null;
      });
    }, t4;
  }()
);
function u0(t4) {
  if (t4) {
    var e = t4.replace(/([^\n\r])(\r?\n)([^\n\r])/gm, `$1

$3`);
    return e.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&");
  }
}
function EY(t4) {
  return t4.indexOf("`") !== -1 ? "`` " + t4 + " ``" : t4;
}
var TY = /* @__PURE__ */ function() {
  var t4 = function(e, n) {
    return t4 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, i) {
      r.__proto__ = i;
    } || function(r, i) {
      for (var o in i)
        i.hasOwnProperty(o) && (r[o] = i[o]);
    }, t4(e, n);
  };
  return function(e, n) {
    t4(e, n);
    function r() {
      this.constructor = e;
    }
    e.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}();
var Yt;
var xc;
if (typeof process == "object")
  xc = process.platform === "win32";
else if (typeof navigator == "object") {
  IY = navigator.userAgent;
  xc = IY.indexOf("Windows") >= 0;
}
var IY;
var $Y = /^\w[\w\d+.-]*$/;
var jY = /^\//;
var RY = /^\/\//;
function DY(t4, e) {
  if (!t4.scheme && e)
    throw new Error('[UriError]: Scheme is missing: {scheme: "", authority: "' + t4.authority + '", path: "' + t4.path + '", query: "' + t4.query + '", fragment: "' + t4.fragment + '"}');
  if (t4.scheme && !$Y.test(t4.scheme))
    throw new Error("[UriError]: Scheme contains illegal characters.");
  if (t4.path) {
    if (t4.authority) {
      if (!jY.test(t4.path))
        throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
    } else if (RY.test(t4.path))
      throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
  }
}
function QY(t4, e) {
  return !t4 && !e ? "file" : t4;
}
function BY(t4, e) {
  switch (t4) {
    case "https":
    case "http":
    case "file":
      e ? e[0] !== Yr && (e = Yr + e) : e = Yr;
      break;
  }
  return e;
}
var Et = "";
var Yr = "/";
var _Y = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
var pO = (
  /** @class */
  function() {
    function t4(e, n, r, i, o, s) {
      s === void 0 && (s = false), typeof e == "object" ? (this.scheme = e.scheme || Et, this.authority = e.authority || Et, this.path = e.path || Et, this.query = e.query || Et, this.fragment = e.fragment || Et) : (this.scheme = QY(e, s), this.authority = n || Et, this.path = BY(this.scheme, r || Et), this.query = i || Et, this.fragment = o || Et, DY(this, s));
    }
    return t4.isUri = function(e) {
      return e instanceof t4 ? true : e ? typeof e.authority == "string" && typeof e.fragment == "string" && typeof e.path == "string" && typeof e.query == "string" && typeof e.scheme == "string" && typeof e.fsPath == "function" && typeof e.with == "function" && typeof e.toString == "function" : false;
    }, Object.defineProperty(t4.prototype, "fsPath", {
      // ---- filesystem path -----------------------
      /**
       * Returns a string representing the corresponding file system path of this URI.
       * Will handle UNC paths, normalizes windows drive letters to lower-case, and uses the
       * platform specific path separator.
       *
       * * Will *not* validate the path for invalid characters and semantics.
       * * Will *not* look at the scheme of this URI.
       * * The result shall *not* be used for display purposes but for accessing a file on disk.
       *
       *
       * The *difference* to `URI#path` is the use of the platform specific separator and the handling
       * of UNC paths. See the below sample of a file-uri with an authority (UNC path).
       *
       * ```ts
          const u = URI.parse('file://server/c$/folder/file.txt')
          u.authority === 'server'
          u.path === '/shares/c$/file.txt'
          u.fsPath === '\\server\c$\folder\file.txt'
      ```
       *
       * Using `URI#path` to read a file (using fs-apis) would not be enough because parts of the path,
       * namely the server name, would be missing. Therefore `URI#fsPath` exists - it's sugar to ease working
       * with URIs that represent files on disk (`file` scheme).
       */
      get: function() {
        return C$(this);
      },
      enumerable: true,
      configurable: true
    }), t4.prototype.with = function(e) {
      if (!e)
        return this;
      var n = e.scheme, r = e.authority, i = e.path, o = e.query, s = e.fragment;
      return n === void 0 ? n = this.scheme : n === null && (n = Et), r === void 0 ? r = this.authority : r === null && (r = Et), i === void 0 ? i = this.path : i === null && (i = Et), o === void 0 ? o = this.query : o === null && (o = Et), s === void 0 ? s = this.fragment : s === null && (s = Et), n === this.scheme && r === this.authority && i === this.path && o === this.query && s === this.fragment ? this : new Ns(n, r, i, o, s);
    }, t4.parse = function(e, n) {
      n === void 0 && (n = false);
      var r = _Y.exec(e);
      return r ? new Ns(r[2] || Et, zu(r[4] || Et), zu(r[5] || Et), zu(r[7] || Et), zu(r[9] || Et), n) : new Ns(Et, Et, Et, Et, Et);
    }, t4.file = function(e) {
      var n = Et;
      if (xc && (e = e.replace(/\\/g, Yr)), e[0] === Yr && e[1] === Yr) {
        var r = e.indexOf(Yr, 2);
        r === -1 ? (n = e.substring(2), e = Yr) : (n = e.substring(2, r), e = e.substring(r) || Yr);
      }
      return new Ns("file", n, e, Et, Et);
    }, t4.from = function(e) {
      return new Ns(e.scheme, e.authority, e.path, e.query, e.fragment);
    }, t4.prototype.toString = function(e) {
      return e === void 0 && (e = false), gO(this, e);
    }, t4.prototype.toJSON = function() {
      return this;
    }, t4.revive = function(e) {
      if (e) {
        if (e instanceof t4)
          return e;
        var n = new Ns(e);
        return n._formatted = e.external, n._fsPath = e._sep === S$ ? e.fsPath : null, n;
      } else
        return e;
    }, t4;
  }()
);
var S$ = xc ? 1 : void 0;
var Ns = (
  /** @class */
  function(t4) {
    TY(e, t4);
    function e() {
      var n = t4 !== null && t4.apply(this, arguments) || this;
      return n._formatted = null, n._fsPath = null, n;
    }
    return Object.defineProperty(e.prototype, "fsPath", {
      get: function() {
        return this._fsPath || (this._fsPath = C$(this)), this._fsPath;
      },
      enumerable: true,
      configurable: true
    }), e.prototype.toString = function(n) {
      return n === void 0 && (n = false), n ? gO(this, true) : (this._formatted || (this._formatted = gO(this, false)), this._formatted);
    }, e.prototype.toJSON = function() {
      var n = {
        $mid: 1
      };
      return this._fsPath && (n.fsPath = this._fsPath, n._sep = S$), this._formatted && (n.external = this._formatted), this.path && (n.path = this.path), this.scheme && (n.scheme = this.scheme), this.authority && (n.authority = this.authority), this.query && (n.query = this.query), this.fragment && (n.fragment = this.fragment), n;
    }, e;
  }(pO)
);
var w$ = (Yt = {}, Yt[
  58
  /* Colon */
] = "%3A", Yt[
  47
  /* Slash */
] = "%2F", Yt[
  63
  /* QuestionMark */
] = "%3F", Yt[
  35
  /* Hash */
] = "%23", Yt[
  91
  /* OpenSquareBracket */
] = "%5B", Yt[
  93
  /* CloseSquareBracket */
] = "%5D", Yt[
  64
  /* AtSign */
] = "%40", Yt[
  33
  /* ExclamationMark */
] = "%21", Yt[
  36
  /* DollarSign */
] = "%24", Yt[
  38
  /* Ampersand */
] = "%26", Yt[
  39
  /* SingleQuote */
] = "%27", Yt[
  40
  /* OpenParen */
] = "%28", Yt[
  41
  /* CloseParen */
] = "%29", Yt[
  42
  /* Asterisk */
] = "%2A", Yt[
  43
  /* Plus */
] = "%2B", Yt[
  44
  /* Comma */
] = "%2C", Yt[
  59
  /* Semicolon */
] = "%3B", Yt[
  61
  /* Equals */
] = "%3D", Yt[
  32
  /* Space */
] = "%20", Yt);
function iC(t4, e) {
  for (var n = void 0, r = -1, i = 0; i < t4.length; i++) {
    var o = t4.charCodeAt(i);
    if (o >= 97 && o <= 122 || o >= 65 && o <= 90 || o >= 48 && o <= 57 || o === 45 || o === 46 || o === 95 || o === 126 || e && o === 47)
      r !== -1 && (n += encodeURIComponent(t4.substring(r, i)), r = -1), n !== void 0 && (n += t4.charAt(i));
    else {
      n === void 0 && (n = t4.substr(0, i));
      var s = w$[o];
      s !== void 0 ? (r !== -1 && (n += encodeURIComponent(t4.substring(r, i)), r = -1), n += s) : r === -1 && (r = i);
    }
  }
  return r !== -1 && (n += encodeURIComponent(t4.substring(r))), n !== void 0 ? n : t4;
}
function MY(t4) {
  for (var e = void 0, n = 0; n < t4.length; n++) {
    var r = t4.charCodeAt(n);
    r === 35 || r === 63 ? (e === void 0 && (e = t4.substr(0, n)), e += w$[r]) : e !== void 0 && (e += t4[n]);
  }
  return e !== void 0 ? e : t4;
}
function C$(t4, e) {
  var n;
  return t4.authority && t4.path.length > 1 && t4.scheme === "file" ? n = "//" + t4.authority + t4.path : t4.path.charCodeAt(0) === 47 && (t4.path.charCodeAt(1) >= 65 && t4.path.charCodeAt(1) <= 90 || t4.path.charCodeAt(1) >= 97 && t4.path.charCodeAt(1) <= 122) && t4.path.charCodeAt(2) === 58 ? n = t4.path[1].toLowerCase() + t4.path.substr(2) : n = t4.path, xc && (n = n.replace(/\//g, "\\")), n;
}
function gO(t4, e) {
  var n = e ? MY : iC, r = "", i = t4.scheme, o = t4.authority, s = t4.path, a = t4.query, l = t4.fragment;
  if (i && (r += i, r += ":"), (o || i === "file") && (r += Yr, r += Yr), o) {
    var c = o.indexOf("@");
    if (c !== -1) {
      var u = o.substr(0, c);
      o = o.substr(c + 1), c = u.indexOf(":"), c === -1 ? r += n(u, false) : (r += n(u.substr(0, c), false), r += ":", r += n(u.substr(c + 1), false)), r += "@";
    }
    o = o.toLowerCase(), c = o.indexOf(":"), c === -1 ? r += n(o, false) : (r += n(o.substr(0, c), false), r += o.substr(c));
  }
  if (s) {
    if (s.length >= 3 && s.charCodeAt(0) === 47 && s.charCodeAt(2) === 58) {
      var f = s.charCodeAt(1);
      f >= 65 && f <= 90 && (s = "/" + String.fromCharCode(f + 32) + ":" + s.substr(3));
    } else if (s.length >= 2 && s.charCodeAt(1) === 58) {
      var f = s.charCodeAt(0);
      f >= 65 && f <= 90 && (s = String.fromCharCode(f + 32) + ":" + s.substr(2));
    }
    r += n(s, true);
  }
  return a && (r += "?", r += n(a, false)), l && (r += "#", r += e ? l : iC(l, false)), r;
}
function k$(t4) {
  try {
    return decodeURIComponent(t4);
  } catch {
    return t4.length > 3 ? t4.substr(0, 3) + k$(t4.substr(3)) : t4;
  }
}
var oC = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
function zu(t4) {
  return t4.match(oC) ? t4.replace(oC, function(e) {
    return k$(e);
  }) : t4;
}
var NY = (
  /** @class */
  function() {
    function t4(e) {
      try {
        this.patternRegExp = new RegExp(wY(e) + "$");
      } catch {
        this.patternRegExp = null;
      }
      this.schemas = [];
    }
    return t4.prototype.addSchema = function(e) {
      this.schemas.push(e);
    }, t4.prototype.matchesPattern = function(e) {
      return this.patternRegExp && this.patternRegExp.test(e);
    }, t4.prototype.getSchemas = function() {
      return this.schemas;
    }, t4;
  }()
);
var FY = (
  /** @class */
  function() {
    function t4(e, n, r) {
      this.service = e, this.url = n, this.dependencies = {}, r && (this.unresolvedSchema = this.service.promise.resolve(new Js(r)));
    }
    return t4.prototype.getUnresolvedSchema = function() {
      return this.unresolvedSchema || (this.unresolvedSchema = this.service.loadSchema(this.url)), this.unresolvedSchema;
    }, t4.prototype.getResolvedSchema = function() {
      var e = this;
      return this.resolvedSchema || (this.resolvedSchema = this.getUnresolvedSchema().then(function(n) {
        return e.service.resolveSchemaContent(n, e.url, e.dependencies);
      })), this.resolvedSchema;
    }, t4.prototype.clearSchema = function() {
      this.resolvedSchema = null, this.unresolvedSchema = null, this.dependencies = {};
    }, t4;
  }()
);
var Js = (
  /** @class */
  /* @__PURE__ */ function() {
    function t4(e, n) {
      n === void 0 && (n = []), this.schema = e, this.errors = n;
    }
    return t4;
  }()
);
var sC = (
  /** @class */
  function() {
    function t4(e, n) {
      n === void 0 && (n = []), this.schema = e, this.errors = n;
    }
    return t4.prototype.getSection = function(e) {
      return Kn(this.getSectionRecursive(e, this.schema));
    }, t4.prototype.getSectionRecursive = function(e, n) {
      if (!n || typeof n == "boolean" || e.length === 0)
        return n;
      var r = e.shift();
      if (n.properties && typeof n.properties[r])
        return this.getSectionRecursive(e, n.properties[r]);
      if (n.patternProperties)
        for (var i = 0, o = Object.keys(n.patternProperties); i < o.length; i++) {
          var s = o[i], a = new RegExp(s);
          if (a.test(r))
            return this.getSectionRecursive(e, n.patternProperties[s]);
        }
      else {
        if (typeof n.additionalProperties == "object")
          return this.getSectionRecursive(e, n.additionalProperties);
        if (r.match("[0-9]+")) {
          if (Array.isArray(n.items)) {
            var l = parseInt(r, 10);
            if (!isNaN(l) && n.items[l])
              return this.getSectionRecursive(e, n.items[l]);
          } else if (n.items)
            return this.getSectionRecursive(e, n.items);
        }
      }
      return null;
    }, t4;
  }()
);
var ZY = (
  /** @class */
  function() {
    function t4(e, n, r) {
      this.contextService = n, this.requestService = e, this.promiseConstructor = r || Promise, this.callOnDispose = [], this.contributionSchemas = {}, this.contributionAssociations = {}, this.schemasById = {}, this.filePatternAssociations = [], this.filePatternAssociationById = {}, this.registeredSchemasIds = {};
    }
    return t4.prototype.getRegisteredSchemaIds = function(e) {
      return Object.keys(this.registeredSchemasIds).filter(function(n) {
        var r = pO.parse(n).scheme;
        return r !== "schemaservice" && (!e || e(r));
      });
    }, Object.defineProperty(t4.prototype, "promise", {
      get: function() {
        return this.promiseConstructor;
      },
      enumerable: true,
      configurable: true
    }), t4.prototype.dispose = function() {
      for (; this.callOnDispose.length > 0; )
        this.callOnDispose.pop()();
    }, t4.prototype.onResourceChange = function(e) {
      var n = this, r = false;
      e = this.normalizeId(e);
      for (var i = [e], o = Object.keys(this.schemasById).map(function(c) {
        return n.schemasById[c];
      }); i.length; )
        for (var s = i.pop(), a = 0; a < o.length; a++) {
          var l = o[a];
          l && (l.url === s || l.dependencies[s]) && (l.url !== s && i.push(l.url), l.clearSchema(), o[a] = void 0, r = true);
        }
      return r;
    }, t4.prototype.normalizeId = function(e) {
      try {
        return pO.parse(e).toString();
      } catch {
        return e;
      }
    }, t4.prototype.setSchemaContributions = function(e) {
      if (e.schemas) {
        var n = e.schemas;
        for (var r in n) {
          var i = this.normalizeId(r);
          this.contributionSchemas[i] = this.addSchemaHandle(i, n[r]);
        }
      }
      if (e.schemaAssociations) {
        var o = e.schemaAssociations;
        for (var s in o) {
          var a = o[s];
          this.contributionAssociations[s] = a;
          for (var l = this.getOrAddFilePatternAssociation(s), c = 0, u = a; c < u.length; c++) {
            var f = u[c], r = this.normalizeId(f);
            l.addSchema(r);
          }
        }
      }
    }, t4.prototype.addSchemaHandle = function(e, n) {
      var r = new FY(this, e, n);
      return this.schemasById[e] = r, r;
    }, t4.prototype.getOrAddSchemaHandle = function(e, n) {
      return this.schemasById[e] || this.addSchemaHandle(e, n);
    }, t4.prototype.getOrAddFilePatternAssociation = function(e) {
      var n = this.filePatternAssociationById[e];
      return n || (n = new NY(e), this.filePatternAssociationById[e] = n, this.filePatternAssociations.push(n)), n;
    }, t4.prototype.registerExternalSchema = function(e, n, r) {
      n === void 0 && (n = null);
      var i = this.normalizeId(e);
      if (this.registeredSchemasIds[i] = true, n)
        for (var o = 0, s = n; o < s.length; o++) {
          var a = s[o];
          this.getOrAddFilePatternAssociation(a).addSchema(i);
        }
      return r ? this.addSchemaHandle(i, r) : this.getOrAddSchemaHandle(i);
    }, t4.prototype.clearExternalSchemas = function() {
      this.schemasById = {}, this.filePatternAssociations = [], this.filePatternAssociationById = {}, this.registeredSchemasIds = {};
      for (var e in this.contributionSchemas)
        this.schemasById[e] = this.contributionSchemas[e], this.registeredSchemasIds[e] = true;
      for (var n in this.contributionAssociations)
        for (var r = this.getOrAddFilePatternAssociation(n), i = 0, o = this.contributionAssociations[n]; i < o.length; i++) {
          var s = o[i], e = this.normalizeId(s);
          r.addSchema(e);
        }
    }, t4.prototype.getResolvedSchema = function(e) {
      var n = this.normalizeId(e), r = this.schemasById[n];
      return r ? r.getResolvedSchema() : this.promise.resolve(null);
    }, t4.prototype.loadSchema = function(e) {
      if (!this.requestService) {
        var n = "Unable to load schema from '" + e + "'. No schema request service available";
        return this.promise.resolve(new Js({}, [n]));
      }
      return this.requestService(e).then(function(r) {
        if (!r) {
          var i = "Unable to load schema from '" + e + "': No content.";
          return new Js({}, [i]);
        }
        var o = {}, s = [];
        o = oY(r, s);
        var a = s.length ? ["Unable to parse content from '" + e + "': Parse error at offset " + s[0].offset] : [];
        return new Js(o, a);
      }, function(r) {
        var i = "Unable to load schema from '" + e + "': " + r.toString();
        return new Js({}, [i]);
      });
    }, t4.prototype.resolveSchemaContent = function(e, n, r) {
      var i = this, o = e.errors.slice(0), s = e.schema;
      if (s.$schema) {
        var a = this.normalizeId(s.$schema);
        if (a === "http://json-schema.org/draft-03/schema")
          return this.promise.resolve(new sC({}, ["Draft-03 schemas are not supported."]));
        a === "https://json-schema.org/draft/2019-09/schema" && e.errors.push("Draft 2019-09 schemas are not yet fully supported.");
      }
      var l = this.contextService, c = function(h, p) {
        if (!p)
          return h;
        var O = h;
        return p[0] === "/" && (p = p.substr(1)), p.split("/").some(function(m) {
          return O = O[m], !O;
        }), O;
      }, u = function(h, p, O, m) {
        var x = c(p, m);
        if (x)
          for (var v in x)
            x.hasOwnProperty(v) && !h.hasOwnProperty(v) && (h[v] = x[v]);
        else
          o.push("$ref '" + m + "' in '" + O + "' can not be resolved.");
      }, f = function(h, p, O, m, x) {
        l && !/^\w+:\/\/.*/.test(p) && (p = l.resolveRelativePath(p, m)), p = i.normalizeId(p);
        var v = i.getOrAddSchemaHandle(p);
        return v.getUnresolvedSchema().then(function(y) {
          if (x[p] = true, y.errors.length) {
            var S = O ? p + "#" + O : p;
            o.push("Problems loading reference '" + S + "': " + y.errors[0] + ".");
          }
          return u(h, y.schema, p, O), d(h, y.schema, p, v.dependencies);
        });
      }, d = function(h, p, O, m) {
        if (!h || typeof h != "object")
          return Promise.resolve(null);
        for (var x = [h], v = [], y = [], S = function() {
          for (var T = [], A = 0; A < arguments.length; A++)
            T[A] = arguments[A];
          for (var E = 0, $ = T; E < $.length; E++) {
            var j = $[E];
            typeof j == "object" && x.push(j);
          }
        }, b = function() {
          for (var T = [], A = 0; A < arguments.length; A++)
            T[A] = arguments[A];
          for (var E = 0, $ = T; E < $.length; E++) {
            var j = $[E];
            if (typeof j == "object")
              for (var B in j) {
                var D = j[B];
                typeof D == "object" && x.push(D);
              }
          }
        }, w = function() {
          for (var T = [], A = 0; A < arguments.length; A++)
            T[A] = arguments[A];
          for (var E = 0, $ = T; E < $.length; E++) {
            var j = $[E];
            if (Array.isArray(j))
              for (var B = 0, D = j; B < D.length; B++) {
                var N = D[B];
                typeof N == "object" && x.push(N);
              }
          }
        }, C = function(T) {
          for (var A = []; T.$ref; ) {
            var E = T.$ref, $ = E.split("#", 2);
            if (delete T.$ref, $[0].length > 0) {
              y.push(f(T, $[0], $[1], O, m));
              return;
            } else
              A.indexOf(E) === -1 && (u(T, p, O, $[1]), A.push(E));
          }
          S(T.items, T.additionalProperties, T.not, T.contains, T.propertyNames, T.if, T.then, T.else), b(T.definitions, T.properties, T.patternProperties, T.dependencies), w(T.anyOf, T.allOf, T.oneOf, T.items);
        }; x.length; ) {
          var k = x.pop();
          v.indexOf(k) >= 0 || (v.push(k), C(k));
        }
        return i.promise.all(y);
      };
      return d(s, s, n, r).then(function(h) {
        return new sC(s, o);
      });
    }, t4.prototype.getSchemaForResource = function(e, n) {
      if (n && n.root && n.root.type === "object") {
        var r = n.root.properties.filter(function(p) {
          return p.keyNode.value === "$schema" && p.valueNode && p.valueNode.type === "string";
        });
        if (r.length > 0) {
          var i = Ao(r[0].valueNode);
          if (i && SY(i, ".") && this.contextService && (i = this.contextService.resolveRelativePath(i, e)), i) {
            var o = this.normalizeId(i);
            return this.getOrAddSchemaHandle(o).getResolvedSchema();
          }
        }
      }
      for (var s = /* @__PURE__ */ Object.create(null), a = [], l = 0, c = this.filePatternAssociations; l < c.length; l++) {
        var u = c[l];
        if (u.matchesPattern(e))
          for (var f = 0, d = u.getSchemas(); f < d.length; f++) {
            var h = d[f];
            s[h] || (a.push(h), s[h] = true);
          }
      }
      return a.length > 0 ? this.createCombinedSchema(e, a).getResolvedSchema() : this.promise.resolve(null);
    }, t4.prototype.createCombinedSchema = function(e, n) {
      if (n.length === 1)
        return this.getOrAddSchemaHandle(n[0]);
      var r = "schemaservice://combinedSchema/" + encodeURIComponent(e), i = {
        allOf: n.map(function(o) {
          return { $ref: o };
        })
      };
      return this.addSchemaHandle(r, i);
    }, t4;
  }()
);
var WY = (
  /** @class */
  function() {
    function t4(e, n) {
      this.jsonSchemaService = e, this.promise = n, this.validationEnabled = true;
    }
    return t4.prototype.configure = function(e) {
      e && (this.validationEnabled = e.validate, this.commentSeverity = e.allowComments ? void 0 : ze.Error);
    }, t4.prototype.doValidation = function(e, n, r, i) {
      var o = this;
      if (!this.validationEnabled)
        return this.promise.resolve([]);
      var s = [], a = {}, l = function(f) {
        var d = f.range.start.line + " " + f.range.start.character + " " + f.message;
        a[d] || (a[d] = true, s.push(f));
      }, c = function(f) {
        var d = r ? aC(r.trailingCommas) : ze.Error, h = r ? aC(r.comments) : o.commentSeverity;
        if (f) {
          if (f.errors.length && n.root) {
            var p = n.root, O = p.type === "object" ? p.properties[0] : null;
            if (O && O.keyNode.value === "$schema") {
              var m = O.valueNode || O, x = at.create(e.positionAt(m.offset), e.positionAt(m.offset + m.length));
              l(Yi.create(x, f.errors[0], ze.Warning, nt.SchemaResolveError));
            } else {
              var x = at.create(e.positionAt(p.offset), e.positionAt(p.offset + 1));
              l(Yi.create(x, f.errors[0], ze.Warning, nt.SchemaResolveError));
            }
          } else {
            var v = n.validate(e, f.schema);
            v && v.forEach(l);
          }
          A$(f.schema) && (h = void 0), P$(f.schema) && (d = void 0);
        }
        for (var y = 0, S = n.syntaxErrors; y < S.length; y++) {
          var b = S[y];
          if (b.code === nt.TrailingComma) {
            if (typeof d != "number")
              continue;
            b.severity = d;
          }
          l(b);
        }
        if (typeof h == "number") {
          var w = "Comments are not permitted in JSON.";
          n.comments.forEach(function(C) {
            l(Yi.create(C, w, h, nt.CommentNotPermitted));
          });
        }
        return s;
      };
      if (i) {
        var u = i.id || "schemaservice://untitled/" + VY++;
        return this.jsonSchemaService.resolveSchemaContent(new Js(i), u, {}).then(function(f) {
          return c(f);
        });
      }
      return this.jsonSchemaService.getSchemaForResource(e.uri, n).then(function(f) {
        return c(f);
      });
    }, t4;
  }()
);
var VY = 0;
function A$(t4) {
  if (t4 && typeof t4 == "object") {
    if (yi(t4.allowComments))
      return t4.allowComments;
    if (t4.allOf)
      for (var e = 0, n = t4.allOf; e < n.length; e++) {
        var r = n[e], i = A$(r);
        if (yi(i))
          return i;
      }
  }
}
function P$(t4) {
  if (t4 && typeof t4 == "object") {
    if (yi(t4.allowTrailingCommas))
      return t4.allowTrailingCommas;
    if (yi(t4.allowsTrailingCommas))
      return t4.allowsTrailingCommas;
    if (t4.allOf)
      for (var e = 0, n = t4.allOf; e < n.length; e++) {
        var r = n[e], i = P$(r);
        if (yi(i))
          return i;
      }
  }
}
function aC(t4) {
  switch (t4) {
    case "error":
      return ze.Error;
    case "warning":
      return ze.Warning;
    case "ignore":
      return;
  }
}
var lC = 48;
var zY = 57;
var LY = 65;
var Lu = 97;
var XY = 102;
function qt(t4) {
  return t4 < lC ? 0 : t4 <= zY ? t4 - lC : (t4 < Lu && (t4 += Lu - LY), t4 >= Lu && t4 <= XY ? t4 - Lu + 10 : 0);
}
function GY(t4) {
  if (t4[0] !== "#")
    return null;
  switch (t4.length) {
    case 4:
      return {
        red: qt(t4.charCodeAt(1)) * 17 / 255,
        green: qt(t4.charCodeAt(2)) * 17 / 255,
        blue: qt(t4.charCodeAt(3)) * 17 / 255,
        alpha: 1
      };
    case 5:
      return {
        red: qt(t4.charCodeAt(1)) * 17 / 255,
        green: qt(t4.charCodeAt(2)) * 17 / 255,
        blue: qt(t4.charCodeAt(3)) * 17 / 255,
        alpha: qt(t4.charCodeAt(4)) * 17 / 255
      };
    case 7:
      return {
        red: (qt(t4.charCodeAt(1)) * 16 + qt(t4.charCodeAt(2))) / 255,
        green: (qt(t4.charCodeAt(3)) * 16 + qt(t4.charCodeAt(4))) / 255,
        blue: (qt(t4.charCodeAt(5)) * 16 + qt(t4.charCodeAt(6))) / 255,
        alpha: 1
      };
    case 9:
      return {
        red: (qt(t4.charCodeAt(1)) * 16 + qt(t4.charCodeAt(2))) / 255,
        green: (qt(t4.charCodeAt(3)) * 16 + qt(t4.charCodeAt(4))) / 255,
        blue: (qt(t4.charCodeAt(5)) * 16 + qt(t4.charCodeAt(6))) / 255,
        alpha: (qt(t4.charCodeAt(7)) * 16 + qt(t4.charCodeAt(8))) / 255
      };
  }
  return null;
}
var YY = (
  /** @class */
  function() {
    function t4(e) {
      this.schemaService = e;
    }
    return t4.prototype.findDocumentSymbols = function(e, n, r) {
      var i = this;
      r === void 0 && (r = { resultLimit: Number.MAX_VALUE });
      var o = n.root;
      if (!o)
        return null;
      var s = r.resultLimit, a = e.uri;
      if ((a === "vscode://defaultsettings/keybindings.json" || hO(a.toLowerCase(), "/user/keybindings.json")) && o.type === "array") {
        for (var l = [], c = 0, u = o.items; c < u.length; c++) {
          var f = u[c];
          if (f.type === "object")
            for (var d = 0, h = f.properties; d < h.length; d++) {
              var p = h[d];
              if (p.keyNode.value === "key" && p.valueNode) {
                var O = ja.create(e.uri, co(e, f));
                if (l.push({ name: Ao(p.valueNode), kind: di.Function, location: O }), s--, s <= 0)
                  return r && r.onResultLimitExceeded && r.onResultLimitExceeded(a), l;
              }
            }
        }
        return l;
      }
      var m = function(v, y, S) {
        return s >= 0 && (y.type === "array" ? y.items.forEach(function(b) {
          return m(v, b, S);
        }) : y.type === "object" && y.properties.forEach(function(b) {
          if (s >= 0) {
            var w = b.valueNode;
            if (w) {
              s--;
              var C = ja.create(e.uri, co(e, b)), k = S ? S + "." + b.keyNode.value : b.keyNode.value;
              v.push({ name: i.getKeyLabel(b), kind: i.getSymbolKind(w.type), location: C, containerName: S }), m(v, w, k);
            }
          }
        })), v;
      }, x = m([], o, void 0);
      return s < 0 && (x.pop(), r && r.onResultLimitExceeded && r.onResultLimitExceeded(a)), x;
    }, t4.prototype.findDocumentSymbols2 = function(e, n, r) {
      var i = this;
      r === void 0 && (r = { resultLimit: Number.MAX_VALUE });
      var o = n.root;
      if (!o)
        return null;
      var s = r.resultLimit, a = e.uri;
      if ((a === "vscode://defaultsettings/keybindings.json" || hO(a.toLowerCase(), "/user/keybindings.json")) && o.type === "array") {
        for (var l = [], c = 0, u = o.items; c < u.length; c++) {
          var f = u[c];
          if (f.type === "object")
            for (var d = 0, h = f.properties; d < h.length; d++) {
              var p = h[d];
              if (p.keyNode.value === "key" && p.valueNode) {
                var O = co(e, f), m = co(e, p.keyNode);
                if (l.push({ name: Ao(p.valueNode), kind: di.Function, range: O, selectionRange: m }), s--, s <= 0)
                  return r && r.onResultLimitExceeded && r.onResultLimitExceeded(a), l;
              }
            }
        }
        return l;
      }
      var x = function(y, S) {
        return s >= 0 && (S.type === "array" ? S.items.forEach(function(b, w) {
          if (b && s >= 0) {
            s--;
            var C = co(e, b), k = C, T = String(w), A = x([], b);
            y.push({ name: T, kind: i.getSymbolKind(b.type), range: C, selectionRange: k, children: A });
          }
        }) : S.type === "object" && S.properties.forEach(function(b) {
          var w = b.valueNode;
          if (w && s >= 0) {
            s--;
            var C = co(e, b), k = co(e, b.keyNode), T = x([], w);
            y.push({ name: i.getKeyLabel(b), kind: i.getSymbolKind(w.type), range: C, selectionRange: k, children: T });
          }
        })), y;
      }, v = x([], o);
      return s < 0 && (v.pop(), r && r.onResultLimitExceeded && r.onResultLimitExceeded(a)), v;
    }, t4.prototype.getSymbolKind = function(e) {
      switch (e) {
        case "object":
          return di.Module;
        case "string":
          return di.String;
        case "number":
          return di.Number;
        case "array":
          return di.Array;
        case "boolean":
          return di.Boolean;
        default:
          return di.Variable;
      }
    }, t4.prototype.getKeyLabel = function(e) {
      var n = e.keyNode.value;
      return n && (n = n.replace(/[\n]/g, "\u21B5")), n && n.trim() ? n : '"' + n + '"';
    }, t4.prototype.findDocumentColors = function(e, n, r) {
      return this.schemaService.getSchemaForResource(e.uri, n).then(function(i) {
        var o = [];
        if (i)
          for (var s = r && typeof r.resultLimit == "number" ? r.resultLimit : Number.MAX_VALUE, a = n.getMatchingSchemas(i.schema), l = {}, c = 0, u = a; c < u.length; c++) {
            var f = u[c];
            if (!f.inverted && f.schema && (f.schema.format === "color" || f.schema.format === "color-hex") && f.node && f.node.type === "string") {
              var d = String(f.node.offset);
              if (!l[d]) {
                var h = GY(Ao(f.node));
                if (h) {
                  var p = co(e, f.node);
                  o.push({ color: h, range: p });
                }
                if (l[d] = true, s--, s <= 0)
                  return r && r.onResultLimitExceeded && r.onResultLimitExceeded(e.uri), o;
              }
            }
          }
        return o;
      });
    }, t4.prototype.getColorPresentations = function(e, n, r, i) {
      var o = [], s = Math.round(r.red * 255), a = Math.round(r.green * 255), l = Math.round(r.blue * 255);
      function c(f) {
        var d = f.toString(16);
        return d.length !== 2 ? "0" + d : d;
      }
      var u;
      return r.alpha === 1 ? u = "#" + c(s) + c(a) + c(l) : u = "#" + c(s) + c(a) + c(l) + c(Math.round(r.alpha * 255)), o.push({ label: u, textEdit: Ki.replace(i, JSON.stringify(u)) }), o;
    }, t4;
  }()
);
function co(t4, e) {
  return at.create(t4.positionAt(e.offset), t4.positionAt(e.offset + e.length));
}
var qY = {
  schemaAssociations: {},
  schemas: {
    // bundle the schema-schema to include (localized) descriptions
    // 'http://json-schema.org/draft-04/schema#': {
    // 	'title': localize('schema.json', 'Describes a JSON file using a schema. See json-schema.org for more info.'),
    // 	'$schema': 'http://json-schema.org/draft-04/schema#',
    // 	'definitions': {
    // 		'schemaArray': {
    // 			'type': 'array',
    // 			'minItems': 1,
    // 			'items': { '$ref': '#' }
    // 		},
    // 		'positiveInteger': {
    // 			'type': 'integer',
    // 			'minimum': 0
    // 		},
    // 		'positiveIntegerDefault0': {
    // 			'allOf': [{ '$ref': '#/definitions/positiveInteger' }, { 'default': 0 }]
    // 		},
    // 		'simpleTypes': {
    // 			'type': 'string',
    // 			'enum': ['array', 'boolean', 'integer', 'null', 'number', 'object', 'string']
    // 		},
    // 		'stringArray': {
    // 			'type': 'array',
    // 			'items': { 'type': 'string' },
    // 			'minItems': 1,
    // 			'uniqueItems': true
    // 		}
    // 	},
    // 	'type': 'object',
    // 	'properties': {
    // 		'id': {
    // 			'type': 'string',
    // 			'format': 'uri',
    // 			'description': localize('schema.json.id', 'A unique identifier for the schema.')
    // 		},
    // 		'$schema': {
    // 			'type': 'string',
    // 			'format': 'uri',
    // 			'description': localize('schema.json.$schema', 'The schema to verify this document against ')
    // 		},
    // 		'title': {
    // 			'type': 'string',
    // 			'description': localize('schema.json.title', 'A descriptive title of the element')
    // 		},
    // 		'description': {
    // 			'type': 'string',
    // 			'description': localize('schema.json.description', 'A long description of the element. Used in hover menus and suggestions.')
    // 		},
    // 		'default': {
    // 			'description': localize('schema.json.default', 'A default value. Used by suggestions.')
    // 		},
    // 		'multipleOf': {
    // 			'type': 'number',
    // 			'minimum': 0,
    // 			'exclusiveMinimum': true,
    // 			'description': localize('schema.json.multipleOf', 'A number that should cleanly divide the current value (i.e. have no remainder)')
    // 		},
    // 		'maximum': {
    // 			'type': 'number',
    // 			'description': localize('schema.json.maximum', 'The maximum numerical value, inclusive by default.')
    // 		},
    // 		'exclusiveMaximum': {
    // 			'type': 'boolean',
    // 			'default': false,
    // 			'description': localize('schema.json.exclusiveMaximum', 'Makes the maximum property exclusive.')
    // 		},
    // 		'minimum': {
    // 			'type': 'number',
    // 			'description': localize('schema.json.minimum', 'The minimum numerical value, inclusive by default.')
    // 		},
    // 		'exclusiveMinimum': {
    // 			'type': 'boolean',
    // 			'default': false,
    // 			'description': localize('schema.json.exclusiveMininum', 'Makes the minimum property exclusive.')
    // 		},
    // 		'maxLength': {
    // 			'allOf': [
    // 				{ '$ref': '#/definitions/positiveInteger' }
    // 			],
    // 			'description': localize('schema.json.maxLength', 'The maximum length of a string.')
    // 		},
    // 		'minLength': {
    // 			'allOf': [
    // 				{ '$ref': '#/definitions/positiveIntegerDefault0' }
    // 			],
    // 			'description': localize('schema.json.minLength', 'The minimum length of a string.')
    // 		},
    // 		'pattern': {
    // 			'type': 'string',
    // 			'format': 'regex',
    // 			'description': localize('schema.json.pattern', 'A regular expression to match the string against. It is not implicitly anchored.')
    // 		},
    // 		'additionalItems': {
    // 			'anyOf': [
    // 				{ 'type': 'boolean' },
    // 				{ '$ref': '#' }
    // 			],
    // 			'default': {},
    // 			'description': localize('schema.json.additionalItems', 'For arrays, only when items is set as an array. If it is a schema, then this schema validates items after the ones specified by the items array. If it is false, then additional items will cause validation to fail.')
    // 		},
    // 		'items': {
    // 			'anyOf': [
    // 				{ '$ref': '#' },
    // 				{ '$ref': '#/definitions/schemaArray' }
    // 			],
    // 			'default': {},
    // 			'description': localize('schema.json.items', 'For arrays. Can either be a schema to validate every element against or an array of schemas to validate each item against in order (the first schema will validate the first element, the second schema will validate the second element, and so on.')
    // 		},
    // 		'maxItems': {
    // 			'allOf': [
    // 				{ '$ref': '#/definitions/positiveInteger' }
    // 			],
    // 			'description': localize('schema.json.maxItems', 'The maximum number of items that can be inside an array. Inclusive.')
    // 		},
    // 		'minItems': {
    // 			'allOf': [
    // 				{ '$ref': '#/definitions/positiveIntegerDefault0' }
    // 			],
    // 			'description': localize('schema.json.minItems', 'The minimum number of items that can be inside an array. Inclusive.')
    // 		},
    // 		'uniqueItems': {
    // 			'type': 'boolean',
    // 			'default': false,
    // 			'description': localize('schema.json.uniqueItems', 'If all of the items in the array must be unique. Defaults to false.')
    // 		},
    // 		'maxProperties': {
    // 			'allOf': [
    // 				{ '$ref': '#/definitions/positiveInteger' }
    // 			],
    // 			'description': localize('schema.json.maxProperties', 'The maximum number of properties an object can have. Inclusive.')
    // 		},
    // 		'minProperties': {
    // 			'allOf': [
    // 				{ '$ref': '#/definitions/positiveIntegerDefault0' },
    // 			],
    // 			'description': localize('schema.json.minProperties', 'The minimum number of properties an object can have. Inclusive.')
    // 		},
    // 		'required': {
    // 			'allOf': [
    // 				{ '$ref': '#/definitions/stringArray' }
    // 			],
    // 			'description': localize('schema.json.required', 'An array of strings that lists the names of all properties required on this object.')
    // 		},
    // 		'additionalProperties': {
    // 			'anyOf': [
    // 				{ 'type': 'boolean' },
    // 				{ '$ref': '#' }
    // 			],
    // 			'default': {},
    // 			'description': localize('schema.json.additionalProperties', 'Either a schema or a boolean. If a schema, then used to validate all properties not matched by \'properties\' or \'patternProperties\'. If false, then any properties not matched by either will cause this schema to fail.')
    // 		},
    // 		'definitions': {
    // 			'type': 'object',
    // 			'additionalProperties': { '$ref': '#' },
    // 			'default': {},
    // 			'description': localize('schema.json.definitions', 'Not used for validation. Place subschemas here that you wish to reference inline with $ref')
    // 		},
    // 		'properties': {
    // 			'type': 'object',
    // 			'additionalProperties': { '$ref': '#' },
    // 			'default': {},
    // 			'description': localize('schema.json.properties', 'A map of property names to schemas for each property.')
    // 		},
    // 		'patternProperties': {
    // 			'type': 'object',
    // 			'additionalProperties': { '$ref': '#' },
    // 			'default': {},
    // 			'description': localize('schema.json.patternProperties', 'A map of regular expressions on property names to schemas for matching properties.')
    // 		},
    // 		'dependencies': {
    // 			'type': 'object',
    // 			'additionalProperties': {
    // 				'anyOf': [
    // 					{ '$ref': '#' },
    // 					{ '$ref': '#/definitions/stringArray' }
    // 				]
    // 			},
    // 			'description': localize('schema.json.dependencies', 'A map of property names to either an array of property names or a schema. An array of property names means the property named in the key depends on the properties in the array being present in the object in order to be valid. If the value is a schema, then the schema is only applied to the object if the property in the key exists on the object.')
    // 		},
    // 		'enum': {
    // 			'type': 'array',
    // 			'minItems': 1,
    // 			'uniqueItems': true,
    // 			'description': localize('schema.json.enum', 'The set of literal values that are valid')
    // 		},
    // 		'type': {
    // 			'anyOf': [
    // 				{ '$ref': '#/definitions/simpleTypes' },
    // 				{
    // 					'type': 'array',
    // 					'items': { '$ref': '#/definitions/simpleTypes' },
    // 					'minItems': 1,
    // 					'uniqueItems': true
    // 				}
    // 			],
    // 			'description': localize('schema.json.type', 'Either a string of one of the basic schema types (number, integer, null, array, object, boolean, string) or an array of strings specifying a subset of those types.')
    // 		},
    // 		'format': {
    // 			'anyOf': [
    // 				{
    // 					'type': 'string',
    // 					'description': localize('schema.json.format', 'Describes the format expected for the value.'),
    // 					'enum': ['date-time', 'uri', 'email', 'hostname', 'ipv4', 'ipv6', 'regex']
    // 				}, {
    // 					'type': 'string'
    // 				}
    // 			]
    // 		},
    // 		'allOf': {
    // 			'allOf': [
    // 				{ '$ref': '#/definitions/schemaArray' }
    // 			],
    // 			'description': localize('schema.json.allOf', 'An array of schemas, all of which must match.')
    // 		},
    // 		'anyOf': {
    // 			'allOf': [
    // 				{ '$ref': '#/definitions/schemaArray' }
    // 			],
    // 			'description': localize('schema.json.anyOf', 'An array of schemas, where at least one must match.')
    // 		},
    // 		'oneOf': {
    // 			'allOf': [
    // 				{ '$ref': '#/definitions/schemaArray' }
    // 			],
    // 			'description': localize('schema.json.oneOf', 'An array of schemas, exactly one of which must match.')
    // 		},
    // 		'not': {
    // 			'allOf': [
    // 				{ '$ref': '#' }
    // 			],
    // 			'description': localize('schema.json.not', 'A schema which must not match.')
    // 		}
    // 	},
    // 	'dependencies': {
    // 		'exclusiveMaximum': ['maximum'],
    // 		'exclusiveMinimum': ['minimum']
    // 	},
    // 	'default': {}
    // }
  }
};
function UY(t4, e) {
  var n = [], r = [], i = [], o = -1, s = pa(t4.getText(), false), a = s.scan();
  function l(A) {
    n.push(A), r.push(i.length);
  }
  for (; a !== 17; ) {
    switch (a) {
      case 1:
      case 3: {
        var c = t4.positionAt(s.getTokenOffset()).line, u = { startLine: c, endLine: c, kind: a === 1 ? "object" : "array" };
        i.push(u);
        break;
      }
      case 2:
      case 4: {
        var f = a === 2 ? "object" : "array";
        if (i.length > 0 && i[i.length - 1].kind === f) {
          var u = i.pop(), d = t4.positionAt(s.getTokenOffset()).line;
          u && d > u.startLine + 1 && o !== u.startLine && (u.endLine = d - 1, l(u), o = u.startLine);
        }
        break;
      }
      case 13: {
        var c = t4.positionAt(s.getTokenOffset()).line, h = t4.positionAt(s.getTokenOffset() + s.getTokenLength()).line;
        s.getTokenError() === 1 && c + 1 < t4.lineCount ? s.setPosition(t4.offsetAt(Ir.create(c + 1, 0))) : c < h && (l({ startLine: c, endLine: h, kind: Xl.Comment }), o = c);
        break;
      }
      case 12: {
        var p = t4.getText().substr(s.getTokenOffset(), s.getTokenLength()), O = p.match(/^\/\/\s*#(region\b)|(endregion\b)/);
        if (O) {
          var d = t4.positionAt(s.getTokenOffset()).line;
          if (O[1]) {
            var u = { startLine: d, endLine: d, kind: Xl.Region };
            i.push(u);
          } else {
            for (var m = i.length - 1; m >= 0 && i[m].kind !== Xl.Region; )
              m--;
            if (m >= 0) {
              var u = i[m];
              i.length = m, d > u.startLine && o !== u.startLine && (u.endLine = d, l(u), o = u.startLine);
            }
          }
        }
        break;
      }
    }
    a = s.scan();
  }
  var x = e && e.rangeLimit;
  if (typeof x != "number" || n.length <= x)
    return n;
  e && e.onRangeLimitExceeded && e.onRangeLimitExceeded(t4.uri);
  for (var v = [], y = 0, S = r; y < S.length; y++) {
    var b = S[y];
    b < 30 && (v[b] = (v[b] || 0) + 1);
  }
  for (var w = 0, C = 0, m = 0; m < v.length; m++) {
    var k = v[m];
    if (k) {
      if (k + w > x) {
        C = m;
        break;
      }
      w += k;
    }
  }
  for (var T = [], m = 0; m < n.length; m++) {
    var b = r[m];
    typeof b == "number" && (b < C || b === C && w++ < x) && T.push(n[m]);
  }
  return T;
}
function HY(t4, e, n) {
  function r(a) {
    for (var l = t4.offsetAt(a), c = n.getNodeFromOffset(l, true), u = []; c; ) {
      switch (c.type) {
        case "string":
        case "object":
        case "array":
          var f = c.offset + 1, d = c.offset + c.length - 1;
          f < d && l >= f && l <= d && u.push(i(f, d)), u.push(i(c.offset, c.offset + c.length));
          break;
        case "number":
        case "boolean":
        case "null":
        case "property":
          u.push(i(c.offset, c.offset + c.length));
          break;
      }
      if (c.type === "property" || c.parent && c.parent.type === "array") {
        var h = s(
          c.offset + c.length,
          5
          /* CommaToken */
        );
        h !== -1 && u.push(i(c.offset, h));
      }
      c = c.parent;
    }
    for (var p = void 0, O = u.length - 1; O >= 0; O--)
      p = Dd.create(u[O], p);
    return p || (p = Dd.create(at.create(a, a))), p;
  }
  function i(a, l) {
    return at.create(t4.positionAt(a), t4.positionAt(l));
  }
  var o = pa(t4.getText(), true);
  function s(a, l) {
    o.setPosition(a);
    var c = o.scan();
    return c === l ? o.getTokenOffset() + o.getTokenLength() : -1;
  }
  return e.map(r);
}
function JY(t4) {
  var e = t4.promiseConstructor || Promise, n = new ZY(t4.schemaRequestService, t4.workspaceContext, e);
  n.setSchemaContributions(qY);
  var r = new AY(n, t4.contributions, e, t4.clientCapabilities), i = new PY(n, t4.contributions, e), o = new YY(n), s = new WY(n, e);
  return {
    configure: function(a) {
      n.clearExternalSchemas(), a.schemas && a.schemas.forEach(function(l) {
        n.registerExternalSchema(l.uri, l.fileMatch, l.schema);
      }), s.configure(a);
    },
    resetSchema: function(a) {
      return n.onResourceChange(a);
    },
    doValidation: s.doValidation.bind(s),
    parseJSONDocument: function(a) {
      return bY(a, { collectComments: true });
    },
    newJSONDocument: function(a, l) {
      return yY(a, l);
    },
    doComplete: r.doComplete.bind(r),
    findDocumentSymbols: o.findDocumentSymbols.bind(o),
    findDocumentSymbols2: o.findDocumentSymbols2.bind(o),
    findColorSymbols: function(a, l) {
      return o.findDocumentColors(a, l).then(function(c) {
        return c.map(function(u) {
          return u.range;
        });
      });
    },
    findDocumentColors: o.findDocumentColors.bind(o),
    getColorPresentations: o.getColorPresentations.bind(o),
    doHover: i.doHover.bind(i),
    getFoldingRanges: UY,
    getSelectionRanges: HY,
    format: function(a, l, c) {
      var u = void 0;
      if (l) {
        var f = a.offsetAt(l.start), d = a.offsetAt(l.end) - f;
        u = { offset: f, length: d };
      }
      var h = { tabSize: c ? c.tabSize : 4, insertSpaces: c ? c.insertSpaces : true, eol: `
` };
      return cY(a.getText(), u, h).map(function(p) {
        return Ki.replace(at.create(a.positionAt(p.offset), a.positionAt(p.offset + p.length)), p.content);
      });
    }
  };
}
function cC(t4) {
  try {
    const e = new URL(t4);
    return (e.protocol === "http:" && e.port === "80" || e.protocol === "https:" && e.port === "443") && (e.port = ""), e.hostname = e.hostname.toLowerCase(), e.protocol + "//" + e.hostname + (e.port ? ":" + e.port : "");
  } catch (e) {
    return console.error("Invalid URL", e), null;
  }
}
function KY(t4, e) {
  const n = {};
  return t4.forEach((r) => {
    const i = String(r[e]);
    n[i] || (n[i] = []), n[i].push(r);
  }), n;
}
function Eh(t4) {
  return t4.replace(/{/g, "{{").replace(/}/g, "}}");
}
function E$(t4, e, n) {
  for (const r of n) {
    const i = uC(t4, r), o = uC(e, r);
    if (typeof i == "object" && typeof o == "object") {
      if (!E$(i, o, n))
        return false;
    } else if (i !== o)
      return false;
  }
  return true;
}
function uC(t4, e) {
  const n = e.split("/");
  let r = t4;
  for (const i of n)
    if (r && typeof r == "object" && i in r)
      r = r[i];
    else
      return;
  return r;
}
var eq = ["GET", "POST", "PUT", "PATCH", "DELETE", "HEAD", "OPTIONS"];
var tq = "https://cors.redocly.com/";
var av = {
  id: "default-security-scheme",
  schemes: ["default-security-scheme"]
};
var fC = {
  documentedOAuth2Types: [],
  grantType: ie.ClientCredentials,
  authRequestExtraParams: [mn()],
  tokenRequestExtraParams: [wA()],
  [ie.ClientCredentials]: {
    clientId: "",
    clientSecret: "",
    clientAssertion: "",
    tokenUrl: "",
    scopes: [mn()],
    accessToken: ""
  },
  [ie.ClientCredentialsWithJwtAssertion]: {
    clientId: "",
    clientSecret: "",
    clientAssertion: "",
    tokenUrl: "",
    scopes: [mn()],
    accessToken: ""
  },
  [ie.AuthorizationCode]: {
    clientId: "",
    clientSecret: "",
    tokenUrl: "",
    authorizationUrl: "",
    callbackUrl: "",
    availableScopes: [],
    scopes: [mn()],
    codeVerifier: "",
    codeChallenge: "",
    accessToken: ""
  },
  [ie.Implicit]: {
    clientId: "",
    authorizationUrl: "",
    callbackUrl: "",
    availableScopes: [],
    scopes: [mn()],
    accessToken: ""
  },
  [ie.Password]: {
    username: "",
    password: "",
    clientId: "",
    clientSecret: "",
    tokenUrl: "",
    accessToken: ""
  }
};
var nq = {
  securityType: H.NoAuth,
  securitySchemeId: av.id,
  [H.BasicAuth]: {
    username: "",
    password: ""
  },
  [H.JWT]: {
    token: ""
  },
  [H.DigestAuth]: {
    username: "",
    password: "",
    nc: "00000001",
    realm: void 0,
    nonce: void 0,
    opaque: void 0,
    qop: void 0,
    algorithm: void 0,
    cnonce: void 0
  },
  [H.APIKey]: {
    location: za.Header,
    name: "",
    key: ""
  },
  [H.OAuth2]: fC,
  [H.OpenIDConnect]: {
    ...fC,
    openIdConnectUrl: "",
    userInfoUrl: ""
  }
};
var mO = "urn:ietf:params:oauth:client-assertion-type:jwt-bearer";
function rq(t4, e) {
  return t4.length === e.length && t4.sort().join() === e.sort().join();
}
function iq(t4, e) {
  return t4.every((n) => e.includes(n));
}
function oq(t4) {
  const { operation: e, request: n } = t4, { security: r } = n, i = nN(t4), { selectedSecuritySchemeId: o, securities: s } = r;
  if (!e)
    return false;
  const l = j$(e).securities.filter(
    (p) => p.securitySchemeId === o || !o
  ), c = s.filter(
    (p) => p.securitySchemeId === o
  ), u = c.map(
    (p) => p.securityType
  ), f = l.map(
    (p) => p.securityType
  );
  if (!rq(
    u,
    f
  ))
    return true;
  let h = [];
  return c.forEach((p) => {
    var w, C, k;
    const O = p.securityType, m = (w = p[H.OAuth2]) == null ? void 0 : w.grantType, x = u.includes(O), v = l.find(
      (T) => T.securityType === O
    ), y = !v || E$(
      p,
      v,
      aq(O, m)
    ), S = sq(
      p,
      O,
      (C = p[H.OAuth2]) == null ? void 0 : C.grantType,
      i
    ), b = !!(x && v && y && S);
    h.push(!((k = e.security) != null && k.length) || b);
  }), h.includes(false);
}
function sq(t4, e, n, r) {
  var i, o;
  if (e === H.OAuth2 && (n === ie.AuthorizationCode || n === ie.Implicit)) {
    const s = (i = t4[H.OAuth2][n]) == null ? void 0 : i.availableScopes, a = Yd(
      (o = t4[H.OAuth2][n]) == null ? void 0 : o.scopes,
      r
    );
    return iq(a, s);
  }
  return true;
}
function aq(t4, e) {
  return t4 === H.APIKey ? [`${H.APIKey}/name`, `${H.APIKey}/location`] : t4 === H.OAuth2 ? [`${H.OAuth2}/grantType`, ...lq(e)] : t4 === H.OpenIDConnect ? [`${H.OpenIDConnect}/openIdConnectUrl`] : [];
}
function lq(t4) {
  return t4 === ie.ClientCredentials ? [`${H.OAuth2}/${ie.ClientCredentials}/tokenUrl`] : t4 === ie.Password ? [`${H.OAuth2}/${ie.Password}/tokenUrl`] : t4 === ie.Implicit ? [`${H.OAuth2}/${ie.Implicit}/authorizationUrl`] : t4 === ie.AuthorizationCode ? [
    `${H.OAuth2}/${ie.AuthorizationCode}/tokenUrl`,
    `${H.OAuth2}/${ie.AuthorizationCode}/authorizationUrl`
  ] : [];
}
function T$(t4) {
  const e = t4.map((n) => {
    let r = "";
    const i = [];
    return n.forEach((o, s) => {
      r = s === 0 ? `${o.id}` : `${r}_${o.id}`, i.push(o.id);
    }), {
      id: r,
      schemes: i
    };
  });
  return t4.length ? e : [av];
}
function I$(t4) {
  return t4.map((e) => {
    const n = e.map((r) => r.id).join("_");
    return e.map((r) => ({
      ...r,
      schemeId: n
    }));
  });
}
function $$(t4) {
  var a;
  const {
    request: { security: e },
    operation: n
  } = t4, r = n.get();
  if (!r)
    return;
  const i = r.security || [], o = T$(i);
  e.securitySchemeVariants.set(o), e.selectedSecuritySchemeId.get() || e.selectedSecuritySchemeId.set(o[0].id);
  const s = ((a = e.securities) == null ? void 0 : a.get({ noproxy: true })) || [];
  e.securities.set(lv(r, s));
}
function j$(t4) {
  var r;
  const n = (t4.security || []).length ? T$(t4.security || []) : [av];
  return {
    selectedSecuritySchemeId: (r = n[0]) == null ? void 0 : r.id,
    securitySchemeVariants: n,
    securities: lv(t4)
  };
}
function lv(t4, e) {
  const n = t4.security || [];
  return n != null && n.length ? I$(n).flat().map((i, o) => cq(i, e == null ? void 0 : e[o])) : [ks()];
}
function cq(t4, e) {
  const n = e || ks();
  n.securitySchemeId = t4.schemeId;
  const r = fv(t4);
  n.securityType = r;
  const i = t4.id;
  if (r === H.BasicAuth && (n[H.BasicAuth].username || (n[H.BasicAuth].username = Jt(
    i + "_username" /* Username */
  )), n[H.BasicAuth].password || (n[H.BasicAuth].password = Jt(
    i + "_password" /* Password */
  ))), r === H.DigestAuth && (n[H.DigestAuth].username || (n[H.DigestAuth].username = Jt(
    i + "_username" /* Username */
  )), n[H.DigestAuth].password || (n[H.DigestAuth].password = Jt(
    i + "_password" /* Password */
  ))), r === H.JWT && !n[H.JWT].token && (n[H.JWT].token = Jt(
    i + "_token" /* JWTToken */
  )), r === H.APIKey && !n[H.APIKey].key && (n[H.APIKey].name = t4.name || "", n[H.APIKey].key = Jt(i + "" /* APIKey */)), r === H.OAuth2) {
    const o = dv(t4), s = Jt(i + "_token" /* Token */), a = n[H.OAuth2];
    a.grantType = o[0], o.forEach((l) => {
      var c, u, f, d, h, p, O, m, x, v, y, S;
      l === ie.AuthorizationCode && !a[ie.AuthorizationCode].accessToken && (a[ie.AuthorizationCode].accessToken = s, a[ie.AuthorizationCode].clientId = Jt(
        i + "_client_id" /* ClientId */
      ), a[ie.AuthorizationCode].authorizationUrl = ((u = (c = t4.flows) == null ? void 0 : c.authorizationCode) == null ? void 0 : u.authorizationUrl) || "", a[ie.AuthorizationCode].clientSecret = Jt(
        i + "_client_secret" /* ClientSecret */
      ), a[ie.AuthorizationCode].availableScopes = Object.keys(((d = (f = t4.flows) == null ? void 0 : f.authorizationCode) == null ? void 0 : d.scopes) || {}) || [], a[ie.AuthorizationCode].scopes = [
        ...Ef(
          Object.keys(((p = (h = t4.flows) == null ? void 0 : h.authorizationCode) == null ? void 0 : p.scopes) || {}) || []
        ),
        mn()
      ]), l === ie.ClientCredentials && !a[ie.ClientCredentials].accessToken && (a[ie.ClientCredentials].accessToken = s, a[ie.ClientCredentials].clientId = Jt(
        i + "_client_id" /* ClientId */
      ), a[ie.ClientCredentials].clientSecret = Jt(
        i + "_client_secret" /* ClientSecret */
      )), l === ie.ClientCredentialsWithJwtAssertion && !a[ie.ClientCredentialsWithJwtAssertion].accessToken && (a[ie.ClientCredentialsWithJwtAssertion].accessToken = s, a[ie.ClientCredentialsWithJwtAssertion].clientId = Jt(
        i + "_client_id" /* ClientId */
      ), a[ie.ClientCredentialsWithJwtAssertion].clientAssertion = Jt(i + "_client_assertion" /* ClientAssertion */)), l === ie.Implicit && !a[ie.Implicit].accessToken && (a[ie.Implicit].accessToken = s, a[ie.Implicit].clientId = Jt(
        i + "_client_id" /* ClientId */
      ), a[ie.Implicit].authorizationUrl = ((m = (O = t4.flows) == null ? void 0 : O.implicit) == null ? void 0 : m.authorizationUrl) || "", a[ie.Implicit].availableScopes = Object.keys(((v = (x = t4.flows) == null ? void 0 : x.implicit) == null ? void 0 : v.scopes) || {}) || [], a[ie.Implicit].scopes = [
        ...Ef(
          Object.keys(((S = (y = t4.flows) == null ? void 0 : y.implicit) == null ? void 0 : S.scopes) || {}) || []
        ),
        mn()
      ]), l === ie.Password && !a[ie.Password].accessToken && (a[ie.Password].accessToken = s, a[ie.Password].clientId = Jt(
        i + "_client_id" /* ClientId */
      ), a[ie.Password].clientSecret = Jt(
        i + "_client_secret" /* ClientSecret */
      ));
    });
  }
  if (r === H.OpenIDConnect) {
    const o = Jt(i + "_token" /* Token */), s = n[H.OpenIDConnect];
    s[ie.AuthorizationCode].accessToken || (s[ie.AuthorizationCode].accessToken = o, s[ie.AuthorizationCode].clientId = Jt(
      i + "_client_id" /* ClientId */
    ), s[ie.AuthorizationCode].clientSecret = Jt(
      i + "_client_secret" /* ClientSecret */
    )), s[ie.Implicit].accessToken || (s[ie.Implicit].accessToken = o, s[ie.Implicit].clientId = Jt(
      i + "_client_id" /* ClientId */
    ));
  }
  return n;
}
function ks() {
  return An(nq);
}
function rl(t4, e) {
  return t4.filter(
    (n) => n.securitySchemeId.get() === e || !e
  );
}
function cv(t4) {
  const e = KY(t4.parameters, "in"), n = R$(t4), r = j$(t4), i = zc(), o = sp(e.query || []);
  return {
    ...i.request,
    method: t4.method.toLocaleUpperCase(),
    url: SA("{{server}}" + Eh(t4.path), o),
    headers: sp(e.header || []),
    queryParameters: o,
    cookies: sp(e.cookie || []),
    body: n,
    security: r
  };
}
function R$(t4) {
  var a, l, c;
  const e = (a = t4.body) == null ? void 0 : a.mediaTypes;
  if (!e || !Object.keys(e).length)
    return po();
  const n = uq(e, t4), r = (n == null ? void 0 : n.name) || "", i = !U$.includes(r) && !H$.includes(r), o = OO(n), s = i && o.length ? JSON.stringify(
    (l = o.find(({ key: u }) => {
      var f;
      return u === ((f = t4.body) == null ? void 0 : f.activeExampleName);
    })) == null ? void 0 : l.value,
    null,
    2
  ) || JSON.stringify(o[0].value, null, 2) : "";
  return {
    ...po(),
    activeExampleName: (c = t4.body) == null ? void 0 : c.activeExampleName,
    ...n && { type: n.name },
    content: s,
    formData: {
      [ut.FormData]: dC(e[ut.FormData]),
      [ut["application/x-www-form-urlencoded"]]: dC(
        e[ut["application/x-www-form-urlencoded"]]
      )
    }
  };
}
function uv(t4) {
  var n;
  return t4 ? {
    ...(Object.keys(((n = t4 == null ? void 0 : t4.body) == null ? void 0 : n.mediaTypes) || {}) || []).reduce(
      (r, i) => ({
        ...r,
        [i]: {
          name: i,
          extensions: void 0
        }
      }),
      {}
    ),
    ...Os
  } : Os;
}
function dC(t4) {
  if (!t4)
    return [na()];
  if (!t4.parameters)
    return [na()];
  const e = t4.parameters.map(
    (n) => ({
      id: crypto.randomUUID(),
      key: n.name,
      value: n.example || "",
      active: true,
      type: n.inputType,
      files: null
    })
  );
  return e.push(na()), e;
}
function OO(t4) {
  const e = t4 == null ? void 0 : t4.examples;
  return Object.keys(e || {}).map((n) => {
    var o;
    const r = e == null ? void 0 : e[n];
    return {
      name: isString(r == null ? void 0 : r.summary) ? r == null ? void 0 : r.summary : ((o = r == null ? void 0 : r.summary) == null ? void 0 : o.raw) || n,
      key: n,
      value: e == null ? void 0 : e[n].value
    };
  });
}
function uq(t4, e) {
  const n = uv(e), r = Object.keys(t4).find((i) => !!n[i]);
  return r ? t4[r] : null;
}
function fq(t4, e) {
  const n = t4 == null ? void 0 : t4.security;
  if (!(n != null && n.length) || !t4)
    return [];
  const r = lv(t4);
  return [
    ...new Set(
      r.filter((i) => i.securitySchemeId === e).map((i) => i.securityType)
    )
  ];
}
function fv(t4) {
  if (t4.type === "http") {
    if (t4.scheme === "bearer")
      return H.JWT;
    if (t4.scheme === "basic")
      return H.BasicAuth;
    if (t4.scheme === "digest")
      return H.DigestAuth;
  } else {
    if (t4.type === "apiKey")
      return H.APIKey;
    if (t4.type === "oauth2")
      return H.OAuth2;
    if (t4.type === "openIdConnect")
      return H.OpenIDConnect;
  }
  return H.NoAuth;
}
function dq(t4, e) {
  if (t4 === "clientCredentials" && e && "x-assertionType" in e && e["x-assertionType"] === mO)
    return ie.ClientCredentialsWithJwtAssertion;
  switch (t4) {
    case "implicit":
      return ie.Implicit;
    case "password":
      return ie.Password;
    case "clientCredentials":
      return ie.ClientCredentials;
    case "authorizationCode":
      return ie.AuthorizationCode;
    default:
      return ie.AuthorizationCode;
  }
}
function hq(t4, e) {
  const n = t4 == null ? void 0 : t4.security;
  if (!(n != null && n.length))
    return [];
  const o = I$(n).flat().filter(
    (s) => s.schemeId === e
  ).find(
    (s) => fv(s) === H.OAuth2
  );
  return dv(o);
}
function dv(t4) {
  return Object.entries((t4 == null ? void 0 : t4.flows) || {}).map(([e, n]) => dq(e, n)).filter(Boolean);
}
function pq(t4) {
  return t4 ? t4.split(";").map((r) => r.trim()).map((r) => {
    const i = r.indexOf("="), o = r.slice(0, i).trim(), s = r.slice(i + 1).trim();
    return [o, s];
  }) : [];
}
async function gq(t4, e) {
  const r = await t4.clone().arrayBuffer(), i = new TextDecoder().decode(r), o = new Uint8Array(r).length, s = pq(document.cookie);
  return {
    bodyUsed: t4.bodyUsed,
    status: t4.status,
    headers: Array.from(new Headers(t4.headers || [])),
    arrayBuffer: r,
    body: i,
    duration: e,
    cookies: s,
    size: o
  };
}
var D$ = { exports: {} };
function mq(t4) {
  throw new Error('Could not dynamically require "' + t4 + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var f0 = { exports: {} };
var Oq = {};
var xq = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: Oq
}, Symbol.toStringTag, { value: "Module" }));
var vq = /* @__PURE__ */ W4(xq);
var hC;
function tt() {
  return hC || (hC = 1, function(t4, e) {
    (function(n, r) {
      t4.exports = r();
    })(Ze, function() {
      var n = n || function(r, i) {
        var o;
        if (typeof window < "u" && window.crypto && (o = window.crypto), typeof self < "u" && self.crypto && (o = self.crypto), typeof globalThis < "u" && globalThis.crypto && (o = globalThis.crypto), !o && typeof window < "u" && window.msCrypto && (o = window.msCrypto), !o && typeof Ze < "u" && Ze.crypto && (o = Ze.crypto), !o && typeof mq == "function")
          try {
            o = vq;
          } catch {
          }
        var s = function() {
          if (o) {
            if (typeof o.getRandomValues == "function")
              try {
                return o.getRandomValues(new Uint32Array(1))[0];
              } catch {
              }
            if (typeof o.randomBytes == "function")
              try {
                return o.randomBytes(4).readInt32LE();
              } catch {
              }
          }
          throw new Error("Native crypto module could not be used to get secure random number.");
        }, a = Object.create || /* @__PURE__ */ function() {
          function v() {
          }
          return function(y) {
            var S;
            return v.prototype = y, S = new v(), v.prototype = null, S;
          };
        }(), l = {}, c = l.lib = {}, u = c.Base = /* @__PURE__ */ function() {
          return {
            /**
             * Creates a new object that inherits from this object.
             *
             * @param {Object} overrides Properties to copy into the new object.
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         field: 'value',
             *
             *         method: function () {
             *         }
             *     });
             */
            extend: function(v) {
              var y = a(this);
              return v && y.mixIn(v), (!y.hasOwnProperty("init") || this.init === y.init) && (y.init = function() {
                y.$super.init.apply(this, arguments);
              }), y.init.prototype = y, y.$super = this, y;
            },
            /**
             * Extends this object and runs the init method.
             * Arguments to create() will be passed to init().
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var instance = MyType.create();
             */
            create: function() {
              var v = this.extend();
              return v.init.apply(v, arguments), v;
            },
            /**
             * Initializes a newly created object.
             * Override this method to add some logic when your objects are created.
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         init: function () {
             *             // ...
             *         }
             *     });
             */
            init: function() {
            },
            /**
             * Copies properties into this object.
             *
             * @param {Object} properties The properties to mix in.
             *
             * @example
             *
             *     MyType.mixIn({
             *         field: 'value'
             *     });
             */
            mixIn: function(v) {
              for (var y in v)
                v.hasOwnProperty(y) && (this[y] = v[y]);
              v.hasOwnProperty("toString") && (this.toString = v.toString);
            },
            /**
             * Creates a copy of this object.
             *
             * @return {Object} The clone.
             *
             * @example
             *
             *     var clone = instance.clone();
             */
            clone: function() {
              return this.init.prototype.extend(this);
            }
          };
        }(), f = c.WordArray = u.extend({
          /**
           * Initializes a newly created word array.
           *
           * @param {Array} words (Optional) An array of 32-bit words.
           * @param {number} sigBytes (Optional) The number of significant bytes in the words.
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.create();
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
           */
          init: function(v, y) {
            v = this.words = v || [], y != i ? this.sigBytes = y : this.sigBytes = v.length * 4;
          },
          /**
           * Converts this word array to a string.
           *
           * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
           *
           * @return {string} The stringified word array.
           *
           * @example
           *
           *     var string = wordArray + '';
           *     var string = wordArray.toString();
           *     var string = wordArray.toString(CryptoJS.enc.Utf8);
           */
          toString: function(v) {
            return (v || h).stringify(this);
          },
          /**
           * Concatenates a word array to this word array.
           *
           * @param {WordArray} wordArray The word array to append.
           *
           * @return {WordArray} This word array.
           *
           * @example
           *
           *     wordArray1.concat(wordArray2);
           */
          concat: function(v) {
            var y = this.words, S = v.words, b = this.sigBytes, w = v.sigBytes;
            if (this.clamp(), b % 4)
              for (var C = 0; C < w; C++) {
                var k = S[C >>> 2] >>> 24 - C % 4 * 8 & 255;
                y[b + C >>> 2] |= k << 24 - (b + C) % 4 * 8;
              }
            else
              for (var T = 0; T < w; T += 4)
                y[b + T >>> 2] = S[T >>> 2];
            return this.sigBytes += w, this;
          },
          /**
           * Removes insignificant bits.
           *
           * @example
           *
           *     wordArray.clamp();
           */
          clamp: function() {
            var v = this.words, y = this.sigBytes;
            v[y >>> 2] &= 4294967295 << 32 - y % 4 * 8, v.length = r.ceil(y / 4);
          },
          /**
           * Creates a copy of this word array.
           *
           * @return {WordArray} The clone.
           *
           * @example
           *
           *     var clone = wordArray.clone();
           */
          clone: function() {
            var v = u.clone.call(this);
            return v.words = this.words.slice(0), v;
          },
          /**
           * Creates a word array filled with random bytes.
           *
           * @param {number} nBytes The number of random bytes to generate.
           *
           * @return {WordArray} The random word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.random(16);
           */
          random: function(v) {
            for (var y = [], S = 0; S < v; S += 4)
              y.push(s());
            return new f.init(y, v);
          }
        }), d = l.enc = {}, h = d.Hex = {
          /**
           * Converts a word array to a hex string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The hex string.
           *
           * @static
           *
           * @example
           *
           *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
           */
          stringify: function(v) {
            for (var y = v.words, S = v.sigBytes, b = [], w = 0; w < S; w++) {
              var C = y[w >>> 2] >>> 24 - w % 4 * 8 & 255;
              b.push((C >>> 4).toString(16)), b.push((C & 15).toString(16));
            }
            return b.join("");
          },
          /**
           * Converts a hex string to a word array.
           *
           * @param {string} hexStr The hex string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
           */
          parse: function(v) {
            for (var y = v.length, S = [], b = 0; b < y; b += 2)
              S[b >>> 3] |= parseInt(v.substr(b, 2), 16) << 24 - b % 8 * 4;
            return new f.init(S, y / 2);
          }
        }, p = d.Latin1 = {
          /**
           * Converts a word array to a Latin1 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Latin1 string.
           *
           * @static
           *
           * @example
           *
           *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
           */
          stringify: function(v) {
            for (var y = v.words, S = v.sigBytes, b = [], w = 0; w < S; w++) {
              var C = y[w >>> 2] >>> 24 - w % 4 * 8 & 255;
              b.push(String.fromCharCode(C));
            }
            return b.join("");
          },
          /**
           * Converts a Latin1 string to a word array.
           *
           * @param {string} latin1Str The Latin1 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
           */
          parse: function(v) {
            for (var y = v.length, S = [], b = 0; b < y; b++)
              S[b >>> 2] |= (v.charCodeAt(b) & 255) << 24 - b % 4 * 8;
            return new f.init(S, y);
          }
        }, O = d.Utf8 = {
          /**
           * Converts a word array to a UTF-8 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-8 string.
           *
           * @static
           *
           * @example
           *
           *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
           */
          stringify: function(v) {
            try {
              return decodeURIComponent(escape(p.stringify(v)));
            } catch {
              throw new Error("Malformed UTF-8 data");
            }
          },
          /**
           * Converts a UTF-8 string to a word array.
           *
           * @param {string} utf8Str The UTF-8 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
           */
          parse: function(v) {
            return p.parse(unescape(encodeURIComponent(v)));
          }
        }, m = c.BufferedBlockAlgorithm = u.extend({
          /**
           * Resets this block algorithm's data buffer to its initial state.
           *
           * @example
           *
           *     bufferedBlockAlgorithm.reset();
           */
          reset: function() {
            this._data = new f.init(), this._nDataBytes = 0;
          },
          /**
           * Adds new data to this block algorithm's buffer.
           *
           * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
           *
           * @example
           *
           *     bufferedBlockAlgorithm._append('data');
           *     bufferedBlockAlgorithm._append(wordArray);
           */
          _append: function(v) {
            typeof v == "string" && (v = O.parse(v)), this._data.concat(v), this._nDataBytes += v.sigBytes;
          },
          /**
           * Processes available data blocks.
           *
           * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
           *
           * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
           *
           * @return {WordArray} The processed data.
           *
           * @example
           *
           *     var processedData = bufferedBlockAlgorithm._process();
           *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
           */
          _process: function(v) {
            var y, S = this._data, b = S.words, w = S.sigBytes, C = this.blockSize, k = C * 4, T = w / k;
            v ? T = r.ceil(T) : T = r.max((T | 0) - this._minBufferSize, 0);
            var A = T * C, E = r.min(A * 4, w);
            if (A) {
              for (var $ = 0; $ < A; $ += C)
                this._doProcessBlock(b, $);
              y = b.splice(0, A), S.sigBytes -= E;
            }
            return new f.init(y, E);
          },
          /**
           * Creates a copy of this object.
           *
           * @return {Object} The clone.
           *
           * @example
           *
           *     var clone = bufferedBlockAlgorithm.clone();
           */
          clone: function() {
            var v = u.clone.call(this);
            return v._data = this._data.clone(), v;
          },
          _minBufferSize: 0
        });
        c.Hasher = m.extend({
          /**
           * Configuration options.
           */
          cfg: u.extend(),
          /**
           * Initializes a newly created hasher.
           *
           * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
           *
           * @example
           *
           *     var hasher = CryptoJS.algo.SHA256.create();
           */
          init: function(v) {
            this.cfg = this.cfg.extend(v), this.reset();
          },
          /**
           * Resets this hasher to its initial state.
           *
           * @example
           *
           *     hasher.reset();
           */
          reset: function() {
            m.reset.call(this), this._doReset();
          },
          /**
           * Updates this hasher with a message.
           *
           * @param {WordArray|string} messageUpdate The message to append.
           *
           * @return {Hasher} This hasher.
           *
           * @example
           *
           *     hasher.update('message');
           *     hasher.update(wordArray);
           */
          update: function(v) {
            return this._append(v), this._process(), this;
          },
          /**
           * Finalizes the hash computation.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} messageUpdate (Optional) A final message update.
           *
           * @return {WordArray} The hash.
           *
           * @example
           *
           *     var hash = hasher.finalize();
           *     var hash = hasher.finalize('message');
           *     var hash = hasher.finalize(wordArray);
           */
          finalize: function(v) {
            v && this._append(v);
            var y = this._doFinalize();
            return y;
          },
          blockSize: 16,
          /**
           * Creates a shortcut function to a hasher's object interface.
           *
           * @param {Hasher} hasher The hasher to create a helper for.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
           */
          _createHelper: function(v) {
            return function(y, S) {
              return new v.init(S).finalize(y);
            };
          },
          /**
           * Creates a shortcut function to the HMAC's object interface.
           *
           * @param {Hasher} hasher The hasher to use in this HMAC helper.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
           */
          _createHmacHelper: function(v) {
            return function(y, S) {
              return new x.HMAC.init(v, S).finalize(y);
            };
          }
        });
        var x = l.algo = {};
        return l;
      }(Math);
      return n;
    });
  }(f0)), f0.exports;
}
var d0 = { exports: {} };
var pC;
function Th() {
  return pC || (pC = 1, function(t4, e) {
    (function(n, r) {
      t4.exports = r(tt());
    })(Ze, function(n) {
      return function(r) {
        var i = n, o = i.lib, s = o.Base, a = o.WordArray, l = i.x64 = {};
        l.Word = s.extend({
          /**
           * Initializes a newly created 64-bit word.
           *
           * @param {number} high The high 32 bits.
           * @param {number} low The low 32 bits.
           *
           * @example
           *
           *     var x64Word = CryptoJS.x64.Word.create(0x00010203, 0x04050607);
           */
          init: function(c, u) {
            this.high = c, this.low = u;
          }
          /**
           * Bitwise NOTs this word.
           *
           * @return {X64Word} A new x64-Word object after negating.
           *
           * @example
           *
           *     var negated = x64Word.not();
           */
          // not: function () {
          // var high = ~this.high;
          // var low = ~this.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Bitwise ANDs this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to AND with this word.
           *
           * @return {X64Word} A new x64-Word object after ANDing.
           *
           * @example
           *
           *     var anded = x64Word.and(anotherX64Word);
           */
          // and: function (word) {
          // var high = this.high & word.high;
          // var low = this.low & word.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Bitwise ORs this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to OR with this word.
           *
           * @return {X64Word} A new x64-Word object after ORing.
           *
           * @example
           *
           *     var ored = x64Word.or(anotherX64Word);
           */
          // or: function (word) {
          // var high = this.high | word.high;
          // var low = this.low | word.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Bitwise XORs this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to XOR with this word.
           *
           * @return {X64Word} A new x64-Word object after XORing.
           *
           * @example
           *
           *     var xored = x64Word.xor(anotherX64Word);
           */
          // xor: function (word) {
          // var high = this.high ^ word.high;
          // var low = this.low ^ word.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Shifts this word n bits to the left.
           *
           * @param {number} n The number of bits to shift.
           *
           * @return {X64Word} A new x64-Word object after shifting.
           *
           * @example
           *
           *     var shifted = x64Word.shiftL(25);
           */
          // shiftL: function (n) {
          // if (n < 32) {
          // var high = (this.high << n) | (this.low >>> (32 - n));
          // var low = this.low << n;
          // } else {
          // var high = this.low << (n - 32);
          // var low = 0;
          // }
          // return X64Word.create(high, low);
          // },
          /**
           * Shifts this word n bits to the right.
           *
           * @param {number} n The number of bits to shift.
           *
           * @return {X64Word} A new x64-Word object after shifting.
           *
           * @example
           *
           *     var shifted = x64Word.shiftR(7);
           */
          // shiftR: function (n) {
          // if (n < 32) {
          // var low = (this.low >>> n) | (this.high << (32 - n));
          // var high = this.high >>> n;
          // } else {
          // var low = this.high >>> (n - 32);
          // var high = 0;
          // }
          // return X64Word.create(high, low);
          // },
          /**
           * Rotates this word n bits to the left.
           *
           * @param {number} n The number of bits to rotate.
           *
           * @return {X64Word} A new x64-Word object after rotating.
           *
           * @example
           *
           *     var rotated = x64Word.rotL(25);
           */
          // rotL: function (n) {
          // return this.shiftL(n).or(this.shiftR(64 - n));
          // },
          /**
           * Rotates this word n bits to the right.
           *
           * @param {number} n The number of bits to rotate.
           *
           * @return {X64Word} A new x64-Word object after rotating.
           *
           * @example
           *
           *     var rotated = x64Word.rotR(7);
           */
          // rotR: function (n) {
          // return this.shiftR(n).or(this.shiftL(64 - n));
          // },
          /**
           * Adds this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to add with this word.
           *
           * @return {X64Word} A new x64-Word object after adding.
           *
           * @example
           *
           *     var added = x64Word.add(anotherX64Word);
           */
          // add: function (word) {
          // var low = (this.low + word.low) | 0;
          // var carry = (low >>> 0) < (this.low >>> 0) ? 1 : 0;
          // var high = (this.high + word.high + carry) | 0;
          // return X64Word.create(high, low);
          // }
        }), l.WordArray = s.extend({
          /**
           * Initializes a newly created word array.
           *
           * @param {Array} words (Optional) An array of CryptoJS.x64.Word objects.
           * @param {number} sigBytes (Optional) The number of significant bytes in the words.
           *
           * @example
           *
           *     var wordArray = CryptoJS.x64.WordArray.create();
           *
           *     var wordArray = CryptoJS.x64.WordArray.create([
           *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
           *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
           *     ]);
           *
           *     var wordArray = CryptoJS.x64.WordArray.create([
           *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
           *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
           *     ], 10);
           */
          init: function(c, u) {
            c = this.words = c || [], u != r ? this.sigBytes = u : this.sigBytes = c.length * 8;
          },
          /**
           * Converts this 64-bit word array to a 32-bit word array.
           *
           * @return {CryptoJS.lib.WordArray} This word array's data as a 32-bit word array.
           *
           * @example
           *
           *     var x32WordArray = x64WordArray.toX32();
           */
          toX32: function() {
            for (var c = this.words, u = c.length, f = [], d = 0; d < u; d++) {
              var h = c[d];
              f.push(h.high), f.push(h.low);
            }
            return a.create(f, this.sigBytes);
          },
          /**
           * Creates a copy of this word array.
           *
           * @return {X64WordArray} The clone.
           *
           * @example
           *
           *     var clone = x64WordArray.clone();
           */
          clone: function() {
            for (var c = s.clone.call(this), u = c.words = this.words.slice(0), f = u.length, d = 0; d < f; d++)
              u[d] = u[d].clone();
            return c;
          }
        });
      }(), n;
    });
  }(d0)), d0.exports;
}
var h0 = { exports: {} };
var gC;
function yq() {
  return gC || (gC = 1, function(t4, e) {
    (function(n, r) {
      t4.exports = r(tt());
    })(Ze, function(n) {
      return function() {
        if (typeof ArrayBuffer == "function") {
          var r = n, i = r.lib, o = i.WordArray, s = o.init, a = o.init = function(l) {
            if (l instanceof ArrayBuffer && (l = new Uint8Array(l)), (l instanceof Int8Array || typeof Uint8ClampedArray < "u" && l instanceof Uint8ClampedArray || l instanceof Int16Array || l instanceof Uint16Array || l instanceof Int32Array || l instanceof Uint32Array || l instanceof Float32Array || l instanceof Float64Array) && (l = new Uint8Array(l.buffer, l.byteOffset, l.byteLength)), l instanceof Uint8Array) {
              for (var c = l.byteLength, u = [], f = 0; f < c; f++)
                u[f >>> 2] |= l[f] << 24 - f % 4 * 8;
              s.call(this, u, c);
            } else
              s.apply(this, arguments);
          };
          a.prototype = o;
        }
      }(), n.lib.WordArray;
    });
  }(h0)), h0.exports;
}
var p0 = { exports: {} };
var mC;
function bq() {
  return mC || (mC = 1, function(t4, e) {
    (function(n, r) {
      t4.exports = r(tt());
    })(Ze, function(n) {
      return function() {
        var r = n, i = r.lib, o = i.WordArray, s = r.enc;
        s.Utf16 = s.Utf16BE = {
          /**
           * Converts a word array to a UTF-16 BE string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-16 BE string.
           *
           * @static
           *
           * @example
           *
           *     var utf16String = CryptoJS.enc.Utf16.stringify(wordArray);
           */
          stringify: function(l) {
            for (var c = l.words, u = l.sigBytes, f = [], d = 0; d < u; d += 2) {
              var h = c[d >>> 2] >>> 16 - d % 4 * 8 & 65535;
              f.push(String.fromCharCode(h));
            }
            return f.join("");
          },
          /**
           * Converts a UTF-16 BE string to a word array.
           *
           * @param {string} utf16Str The UTF-16 BE string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf16.parse(utf16String);
           */
          parse: function(l) {
            for (var c = l.length, u = [], f = 0; f < c; f++)
              u[f >>> 1] |= l.charCodeAt(f) << 16 - f % 2 * 16;
            return o.create(u, c * 2);
          }
        }, s.Utf16LE = {
          /**
           * Converts a word array to a UTF-16 LE string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-16 LE string.
           *
           * @static
           *
           * @example
           *
           *     var utf16Str = CryptoJS.enc.Utf16LE.stringify(wordArray);
           */
          stringify: function(l) {
            for (var c = l.words, u = l.sigBytes, f = [], d = 0; d < u; d += 2) {
              var h = a(c[d >>> 2] >>> 16 - d % 4 * 8 & 65535);
              f.push(String.fromCharCode(h));
            }
            return f.join("");
          },
          /**
           * Converts a UTF-16 LE string to a word array.
           *
           * @param {string} utf16Str The UTF-16 LE string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf16LE.parse(utf16Str);
           */
          parse: function(l) {
            for (var c = l.length, u = [], f = 0; f < c; f++)
              u[f >>> 1] |= a(l.charCodeAt(f) << 16 - f % 2 * 16);
            return o.create(u, c * 2);
          }
        };
        function a(l) {
          return l << 8 & 4278255360 | l >>> 8 & 16711935;
        }
      }(), n.enc.Utf16;
    });
  }(p0)), p0.exports;
}
var g0 = { exports: {} };
var OC;
function As() {
  return OC || (OC = 1, function(t4, e) {
    (function(n, r) {
      t4.exports = r(tt());
    })(Ze, function(n) {
      return function() {
        var r = n, i = r.lib, o = i.WordArray, s = r.enc;
        s.Base64 = {
          /**
           * Converts a word array to a Base64 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Base64 string.
           *
           * @static
           *
           * @example
           *
           *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
           */
          stringify: function(l) {
            var c = l.words, u = l.sigBytes, f = this._map;
            l.clamp();
            for (var d = [], h = 0; h < u; h += 3)
              for (var p = c[h >>> 2] >>> 24 - h % 4 * 8 & 255, O = c[h + 1 >>> 2] >>> 24 - (h + 1) % 4 * 8 & 255, m = c[h + 2 >>> 2] >>> 24 - (h + 2) % 4 * 8 & 255, x = p << 16 | O << 8 | m, v = 0; v < 4 && h + v * 0.75 < u; v++)
                d.push(f.charAt(x >>> 6 * (3 - v) & 63));
            var y = f.charAt(64);
            if (y)
              for (; d.length % 4; )
                d.push(y);
            return d.join("");
          },
          /**
           * Converts a Base64 string to a word array.
           *
           * @param {string} base64Str The Base64 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
           */
          parse: function(l) {
            var c = l.length, u = this._map, f = this._reverseMap;
            if (!f) {
              f = this._reverseMap = [];
              for (var d = 0; d < u.length; d++)
                f[u.charCodeAt(d)] = d;
            }
            var h = u.charAt(64);
            if (h) {
              var p = l.indexOf(h);
              p !== -1 && (c = p);
            }
            return a(l, c, f);
          },
          _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
        };
        function a(l, c, u) {
          for (var f = [], d = 0, h = 0; h < c; h++)
            if (h % 4) {
              var p = u[l.charCodeAt(h - 1)] << h % 4 * 2, O = u[l.charCodeAt(h)] >>> 6 - h % 4 * 2, m = p | O;
              f[d >>> 2] |= m << 24 - d % 4 * 8, d++;
            }
          return o.create(f, d);
        }
      }(), n.enc.Base64;
    });
  }(g0)), g0.exports;
}
var m0 = { exports: {} };
var xC;
function Sq() {
  return xC || (xC = 1, function(t4, e) {
    (function(n, r) {
      t4.exports = r(tt());
    })(Ze, function(n) {
      return function() {
        var r = n, i = r.lib, o = i.WordArray, s = r.enc;
        s.Base64url = {
          /**
           * Converts a word array to a Base64url string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @param {boolean} urlSafe Whether to use url safe
           *
           * @return {string} The Base64url string.
           *
           * @static
           *
           * @example
           *
           *     var base64String = CryptoJS.enc.Base64url.stringify(wordArray);
           */
          stringify: function(l, c) {
            c === void 0 && (c = true);
            var u = l.words, f = l.sigBytes, d = c ? this._safe_map : this._map;
            l.clamp();
            for (var h = [], p = 0; p < f; p += 3)
              for (var O = u[p >>> 2] >>> 24 - p % 4 * 8 & 255, m = u[p + 1 >>> 2] >>> 24 - (p + 1) % 4 * 8 & 255, x = u[p + 2 >>> 2] >>> 24 - (p + 2) % 4 * 8 & 255, v = O << 16 | m << 8 | x, y = 0; y < 4 && p + y * 0.75 < f; y++)
                h.push(d.charAt(v >>> 6 * (3 - y) & 63));
            var S = d.charAt(64);
            if (S)
              for (; h.length % 4; )
                h.push(S);
            return h.join("");
          },
          /**
           * Converts a Base64url string to a word array.
           *
           * @param {string} base64Str The Base64url string.
           *
           * @param {boolean} urlSafe Whether to use url safe
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Base64url.parse(base64String);
           */
          parse: function(l, c) {
            c === void 0 && (c = true);
            var u = l.length, f = c ? this._safe_map : this._map, d = this._reverseMap;
            if (!d) {
              d = this._reverseMap = [];
              for (var h = 0; h < f.length; h++)
                d[f.charCodeAt(h)] = h;
            }
            var p = f.charAt(64);
            if (p) {
              var O = l.indexOf(p);
              O !== -1 && (u = O);
            }
            return a(l, u, d);
          },
          _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
          _safe_map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"
        };
        function a(l, c, u) {
          for (var f = [], d = 0, h = 0; h < c; h++)
            if (h % 4) {
              var p = u[l.charCodeAt(h - 1)] << h % 4 * 2, O = u[l.charCodeAt(h)] >>> 6 - h % 4 * 2, m = p | O;
              f[d >>> 2] |= m << 24 - d % 4 * 8, d++;
            }
          return o.create(f, d);
        }
      }(), n.enc.Base64url;
    });
  }(m0)), m0.exports;
}
var O0 = { exports: {} };
var vC;
function Ps() {
  return vC || (vC = 1, function(t4, e) {
    (function(n, r) {
      t4.exports = r(tt());
    })(Ze, function(n) {
      return function(r) {
        var i = n, o = i.lib, s = o.WordArray, a = o.Hasher, l = i.algo, c = [];
        (function() {
          for (var O = 0; O < 64; O++)
            c[O] = r.abs(r.sin(O + 1)) * 4294967296 | 0;
        })();
        var u = l.MD5 = a.extend({
          _doReset: function() {
            this._hash = new s.init([
              1732584193,
              4023233417,
              2562383102,
              271733878
            ]);
          },
          _doProcessBlock: function(O, m) {
            for (var x = 0; x < 16; x++) {
              var v = m + x, y = O[v];
              O[v] = (y << 8 | y >>> 24) & 16711935 | (y << 24 | y >>> 8) & 4278255360;
            }
            var S = this._hash.words, b = O[m + 0], w = O[m + 1], C = O[m + 2], k = O[m + 3], T = O[m + 4], A = O[m + 5], E = O[m + 6], $ = O[m + 7], j = O[m + 8], B = O[m + 9], D = O[m + 10], N = O[m + 11], z = O[m + 12], Z = O[m + 13], J = O[m + 14], L = O[m + 15], W = S[0], R = S[1], Q = S[2], _ = S[3];
            W = f(W, R, Q, _, b, 7, c[0]), _ = f(_, W, R, Q, w, 12, c[1]), Q = f(Q, _, W, R, C, 17, c[2]), R = f(R, Q, _, W, k, 22, c[3]), W = f(W, R, Q, _, T, 7, c[4]), _ = f(_, W, R, Q, A, 12, c[5]), Q = f(Q, _, W, R, E, 17, c[6]), R = f(R, Q, _, W, $, 22, c[7]), W = f(W, R, Q, _, j, 7, c[8]), _ = f(_, W, R, Q, B, 12, c[9]), Q = f(Q, _, W, R, D, 17, c[10]), R = f(R, Q, _, W, N, 22, c[11]), W = f(W, R, Q, _, z, 7, c[12]), _ = f(_, W, R, Q, Z, 12, c[13]), Q = f(Q, _, W, R, J, 17, c[14]), R = f(R, Q, _, W, L, 22, c[15]), W = d(W, R, Q, _, w, 5, c[16]), _ = d(_, W, R, Q, E, 9, c[17]), Q = d(Q, _, W, R, N, 14, c[18]), R = d(R, Q, _, W, b, 20, c[19]), W = d(W, R, Q, _, A, 5, c[20]), _ = d(_, W, R, Q, D, 9, c[21]), Q = d(Q, _, W, R, L, 14, c[22]), R = d(R, Q, _, W, T, 20, c[23]), W = d(W, R, Q, _, B, 5, c[24]), _ = d(_, W, R, Q, J, 9, c[25]), Q = d(Q, _, W, R, k, 14, c[26]), R = d(R, Q, _, W, j, 20, c[27]), W = d(W, R, Q, _, Z, 5, c[28]), _ = d(_, W, R, Q, C, 9, c[29]), Q = d(Q, _, W, R, $, 14, c[30]), R = d(R, Q, _, W, z, 20, c[31]), W = h(W, R, Q, _, A, 4, c[32]), _ = h(_, W, R, Q, j, 11, c[33]), Q = h(Q, _, W, R, N, 16, c[34]), R = h(R, Q, _, W, J, 23, c[35]), W = h(W, R, Q, _, w, 4, c[36]), _ = h(_, W, R, Q, T, 11, c[37]), Q = h(Q, _, W, R, $, 16, c[38]), R = h(R, Q, _, W, D, 23, c[39]), W = h(W, R, Q, _, Z, 4, c[40]), _ = h(_, W, R, Q, b, 11, c[41]), Q = h(Q, _, W, R, k, 16, c[42]), R = h(R, Q, _, W, E, 23, c[43]), W = h(W, R, Q, _, B, 4, c[44]), _ = h(_, W, R, Q, z, 11, c[45]), Q = h(Q, _, W, R, L, 16, c[46]), R = h(R, Q, _, W, C, 23, c[47]), W = p(W, R, Q, _, b, 6, c[48]), _ = p(_, W, R, Q, $, 10, c[49]), Q = p(Q, _, W, R, J, 15, c[50]), R = p(R, Q, _, W, A, 21, c[51]), W = p(W, R, Q, _, z, 6, c[52]), _ = p(_, W, R, Q, k, 10, c[53]), Q = p(Q, _, W, R, D, 15, c[54]), R = p(R, Q, _, W, w, 21, c[55]), W = p(W, R, Q, _, j, 6, c[56]), _ = p(_, W, R, Q, L, 10, c[57]), Q = p(Q, _, W, R, E, 15, c[58]), R = p(R, Q, _, W, Z, 21, c[59]), W = p(W, R, Q, _, T, 6, c[60]), _ = p(_, W, R, Q, N, 10, c[61]), Q = p(Q, _, W, R, C, 15, c[62]), R = p(R, Q, _, W, B, 21, c[63]), S[0] = S[0] + W | 0, S[1] = S[1] + R | 0, S[2] = S[2] + Q | 0, S[3] = S[3] + _ | 0;
          },
          _doFinalize: function() {
            var O = this._data, m = O.words, x = this._nDataBytes * 8, v = O.sigBytes * 8;
            m[v >>> 5] |= 128 << 24 - v % 32;
            var y = r.floor(x / 4294967296), S = x;
            m[(v + 64 >>> 9 << 4) + 15] = (y << 8 | y >>> 24) & 16711935 | (y << 24 | y >>> 8) & 4278255360, m[(v + 64 >>> 9 << 4) + 14] = (S << 8 | S >>> 24) & 16711935 | (S << 24 | S >>> 8) & 4278255360, O.sigBytes = (m.length + 1) * 4, this._process();
            for (var b = this._hash, w = b.words, C = 0; C < 4; C++) {
              var k = w[C];
              w[C] = (k << 8 | k >>> 24) & 16711935 | (k << 24 | k >>> 8) & 4278255360;
            }
            return b;
          },
          clone: function() {
            var O = a.clone.call(this);
            return O._hash = this._hash.clone(), O;
          }
        });
        function f(O, m, x, v, y, S, b) {
          var w = O + (m & x | ~m & v) + y + b;
          return (w << S | w >>> 32 - S) + m;
        }
        function d(O, m, x, v, y, S, b) {
          var w = O + (m & v | x & ~v) + y + b;
          return (w << S | w >>> 32 - S) + m;
        }
        function h(O, m, x, v, y, S, b) {
          var w = O + (m ^ x ^ v) + y + b;
          return (w << S | w >>> 32 - S) + m;
        }
        function p(O, m, x, v, y, S, b) {
          var w = O + (x ^ (m | ~v)) + y + b;
          return (w << S | w >>> 32 - S) + m;
        }
        i.MD5 = a._createHelper(u), i.HmacMD5 = a._createHmacHelper(u);
      }(Math), n.MD5;
    });
  }(O0)), O0.exports;
}
var x0 = { exports: {} };
var yC;
function Q$() {
  return yC || (yC = 1, function(t4, e) {
    (function(n, r) {
      t4.exports = r(tt());
    })(Ze, function(n) {
      return function() {
        var r = n, i = r.lib, o = i.WordArray, s = i.Hasher, a = r.algo, l = [], c = a.SHA1 = s.extend({
          _doReset: function() {
            this._hash = new o.init([
              1732584193,
              4023233417,
              2562383102,
              271733878,
              3285377520
            ]);
          },
          _doProcessBlock: function(u, f) {
            for (var d = this._hash.words, h = d[0], p = d[1], O = d[2], m = d[3], x = d[4], v = 0; v < 80; v++) {
              if (v < 16)
                l[v] = u[f + v] | 0;
              else {
                var y = l[v - 3] ^ l[v - 8] ^ l[v - 14] ^ l[v - 16];
                l[v] = y << 1 | y >>> 31;
              }
              var S = (h << 5 | h >>> 27) + x + l[v];
              v < 20 ? S += (p & O | ~p & m) + 1518500249 : v < 40 ? S += (p ^ O ^ m) + 1859775393 : v < 60 ? S += (p & O | p & m | O & m) - 1894007588 : S += (p ^ O ^ m) - 899497514, x = m, m = O, O = p << 30 | p >>> 2, p = h, h = S;
            }
            d[0] = d[0] + h | 0, d[1] = d[1] + p | 0, d[2] = d[2] + O | 0, d[3] = d[3] + m | 0, d[4] = d[4] + x | 0;
          },
          _doFinalize: function() {
            var u = this._data, f = u.words, d = this._nDataBytes * 8, h = u.sigBytes * 8;
            return f[h >>> 5] |= 128 << 24 - h % 32, f[(h + 64 >>> 9 << 4) + 14] = Math.floor(d / 4294967296), f[(h + 64 >>> 9 << 4) + 15] = d, u.sigBytes = f.length * 4, this._process(), this._hash;
          },
          clone: function() {
            var u = s.clone.call(this);
            return u._hash = this._hash.clone(), u;
          }
        });
        r.SHA1 = s._createHelper(c), r.HmacSHA1 = s._createHmacHelper(c);
      }(), n.SHA1;
    });
  }(x0)), x0.exports;
}
var v0 = { exports: {} };
var bC;
function hv() {
  return bC || (bC = 1, function(t4, e) {
    (function(n, r) {
      t4.exports = r(tt());
    })(Ze, function(n) {
      return function(r) {
        var i = n, o = i.lib, s = o.WordArray, a = o.Hasher, l = i.algo, c = [], u = [];
        (function() {
          function h(x) {
            for (var v = r.sqrt(x), y = 2; y <= v; y++)
              if (!(x % y))
                return false;
            return true;
          }
          function p(x) {
            return (x - (x | 0)) * 4294967296 | 0;
          }
          for (var O = 2, m = 0; m < 64; )
            h(O) && (m < 8 && (c[m] = p(r.pow(O, 1 / 2))), u[m] = p(r.pow(O, 1 / 3)), m++), O++;
        })();
        var f = [], d = l.SHA256 = a.extend({
          _doReset: function() {
            this._hash = new s.init(c.slice(0));
          },
          _doProcessBlock: function(h, p) {
            for (var O = this._hash.words, m = O[0], x = O[1], v = O[2], y = O[3], S = O[4], b = O[5], w = O[6], C = O[7], k = 0; k < 64; k++) {
              if (k < 16)
                f[k] = h[p + k] | 0;
              else {
                var T = f[k - 15], A = (T << 25 | T >>> 7) ^ (T << 14 | T >>> 18) ^ T >>> 3, E = f[k - 2], $ = (E << 15 | E >>> 17) ^ (E << 13 | E >>> 19) ^ E >>> 10;
                f[k] = A + f[k - 7] + $ + f[k - 16];
              }
              var j = S & b ^ ~S & w, B = m & x ^ m & v ^ x & v, D = (m << 30 | m >>> 2) ^ (m << 19 | m >>> 13) ^ (m << 10 | m >>> 22), N = (S << 26 | S >>> 6) ^ (S << 21 | S >>> 11) ^ (S << 7 | S >>> 25), z = C + N + j + u[k] + f[k], Z = D + B;
              C = w, w = b, b = S, S = y + z | 0, y = v, v = x, x = m, m = z + Z | 0;
            }
            O[0] = O[0] + m | 0, O[1] = O[1] + x | 0, O[2] = O[2] + v | 0, O[3] = O[3] + y | 0, O[4] = O[4] + S | 0, O[5] = O[5] + b | 0, O[6] = O[6] + w | 0, O[7] = O[7] + C | 0;
          },
          _doFinalize: function() {
            var h = this._data, p = h.words, O = this._nDataBytes * 8, m = h.sigBytes * 8;
            return p[m >>> 5] |= 128 << 24 - m % 32, p[(m + 64 >>> 9 << 4) + 14] = r.floor(O / 4294967296), p[(m + 64 >>> 9 << 4) + 15] = O, h.sigBytes = p.length * 4, this._process(), this._hash;
          },
          clone: function() {
            var h = a.clone.call(this);
            return h._hash = this._hash.clone(), h;
          }
        });
        i.SHA256 = a._createHelper(d), i.HmacSHA256 = a._createHmacHelper(d);
      }(Math), n.SHA256;
    });
  }(v0)), v0.exports;
}
var y0 = { exports: {} };
var SC;
function wq() {
  return SC || (SC = 1, function(t4, e) {
    (function(n, r, i) {
      t4.exports = r(tt(), hv());
    })(Ze, function(n) {
      return function() {
        var r = n, i = r.lib, o = i.WordArray, s = r.algo, a = s.SHA256, l = s.SHA224 = a.extend({
          _doReset: function() {
            this._hash = new o.init([
              3238371032,
              914150663,
              812702999,
              4144912697,
              4290775857,
              1750603025,
              1694076839,
              3204075428
            ]);
          },
          _doFinalize: function() {
            var c = a._doFinalize.call(this);
            return c.sigBytes -= 4, c;
          }
        });
        r.SHA224 = a._createHelper(l), r.HmacSHA224 = a._createHmacHelper(l);
      }(), n.SHA224;
    });
  }(y0)), y0.exports;
}
var b0 = { exports: {} };
var wC;
function B$() {
  return wC || (wC = 1, function(t4, e) {
    (function(n, r, i) {
      t4.exports = r(tt(), Th());
    })(Ze, function(n) {
      return function() {
        var r = n, i = r.lib, o = i.Hasher, s = r.x64, a = s.Word, l = s.WordArray, c = r.algo;
        function u() {
          return a.create.apply(a, arguments);
        }
        var f = [
          u(1116352408, 3609767458),
          u(1899447441, 602891725),
          u(3049323471, 3964484399),
          u(3921009573, 2173295548),
          u(961987163, 4081628472),
          u(1508970993, 3053834265),
          u(2453635748, 2937671579),
          u(2870763221, 3664609560),
          u(3624381080, 2734883394),
          u(310598401, 1164996542),
          u(607225278, 1323610764),
          u(1426881987, 3590304994),
          u(1925078388, 4068182383),
          u(2162078206, 991336113),
          u(2614888103, 633803317),
          u(3248222580, 3479774868),
          u(3835390401, 2666613458),
          u(4022224774, 944711139),
          u(264347078, 2341262773),
          u(604807628, 2007800933),
          u(770255983, 1495990901),
          u(1249150122, 1856431235),
          u(1555081692, 3175218132),
          u(1996064986, 2198950837),
          u(2554220882, 3999719339),
          u(2821834349, 766784016),
          u(2952996808, 2566594879),
          u(3210313671, 3203337956),
          u(3336571891, 1034457026),
          u(3584528711, 2466948901),
          u(113926993, 3758326383),
          u(338241895, 168717936),
          u(666307205, 1188179964),
          u(773529912, 1546045734),
          u(1294757372, 1522805485),
          u(1396182291, 2643833823),
          u(1695183700, 2343527390),
          u(1986661051, 1014477480),
          u(2177026350, 1206759142),
          u(2456956037, 344077627),
          u(2730485921, 1290863460),
          u(2820302411, 3158454273),
          u(3259730800, 3505952657),
          u(3345764771, 106217008),
          u(3516065817, 3606008344),
          u(3600352804, 1432725776),
          u(4094571909, 1467031594),
          u(275423344, 851169720),
          u(430227734, 3100823752),
          u(506948616, 1363258195),
          u(659060556, 3750685593),
          u(883997877, 3785050280),
          u(958139571, 3318307427),
          u(1322822218, 3812723403),
          u(1537002063, 2003034995),
          u(1747873779, 3602036899),
          u(1955562222, 1575990012),
          u(2024104815, 1125592928),
          u(2227730452, 2716904306),
          u(2361852424, 442776044),
          u(2428436474, 593698344),
          u(2756734187, 3733110249),
          u(3204031479, 2999351573),
          u(3329325298, 3815920427),
          u(3391569614, 3928383900),
          u(3515267271, 566280711),
          u(3940187606, 3454069534),
          u(4118630271, 4000239992),
          u(116418474, 1914138554),
          u(174292421, 2731055270),
          u(289380356, 3203993006),
          u(460393269, 320620315),
          u(685471733, 587496836),
          u(852142971, 1086792851),
          u(1017036298, 365543100),
          u(1126000580, 2618297676),
          u(1288033470, 3409855158),
          u(1501505948, 4234509866),
          u(1607167915, 987167468),
          u(1816402316, 1246189591)
        ], d = [];
        (function() {
          for (var p = 0; p < 80; p++)
            d[p] = u();
        })();
        var h = c.SHA512 = o.extend({
          _doReset: function() {
            this._hash = new l.init([
              new a.init(1779033703, 4089235720),
              new a.init(3144134277, 2227873595),
              new a.init(1013904242, 4271175723),
              new a.init(2773480762, 1595750129),
              new a.init(1359893119, 2917565137),
              new a.init(2600822924, 725511199),
              new a.init(528734635, 4215389547),
              new a.init(1541459225, 327033209)
            ]);
          },
          _doProcessBlock: function(p, O) {
            for (var m = this._hash.words, x = m[0], v = m[1], y = m[2], S = m[3], b = m[4], w = m[5], C = m[6], k = m[7], T = x.high, A = x.low, E = v.high, $ = v.low, j = y.high, B = y.low, D = S.high, N = S.low, z = b.high, Z = b.low, J = w.high, L = w.low, W = C.high, R = C.low, Q = k.high, _ = k.low, G = T, M = A, K = E, V = $, ae = j, te = B, oe = D, Y = N, he = z, X = Z, ee = J, de = L, ve = W, Re = R, ye = Q, Ee = _, $e = 0; $e < 80; $e++) {
              var Ge, Je, be = d[$e];
              if ($e < 16)
                Je = be.high = p[O + $e * 2] | 0, Ge = be.low = p[O + $e * 2 + 1] | 0;
              else {
                var lt = d[$e - 15], wt = lt.high, nn = lt.low, gn = (wt >>> 1 | nn << 31) ^ (wt >>> 8 | nn << 24) ^ wt >>> 7, xn = (nn >>> 1 | wt << 31) ^ (nn >>> 8 | wt << 24) ^ (nn >>> 7 | wt << 25), vn = d[$e - 2], Wn = vn.high, rn = vn.low, zo = (Wn >>> 19 | rn << 13) ^ (Wn << 3 | rn >>> 29) ^ Wn >>> 6, _i = (rn >>> 19 | Wn << 13) ^ (rn << 3 | Wn >>> 29) ^ (rn >>> 6 | Wn << 26), ro = d[$e - 7], Wr = ro.high, Rn = ro.low, lr = d[$e - 16], Vn = lr.high, on = lr.low;
                Ge = xn + Rn, Je = gn + Wr + (Ge >>> 0 < xn >>> 0 ? 1 : 0), Ge = Ge + _i, Je = Je + zo + (Ge >>> 0 < _i >>> 0 ? 1 : 0), Ge = Ge + on, Je = Je + Vn + (Ge >>> 0 < on >>> 0 ? 1 : 0), be.high = Je, be.low = Ge;
              }
              var cr = he & ee ^ ~he & ve, Vr = X & de ^ ~X & Re, zn = G & K ^ G & ae ^ K & ae, Dt = M & V ^ M & te ^ V & te, Qt = (G >>> 28 | M << 4) ^ (G << 30 | M >>> 2) ^ (G << 25 | M >>> 7), At = (M >>> 28 | G << 4) ^ (M << 30 | G >>> 2) ^ (M << 25 | G >>> 7), ri = (he >>> 14 | X << 18) ^ (he >>> 18 | X << 14) ^ (he << 23 | X >>> 9), ur = (X >>> 14 | he << 18) ^ (X >>> 18 | he << 14) ^ (X << 23 | he >>> 9), fr = f[$e], Mi = fr.high, ii = fr.low, Mt = Ee + ur, Vt = ye + ri + (Mt >>> 0 < Ee >>> 0 ? 1 : 0), Mt = Mt + Vr, Vt = Vt + cr + (Mt >>> 0 < Vr >>> 0 ? 1 : 0), Mt = Mt + ii, Vt = Vt + Mi + (Mt >>> 0 < ii >>> 0 ? 1 : 0), Mt = Mt + Ge, Vt = Vt + Je + (Mt >>> 0 < Ge >>> 0 ? 1 : 0), io = At + Dt, Ni = Qt + zn + (io >>> 0 < At >>> 0 ? 1 : 0);
              ye = ve, Ee = Re, ve = ee, Re = de, ee = he, de = X, X = Y + Mt | 0, he = oe + Vt + (X >>> 0 < Y >>> 0 ? 1 : 0) | 0, oe = ae, Y = te, ae = K, te = V, K = G, V = M, M = Mt + io | 0, G = Vt + Ni + (M >>> 0 < Mt >>> 0 ? 1 : 0) | 0;
            }
            A = x.low = A + M, x.high = T + G + (A >>> 0 < M >>> 0 ? 1 : 0), $ = v.low = $ + V, v.high = E + K + ($ >>> 0 < V >>> 0 ? 1 : 0), B = y.low = B + te, y.high = j + ae + (B >>> 0 < te >>> 0 ? 1 : 0), N = S.low = N + Y, S.high = D + oe + (N >>> 0 < Y >>> 0 ? 1 : 0), Z = b.low = Z + X, b.high = z + he + (Z >>> 0 < X >>> 0 ? 1 : 0), L = w.low = L + de, w.high = J + ee + (L >>> 0 < de >>> 0 ? 1 : 0), R = C.low = R + Re, C.high = W + ve + (R >>> 0 < Re >>> 0 ? 1 : 0), _ = k.low = _ + Ee, k.high = Q + ye + (_ >>> 0 < Ee >>> 0 ? 1 : 0);
          },
          _doFinalize: function() {
            var p = this._data, O = p.words, m = this._nDataBytes * 8, x = p.sigBytes * 8;
            O[x >>> 5] |= 128 << 24 - x % 32, O[(x + 128 >>> 10 << 5) + 30] = Math.floor(m / 4294967296), O[(x + 128 >>> 10 << 5) + 31] = m, p.sigBytes = O.length * 4, this._process();
            var v = this._hash.toX32();
            return v;
          },
          clone: function() {
            var p = o.clone.call(this);
            return p._hash = this._hash.clone(), p;
          },
          blockSize: 1024 / 32
        });
        r.SHA512 = o._createHelper(h), r.HmacSHA512 = o._createHmacHelper(h);
      }(), n.SHA512;
    });
  }(b0)), b0.exports;
}
var S0 = { exports: {} };
var CC;
function Cq() {
  return CC || (CC = 1, function(t4, e) {
    (function(n, r, i) {
      t4.exports = r(tt(), Th(), B$());
    })(Ze, function(n) {
      return function() {
        var r = n, i = r.x64, o = i.Word, s = i.WordArray, a = r.algo, l = a.SHA512, c = a.SHA384 = l.extend({
          _doReset: function() {
            this._hash = new s.init([
              new o.init(3418070365, 3238371032),
              new o.init(1654270250, 914150663),
              new o.init(2438529370, 812702999),
              new o.init(355462360, 4144912697),
              new o.init(1731405415, 4290775857),
              new o.init(2394180231, 1750603025),
              new o.init(3675008525, 1694076839),
              new o.init(1203062813, 3204075428)
            ]);
          },
          _doFinalize: function() {
            var u = l._doFinalize.call(this);
            return u.sigBytes -= 16, u;
          }
        });
        r.SHA384 = l._createHelper(c), r.HmacSHA384 = l._createHmacHelper(c);
      }(), n.SHA384;
    });
  }(S0)), S0.exports;
}
var w0 = { exports: {} };
var kC;
function kq() {
  return kC || (kC = 1, function(t4, e) {
    (function(n, r, i) {
      t4.exports = r(tt(), Th());
    })(Ze, function(n) {
      return function(r) {
        var i = n, o = i.lib, s = o.WordArray, a = o.Hasher, l = i.x64, c = l.Word, u = i.algo, f = [], d = [], h = [];
        (function() {
          for (var m = 1, x = 0, v = 0; v < 24; v++) {
            f[m + 5 * x] = (v + 1) * (v + 2) / 2 % 64;
            var y = x % 5, S = (2 * m + 3 * x) % 5;
            m = y, x = S;
          }
          for (var m = 0; m < 5; m++)
            for (var x = 0; x < 5; x++)
              d[m + 5 * x] = x + (2 * m + 3 * x) % 5 * 5;
          for (var b = 1, w = 0; w < 24; w++) {
            for (var C = 0, k = 0, T = 0; T < 7; T++) {
              if (b & 1) {
                var A = (1 << T) - 1;
                A < 32 ? k ^= 1 << A : C ^= 1 << A - 32;
              }
              b & 128 ? b = b << 1 ^ 113 : b <<= 1;
            }
            h[w] = c.create(C, k);
          }
        })();
        var p = [];
        (function() {
          for (var m = 0; m < 25; m++)
            p[m] = c.create();
        })();
        var O = u.SHA3 = a.extend({
          /**
           * Configuration options.
           *
           * @property {number} outputLength
           *   The desired number of bits in the output hash.
           *   Only values permitted are: 224, 256, 384, 512.
           *   Default: 512
           */
          cfg: a.cfg.extend({
            outputLength: 512
          }),
          _doReset: function() {
            for (var m = this._state = [], x = 0; x < 25; x++)
              m[x] = new c.init();
            this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
          },
          _doProcessBlock: function(m, x) {
            for (var v = this._state, y = this.blockSize / 2, S = 0; S < y; S++) {
              var b = m[x + 2 * S], w = m[x + 2 * S + 1];
              b = (b << 8 | b >>> 24) & 16711935 | (b << 24 | b >>> 8) & 4278255360, w = (w << 8 | w >>> 24) & 16711935 | (w << 24 | w >>> 8) & 4278255360;
              var C = v[S];
              C.high ^= w, C.low ^= b;
            }
            for (var k = 0; k < 24; k++) {
              for (var T = 0; T < 5; T++) {
                for (var A = 0, E = 0, $ = 0; $ < 5; $++) {
                  var C = v[T + 5 * $];
                  A ^= C.high, E ^= C.low;
                }
                var j = p[T];
                j.high = A, j.low = E;
              }
              for (var T = 0; T < 5; T++)
                for (var B = p[(T + 4) % 5], D = p[(T + 1) % 5], N = D.high, z = D.low, A = B.high ^ (N << 1 | z >>> 31), E = B.low ^ (z << 1 | N >>> 31), $ = 0; $ < 5; $++) {
                  var C = v[T + 5 * $];
                  C.high ^= A, C.low ^= E;
                }
              for (var Z = 1; Z < 25; Z++) {
                var A, E, C = v[Z], J = C.high, L = C.low, W = f[Z];
                W < 32 ? (A = J << W | L >>> 32 - W, E = L << W | J >>> 32 - W) : (A = L << W - 32 | J >>> 64 - W, E = J << W - 32 | L >>> 64 - W);
                var R = p[d[Z]];
                R.high = A, R.low = E;
              }
              var Q = p[0], _ = v[0];
              Q.high = _.high, Q.low = _.low;
              for (var T = 0; T < 5; T++)
                for (var $ = 0; $ < 5; $++) {
                  var Z = T + 5 * $, C = v[Z], G = p[Z], M = p[(T + 1) % 5 + 5 * $], K = p[(T + 2) % 5 + 5 * $];
                  C.high = G.high ^ ~M.high & K.high, C.low = G.low ^ ~M.low & K.low;
                }
              var C = v[0], V = h[k];
              C.high ^= V.high, C.low ^= V.low;
            }
          },
          _doFinalize: function() {
            var m = this._data, x = m.words;
            this._nDataBytes * 8;
            var v = m.sigBytes * 8, y = this.blockSize * 32;
            x[v >>> 5] |= 1 << 24 - v % 32, x[(r.ceil((v + 1) / y) * y >>> 5) - 1] |= 128, m.sigBytes = x.length * 4, this._process();
            for (var S = this._state, b = this.cfg.outputLength / 8, w = b / 8, C = [], k = 0; k < w; k++) {
              var T = S[k], A = T.high, E = T.low;
              A = (A << 8 | A >>> 24) & 16711935 | (A << 24 | A >>> 8) & 4278255360, E = (E << 8 | E >>> 24) & 16711935 | (E << 24 | E >>> 8) & 4278255360, C.push(E), C.push(A);
            }
            return new s.init(C, b);
          },
          clone: function() {
            for (var m = a.clone.call(this), x = m._state = this._state.slice(0), v = 0; v < 25; v++)
              x[v] = x[v].clone();
            return m;
          }
        });
        i.SHA3 = a._createHelper(O), i.HmacSHA3 = a._createHmacHelper(O);
      }(Math), n.SHA3;
    });
  }(w0)), w0.exports;
}
var C0 = { exports: {} };
var AC;
function Aq() {
  return AC || (AC = 1, function(t4, e) {
    (function(n, r) {
      t4.exports = r(tt());
    })(Ze, function(n) {
      return function(r) {
        var i = n, o = i.lib, s = o.WordArray, a = o.Hasher, l = i.algo, c = s.create([
          0,
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15,
          7,
          4,
          13,
          1,
          10,
          6,
          15,
          3,
          12,
          0,
          9,
          5,
          2,
          14,
          11,
          8,
          3,
          10,
          14,
          4,
          9,
          15,
          8,
          1,
          2,
          7,
          0,
          6,
          13,
          11,
          5,
          12,
          1,
          9,
          11,
          10,
          0,
          8,
          12,
          4,
          13,
          3,
          7,
          15,
          14,
          5,
          6,
          2,
          4,
          0,
          5,
          9,
          7,
          12,
          2,
          10,
          14,
          1,
          3,
          8,
          11,
          6,
          15,
          13
        ]), u = s.create([
          5,
          14,
          7,
          0,
          9,
          2,
          11,
          4,
          13,
          6,
          15,
          8,
          1,
          10,
          3,
          12,
          6,
          11,
          3,
          7,
          0,
          13,
          5,
          10,
          14,
          15,
          8,
          12,
          4,
          9,
          1,
          2,
          15,
          5,
          1,
          3,
          7,
          14,
          6,
          9,
          11,
          8,
          12,
          2,
          10,
          0,
          4,
          13,
          8,
          6,
          4,
          1,
          3,
          11,
          15,
          0,
          5,
          12,
          2,
          13,
          9,
          7,
          10,
          14,
          12,
          15,
          10,
          4,
          1,
          5,
          8,
          7,
          6,
          2,
          13,
          14,
          0,
          3,
          9,
          11
        ]), f = s.create([
          11,
          14,
          15,
          12,
          5,
          8,
          7,
          9,
          11,
          13,
          14,
          15,
          6,
          7,
          9,
          8,
          7,
          6,
          8,
          13,
          11,
          9,
          7,
          15,
          7,
          12,
          15,
          9,
          11,
          7,
          13,
          12,
          11,
          13,
          6,
          7,
          14,
          9,
          13,
          15,
          14,
          8,
          13,
          6,
          5,
          12,
          7,
          5,
          11,
          12,
          14,
          15,
          14,
          15,
          9,
          8,
          9,
          14,
          5,
          6,
          8,
          6,
          5,
          12,
          9,
          15,
          5,
          11,
          6,
          8,
          13,
          12,
          5,
          12,
          13,
          14,
          11,
          8,
          5,
          6
        ]), d = s.create([
          8,
          9,
          9,
          11,
          13,
          15,
          15,
          5,
          7,
          7,
          8,
          11,
          14,
          14,
          12,
          6,
          9,
          13,
          15,
          7,
          12,
          8,
          9,
          11,
          7,
          7,
          12,
          7,
          6,
          15,
          13,
          11,
          9,
          7,
          15,
          11,
          8,
          6,
          6,
          14,
          12,
          13,
          5,
          14,
          13,
          13,
          7,
          5,
          15,
          5,
          8,
          11,
          14,
          14,
          6,
          14,
          6,
          9,
          12,
          9,
          12,
          5,
          15,
          8,
          8,
          5,
          12,
          9,
          12,
          5,
          14,
          6,
          8,
          13,
          6,
          5,
          15,
          13,
          11,
          11
        ]), h = s.create([0, 1518500249, 1859775393, 2400959708, 2840853838]), p = s.create([1352829926, 1548603684, 1836072691, 2053994217, 0]), O = l.RIPEMD160 = a.extend({
          _doReset: function() {
            this._hash = s.create([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
          },
          _doProcessBlock: function(w, C) {
            for (var k = 0; k < 16; k++) {
              var T = C + k, A = w[T];
              w[T] = (A << 8 | A >>> 24) & 16711935 | (A << 24 | A >>> 8) & 4278255360;
            }
            var E = this._hash.words, $ = h.words, j = p.words, B = c.words, D = u.words, N = f.words, z = d.words, Z, J, L, W, R, Q, _, G, M, K;
            Q = Z = E[0], _ = J = E[1], G = L = E[2], M = W = E[3], K = R = E[4];
            for (var V, k = 0; k < 80; k += 1)
              V = Z + w[C + B[k]] | 0, k < 16 ? V += m(J, L, W) + $[0] : k < 32 ? V += x(J, L, W) + $[1] : k < 48 ? V += v(J, L, W) + $[2] : k < 64 ? V += y(J, L, W) + $[3] : V += S(J, L, W) + $[4], V = V | 0, V = b(V, N[k]), V = V + R | 0, Z = R, R = W, W = b(L, 10), L = J, J = V, V = Q + w[C + D[k]] | 0, k < 16 ? V += S(_, G, M) + j[0] : k < 32 ? V += y(_, G, M) + j[1] : k < 48 ? V += v(_, G, M) + j[2] : k < 64 ? V += x(_, G, M) + j[3] : V += m(_, G, M) + j[4], V = V | 0, V = b(V, z[k]), V = V + K | 0, Q = K, K = M, M = b(G, 10), G = _, _ = V;
            V = E[1] + L + M | 0, E[1] = E[2] + W + K | 0, E[2] = E[3] + R + Q | 0, E[3] = E[4] + Z + _ | 0, E[4] = E[0] + J + G | 0, E[0] = V;
          },
          _doFinalize: function() {
            var w = this._data, C = w.words, k = this._nDataBytes * 8, T = w.sigBytes * 8;
            C[T >>> 5] |= 128 << 24 - T % 32, C[(T + 64 >>> 9 << 4) + 14] = (k << 8 | k >>> 24) & 16711935 | (k << 24 | k >>> 8) & 4278255360, w.sigBytes = (C.length + 1) * 4, this._process();
            for (var A = this._hash, E = A.words, $ = 0; $ < 5; $++) {
              var j = E[$];
              E[$] = (j << 8 | j >>> 24) & 16711935 | (j << 24 | j >>> 8) & 4278255360;
            }
            return A;
          },
          clone: function() {
            var w = a.clone.call(this);
            return w._hash = this._hash.clone(), w;
          }
        });
        function m(w, C, k) {
          return w ^ C ^ k;
        }
        function x(w, C, k) {
          return w & C | ~w & k;
        }
        function v(w, C, k) {
          return (w | ~C) ^ k;
        }
        function y(w, C, k) {
          return w & k | C & ~k;
        }
        function S(w, C, k) {
          return w ^ (C | ~k);
        }
        function b(w, C) {
          return w << C | w >>> 32 - C;
        }
        i.RIPEMD160 = a._createHelper(O), i.HmacRIPEMD160 = a._createHmacHelper(O);
      }(), n.RIPEMD160;
    });
  }(C0)), C0.exports;
}
var k0 = { exports: {} };
var PC;
function pv() {
  return PC || (PC = 1, function(t4, e) {
    (function(n, r) {
      t4.exports = r(tt());
    })(Ze, function(n) {
      (function() {
        var r = n, i = r.lib, o = i.Base, s = r.enc, a = s.Utf8, l = r.algo;
        l.HMAC = o.extend({
          /**
           * Initializes a newly created HMAC.
           *
           * @param {Hasher} hasher The hash algorithm to use.
           * @param {WordArray|string} key The secret key.
           *
           * @example
           *
           *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
           */
          init: function(c, u) {
            c = this._hasher = new c.init(), typeof u == "string" && (u = a.parse(u));
            var f = c.blockSize, d = f * 4;
            u.sigBytes > d && (u = c.finalize(u)), u.clamp();
            for (var h = this._oKey = u.clone(), p = this._iKey = u.clone(), O = h.words, m = p.words, x = 0; x < f; x++)
              O[x] ^= 1549556828, m[x] ^= 909522486;
            h.sigBytes = p.sigBytes = d, this.reset();
          },
          /**
           * Resets this HMAC to its initial state.
           *
           * @example
           *
           *     hmacHasher.reset();
           */
          reset: function() {
            var c = this._hasher;
            c.reset(), c.update(this._iKey);
          },
          /**
           * Updates this HMAC with a message.
           *
           * @param {WordArray|string} messageUpdate The message to append.
           *
           * @return {HMAC} This HMAC instance.
           *
           * @example
           *
           *     hmacHasher.update('message');
           *     hmacHasher.update(wordArray);
           */
          update: function(c) {
            return this._hasher.update(c), this;
          },
          /**
           * Finalizes the HMAC computation.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} messageUpdate (Optional) A final message update.
           *
           * @return {WordArray} The HMAC.
           *
           * @example
           *
           *     var hmac = hmacHasher.finalize();
           *     var hmac = hmacHasher.finalize('message');
           *     var hmac = hmacHasher.finalize(wordArray);
           */
          finalize: function(c) {
            var u = this._hasher, f = u.finalize(c);
            u.reset();
            var d = u.finalize(this._oKey.clone().concat(f));
            return d;
          }
        });
      })();
    });
  }(k0)), k0.exports;
}
var A0 = { exports: {} };
var EC;
function Pq() {
  return EC || (EC = 1, function(t4, e) {
    (function(n, r, i) {
      t4.exports = r(tt(), hv(), pv());
    })(Ze, function(n) {
      return function() {
        var r = n, i = r.lib, o = i.Base, s = i.WordArray, a = r.algo, l = a.SHA256, c = a.HMAC, u = a.PBKDF2 = o.extend({
          /**
           * Configuration options.
           *
           * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
           * @property {Hasher} hasher The hasher to use. Default: SHA256
           * @property {number} iterations The number of iterations to perform. Default: 250000
           */
          cfg: o.extend({
            keySize: 128 / 32,
            hasher: l,
            iterations: 25e4
          }),
          /**
           * Initializes a newly created key derivation function.
           *
           * @param {Object} cfg (Optional) The configuration options to use for the derivation.
           *
           * @example
           *
           *     var kdf = CryptoJS.algo.PBKDF2.create();
           *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8 });
           *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8, iterations: 1000 });
           */
          init: function(f) {
            this.cfg = this.cfg.extend(f);
          },
          /**
           * Computes the Password-Based Key Derivation Function 2.
           *
           * @param {WordArray|string} password The password.
           * @param {WordArray|string} salt A salt.
           *
           * @return {WordArray} The derived key.
           *
           * @example
           *
           *     var key = kdf.compute(password, salt);
           */
          compute: function(f, d) {
            for (var h = this.cfg, p = c.create(h.hasher, f), O = s.create(), m = s.create([1]), x = O.words, v = m.words, y = h.keySize, S = h.iterations; x.length < y; ) {
              var b = p.update(d).finalize(m);
              p.reset();
              for (var w = b.words, C = w.length, k = b, T = 1; T < S; T++) {
                k = p.finalize(k), p.reset();
                for (var A = k.words, E = 0; E < C; E++)
                  w[E] ^= A[E];
              }
              O.concat(b), v[0]++;
            }
            return O.sigBytes = y * 4, O;
          }
        });
        r.PBKDF2 = function(f, d, h) {
          return u.create(h).compute(f, d);
        };
      }(), n.PBKDF2;
    });
  }(A0)), A0.exports;
}
var P0 = { exports: {} };
var TC;
function Wo() {
  return TC || (TC = 1, function(t4, e) {
    (function(n, r, i) {
      t4.exports = r(tt(), Q$(), pv());
    })(Ze, function(n) {
      return function() {
        var r = n, i = r.lib, o = i.Base, s = i.WordArray, a = r.algo, l = a.MD5, c = a.EvpKDF = o.extend({
          /**
           * Configuration options.
           *
           * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
           * @property {Hasher} hasher The hash algorithm to use. Default: MD5
           * @property {number} iterations The number of iterations to perform. Default: 1
           */
          cfg: o.extend({
            keySize: 128 / 32,
            hasher: l,
            iterations: 1
          }),
          /**
           * Initializes a newly created key derivation function.
           *
           * @param {Object} cfg (Optional) The configuration options to use for the derivation.
           *
           * @example
           *
           *     var kdf = CryptoJS.algo.EvpKDF.create();
           *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
           *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
           */
          init: function(u) {
            this.cfg = this.cfg.extend(u);
          },
          /**
           * Derives a key from a password.
           *
           * @param {WordArray|string} password The password.
           * @param {WordArray|string} salt A salt.
           *
           * @return {WordArray} The derived key.
           *
           * @example
           *
           *     var key = kdf.compute(password, salt);
           */
          compute: function(u, f) {
            for (var d, h = this.cfg, p = h.hasher.create(), O = s.create(), m = O.words, x = h.keySize, v = h.iterations; m.length < x; ) {
              d && p.update(d), d = p.update(u).finalize(f), p.reset();
              for (var y = 1; y < v; y++)
                d = p.finalize(d), p.reset();
              O.concat(d);
            }
            return O.sigBytes = x * 4, O;
          }
        });
        r.EvpKDF = function(u, f, d) {
          return c.create(d).compute(u, f);
        };
      }(), n.EvpKDF;
    });
  }(P0)), P0.exports;
}
var E0 = { exports: {} };
var IC;
function On() {
  return IC || (IC = 1, function(t4, e) {
    (function(n, r, i) {
      t4.exports = r(tt(), Wo());
    })(Ze, function(n) {
      n.lib.Cipher || function(r) {
        var i = n, o = i.lib, s = o.Base, a = o.WordArray, l = o.BufferedBlockAlgorithm, c = i.enc;
        c.Utf8;
        var u = c.Base64, f = i.algo, d = f.EvpKDF, h = o.Cipher = l.extend({
          /**
           * Configuration options.
           *
           * @property {WordArray} iv The IV to use for this operation.
           */
          cfg: s.extend(),
          /**
           * Creates this cipher in encryption mode.
           *
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {Cipher} A cipher instance.
           *
           * @static
           *
           * @example
           *
           *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
           */
          createEncryptor: function(A, E) {
            return this.create(this._ENC_XFORM_MODE, A, E);
          },
          /**
           * Creates this cipher in decryption mode.
           *
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {Cipher} A cipher instance.
           *
           * @static
           *
           * @example
           *
           *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
           */
          createDecryptor: function(A, E) {
            return this.create(this._DEC_XFORM_MODE, A, E);
          },
          /**
           * Initializes a newly created cipher.
           *
           * @param {number} xformMode Either the encryption or decryption transormation mode constant.
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @example
           *
           *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
           */
          init: function(A, E, $) {
            this.cfg = this.cfg.extend($), this._xformMode = A, this._key = E, this.reset();
          },
          /**
           * Resets this cipher to its initial state.
           *
           * @example
           *
           *     cipher.reset();
           */
          reset: function() {
            l.reset.call(this), this._doReset();
          },
          /**
           * Adds data to be encrypted or decrypted.
           *
           * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
           *
           * @return {WordArray} The data after processing.
           *
           * @example
           *
           *     var encrypted = cipher.process('data');
           *     var encrypted = cipher.process(wordArray);
           */
          process: function(A) {
            return this._append(A), this._process();
          },
          /**
           * Finalizes the encryption or decryption process.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
           *
           * @return {WordArray} The data after final processing.
           *
           * @example
           *
           *     var encrypted = cipher.finalize();
           *     var encrypted = cipher.finalize('data');
           *     var encrypted = cipher.finalize(wordArray);
           */
          finalize: function(A) {
            A && this._append(A);
            var E = this._doFinalize();
            return E;
          },
          keySize: 128 / 32,
          ivSize: 128 / 32,
          _ENC_XFORM_MODE: 1,
          _DEC_XFORM_MODE: 2,
          /**
           * Creates shortcut functions to a cipher's object interface.
           *
           * @param {Cipher} cipher The cipher to create a helper for.
           *
           * @return {Object} An object with encrypt and decrypt shortcut functions.
           *
           * @static
           *
           * @example
           *
           *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
           */
          _createHelper: /* @__PURE__ */ function() {
            function A(E) {
              return typeof E == "string" ? T : w;
            }
            return function(E) {
              return {
                encrypt: function($, j, B) {
                  return A(j).encrypt(E, $, j, B);
                },
                decrypt: function($, j, B) {
                  return A(j).decrypt(E, $, j, B);
                }
              };
            };
          }()
        });
        o.StreamCipher = h.extend({
          _doFinalize: function() {
            var A = this._process(true);
            return A;
          },
          blockSize: 1
        });
        var p = i.mode = {}, O = o.BlockCipherMode = s.extend({
          /**
           * Creates this mode for encryption.
           *
           * @param {Cipher} cipher A block cipher instance.
           * @param {Array} iv The IV words.
           *
           * @static
           *
           * @example
           *
           *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
           */
          createEncryptor: function(A, E) {
            return this.Encryptor.create(A, E);
          },
          /**
           * Creates this mode for decryption.
           *
           * @param {Cipher} cipher A block cipher instance.
           * @param {Array} iv The IV words.
           *
           * @static
           *
           * @example
           *
           *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
           */
          createDecryptor: function(A, E) {
            return this.Decryptor.create(A, E);
          },
          /**
           * Initializes a newly created mode.
           *
           * @param {Cipher} cipher A block cipher instance.
           * @param {Array} iv The IV words.
           *
           * @example
           *
           *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
           */
          init: function(A, E) {
            this._cipher = A, this._iv = E;
          }
        }), m = p.CBC = function() {
          var A = O.extend();
          A.Encryptor = A.extend({
            /**
             * Processes the data block at offset.
             *
             * @param {Array} words The data words to operate on.
             * @param {number} offset The offset where the block starts.
             *
             * @example
             *
             *     mode.processBlock(data.words, offset);
             */
            processBlock: function($, j) {
              var B = this._cipher, D = B.blockSize;
              E.call(this, $, j, D), B.encryptBlock($, j), this._prevBlock = $.slice(j, j + D);
            }
          }), A.Decryptor = A.extend({
            /**
             * Processes the data block at offset.
             *
             * @param {Array} words The data words to operate on.
             * @param {number} offset The offset where the block starts.
             *
             * @example
             *
             *     mode.processBlock(data.words, offset);
             */
            processBlock: function($, j) {
              var B = this._cipher, D = B.blockSize, N = $.slice(j, j + D);
              B.decryptBlock($, j), E.call(this, $, j, D), this._prevBlock = N;
            }
          });
          function E($, j, B) {
            var D, N = this._iv;
            N ? (D = N, this._iv = r) : D = this._prevBlock;
            for (var z = 0; z < B; z++)
              $[j + z] ^= D[z];
          }
          return A;
        }(), x = i.pad = {}, v = x.Pkcs7 = {
          /**
           * Pads data using the algorithm defined in PKCS #5/7.
           *
           * @param {WordArray} data The data to pad.
           * @param {number} blockSize The multiple that the data should be padded to.
           *
           * @static
           *
           * @example
           *
           *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
           */
          pad: function(A, E) {
            for (var $ = E * 4, j = $ - A.sigBytes % $, B = j << 24 | j << 16 | j << 8 | j, D = [], N = 0; N < j; N += 4)
              D.push(B);
            var z = a.create(D, j);
            A.concat(z);
          },
          /**
           * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
           *
           * @param {WordArray} data The data to unpad.
           *
           * @static
           *
           * @example
           *
           *     CryptoJS.pad.Pkcs7.unpad(wordArray);
           */
          unpad: function(A) {
            var E = A.words[A.sigBytes - 1 >>> 2] & 255;
            A.sigBytes -= E;
          }
        };
        o.BlockCipher = h.extend({
          /**
           * Configuration options.
           *
           * @property {Mode} mode The block mode to use. Default: CBC
           * @property {Padding} padding The padding strategy to use. Default: Pkcs7
           */
          cfg: h.cfg.extend({
            mode: m,
            padding: v
          }),
          reset: function() {
            var A;
            h.reset.call(this);
            var E = this.cfg, $ = E.iv, j = E.mode;
            this._xformMode == this._ENC_XFORM_MODE ? A = j.createEncryptor : (A = j.createDecryptor, this._minBufferSize = 1), this._mode && this._mode.__creator == A ? this._mode.init(this, $ && $.words) : (this._mode = A.call(j, this, $ && $.words), this._mode.__creator = A);
          },
          _doProcessBlock: function(A, E) {
            this._mode.processBlock(A, E);
          },
          _doFinalize: function() {
            var A, E = this.cfg.padding;
            return this._xformMode == this._ENC_XFORM_MODE ? (E.pad(this._data, this.blockSize), A = this._process(true)) : (A = this._process(true), E.unpad(A)), A;
          },
          blockSize: 128 / 32
        });
        var y = o.CipherParams = s.extend({
          /**
           * Initializes a newly created cipher params object.
           *
           * @param {Object} cipherParams An object with any of the possible cipher parameters.
           *
           * @example
           *
           *     var cipherParams = CryptoJS.lib.CipherParams.create({
           *         ciphertext: ciphertextWordArray,
           *         key: keyWordArray,
           *         iv: ivWordArray,
           *         salt: saltWordArray,
           *         algorithm: CryptoJS.algo.AES,
           *         mode: CryptoJS.mode.CBC,
           *         padding: CryptoJS.pad.PKCS7,
           *         blockSize: 4,
           *         formatter: CryptoJS.format.OpenSSL
           *     });
           */
          init: function(A) {
            this.mixIn(A);
          },
          /**
           * Converts this cipher params object to a string.
           *
           * @param {Format} formatter (Optional) The formatting strategy to use.
           *
           * @return {string} The stringified cipher params.
           *
           * @throws Error If neither the formatter nor the default formatter is set.
           *
           * @example
           *
           *     var string = cipherParams + '';
           *     var string = cipherParams.toString();
           *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
           */
          toString: function(A) {
            return (A || this.formatter).stringify(this);
          }
        }), S = i.format = {}, b = S.OpenSSL = {
          /**
           * Converts a cipher params object to an OpenSSL-compatible string.
           *
           * @param {CipherParams} cipherParams The cipher params object.
           *
           * @return {string} The OpenSSL-compatible string.
           *
           * @static
           *
           * @example
           *
           *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
           */
          stringify: function(A) {
            var E, $ = A.ciphertext, j = A.salt;
            return j ? E = a.create([1398893684, 1701076831]).concat(j).concat($) : E = $, E.toString(u);
          },
          /**
           * Converts an OpenSSL-compatible string to a cipher params object.
           *
           * @param {string} openSSLStr The OpenSSL-compatible string.
           *
           * @return {CipherParams} The cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
           */
          parse: function(A) {
            var E, $ = u.parse(A), j = $.words;
            return j[0] == 1398893684 && j[1] == 1701076831 && (E = a.create(j.slice(2, 4)), j.splice(0, 4), $.sigBytes -= 16), y.create({ ciphertext: $, salt: E });
          }
        }, w = o.SerializableCipher = s.extend({
          /**
           * Configuration options.
           *
           * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
           */
          cfg: s.extend({
            format: b
          }),
          /**
           * Encrypts a message.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {WordArray|string} message The message to encrypt.
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {CipherParams} A cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
           */
          encrypt: function(A, E, $, j) {
            j = this.cfg.extend(j);
            var B = A.createEncryptor($, j), D = B.finalize(E), N = B.cfg;
            return y.create({
              ciphertext: D,
              key: $,
              iv: N.iv,
              algorithm: A,
              mode: N.mode,
              padding: N.padding,
              blockSize: A.blockSize,
              formatter: j.format
            });
          },
          /**
           * Decrypts serialized ciphertext.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {WordArray} The plaintext.
           *
           * @static
           *
           * @example
           *
           *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
           *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
           */
          decrypt: function(A, E, $, j) {
            j = this.cfg.extend(j), E = this._parse(E, j.format);
            var B = A.createDecryptor($, j).finalize(E.ciphertext);
            return B;
          },
          /**
           * Converts serialized ciphertext to CipherParams,
           * else assumed CipherParams already and returns ciphertext unchanged.
           *
           * @param {CipherParams|string} ciphertext The ciphertext.
           * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
           *
           * @return {CipherParams} The unserialized ciphertext.
           *
           * @static
           *
           * @example
           *
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
           */
          _parse: function(A, E) {
            return typeof A == "string" ? E.parse(A, this) : A;
          }
        }), C = i.kdf = {}, k = C.OpenSSL = {
          /**
           * Derives a key and IV from a password.
           *
           * @param {string} password The password to derive from.
           * @param {number} keySize The size in words of the key to generate.
           * @param {number} ivSize The size in words of the IV to generate.
           * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
           *
           * @return {CipherParams} A cipher params object with the key, IV, and salt.
           *
           * @static
           *
           * @example
           *
           *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
           *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
           */
          execute: function(A, E, $, j, B) {
            if (j || (j = a.random(64 / 8)), B)
              var D = d.create({ keySize: E + $, hasher: B }).compute(A, j);
            else
              var D = d.create({ keySize: E + $ }).compute(A, j);
            var N = a.create(D.words.slice(E), $ * 4);
            return D.sigBytes = E * 4, y.create({ key: D, iv: N, salt: j });
          }
        }, T = o.PasswordBasedCipher = w.extend({
          /**
           * Configuration options.
           *
           * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
           */
          cfg: w.cfg.extend({
            kdf: k
          }),
          /**
           * Encrypts a message using a password.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {WordArray|string} message The message to encrypt.
           * @param {string} password The password.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {CipherParams} A cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
           *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
           */
          encrypt: function(A, E, $, j) {
            j = this.cfg.extend(j);
            var B = j.kdf.execute($, A.keySize, A.ivSize, j.salt, j.hasher);
            j.iv = B.iv;
            var D = w.encrypt.call(this, A, E, B.key, j);
            return D.mixIn(B), D;
          },
          /**
           * Decrypts serialized ciphertext using a password.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
           * @param {string} password The password.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {WordArray} The plaintext.
           *
           * @static
           *
           * @example
           *
           *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
           *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
           */
          decrypt: function(A, E, $, j) {
            j = this.cfg.extend(j), E = this._parse(E, j.format);
            var B = j.kdf.execute($, A.keySize, A.ivSize, E.salt, j.hasher);
            j.iv = B.iv;
            var D = w.decrypt.call(this, A, E, B.key, j);
            return D;
          }
        });
      }();
    });
  }(E0)), E0.exports;
}
var T0 = { exports: {} };
var $C;
function Eq() {
  return $C || ($C = 1, function(t4, e) {
    (function(n, r, i) {
      t4.exports = r(tt(), On());
    })(Ze, function(n) {
      return n.mode.CFB = function() {
        var r = n.lib.BlockCipherMode.extend();
        r.Encryptor = r.extend({
          processBlock: function(o, s) {
            var a = this._cipher, l = a.blockSize;
            i.call(this, o, s, l, a), this._prevBlock = o.slice(s, s + l);
          }
        }), r.Decryptor = r.extend({
          processBlock: function(o, s) {
            var a = this._cipher, l = a.blockSize, c = o.slice(s, s + l);
            i.call(this, o, s, l, a), this._prevBlock = c;
          }
        });
        function i(o, s, a, l) {
          var c, u = this._iv;
          u ? (c = u.slice(0), this._iv = void 0) : c = this._prevBlock, l.encryptBlock(c, 0);
          for (var f = 0; f < a; f++)
            o[s + f] ^= c[f];
        }
        return r;
      }(), n.mode.CFB;
    });
  }(T0)), T0.exports;
}
var I0 = { exports: {} };
var jC;
function Tq() {
  return jC || (jC = 1, function(t4, e) {
    (function(n, r, i) {
      t4.exports = r(tt(), On());
    })(Ze, function(n) {
      return n.mode.CTR = function() {
        var r = n.lib.BlockCipherMode.extend(), i = r.Encryptor = r.extend({
          processBlock: function(o, s) {
            var a = this._cipher, l = a.blockSize, c = this._iv, u = this._counter;
            c && (u = this._counter = c.slice(0), this._iv = void 0);
            var f = u.slice(0);
            a.encryptBlock(f, 0), u[l - 1] = u[l - 1] + 1 | 0;
            for (var d = 0; d < l; d++)
              o[s + d] ^= f[d];
          }
        });
        return r.Decryptor = i, r;
      }(), n.mode.CTR;
    });
  }(I0)), I0.exports;
}
var $0 = { exports: {} };
var RC;
function Iq() {
  return RC || (RC = 1, function(t4, e) {
    (function(n, r, i) {
      t4.exports = r(tt(), On());
    })(Ze, function(n) {
      return n.mode.CTRGladman = function() {
        var r = n.lib.BlockCipherMode.extend();
        function i(a) {
          if ((a >> 24 & 255) === 255) {
            var l = a >> 16 & 255, c = a >> 8 & 255, u = a & 255;
            l === 255 ? (l = 0, c === 255 ? (c = 0, u === 255 ? u = 0 : ++u) : ++c) : ++l, a = 0, a += l << 16, a += c << 8, a += u;
          } else
            a += 1 << 24;
          return a;
        }
        function o(a) {
          return (a[0] = i(a[0])) === 0 && (a[1] = i(a[1])), a;
        }
        var s = r.Encryptor = r.extend({
          processBlock: function(a, l) {
            var c = this._cipher, u = c.blockSize, f = this._iv, d = this._counter;
            f && (d = this._counter = f.slice(0), this._iv = void 0), o(d);
            var h = d.slice(0);
            c.encryptBlock(h, 0);
            for (var p = 0; p < u; p++)
              a[l + p] ^= h[p];
          }
        });
        return r.Decryptor = s, r;
      }(), n.mode.CTRGladman;
    });
  }($0)), $0.exports;
}
var j0 = { exports: {} };
var DC;
function $q() {
  return DC || (DC = 1, function(t4, e) {
    (function(n, r, i) {
      t4.exports = r(tt(), On());
    })(Ze, function(n) {
      return n.mode.OFB = function() {
        var r = n.lib.BlockCipherMode.extend(), i = r.Encryptor = r.extend({
          processBlock: function(o, s) {
            var a = this._cipher, l = a.blockSize, c = this._iv, u = this._keystream;
            c && (u = this._keystream = c.slice(0), this._iv = void 0), a.encryptBlock(u, 0);
            for (var f = 0; f < l; f++)
              o[s + f] ^= u[f];
          }
        });
        return r.Decryptor = i, r;
      }(), n.mode.OFB;
    });
  }(j0)), j0.exports;
}
var R0 = { exports: {} };
var QC;
function jq() {
  return QC || (QC = 1, function(t4, e) {
    (function(n, r, i) {
      t4.exports = r(tt(), On());
    })(Ze, function(n) {
      return n.mode.ECB = function() {
        var r = n.lib.BlockCipherMode.extend();
        return r.Encryptor = r.extend({
          processBlock: function(i, o) {
            this._cipher.encryptBlock(i, o);
          }
        }), r.Decryptor = r.extend({
          processBlock: function(i, o) {
            this._cipher.decryptBlock(i, o);
          }
        }), r;
      }(), n.mode.ECB;
    });
  }(R0)), R0.exports;
}
var D0 = { exports: {} };
var BC;
function Rq() {
  return BC || (BC = 1, function(t4, e) {
    (function(n, r, i) {
      t4.exports = r(tt(), On());
    })(Ze, function(n) {
      return n.pad.AnsiX923 = {
        pad: function(r, i) {
          var o = r.sigBytes, s = i * 4, a = s - o % s, l = o + a - 1;
          r.clamp(), r.words[l >>> 2] |= a << 24 - l % 4 * 8, r.sigBytes += a;
        },
        unpad: function(r) {
          var i = r.words[r.sigBytes - 1 >>> 2] & 255;
          r.sigBytes -= i;
        }
      }, n.pad.Ansix923;
    });
  }(D0)), D0.exports;
}
var Q0 = { exports: {} };
var _C;
function Dq() {
  return _C || (_C = 1, function(t4, e) {
    (function(n, r, i) {
      t4.exports = r(tt(), On());
    })(Ze, function(n) {
      return n.pad.Iso10126 = {
        pad: function(r, i) {
          var o = i * 4, s = o - r.sigBytes % o;
          r.concat(n.lib.WordArray.random(s - 1)).concat(n.lib.WordArray.create([s << 24], 1));
        },
        unpad: function(r) {
          var i = r.words[r.sigBytes - 1 >>> 2] & 255;
          r.sigBytes -= i;
        }
      }, n.pad.Iso10126;
    });
  }(Q0)), Q0.exports;
}
var B0 = { exports: {} };
var MC;
function Qq() {
  return MC || (MC = 1, function(t4, e) {
    (function(n, r, i) {
      t4.exports = r(tt(), On());
    })(Ze, function(n) {
      return n.pad.Iso97971 = {
        pad: function(r, i) {
          r.concat(n.lib.WordArray.create([2147483648], 1)), n.pad.ZeroPadding.pad(r, i);
        },
        unpad: function(r) {
          n.pad.ZeroPadding.unpad(r), r.sigBytes--;
        }
      }, n.pad.Iso97971;
    });
  }(B0)), B0.exports;
}
var _0 = { exports: {} };
var NC;
function Bq() {
  return NC || (NC = 1, function(t4, e) {
    (function(n, r, i) {
      t4.exports = r(tt(), On());
    })(Ze, function(n) {
      return n.pad.ZeroPadding = {
        pad: function(r, i) {
          var o = i * 4;
          r.clamp(), r.sigBytes += o - (r.sigBytes % o || o);
        },
        unpad: function(r) {
          for (var i = r.words, o = r.sigBytes - 1, o = r.sigBytes - 1; o >= 0; o--)
            if (i[o >>> 2] >>> 24 - o % 4 * 8 & 255) {
              r.sigBytes = o + 1;
              break;
            }
        }
      }, n.pad.ZeroPadding;
    });
  }(_0)), _0.exports;
}
var M0 = { exports: {} };
var FC;
function _q() {
  return FC || (FC = 1, function(t4, e) {
    (function(n, r, i) {
      t4.exports = r(tt(), On());
    })(Ze, function(n) {
      return n.pad.NoPadding = {
        pad: function() {
        },
        unpad: function() {
        }
      }, n.pad.NoPadding;
    });
  }(M0)), M0.exports;
}
var N0 = { exports: {} };
var ZC;
function Mq() {
  return ZC || (ZC = 1, function(t4, e) {
    (function(n, r, i) {
      t4.exports = r(tt(), On());
    })(Ze, function(n) {
      return function(r) {
        var i = n, o = i.lib, s = o.CipherParams, a = i.enc, l = a.Hex, c = i.format;
        c.Hex = {
          /**
           * Converts the ciphertext of a cipher params object to a hexadecimally encoded string.
           *
           * @param {CipherParams} cipherParams The cipher params object.
           *
           * @return {string} The hexadecimally encoded string.
           *
           * @static
           *
           * @example
           *
           *     var hexString = CryptoJS.format.Hex.stringify(cipherParams);
           */
          stringify: function(u) {
            return u.ciphertext.toString(l);
          },
          /**
           * Converts a hexadecimally encoded ciphertext string to a cipher params object.
           *
           * @param {string} input The hexadecimally encoded string.
           *
           * @return {CipherParams} The cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var cipherParams = CryptoJS.format.Hex.parse(hexString);
           */
          parse: function(u) {
            var f = l.parse(u);
            return s.create({ ciphertext: f });
          }
        };
      }(), n.format.Hex;
    });
  }(N0)), N0.exports;
}
var F0 = { exports: {} };
var WC;
function Nq() {
  return WC || (WC = 1, function(t4, e) {
    (function(n, r, i) {
      t4.exports = r(tt(), As(), Ps(), Wo(), On());
    })(Ze, function(n) {
      return function() {
        var r = n, i = r.lib, o = i.BlockCipher, s = r.algo, a = [], l = [], c = [], u = [], f = [], d = [], h = [], p = [], O = [], m = [];
        (function() {
          for (var y = [], S = 0; S < 256; S++)
            S < 128 ? y[S] = S << 1 : y[S] = S << 1 ^ 283;
          for (var b = 0, w = 0, S = 0; S < 256; S++) {
            var C = w ^ w << 1 ^ w << 2 ^ w << 3 ^ w << 4;
            C = C >>> 8 ^ C & 255 ^ 99, a[b] = C, l[C] = b;
            var k = y[b], T = y[k], A = y[T], E = y[C] * 257 ^ C * 16843008;
            c[b] = E << 24 | E >>> 8, u[b] = E << 16 | E >>> 16, f[b] = E << 8 | E >>> 24, d[b] = E;
            var E = A * 16843009 ^ T * 65537 ^ k * 257 ^ b * 16843008;
            h[C] = E << 24 | E >>> 8, p[C] = E << 16 | E >>> 16, O[C] = E << 8 | E >>> 24, m[C] = E, b ? (b = k ^ y[y[y[A ^ k]]], w ^= y[y[w]]) : b = w = 1;
          }
        })();
        var x = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], v = s.AES = o.extend({
          _doReset: function() {
            var y;
            if (!(this._nRounds && this._keyPriorReset === this._key)) {
              for (var S = this._keyPriorReset = this._key, b = S.words, w = S.sigBytes / 4, C = this._nRounds = w + 6, k = (C + 1) * 4, T = this._keySchedule = [], A = 0; A < k; A++)
                A < w ? T[A] = b[A] : (y = T[A - 1], A % w ? w > 6 && A % w == 4 && (y = a[y >>> 24] << 24 | a[y >>> 16 & 255] << 16 | a[y >>> 8 & 255] << 8 | a[y & 255]) : (y = y << 8 | y >>> 24, y = a[y >>> 24] << 24 | a[y >>> 16 & 255] << 16 | a[y >>> 8 & 255] << 8 | a[y & 255], y ^= x[A / w | 0] << 24), T[A] = T[A - w] ^ y);
              for (var E = this._invKeySchedule = [], $ = 0; $ < k; $++) {
                var A = k - $;
                if ($ % 4)
                  var y = T[A];
                else
                  var y = T[A - 4];
                $ < 4 || A <= 4 ? E[$] = y : E[$] = h[a[y >>> 24]] ^ p[a[y >>> 16 & 255]] ^ O[a[y >>> 8 & 255]] ^ m[a[y & 255]];
              }
            }
          },
          encryptBlock: function(y, S) {
            this._doCryptBlock(y, S, this._keySchedule, c, u, f, d, a);
          },
          decryptBlock: function(y, S) {
            var b = y[S + 1];
            y[S + 1] = y[S + 3], y[S + 3] = b, this._doCryptBlock(y, S, this._invKeySchedule, h, p, O, m, l);
            var b = y[S + 1];
            y[S + 1] = y[S + 3], y[S + 3] = b;
          },
          _doCryptBlock: function(y, S, b, w, C, k, T, A) {
            for (var E = this._nRounds, $ = y[S] ^ b[0], j = y[S + 1] ^ b[1], B = y[S + 2] ^ b[2], D = y[S + 3] ^ b[3], N = 4, z = 1; z < E; z++) {
              var Z = w[$ >>> 24] ^ C[j >>> 16 & 255] ^ k[B >>> 8 & 255] ^ T[D & 255] ^ b[N++], J = w[j >>> 24] ^ C[B >>> 16 & 255] ^ k[D >>> 8 & 255] ^ T[$ & 255] ^ b[N++], L = w[B >>> 24] ^ C[D >>> 16 & 255] ^ k[$ >>> 8 & 255] ^ T[j & 255] ^ b[N++], W = w[D >>> 24] ^ C[$ >>> 16 & 255] ^ k[j >>> 8 & 255] ^ T[B & 255] ^ b[N++];
              $ = Z, j = J, B = L, D = W;
            }
            var Z = (A[$ >>> 24] << 24 | A[j >>> 16 & 255] << 16 | A[B >>> 8 & 255] << 8 | A[D & 255]) ^ b[N++], J = (A[j >>> 24] << 24 | A[B >>> 16 & 255] << 16 | A[D >>> 8 & 255] << 8 | A[$ & 255]) ^ b[N++], L = (A[B >>> 24] << 24 | A[D >>> 16 & 255] << 16 | A[$ >>> 8 & 255] << 8 | A[j & 255]) ^ b[N++], W = (A[D >>> 24] << 24 | A[$ >>> 16 & 255] << 16 | A[j >>> 8 & 255] << 8 | A[B & 255]) ^ b[N++];
            y[S] = Z, y[S + 1] = J, y[S + 2] = L, y[S + 3] = W;
          },
          keySize: 256 / 32
        });
        r.AES = o._createHelper(v);
      }(), n.AES;
    });
  }(F0)), F0.exports;
}
var Z0 = { exports: {} };
var VC;
function Fq() {
  return VC || (VC = 1, function(t4, e) {
    (function(n, r, i) {
      t4.exports = r(tt(), As(), Ps(), Wo(), On());
    })(Ze, function(n) {
      return function() {
        var r = n, i = r.lib, o = i.WordArray, s = i.BlockCipher, a = r.algo, l = [
          57,
          49,
          41,
          33,
          25,
          17,
          9,
          1,
          58,
          50,
          42,
          34,
          26,
          18,
          10,
          2,
          59,
          51,
          43,
          35,
          27,
          19,
          11,
          3,
          60,
          52,
          44,
          36,
          63,
          55,
          47,
          39,
          31,
          23,
          15,
          7,
          62,
          54,
          46,
          38,
          30,
          22,
          14,
          6,
          61,
          53,
          45,
          37,
          29,
          21,
          13,
          5,
          28,
          20,
          12,
          4
        ], c = [
          14,
          17,
          11,
          24,
          1,
          5,
          3,
          28,
          15,
          6,
          21,
          10,
          23,
          19,
          12,
          4,
          26,
          8,
          16,
          7,
          27,
          20,
          13,
          2,
          41,
          52,
          31,
          37,
          47,
          55,
          30,
          40,
          51,
          45,
          33,
          48,
          44,
          49,
          39,
          56,
          34,
          53,
          46,
          42,
          50,
          36,
          29,
          32
        ], u = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28], f = [
          {
            0: 8421888,
            268435456: 32768,
            536870912: 8421378,
            805306368: 2,
            1073741824: 512,
            1342177280: 8421890,
            1610612736: 8389122,
            1879048192: 8388608,
            2147483648: 514,
            2415919104: 8389120,
            2684354560: 33280,
            2952790016: 8421376,
            3221225472: 32770,
            3489660928: 8388610,
            3758096384: 0,
            4026531840: 33282,
            134217728: 0,
            402653184: 8421890,
            671088640: 33282,
            939524096: 32768,
            1207959552: 8421888,
            1476395008: 512,
            1744830464: 8421378,
            2013265920: 2,
            2281701376: 8389120,
            2550136832: 33280,
            2818572288: 8421376,
            3087007744: 8389122,
            3355443200: 8388610,
            3623878656: 32770,
            3892314112: 514,
            4160749568: 8388608,
            1: 32768,
            268435457: 2,
            536870913: 8421888,
            805306369: 8388608,
            1073741825: 8421378,
            1342177281: 33280,
            1610612737: 512,
            1879048193: 8389122,
            2147483649: 8421890,
            2415919105: 8421376,
            2684354561: 8388610,
            2952790017: 33282,
            3221225473: 514,
            3489660929: 8389120,
            3758096385: 32770,
            4026531841: 0,
            134217729: 8421890,
            402653185: 8421376,
            671088641: 8388608,
            939524097: 512,
            1207959553: 32768,
            1476395009: 8388610,
            1744830465: 2,
            2013265921: 33282,
            2281701377: 32770,
            2550136833: 8389122,
            2818572289: 514,
            3087007745: 8421888,
            3355443201: 8389120,
            3623878657: 0,
            3892314113: 33280,
            4160749569: 8421378
          },
          {
            0: 1074282512,
            16777216: 16384,
            33554432: 524288,
            50331648: 1074266128,
            67108864: 1073741840,
            83886080: 1074282496,
            100663296: 1073758208,
            117440512: 16,
            134217728: 540672,
            150994944: 1073758224,
            167772160: 1073741824,
            184549376: 540688,
            201326592: 524304,
            218103808: 0,
            234881024: 16400,
            251658240: 1074266112,
            8388608: 1073758208,
            25165824: 540688,
            41943040: 16,
            58720256: 1073758224,
            75497472: 1074282512,
            92274688: 1073741824,
            109051904: 524288,
            125829120: 1074266128,
            142606336: 524304,
            159383552: 0,
            176160768: 16384,
            192937984: 1074266112,
            209715200: 1073741840,
            226492416: 540672,
            243269632: 1074282496,
            260046848: 16400,
            268435456: 0,
            285212672: 1074266128,
            301989888: 1073758224,
            318767104: 1074282496,
            335544320: 1074266112,
            352321536: 16,
            369098752: 540688,
            385875968: 16384,
            402653184: 16400,
            419430400: 524288,
            436207616: 524304,
            452984832: 1073741840,
            469762048: 540672,
            486539264: 1073758208,
            503316480: 1073741824,
            520093696: 1074282512,
            276824064: 540688,
            293601280: 524288,
            310378496: 1074266112,
            327155712: 16384,
            343932928: 1073758208,
            360710144: 1074282512,
            377487360: 16,
            394264576: 1073741824,
            411041792: 1074282496,
            427819008: 1073741840,
            444596224: 1073758224,
            461373440: 524304,
            478150656: 0,
            494927872: 16400,
            511705088: 1074266128,
            528482304: 540672
          },
          {
            0: 260,
            1048576: 0,
            2097152: 67109120,
            3145728: 65796,
            4194304: 65540,
            5242880: 67108868,
            6291456: 67174660,
            7340032: 67174400,
            8388608: 67108864,
            9437184: 67174656,
            10485760: 65792,
            11534336: 67174404,
            12582912: 67109124,
            13631488: 65536,
            14680064: 4,
            15728640: 256,
            524288: 67174656,
            1572864: 67174404,
            2621440: 0,
            3670016: 67109120,
            4718592: 67108868,
            5767168: 65536,
            6815744: 65540,
            7864320: 260,
            8912896: 4,
            9961472: 256,
            11010048: 67174400,
            12058624: 65796,
            13107200: 65792,
            14155776: 67109124,
            15204352: 67174660,
            16252928: 67108864,
            16777216: 67174656,
            17825792: 65540,
            18874368: 65536,
            19922944: 67109120,
            20971520: 256,
            22020096: 67174660,
            23068672: 67108868,
            24117248: 0,
            25165824: 67109124,
            26214400: 67108864,
            27262976: 4,
            28311552: 65792,
            29360128: 67174400,
            30408704: 260,
            31457280: 65796,
            32505856: 67174404,
            17301504: 67108864,
            18350080: 260,
            19398656: 67174656,
            20447232: 0,
            21495808: 65540,
            22544384: 67109120,
            23592960: 256,
            24641536: 67174404,
            25690112: 65536,
            26738688: 67174660,
            27787264: 65796,
            28835840: 67108868,
            29884416: 67109124,
            30932992: 67174400,
            31981568: 4,
            33030144: 65792
          },
          {
            0: 2151682048,
            65536: 2147487808,
            131072: 4198464,
            196608: 2151677952,
            262144: 0,
            327680: 4198400,
            393216: 2147483712,
            458752: 4194368,
            524288: 2147483648,
            589824: 4194304,
            655360: 64,
            720896: 2147487744,
            786432: 2151678016,
            851968: 4160,
            917504: 4096,
            983040: 2151682112,
            32768: 2147487808,
            98304: 64,
            163840: 2151678016,
            229376: 2147487744,
            294912: 4198400,
            360448: 2151682112,
            425984: 0,
            491520: 2151677952,
            557056: 4096,
            622592: 2151682048,
            688128: 4194304,
            753664: 4160,
            819200: 2147483648,
            884736: 4194368,
            950272: 4198464,
            1015808: 2147483712,
            1048576: 4194368,
            1114112: 4198400,
            1179648: 2147483712,
            1245184: 0,
            1310720: 4160,
            1376256: 2151678016,
            1441792: 2151682048,
            1507328: 2147487808,
            1572864: 2151682112,
            1638400: 2147483648,
            1703936: 2151677952,
            1769472: 4198464,
            1835008: 2147487744,
            1900544: 4194304,
            1966080: 64,
            2031616: 4096,
            1081344: 2151677952,
            1146880: 2151682112,
            1212416: 0,
            1277952: 4198400,
            1343488: 4194368,
            1409024: 2147483648,
            1474560: 2147487808,
            1540096: 64,
            1605632: 2147483712,
            1671168: 4096,
            1736704: 2147487744,
            1802240: 2151678016,
            1867776: 4160,
            1933312: 2151682048,
            1998848: 4194304,
            2064384: 4198464
          },
          {
            0: 128,
            4096: 17039360,
            8192: 262144,
            12288: 536870912,
            16384: 537133184,
            20480: 16777344,
            24576: 553648256,
            28672: 262272,
            32768: 16777216,
            36864: 537133056,
            40960: 536871040,
            45056: 553910400,
            49152: 553910272,
            53248: 0,
            57344: 17039488,
            61440: 553648128,
            2048: 17039488,
            6144: 553648256,
            10240: 128,
            14336: 17039360,
            18432: 262144,
            22528: 537133184,
            26624: 553910272,
            30720: 536870912,
            34816: 537133056,
            38912: 0,
            43008: 553910400,
            47104: 16777344,
            51200: 536871040,
            55296: 553648128,
            59392: 16777216,
            63488: 262272,
            65536: 262144,
            69632: 128,
            73728: 536870912,
            77824: 553648256,
            81920: 16777344,
            86016: 553910272,
            90112: 537133184,
            94208: 16777216,
            98304: 553910400,
            102400: 553648128,
            106496: 17039360,
            110592: 537133056,
            114688: 262272,
            118784: 536871040,
            122880: 0,
            126976: 17039488,
            67584: 553648256,
            71680: 16777216,
            75776: 17039360,
            79872: 537133184,
            83968: 536870912,
            88064: 17039488,
            92160: 128,
            96256: 553910272,
            100352: 262272,
            104448: 553910400,
            108544: 0,
            112640: 553648128,
            116736: 16777344,
            120832: 262144,
            124928: 537133056,
            129024: 536871040
          },
          {
            0: 268435464,
            256: 8192,
            512: 270532608,
            768: 270540808,
            1024: 268443648,
            1280: 2097152,
            1536: 2097160,
            1792: 268435456,
            2048: 0,
            2304: 268443656,
            2560: 2105344,
            2816: 8,
            3072: 270532616,
            3328: 2105352,
            3584: 8200,
            3840: 270540800,
            128: 270532608,
            384: 270540808,
            640: 8,
            896: 2097152,
            1152: 2105352,
            1408: 268435464,
            1664: 268443648,
            1920: 8200,
            2176: 2097160,
            2432: 8192,
            2688: 268443656,
            2944: 270532616,
            3200: 0,
            3456: 270540800,
            3712: 2105344,
            3968: 268435456,
            4096: 268443648,
            4352: 270532616,
            4608: 270540808,
            4864: 8200,
            5120: 2097152,
            5376: 268435456,
            5632: 268435464,
            5888: 2105344,
            6144: 2105352,
            6400: 0,
            6656: 8,
            6912: 270532608,
            7168: 8192,
            7424: 268443656,
            7680: 270540800,
            7936: 2097160,
            4224: 8,
            4480: 2105344,
            4736: 2097152,
            4992: 268435464,
            5248: 268443648,
            5504: 8200,
            5760: 270540808,
            6016: 270532608,
            6272: 270540800,
            6528: 270532616,
            6784: 8192,
            7040: 2105352,
            7296: 2097160,
            7552: 0,
            7808: 268435456,
            8064: 268443656
          },
          {
            0: 1048576,
            16: 33555457,
            32: 1024,
            48: 1049601,
            64: 34604033,
            80: 0,
            96: 1,
            112: 34603009,
            128: 33555456,
            144: 1048577,
            160: 33554433,
            176: 34604032,
            192: 34603008,
            208: 1025,
            224: 1049600,
            240: 33554432,
            8: 34603009,
            24: 0,
            40: 33555457,
            56: 34604032,
            72: 1048576,
            88: 33554433,
            104: 33554432,
            120: 1025,
            136: 1049601,
            152: 33555456,
            168: 34603008,
            184: 1048577,
            200: 1024,
            216: 34604033,
            232: 1,
            248: 1049600,
            256: 33554432,
            272: 1048576,
            288: 33555457,
            304: 34603009,
            320: 1048577,
            336: 33555456,
            352: 34604032,
            368: 1049601,
            384: 1025,
            400: 34604033,
            416: 1049600,
            432: 1,
            448: 0,
            464: 34603008,
            480: 33554433,
            496: 1024,
            264: 1049600,
            280: 33555457,
            296: 34603009,
            312: 1,
            328: 33554432,
            344: 1048576,
            360: 1025,
            376: 34604032,
            392: 33554433,
            408: 34603008,
            424: 0,
            440: 34604033,
            456: 1049601,
            472: 1024,
            488: 33555456,
            504: 1048577
          },
          {
            0: 134219808,
            1: 131072,
            2: 134217728,
            3: 32,
            4: 131104,
            5: 134350880,
            6: 134350848,
            7: 2048,
            8: 134348800,
            9: 134219776,
            10: 133120,
            11: 134348832,
            12: 2080,
            13: 0,
            14: 134217760,
            15: 133152,
            2147483648: 2048,
            2147483649: 134350880,
            2147483650: 134219808,
            2147483651: 134217728,
            2147483652: 134348800,
            2147483653: 133120,
            2147483654: 133152,
            2147483655: 32,
            2147483656: 134217760,
            2147483657: 2080,
            2147483658: 131104,
            2147483659: 134350848,
            2147483660: 0,
            2147483661: 134348832,
            2147483662: 134219776,
            2147483663: 131072,
            16: 133152,
            17: 134350848,
            18: 32,
            19: 2048,
            20: 134219776,
            21: 134217760,
            22: 134348832,
            23: 131072,
            24: 0,
            25: 131104,
            26: 134348800,
            27: 134219808,
            28: 134350880,
            29: 133120,
            30: 2080,
            31: 134217728,
            2147483664: 131072,
            2147483665: 2048,
            2147483666: 134348832,
            2147483667: 133152,
            2147483668: 32,
            2147483669: 134348800,
            2147483670: 134217728,
            2147483671: 134219808,
            2147483672: 134350880,
            2147483673: 134217760,
            2147483674: 134219776,
            2147483675: 0,
            2147483676: 133120,
            2147483677: 2080,
            2147483678: 131104,
            2147483679: 134350848
          }
        ], d = [
          4160749569,
          528482304,
          33030144,
          2064384,
          129024,
          8064,
          504,
          2147483679
        ], h = a.DES = s.extend({
          _doReset: function() {
            for (var x = this._key, v = x.words, y = [], S = 0; S < 56; S++) {
              var b = l[S] - 1;
              y[S] = v[b >>> 5] >>> 31 - b % 32 & 1;
            }
            for (var w = this._subKeys = [], C = 0; C < 16; C++) {
              for (var k = w[C] = [], T = u[C], S = 0; S < 24; S++)
                k[S / 6 | 0] |= y[(c[S] - 1 + T) % 28] << 31 - S % 6, k[4 + (S / 6 | 0)] |= y[28 + (c[S + 24] - 1 + T) % 28] << 31 - S % 6;
              k[0] = k[0] << 1 | k[0] >>> 31;
              for (var S = 1; S < 7; S++)
                k[S] = k[S] >>> (S - 1) * 4 + 3;
              k[7] = k[7] << 5 | k[7] >>> 27;
            }
            for (var A = this._invSubKeys = [], S = 0; S < 16; S++)
              A[S] = w[15 - S];
          },
          encryptBlock: function(x, v) {
            this._doCryptBlock(x, v, this._subKeys);
          },
          decryptBlock: function(x, v) {
            this._doCryptBlock(x, v, this._invSubKeys);
          },
          _doCryptBlock: function(x, v, y) {
            this._lBlock = x[v], this._rBlock = x[v + 1], p.call(this, 4, 252645135), p.call(this, 16, 65535), O.call(this, 2, 858993459), O.call(this, 8, 16711935), p.call(this, 1, 1431655765);
            for (var S = 0; S < 16; S++) {
              for (var b = y[S], w = this._lBlock, C = this._rBlock, k = 0, T = 0; T < 8; T++)
                k |= f[T][((C ^ b[T]) & d[T]) >>> 0];
              this._lBlock = C, this._rBlock = w ^ k;
            }
            var A = this._lBlock;
            this._lBlock = this._rBlock, this._rBlock = A, p.call(this, 1, 1431655765), O.call(this, 8, 16711935), O.call(this, 2, 858993459), p.call(this, 16, 65535), p.call(this, 4, 252645135), x[v] = this._lBlock, x[v + 1] = this._rBlock;
          },
          keySize: 64 / 32,
          ivSize: 64 / 32,
          blockSize: 64 / 32
        });
        function p(x, v) {
          var y = (this._lBlock >>> x ^ this._rBlock) & v;
          this._rBlock ^= y, this._lBlock ^= y << x;
        }
        function O(x, v) {
          var y = (this._rBlock >>> x ^ this._lBlock) & v;
          this._lBlock ^= y, this._rBlock ^= y << x;
        }
        r.DES = s._createHelper(h);
        var m = a.TripleDES = s.extend({
          _doReset: function() {
            var x = this._key, v = x.words;
            if (v.length !== 2 && v.length !== 4 && v.length < 6)
              throw new Error("Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192.");
            var y = v.slice(0, 2), S = v.length < 4 ? v.slice(0, 2) : v.slice(2, 4), b = v.length < 6 ? v.slice(0, 2) : v.slice(4, 6);
            this._des1 = h.createEncryptor(o.create(y)), this._des2 = h.createEncryptor(o.create(S)), this._des3 = h.createEncryptor(o.create(b));
          },
          encryptBlock: function(x, v) {
            this._des1.encryptBlock(x, v), this._des2.decryptBlock(x, v), this._des3.encryptBlock(x, v);
          },
          decryptBlock: function(x, v) {
            this._des3.decryptBlock(x, v), this._des2.encryptBlock(x, v), this._des1.decryptBlock(x, v);
          },
          keySize: 192 / 32,
          ivSize: 64 / 32,
          blockSize: 64 / 32
        });
        r.TripleDES = s._createHelper(m);
      }(), n.TripleDES;
    });
  }(Z0)), Z0.exports;
}
var W0 = { exports: {} };
var zC;
function Zq() {
  return zC || (zC = 1, function(t4, e) {
    (function(n, r, i) {
      t4.exports = r(tt(), As(), Ps(), Wo(), On());
    })(Ze, function(n) {
      return function() {
        var r = n, i = r.lib, o = i.StreamCipher, s = r.algo, a = s.RC4 = o.extend({
          _doReset: function() {
            for (var u = this._key, f = u.words, d = u.sigBytes, h = this._S = [], p = 0; p < 256; p++)
              h[p] = p;
            for (var p = 0, O = 0; p < 256; p++) {
              var m = p % d, x = f[m >>> 2] >>> 24 - m % 4 * 8 & 255;
              O = (O + h[p] + x) % 256;
              var v = h[p];
              h[p] = h[O], h[O] = v;
            }
            this._i = this._j = 0;
          },
          _doProcessBlock: function(u, f) {
            u[f] ^= l.call(this);
          },
          keySize: 256 / 32,
          ivSize: 0
        });
        function l() {
          for (var u = this._S, f = this._i, d = this._j, h = 0, p = 0; p < 4; p++) {
            f = (f + 1) % 256, d = (d + u[f]) % 256;
            var O = u[f];
            u[f] = u[d], u[d] = O, h |= u[(u[f] + u[d]) % 256] << 24 - p * 8;
          }
          return this._i = f, this._j = d, h;
        }
        r.RC4 = o._createHelper(a);
        var c = s.RC4Drop = a.extend({
          /**
           * Configuration options.
           *
           * @property {number} drop The number of keystream words to drop. Default 192
           */
          cfg: a.cfg.extend({
            drop: 192
          }),
          _doReset: function() {
            a._doReset.call(this);
            for (var u = this.cfg.drop; u > 0; u--)
              l.call(this);
          }
        });
        r.RC4Drop = o._createHelper(c);
      }(), n.RC4;
    });
  }(W0)), W0.exports;
}
var V0 = { exports: {} };
var LC;
function Wq() {
  return LC || (LC = 1, function(t4, e) {
    (function(n, r, i) {
      t4.exports = r(tt(), As(), Ps(), Wo(), On());
    })(Ze, function(n) {
      return function() {
        var r = n, i = r.lib, o = i.StreamCipher, s = r.algo, a = [], l = [], c = [], u = s.Rabbit = o.extend({
          _doReset: function() {
            for (var d = this._key.words, h = this.cfg.iv, p = 0; p < 4; p++)
              d[p] = (d[p] << 8 | d[p] >>> 24) & 16711935 | (d[p] << 24 | d[p] >>> 8) & 4278255360;
            var O = this._X = [
              d[0],
              d[3] << 16 | d[2] >>> 16,
              d[1],
              d[0] << 16 | d[3] >>> 16,
              d[2],
              d[1] << 16 | d[0] >>> 16,
              d[3],
              d[2] << 16 | d[1] >>> 16
            ], m = this._C = [
              d[2] << 16 | d[2] >>> 16,
              d[0] & 4294901760 | d[1] & 65535,
              d[3] << 16 | d[3] >>> 16,
              d[1] & 4294901760 | d[2] & 65535,
              d[0] << 16 | d[0] >>> 16,
              d[2] & 4294901760 | d[3] & 65535,
              d[1] << 16 | d[1] >>> 16,
              d[3] & 4294901760 | d[0] & 65535
            ];
            this._b = 0;
            for (var p = 0; p < 4; p++)
              f.call(this);
            for (var p = 0; p < 8; p++)
              m[p] ^= O[p + 4 & 7];
            if (h) {
              var x = h.words, v = x[0], y = x[1], S = (v << 8 | v >>> 24) & 16711935 | (v << 24 | v >>> 8) & 4278255360, b = (y << 8 | y >>> 24) & 16711935 | (y << 24 | y >>> 8) & 4278255360, w = S >>> 16 | b & 4294901760, C = b << 16 | S & 65535;
              m[0] ^= S, m[1] ^= w, m[2] ^= b, m[3] ^= C, m[4] ^= S, m[5] ^= w, m[6] ^= b, m[7] ^= C;
              for (var p = 0; p < 4; p++)
                f.call(this);
            }
          },
          _doProcessBlock: function(d, h) {
            var p = this._X;
            f.call(this), a[0] = p[0] ^ p[5] >>> 16 ^ p[3] << 16, a[1] = p[2] ^ p[7] >>> 16 ^ p[5] << 16, a[2] = p[4] ^ p[1] >>> 16 ^ p[7] << 16, a[3] = p[6] ^ p[3] >>> 16 ^ p[1] << 16;
            for (var O = 0; O < 4; O++)
              a[O] = (a[O] << 8 | a[O] >>> 24) & 16711935 | (a[O] << 24 | a[O] >>> 8) & 4278255360, d[h + O] ^= a[O];
          },
          blockSize: 128 / 32,
          ivSize: 64 / 32
        });
        function f() {
          for (var d = this._X, h = this._C, p = 0; p < 8; p++)
            l[p] = h[p];
          h[0] = h[0] + 1295307597 + this._b | 0, h[1] = h[1] + 3545052371 + (h[0] >>> 0 < l[0] >>> 0 ? 1 : 0) | 0, h[2] = h[2] + 886263092 + (h[1] >>> 0 < l[1] >>> 0 ? 1 : 0) | 0, h[3] = h[3] + 1295307597 + (h[2] >>> 0 < l[2] >>> 0 ? 1 : 0) | 0, h[4] = h[4] + 3545052371 + (h[3] >>> 0 < l[3] >>> 0 ? 1 : 0) | 0, h[5] = h[5] + 886263092 + (h[4] >>> 0 < l[4] >>> 0 ? 1 : 0) | 0, h[6] = h[6] + 1295307597 + (h[5] >>> 0 < l[5] >>> 0 ? 1 : 0) | 0, h[7] = h[7] + 3545052371 + (h[6] >>> 0 < l[6] >>> 0 ? 1 : 0) | 0, this._b = h[7] >>> 0 < l[7] >>> 0 ? 1 : 0;
          for (var p = 0; p < 8; p++) {
            var O = d[p] + h[p], m = O & 65535, x = O >>> 16, v = ((m * m >>> 17) + m * x >>> 15) + x * x, y = ((O & 4294901760) * O | 0) + ((O & 65535) * O | 0);
            c[p] = v ^ y;
          }
          d[0] = c[0] + (c[7] << 16 | c[7] >>> 16) + (c[6] << 16 | c[6] >>> 16) | 0, d[1] = c[1] + (c[0] << 8 | c[0] >>> 24) + c[7] | 0, d[2] = c[2] + (c[1] << 16 | c[1] >>> 16) + (c[0] << 16 | c[0] >>> 16) | 0, d[3] = c[3] + (c[2] << 8 | c[2] >>> 24) + c[1] | 0, d[4] = c[4] + (c[3] << 16 | c[3] >>> 16) + (c[2] << 16 | c[2] >>> 16) | 0, d[5] = c[5] + (c[4] << 8 | c[4] >>> 24) + c[3] | 0, d[6] = c[6] + (c[5] << 16 | c[5] >>> 16) + (c[4] << 16 | c[4] >>> 16) | 0, d[7] = c[7] + (c[6] << 8 | c[6] >>> 24) + c[5] | 0;
        }
        r.Rabbit = o._createHelper(u);
      }(), n.Rabbit;
    });
  }(V0)), V0.exports;
}
var z0 = { exports: {} };
var XC;
function Vq() {
  return XC || (XC = 1, function(t4, e) {
    (function(n, r, i) {
      t4.exports = r(tt(), As(), Ps(), Wo(), On());
    })(Ze, function(n) {
      return function() {
        var r = n, i = r.lib, o = i.StreamCipher, s = r.algo, a = [], l = [], c = [], u = s.RabbitLegacy = o.extend({
          _doReset: function() {
            var d = this._key.words, h = this.cfg.iv, p = this._X = [
              d[0],
              d[3] << 16 | d[2] >>> 16,
              d[1],
              d[0] << 16 | d[3] >>> 16,
              d[2],
              d[1] << 16 | d[0] >>> 16,
              d[3],
              d[2] << 16 | d[1] >>> 16
            ], O = this._C = [
              d[2] << 16 | d[2] >>> 16,
              d[0] & 4294901760 | d[1] & 65535,
              d[3] << 16 | d[3] >>> 16,
              d[1] & 4294901760 | d[2] & 65535,
              d[0] << 16 | d[0] >>> 16,
              d[2] & 4294901760 | d[3] & 65535,
              d[1] << 16 | d[1] >>> 16,
              d[3] & 4294901760 | d[0] & 65535
            ];
            this._b = 0;
            for (var m = 0; m < 4; m++)
              f.call(this);
            for (var m = 0; m < 8; m++)
              O[m] ^= p[m + 4 & 7];
            if (h) {
              var x = h.words, v = x[0], y = x[1], S = (v << 8 | v >>> 24) & 16711935 | (v << 24 | v >>> 8) & 4278255360, b = (y << 8 | y >>> 24) & 16711935 | (y << 24 | y >>> 8) & 4278255360, w = S >>> 16 | b & 4294901760, C = b << 16 | S & 65535;
              O[0] ^= S, O[1] ^= w, O[2] ^= b, O[3] ^= C, O[4] ^= S, O[5] ^= w, O[6] ^= b, O[7] ^= C;
              for (var m = 0; m < 4; m++)
                f.call(this);
            }
          },
          _doProcessBlock: function(d, h) {
            var p = this._X;
            f.call(this), a[0] = p[0] ^ p[5] >>> 16 ^ p[3] << 16, a[1] = p[2] ^ p[7] >>> 16 ^ p[5] << 16, a[2] = p[4] ^ p[1] >>> 16 ^ p[7] << 16, a[3] = p[6] ^ p[3] >>> 16 ^ p[1] << 16;
            for (var O = 0; O < 4; O++)
              a[O] = (a[O] << 8 | a[O] >>> 24) & 16711935 | (a[O] << 24 | a[O] >>> 8) & 4278255360, d[h + O] ^= a[O];
          },
          blockSize: 128 / 32,
          ivSize: 64 / 32
        });
        function f() {
          for (var d = this._X, h = this._C, p = 0; p < 8; p++)
            l[p] = h[p];
          h[0] = h[0] + 1295307597 + this._b | 0, h[1] = h[1] + 3545052371 + (h[0] >>> 0 < l[0] >>> 0 ? 1 : 0) | 0, h[2] = h[2] + 886263092 + (h[1] >>> 0 < l[1] >>> 0 ? 1 : 0) | 0, h[3] = h[3] + 1295307597 + (h[2] >>> 0 < l[2] >>> 0 ? 1 : 0) | 0, h[4] = h[4] + 3545052371 + (h[3] >>> 0 < l[3] >>> 0 ? 1 : 0) | 0, h[5] = h[5] + 886263092 + (h[4] >>> 0 < l[4] >>> 0 ? 1 : 0) | 0, h[6] = h[6] + 1295307597 + (h[5] >>> 0 < l[5] >>> 0 ? 1 : 0) | 0, h[7] = h[7] + 3545052371 + (h[6] >>> 0 < l[6] >>> 0 ? 1 : 0) | 0, this._b = h[7] >>> 0 < l[7] >>> 0 ? 1 : 0;
          for (var p = 0; p < 8; p++) {
            var O = d[p] + h[p], m = O & 65535, x = O >>> 16, v = ((m * m >>> 17) + m * x >>> 15) + x * x, y = ((O & 4294901760) * O | 0) + ((O & 65535) * O | 0);
            c[p] = v ^ y;
          }
          d[0] = c[0] + (c[7] << 16 | c[7] >>> 16) + (c[6] << 16 | c[6] >>> 16) | 0, d[1] = c[1] + (c[0] << 8 | c[0] >>> 24) + c[7] | 0, d[2] = c[2] + (c[1] << 16 | c[1] >>> 16) + (c[0] << 16 | c[0] >>> 16) | 0, d[3] = c[3] + (c[2] << 8 | c[2] >>> 24) + c[1] | 0, d[4] = c[4] + (c[3] << 16 | c[3] >>> 16) + (c[2] << 16 | c[2] >>> 16) | 0, d[5] = c[5] + (c[4] << 8 | c[4] >>> 24) + c[3] | 0, d[6] = c[6] + (c[5] << 16 | c[5] >>> 16) + (c[4] << 16 | c[4] >>> 16) | 0, d[7] = c[7] + (c[6] << 8 | c[6] >>> 24) + c[5] | 0;
        }
        r.RabbitLegacy = o._createHelper(u);
      }(), n.RabbitLegacy;
    });
  }(z0)), z0.exports;
}
var L0 = { exports: {} };
var GC;
function zq() {
  return GC || (GC = 1, function(t4, e) {
    (function(n, r, i) {
      t4.exports = r(tt(), As(), Ps(), Wo(), On());
    })(Ze, function(n) {
      return function() {
        var r = n, i = r.lib, o = i.BlockCipher, s = r.algo;
        const a = 16, l = [
          608135816,
          2242054355,
          320440878,
          57701188,
          2752067618,
          698298832,
          137296536,
          3964562569,
          1160258022,
          953160567,
          3193202383,
          887688300,
          3232508343,
          3380367581,
          1065670069,
          3041331479,
          2450970073,
          2306472731
        ], c = [
          [
            3509652390,
            2564797868,
            805139163,
            3491422135,
            3101798381,
            1780907670,
            3128725573,
            4046225305,
            614570311,
            3012652279,
            134345442,
            2240740374,
            1667834072,
            1901547113,
            2757295779,
            4103290238,
            227898511,
            1921955416,
            1904987480,
            2182433518,
            2069144605,
            3260701109,
            2620446009,
            720527379,
            3318853667,
            677414384,
            3393288472,
            3101374703,
            2390351024,
            1614419982,
            1822297739,
            2954791486,
            3608508353,
            3174124327,
            2024746970,
            1432378464,
            3864339955,
            2857741204,
            1464375394,
            1676153920,
            1439316330,
            715854006,
            3033291828,
            289532110,
            2706671279,
            2087905683,
            3018724369,
            1668267050,
            732546397,
            1947742710,
            3462151702,
            2609353502,
            2950085171,
            1814351708,
            2050118529,
            680887927,
            999245976,
            1800124847,
            3300911131,
            1713906067,
            1641548236,
            4213287313,
            1216130144,
            1575780402,
            4018429277,
            3917837745,
            3693486850,
            3949271944,
            596196993,
            3549867205,
            258830323,
            2213823033,
            772490370,
            2760122372,
            1774776394,
            2652871518,
            566650946,
            4142492826,
            1728879713,
            2882767088,
            1783734482,
            3629395816,
            2517608232,
            2874225571,
            1861159788,
            326777828,
            3124490320,
            2130389656,
            2716951837,
            967770486,
            1724537150,
            2185432712,
            2364442137,
            1164943284,
            2105845187,
            998989502,
            3765401048,
            2244026483,
            1075463327,
            1455516326,
            1322494562,
            910128902,
            469688178,
            1117454909,
            936433444,
            3490320968,
            3675253459,
            1240580251,
            122909385,
            2157517691,
            634681816,
            4142456567,
            3825094682,
            3061402683,
            2540495037,
            79693498,
            3249098678,
            1084186820,
            1583128258,
            426386531,
            1761308591,
            1047286709,
            322548459,
            995290223,
            1845252383,
            2603652396,
            3431023940,
            2942221577,
            3202600964,
            3727903485,
            1712269319,
            422464435,
            3234572375,
            1170764815,
            3523960633,
            3117677531,
            1434042557,
            442511882,
            3600875718,
            1076654713,
            1738483198,
            4213154764,
            2393238008,
            3677496056,
            1014306527,
            4251020053,
            793779912,
            2902807211,
            842905082,
            4246964064,
            1395751752,
            1040244610,
            2656851899,
            3396308128,
            445077038,
            3742853595,
            3577915638,
            679411651,
            2892444358,
            2354009459,
            1767581616,
            3150600392,
            3791627101,
            3102740896,
            284835224,
            4246832056,
            1258075500,
            768725851,
            2589189241,
            3069724005,
            3532540348,
            1274779536,
            3789419226,
            2764799539,
            1660621633,
            3471099624,
            4011903706,
            913787905,
            3497959166,
            737222580,
            2514213453,
            2928710040,
            3937242737,
            1804850592,
            3499020752,
            2949064160,
            2386320175,
            2390070455,
            2415321851,
            4061277028,
            2290661394,
            2416832540,
            1336762016,
            1754252060,
            3520065937,
            3014181293,
            791618072,
            3188594551,
            3933548030,
            2332172193,
            3852520463,
            3043980520,
            413987798,
            3465142937,
            3030929376,
            4245938359,
            2093235073,
            3534596313,
            375366246,
            2157278981,
            2479649556,
            555357303,
            3870105701,
            2008414854,
            3344188149,
            4221384143,
            3956125452,
            2067696032,
            3594591187,
            2921233993,
            2428461,
            544322398,
            577241275,
            1471733935,
            610547355,
            4027169054,
            1432588573,
            1507829418,
            2025931657,
            3646575487,
            545086370,
            48609733,
            2200306550,
            1653985193,
            298326376,
            1316178497,
            3007786442,
            2064951626,
            458293330,
            2589141269,
            3591329599,
            3164325604,
            727753846,
            2179363840,
            146436021,
            1461446943,
            4069977195,
            705550613,
            3059967265,
            3887724982,
            4281599278,
            3313849956,
            1404054877,
            2845806497,
            146425753,
            1854211946
          ],
          [
            1266315497,
            3048417604,
            3681880366,
            3289982499,
            290971e4,
            1235738493,
            2632868024,
            2414719590,
            3970600049,
            1771706367,
            1449415276,
            3266420449,
            422970021,
            1963543593,
            2690192192,
            3826793022,
            1062508698,
            1531092325,
            1804592342,
            2583117782,
            2714934279,
            4024971509,
            1294809318,
            4028980673,
            1289560198,
            2221992742,
            1669523910,
            35572830,
            157838143,
            1052438473,
            1016535060,
            1802137761,
            1753167236,
            1386275462,
            3080475397,
            2857371447,
            1040679964,
            2145300060,
            2390574316,
            1461121720,
            2956646967,
            4031777805,
            4028374788,
            33600511,
            2920084762,
            1018524850,
            629373528,
            3691585981,
            3515945977,
            2091462646,
            2486323059,
            586499841,
            988145025,
            935516892,
            3367335476,
            2599673255,
            2839830854,
            265290510,
            3972581182,
            2759138881,
            3795373465,
            1005194799,
            847297441,
            406762289,
            1314163512,
            1332590856,
            1866599683,
            4127851711,
            750260880,
            613907577,
            1450815602,
            3165620655,
            3734664991,
            3650291728,
            3012275730,
            3704569646,
            1427272223,
            778793252,
            1343938022,
            2676280711,
            2052605720,
            1946737175,
            3164576444,
            3914038668,
            3967478842,
            3682934266,
            1661551462,
            3294938066,
            4011595847,
            840292616,
            3712170807,
            616741398,
            312560963,
            711312465,
            1351876610,
            322626781,
            1910503582,
            271666773,
            2175563734,
            1594956187,
            70604529,
            3617834859,
            1007753275,
            1495573769,
            4069517037,
            2549218298,
            2663038764,
            504708206,
            2263041392,
            3941167025,
            2249088522,
            1514023603,
            1998579484,
            1312622330,
            694541497,
            2582060303,
            2151582166,
            1382467621,
            776784248,
            2618340202,
            3323268794,
            2497899128,
            2784771155,
            503983604,
            4076293799,
            907881277,
            423175695,
            432175456,
            1378068232,
            4145222326,
            3954048622,
            3938656102,
            3820766613,
            2793130115,
            2977904593,
            26017576,
            3274890735,
            3194772133,
            1700274565,
            1756076034,
            4006520079,
            3677328699,
            720338349,
            1533947780,
            354530856,
            688349552,
            3973924725,
            1637815568,
            332179504,
            3949051286,
            53804574,
            2852348879,
            3044236432,
            1282449977,
            3583942155,
            3416972820,
            4006381244,
            1617046695,
            2628476075,
            3002303598,
            1686838959,
            431878346,
            2686675385,
            1700445008,
            1080580658,
            1009431731,
            832498133,
            3223435511,
            2605976345,
            2271191193,
            2516031870,
            1648197032,
            4164389018,
            2548247927,
            300782431,
            375919233,
            238389289,
            3353747414,
            2531188641,
            2019080857,
            1475708069,
            455242339,
            2609103871,
            448939670,
            3451063019,
            1395535956,
            2413381860,
            1841049896,
            1491858159,
            885456874,
            4264095073,
            4001119347,
            1565136089,
            3898914787,
            1108368660,
            540939232,
            1173283510,
            2745871338,
            3681308437,
            4207628240,
            3343053890,
            4016749493,
            1699691293,
            1103962373,
            3625875870,
            2256883143,
            3830138730,
            1031889488,
            3479347698,
            1535977030,
            4236805024,
            3251091107,
            2132092099,
            1774941330,
            1199868427,
            1452454533,
            157007616,
            2904115357,
            342012276,
            595725824,
            1480756522,
            206960106,
            497939518,
            591360097,
            863170706,
            2375253569,
            3596610801,
            1814182875,
            2094937945,
            3421402208,
            1082520231,
            3463918190,
            2785509508,
            435703966,
            3908032597,
            1641649973,
            2842273706,
            3305899714,
            1510255612,
            2148256476,
            2655287854,
            3276092548,
            4258621189,
            236887753,
            3681803219,
            274041037,
            1734335097,
            3815195456,
            3317970021,
            1899903192,
            1026095262,
            4050517792,
            356393447,
            2410691914,
            3873677099,
            3682840055
          ],
          [
            3913112168,
            2491498743,
            4132185628,
            2489919796,
            1091903735,
            1979897079,
            3170134830,
            3567386728,
            3557303409,
            857797738,
            1136121015,
            1342202287,
            507115054,
            2535736646,
            337727348,
            3213592640,
            1301675037,
            2528481711,
            1895095763,
            1721773893,
            3216771564,
            62756741,
            2142006736,
            835421444,
            2531993523,
            1442658625,
            3659876326,
            2882144922,
            676362277,
            1392781812,
            170690266,
            3921047035,
            1759253602,
            3611846912,
            1745797284,
            664899054,
            1329594018,
            3901205900,
            3045908486,
            2062866102,
            2865634940,
            3543621612,
            3464012697,
            1080764994,
            553557557,
            3656615353,
            3996768171,
            991055499,
            499776247,
            1265440854,
            648242737,
            3940784050,
            980351604,
            3713745714,
            1749149687,
            3396870395,
            4211799374,
            3640570775,
            1161844396,
            3125318951,
            1431517754,
            545492359,
            4268468663,
            3499529547,
            1437099964,
            2702547544,
            3433638243,
            2581715763,
            2787789398,
            1060185593,
            1593081372,
            2418618748,
            4260947970,
            69676912,
            2159744348,
            86519011,
            2512459080,
            3838209314,
            1220612927,
            3339683548,
            133810670,
            1090789135,
            1078426020,
            1569222167,
            845107691,
            3583754449,
            4072456591,
            1091646820,
            628848692,
            1613405280,
            3757631651,
            526609435,
            236106946,
            48312990,
            2942717905,
            3402727701,
            1797494240,
            859738849,
            992217954,
            4005476642,
            2243076622,
            3870952857,
            3732016268,
            765654824,
            3490871365,
            2511836413,
            1685915746,
            3888969200,
            1414112111,
            2273134842,
            3281911079,
            4080962846,
            172450625,
            2569994100,
            980381355,
            4109958455,
            2819808352,
            2716589560,
            2568741196,
            3681446669,
            3329971472,
            1835478071,
            660984891,
            3704678404,
            4045999559,
            3422617507,
            3040415634,
            1762651403,
            1719377915,
            3470491036,
            2693910283,
            3642056355,
            3138596744,
            1364962596,
            2073328063,
            1983633131,
            926494387,
            3423689081,
            2150032023,
            4096667949,
            1749200295,
            3328846651,
            309677260,
            2016342300,
            1779581495,
            3079819751,
            111262694,
            1274766160,
            443224088,
            298511866,
            1025883608,
            3806446537,
            1145181785,
            168956806,
            3641502830,
            3584813610,
            1689216846,
            3666258015,
            3200248200,
            1692713982,
            2646376535,
            4042768518,
            1618508792,
            1610833997,
            3523052358,
            4130873264,
            2001055236,
            3610705100,
            2202168115,
            4028541809,
            2961195399,
            1006657119,
            2006996926,
            3186142756,
            1430667929,
            3210227297,
            1314452623,
            4074634658,
            4101304120,
            2273951170,
            1399257539,
            3367210612,
            3027628629,
            1190975929,
            2062231137,
            2333990788,
            2221543033,
            2438960610,
            1181637006,
            548689776,
            2362791313,
            3372408396,
            3104550113,
            3145860560,
            296247880,
            1970579870,
            3078560182,
            3769228297,
            1714227617,
            3291629107,
            3898220290,
            166772364,
            1251581989,
            493813264,
            448347421,
            195405023,
            2709975567,
            677966185,
            3703036547,
            1463355134,
            2715995803,
            1338867538,
            1343315457,
            2802222074,
            2684532164,
            233230375,
            2599980071,
            2000651841,
            3277868038,
            1638401717,
            4028070440,
            3237316320,
            6314154,
            819756386,
            300326615,
            590932579,
            1405279636,
            3267499572,
            3150704214,
            2428286686,
            3959192993,
            3461946742,
            1862657033,
            1266418056,
            963775037,
            2089974820,
            2263052895,
            1917689273,
            448879540,
            3550394620,
            3981727096,
            150775221,
            3627908307,
            1303187396,
            508620638,
            2975983352,
            2726630617,
            1817252668,
            1876281319,
            1457606340,
            908771278,
            3720792119,
            3617206836,
            2455994898,
            1729034894,
            1080033504
          ],
          [
            976866871,
            3556439503,
            2881648439,
            1522871579,
            1555064734,
            1336096578,
            3548522304,
            2579274686,
            3574697629,
            3205460757,
            3593280638,
            3338716283,
            3079412587,
            564236357,
            2993598910,
            1781952180,
            1464380207,
            3163844217,
            3332601554,
            1699332808,
            1393555694,
            1183702653,
            3581086237,
            1288719814,
            691649499,
            2847557200,
            2895455976,
            3193889540,
            2717570544,
            1781354906,
            1676643554,
            2592534050,
            3230253752,
            1126444790,
            2770207658,
            2633158820,
            2210423226,
            2615765581,
            2414155088,
            3127139286,
            673620729,
            2805611233,
            1269405062,
            4015350505,
            3341807571,
            4149409754,
            1057255273,
            2012875353,
            2162469141,
            2276492801,
            2601117357,
            993977747,
            3918593370,
            2654263191,
            753973209,
            36408145,
            2530585658,
            25011837,
            3520020182,
            2088578344,
            530523599,
            2918365339,
            1524020338,
            1518925132,
            3760827505,
            3759777254,
            1202760957,
            3985898139,
            3906192525,
            674977740,
            4174734889,
            2031300136,
            2019492241,
            3983892565,
            4153806404,
            3822280332,
            352677332,
            2297720250,
            60907813,
            90501309,
            3286998549,
            1016092578,
            2535922412,
            2839152426,
            457141659,
            509813237,
            4120667899,
            652014361,
            1966332200,
            2975202805,
            55981186,
            2327461051,
            676427537,
            3255491064,
            2882294119,
            3433927263,
            1307055953,
            942726286,
            933058658,
            2468411793,
            3933900994,
            4215176142,
            1361170020,
            2001714738,
            2830558078,
            3274259782,
            1222529897,
            1679025792,
            2729314320,
            3714953764,
            1770335741,
            151462246,
            3013232138,
            1682292957,
            1483529935,
            471910574,
            1539241949,
            458788160,
            3436315007,
            1807016891,
            3718408830,
            978976581,
            1043663428,
            3165965781,
            1927990952,
            4200891579,
            2372276910,
            3208408903,
            3533431907,
            1412390302,
            2931980059,
            4132332400,
            1947078029,
            3881505623,
            4168226417,
            2941484381,
            1077988104,
            1320477388,
            886195818,
            18198404,
            3786409e3,
            2509781533,
            112762804,
            3463356488,
            1866414978,
            891333506,
            18488651,
            661792760,
            1628790961,
            3885187036,
            3141171499,
            876946877,
            2693282273,
            1372485963,
            791857591,
            2686433993,
            3759982718,
            3167212022,
            3472953795,
            2716379847,
            445679433,
            3561995674,
            3504004811,
            3574258232,
            54117162,
            3331405415,
            2381918588,
            3769707343,
            4154350007,
            1140177722,
            4074052095,
            668550556,
            3214352940,
            367459370,
            261225585,
            2610173221,
            4209349473,
            3468074219,
            3265815641,
            314222801,
            3066103646,
            3808782860,
            282218597,
            3406013506,
            3773591054,
            379116347,
            1285071038,
            846784868,
            2669647154,
            3771962079,
            3550491691,
            2305946142,
            453669953,
            1268987020,
            3317592352,
            3279303384,
            3744833421,
            2610507566,
            3859509063,
            266596637,
            3847019092,
            517658769,
            3462560207,
            3443424879,
            370717030,
            4247526661,
            2224018117,
            4143653529,
            4112773975,
            2788324899,
            2477274417,
            1456262402,
            2901442914,
            1517677493,
            1846949527,
            2295493580,
            3734397586,
            2176403920,
            1280348187,
            1908823572,
            3871786941,
            846861322,
            1172426758,
            3287448474,
            3383383037,
            1655181056,
            3139813346,
            901632758,
            1897031941,
            2986607138,
            3066810236,
            3447102507,
            1393639104,
            373351379,
            950779232,
            625454576,
            3124240540,
            4148612726,
            2007998917,
            544563296,
            2244738638,
            2330496472,
            2058025392,
            1291430526,
            424198748,
            50039436,
            29584100,
            3605783033,
            2429876329,
            2791104160,
            1057563949,
            3255363231,
            3075367218,
            3463963227,
            1469046755,
            985887462
          ]
        ];
        var u = {
          pbox: [],
          sbox: []
        };
        function f(m, x) {
          let v = x >> 24 & 255, y = x >> 16 & 255, S = x >> 8 & 255, b = x & 255, w = m.sbox[0][v] + m.sbox[1][y];
          return w = w ^ m.sbox[2][S], w = w + m.sbox[3][b], w;
        }
        function d(m, x, v) {
          let y = x, S = v, b;
          for (let w = 0; w < a; ++w)
            y = y ^ m.pbox[w], S = f(m, y) ^ S, b = y, y = S, S = b;
          return b = y, y = S, S = b, S = S ^ m.pbox[a], y = y ^ m.pbox[a + 1], { left: y, right: S };
        }
        function h(m, x, v) {
          let y = x, S = v, b;
          for (let w = a + 1; w > 1; --w)
            y = y ^ m.pbox[w], S = f(m, y) ^ S, b = y, y = S, S = b;
          return b = y, y = S, S = b, S = S ^ m.pbox[1], y = y ^ m.pbox[0], { left: y, right: S };
        }
        function p(m, x, v) {
          for (let C = 0; C < 4; C++) {
            m.sbox[C] = [];
            for (let k = 0; k < 256; k++)
              m.sbox[C][k] = c[C][k];
          }
          let y = 0;
          for (let C = 0; C < a + 2; C++)
            m.pbox[C] = l[C] ^ x[y], y++, y >= v && (y = 0);
          let S = 0, b = 0, w = 0;
          for (let C = 0; C < a + 2; C += 2)
            w = d(m, S, b), S = w.left, b = w.right, m.pbox[C] = S, m.pbox[C + 1] = b;
          for (let C = 0; C < 4; C++)
            for (let k = 0; k < 256; k += 2)
              w = d(m, S, b), S = w.left, b = w.right, m.sbox[C][k] = S, m.sbox[C][k + 1] = b;
          return true;
        }
        var O = s.Blowfish = o.extend({
          _doReset: function() {
            if (this._keyPriorReset !== this._key) {
              var m = this._keyPriorReset = this._key, x = m.words, v = m.sigBytes / 4;
              p(u, x, v);
            }
          },
          encryptBlock: function(m, x) {
            var v = d(u, m[x], m[x + 1]);
            m[x] = v.left, m[x + 1] = v.right;
          },
          decryptBlock: function(m, x) {
            var v = h(u, m[x], m[x + 1]);
            m[x] = v.left, m[x + 1] = v.right;
          },
          blockSize: 64 / 32,
          keySize: 128 / 32,
          ivSize: 64 / 32
        });
        r.Blowfish = o._createHelper(O);
      }(), n.Blowfish;
    });
  }(L0)), L0.exports;
}
(function(t4, e) {
  (function(n, r, i) {
    t4.exports = r(tt(), Th(), yq(), bq(), As(), Sq(), Ps(), Q$(), hv(), wq(), B$(), Cq(), kq(), Aq(), pv(), Pq(), Wo(), On(), Eq(), Tq(), Iq(), $q(), jq(), Rq(), Dq(), Qq(), Bq(), _q(), Mq(), Nq(), Fq(), Zq(), Wq(), Vq(), zq());
  })(Ze, function(n) {
    return n;
  });
})(D$);
var YC = D$.exports;
function Lq(t4) {
  const e = t4.substring(7).split(", "), n = {};
  for (const r of e) {
    const [i, o] = r.split("=");
    n[i] = o.replace(/"/g, "");
  }
  return n;
}
function _$(t4, e) {
  const {
    url: n,
    body: { content: r },
    method: i,
    security: { securities: o, selectedSecuritySchemeId: s }
  } = t4, a = o.filter(
    (w) => w.securitySchemeId === s || !s
  ).findLast((w) => w.securityType === H.DigestAuth);
  if (!a)
    return "";
  const {
    username: l,
    password: c,
    realm: u,
    nonce: f,
    cnonce: d,
    algorithm: h,
    qop: p,
    nc: O,
    opaque: m
  } = a[H.DigestAuth], x = qe(l, e), { pathname: v, search: y } = new URL(qe(n, e)), S = y ? `${v}${y}` : v, b = Xq({
    username: x,
    password: qe(c, e),
    uri: S,
    realm: u,
    nonce: f,
    cnonce: d,
    algorithm: h,
    qop: p,
    nc: O,
    opaque: m,
    method: i,
    bodyContent: r
  });
  return `Digest username="${x}", realm="${u}", nonce="${f}", uri="${S}", qop=${p}, nc=${O}, cnonce="${d}", response="${b}", algorithm=${h}${m ? `, opaque="${m}"` : ""}`;
}
function Xq(t4) {
  const { username: e, password: n, realm: r, nonce: i, cnonce: o, algorithm: s, qop: a, nc: l, uri: c, method: u, bodyContent: f } = t4, d = Gq(s), h = s != null && s.endsWith("-sess") ? d(`${d(`${e}:${r}:${n}`)}:${i}:${o}`) : d(`${e}:${r}:${n}`), p = a != null && a.includes("auth-int") ? d(`${u}:${c}:${d(f)}`) : d(`${u}:${c}`);
  return d(`${h}:${i}:${l}:${o}:${a}:${p}`).toString();
}
function Gq(t4) {
  switch (t4 == null ? void 0 : t4.replace("-sess", "")) {
    case "SHA-256":
      return YC.SHA256;
    default:
      return YC.MD5;
  }
}
function Yq(t4) {
  try {
    const n = new URL(t4).hostname;
    return n === "localhost" || n === "127.0.0.1";
  } catch {
    return false;
  }
}
function M$(t4, e) {
  return e.find(({ id: n }) => n === t4) || e[0];
}
async function qq(t4) {
  var f, d, h, p;
  const {
    request: e,
    response: n,
    requestError: r,
    corsProxyUrl: i,
    isProcessingRequest: o,
    mockServer: s,
    requestController: a,
    certificates: l
  } = t4, c = An(e.value);
  o.set(true), (d = (f = a.get()) == null ? void 0 : f.abort) == null || d.call(f), a.set(new AbortController());
  const u = (h = a.get()) == null ? void 0 : h.signal;
  try {
    const { method: O, url: m } = e.get(), x = m.split("?")[0], v = Gt(x, t4), y = (p = s.get()) == null ? void 0 : p.url, S = y ? v.startsWith(location.origin + y) : false, b = i.get() ? i.get() : "", w = rU(t4), k = `${S || Yq(v) ? "" : b}${v}${w ? `?${w}` : ""}`;
    await Hq(t4, k, S, u);
    const T = F$(t4), A = gv(t4), E = Date.now(), { clientCert: $, clientKey: j } = Uq(
      x,
      l.get() ? l.get() : []
    ), B = await as(k, {
      signal: u,
      method: O,
      headers: T,
      body: A || void 0,
      mode: S || V$(k) ? "same-origin" : "cors",
      clientCert: $,
      clientKey: j
    }), D = Date.now() - E;
    r.set(null), n.set(await gq(B, D));
    const N = An(n.value);
    qC(c, N, t4.history);
  } catch (O) {
    if (n.set(null), O.name === "AbortError")
      return;
    r.set(O.message);
    const m = An(n.value);
    qC(c, m, t4.history);
  } finally {
    o.set(false);
  }
}
function Uq(t4, e) {
  let n = cC(t4);
  const r = e.find(
    ({ host: i, port: o }) => cC(`https://${i}:${o}`) === n
  );
  return { clientCert: r == null ? void 0 : r.crtFilePath, clientKey: r == null ? void 0 : r.keyFilePath };
}
async function Hq(t4, e, n, r) {
  const { request: i } = t4.get(), {
    method: o,
    security: { selectedSecuritySchemeId: s }
  } = i, {
    request: {
      security: { securities: a }
    }
  } = t4, l = rl(
    a,
    s
  ).findLast((c) => c.securityType.get() === H.DigestAuth);
  if (l) {
    const c = await as(e, {
      signal: r,
      method: o,
      mode: n || V$(e) ? "same-origin" : "cors"
    }), u = Lq(c.headers.get("WWW-Authenticate") || "");
    l[H.DigestAuth].merge({
      nonce: u.nonce,
      realm: u.realm,
      qop: u.qop,
      algorithm: u.algorithm,
      opaque: u.opaque,
      cnonce: crypto.randomUUID(),
      nc: "00000001"
    });
  }
}
function qC(t4, e, n) {
  n.merge([
    {
      date: (/* @__PURE__ */ new Date()).getTime(),
      request: t4,
      response: e
    }
  ]);
}
function Jq(t4) {
  const {
    request: {
      security: { selectedSecuritySchemeId: e, securities: n }
    }
  } = t4;
  return [...rl(
    n,
    e.get()
  )].reduce(
    (o, s) => {
      const { securityType: a, ...l } = s.get();
      if (a === H.BasicAuth) {
        const u = l[H.BasicAuth];
        o.Authorization = "Basic " + btoa(`${Gt(u.username, t4)}:${Gt(u.password, t4)}`);
      }
      if (a === H.DigestAuth) {
        const { selectedEnvironmentId: u, environments: f } = t4.get(), d = M$(
          u || "",
          f
        );
        o.Authorization = _$(t4.request.get(), d.variables);
      }
      if (a === H.JWT) {
        const u = l[H.JWT];
        o.Authorization = "Bearer " + u.token;
      }
      if (a === H.OAuth2) {
        const { grantType: u } = l[H.OAuth2], { accessToken: f } = l[H.OAuth2][u];
        o.Authorization = "Bearer " + f;
      }
      if (a === H.OpenIDConnect) {
        const { grantType: u } = l[H.OpenIDConnect], { accessToken: f } = l[H.OpenIDConnect][u];
        o.Authorization = "Bearer " + f;
      }
      const c = l[H.APIKey];
      return a === H.APIKey && c.location === za.Header && c.name && c.key && (o[c.name] = c.key), o;
    },
    {}
  );
}
function Kq(t4) {
  var x, v, y;
  const {
    request: { method: e, url: n, body: r, headers: i, cookies: o, queryParameters: s },
    operation: a
  } = t4, l = n.split("?")[0].split("{{server}}")[1];
  if (!a)
    return false;
  const c = cv(a), u = !n.startsWith("{{server}}") || l !== Eh(a.path), f = c.method !== e, d = ((x = a.body) == null ? void 0 : x.mediaTypes) && ((y = (v = a.body) == null ? void 0 : v.mediaTypes) == null ? void 0 : y[r.type]) === void 0, h = c.headers && !c.headers.every((S) => i.some((b) => b.key === S.key)), p = c.cookies && !c.cookies.every((S) => o.some((b) => b.key === S.key)), O = c.queryParameters && !c.queryParameters.every((S) => s.some((b) => b.key === S.key)), m = oq(t4);
  return !u && !f && !d && !h && !p && !O && !m;
}
function gv(t4) {
  const { body: e, method: n } = t4.get().request;
  if (n === "GET" || n === "HEAD" || n === "OPTIONS")
    return null;
  try {
    switch (e.type) {
      case "JSON":
        return structuredClone(Gt(e.content, t4));
      case "multipart/form-data":
        return nU(t4);
      case "application/x-www-form-urlencoded":
        return tU(t4);
      case "application/octet-stream":
        return eU(e.binary);
      default:
        return Gt(e.content, t4);
    }
  } catch (r) {
    console.error(r);
  }
}
function eU(t4) {
  return t4 || null;
}
function tU(t4) {
  const { body: e } = t4.get().request, n = new URLSearchParams();
  return Wc(
    e.formData[ut["application/x-www-form-urlencoded"]]
  ).forEach((r) => {
    const i = Gt(r.value, t4);
    n.append(Gt(r.key, t4), i);
  }), n;
}
function nU(t4) {
  const { body: e } = t4.get().request, n = new FormData();
  return Wc(e.formData[ut.FormData]).forEach(
    ({ type: r, files: i, value: o, key: s }) => {
      const a = Gt(s, t4);
      if (r === "file" && i) {
        if (i instanceof FileList)
          for (const l of i)
            n.append(a, l);
      } else if (o) {
        const l = Gt(o, t4);
        return n.append(a, l);
      }
    }
  ), n;
}
function N$(t4) {
  const {
    request: {
      security: { selectedSecuritySchemeId: e, securities: n }
    }
  } = t4, r = rl(
    n,
    e.get()
  ), {
    request: { queryParameters: i }
  } = t4.get(), o = [...r].map((s) => {
    const { [H.APIKey]: a } = s.get();
    return a.location === za.Query ? W$(a) : null;
  }).filter(Boolean);
  return Wc([...i, ...o]);
}
function rU(t4) {
  return N$(t4).map((n) => {
    const r = Gt(n.value, t4);
    return `${Gt(n.key, t4)}=${r}`;
  }).join("&");
}
function iU(t4) {
  return N$(t4).reduce((n, r) => {
    const i = Gt(r.value, t4), o = Gt(r.key, t4);
    return {
      ...n,
      [o]: i
    };
  }, {});
}
function oU(t4) {
  const e = t4.indexOf("?");
  if (e === -1)
    return;
  const n = new URLSearchParams(t4.slice(e + 1)), r = [];
  for (const [i, o] of n.entries())
    r.push({ id: crypto.randomUUID(), active: true, key: i, value: o });
  return r;
}
function F$(t4) {
  const e = Jq(t4), n = lU(t4), r = sU(t4), { headers: i } = t4.get().request, s = {
    ...Wc(i).reduce(
      (l, c) => (l[c.key] = c.value, l),
      {}
    ),
    ...e,
    ...n || {},
    ...r && { Cookie: r, "X-Redocly-Cookie": r }
  };
  return Object.entries(s).reduce(
    (l, [c, u]) => {
      const f = Gt(c, t4), d = Gt(u, t4);
      return l[f] = d, l;
    },
    {}
  );
}
function sU(t4) {
  return Z$(t4).map((n) => {
    const r = Gt(n.value, t4);
    return `${Gt(n.key, t4)}=${r}`;
  }).join("; ");
}
function aU(t4) {
  return Z$(t4).reduce(
    (n, r) => {
      const i = Gt(r.value, t4);
      return {
        ...n,
        [Gt(r.key, t4)]: i
      };
    },
    {}
  );
}
function Z$(t4) {
  const {
    request: {
      security: { selectedSecuritySchemeId: e, securities: n }
    }
  } = t4, r = rl(
    n,
    e.get()
  ), {
    request: { cookies: i }
  } = t4.get(), o = [...r].map((s) => {
    const { [H.APIKey]: a } = s.get();
    return a.location === za.Cookie ? W$(a) : null;
  }).filter(Boolean);
  return Wc([...i, ...o]);
}
function Wc(t4) {
  return t4.filter((e) => e.active && e.key && (e.value || (e == null ? void 0 : e.files)));
}
function lU(t4) {
  const { body: e } = t4.get().request;
  if (!(!gv(t4) || e.type === "binary"))
    return { "Content-Type": e.type };
}
function W$(t4) {
  return {
    key: t4.name,
    value: t4.key,
    active: true
  };
}
function mv(t4) {
  var e;
  return (e = t4.environments.find((n) => n.get().id === t4.selectedEnvironmentId.get())) == null ? void 0 : e.get();
}
function Gt(t4, e) {
  var r;
  const { environments: n } = e.get();
  return qe(
    t4,
    ((r = mv(e)) == null ? void 0 : r.variables) || n[0].variables
  );
}
function cU(t4, e) {
  var r;
  const { environments: n } = e.get();
  return oD(
    t4,
    ((r = mv(e)) == null ? void 0 : r.variables) || n[0].variables
  );
}
function V$(t4) {
  const e = document.createElement("a");
  return e.href = t4, e.origin === window.location.origin;
}
var Ih = JY({});
var UC = null;
function z$(t4) {
  UC !== t4 && (UC = t4, Ih.configure({
    validate: true,
    schemas: [{ uri: "stub://test", fileMatch: ["*"], schema: t4 }]
  }));
}
function L$(t4) {
  const e = lO.create("stub.json", "json", 0, t4), n = Ih.parseJSONDocument(e);
  return { textDoc: e, jsonDoc: n };
}
var X$ = pn.define({
  create() {
  },
  update(t4) {
    return t4;
  }
});
var G$ = (t4) => t4.field(X$, false);
var uU = ({ state: t4 }) => {
  var n, r, i, o;
  const e = (o = (i = (r = (n = t4.operation.get({ noproxy: true, stealth: true })) == null ? void 0 : n.body) == null ? void 0 : r.mediaTypes) == null ? void 0 : i[ut.JSON]) == null ? void 0 : o.schema;
  return [X$.init(() => ({ schema: An(e || {}), state: t4 }))];
};
function fU() {
  return async (t4) => {
    const { schema: e, state: n } = G$(t4.state) || {};
    if (!e)
      return [];
    z$(e);
    const r = t4.state.doc, { content: i, sourceMap: o } = cU(r.toString(), n), { textDoc: s, jsonDoc: a } = L$(i), l = await Ih.doValidation(s, a);
    return l == null ? void 0 : l.map((c) => {
      const u = mU(s, c.range.start, o), f = u < 0 ? 0 : u;
      return {
        from: f,
        to: f + s.offsetAt(c.range.end) - s.offsetAt(c.range.start),
        message: c.message,
        severity: pU[c.severity || 3]
      };
    });
  };
}
var dU = ji.highest(
  qa.of([
    {
      key: "Tab",
      run: (t4) => yI(t4)
    }
  ])
);
function hU() {
  return async function(e) {
    const n = {
      from: e.pos,
      to: e.pos,
      options: [],
      filter: false
    }, { schema: r } = G$(e.state);
    if (!r)
      return n;
    z$(r);
    const i = e.state.doc, o = gU.bind(null, i), { textDoc: s, jsonDoc: a } = L$(i.toString()), l = e.state.doc.lineAt(e.pos), c = l.number - 1, u = e.pos - l.from, f = await Ih.doComplete(s, { line: c, character: u }, a);
    if (!f)
      return n;
    const d = e.state.sliceDoc(l.from, e.pos);
    if (d.trim().endsWith(",") || OU(d))
      return n;
    n.options = f.items.map((O) => ({
      label: O.label,
      info: O.documentation,
      apply: (m) => {
        if (!O.textEdit || !("range" in O.textEdit))
          return;
        const x = O.textEdit.range, v = O.textEdit.newText.search(/(\$1|\${1:.*?})/);
        let y = O.textEdit.newText.replace(/(\$1|\${1:.*?})/, "");
        const S = v === -1 ? 0 : v - y.length;
        m.dispatch({
          changes: {
            from: o(x.start),
            to: o(x.end),
            insert: y
          }
        });
        const b = y.length - (x.end.character - x.start.character);
        m.dispatch({
          selection: ne.single(o(x.end) + b + S)
        });
      }
    })) || [];
    const h = e.state.wordAt(e.pos), p = h != null && h.from ? e.state.sliceDoc(h == null ? void 0 : h.from, h == null ? void 0 : h.to).toLowerCase() : "";
    return p && (n.options = n.options.filter(
      (O) => O.label.toLowerCase().replace(/^"/, "").startsWith(p)
    )), n;
  };
}
var pU = {
  1: "error",
  2: "warning",
  3: "info",
  4: "hint"
};
function gU(t4, e) {
  return t4.line(e.line + 1).from + e.character;
}
function mU(t4, e, n) {
  let r = t4.offsetAt(e);
  for (const i of n)
    r > i.pos && (r -= i.offset);
  return r;
}
function OU(t4) {
  try {
    return JSON.parse(`{${t4}}`), true;
  } catch {
    return false;
  }
}
function HC(t4) {
  return new HE({
    regexp: new RegExp(`${bs}(.*?)${Ss}`, "g"),
    decoration: (e) => {
      const { selectedEnvironment: n } = t4, r = e[1], o = n.get().variables.find((l) => l.name === r), s = !(o != null && o.value), a = r === px;
      return we.mark({
        attributes: {
          style: `color: var(--replay-${a ? "server" : s ? "undefined" : "defined"}-variable-color);
          background-color: var(--replay-${a ? "server" : s ? "undefined" : "defined"}-variable-bg-color);`
        }
      });
    }
  });
}
var Gl = (t4) => Wt.fromClass(
  class {
    constructor(e) {
      Mv(this, "decorations");
      const n = HC(t4);
      this.decorations = n.createDeco(e);
    }
    update(e) {
      const n = HC(t4);
      this.decorations = n.updateDeco(e, this.decorations);
    }
  },
  {
    decorations: (e) => e.decorations
  }
);
var Qd = {
  [ut.Text]: {
    name: "Text",
    extensions: [ue.lineWrapping],
    stateExtensions: [Gl]
  },
  [ut.JSON]: {
    name: "JSON",
    extensions: [
      EL(),
      Xz(fU(), {
        delay: 300,
        needsRefresh: (t4) => t4.transactions.some((e) => e.effects.some((n) => n.is(QI)))
      }),
      _I.data.of({
        autocomplete: hU()
      }),
      dU
    ],
    stateExtensions: [Gl, uU]
  },
  [ut.XML]: {
    name: "XML",
    extensions: [HG()],
    stateExtensions: [Gl]
  }
};
var xU = {
  [ut.Image]: {
    name: "Image",
    extensions: [],
    stateExtensions: [Gl]
  }
};
var vU = {
  [ut.HTML]: {
    name: "HTML",
    extensions: [PG()],
    stateExtensions: [Gl]
  }
};
var Xu = {
  ...Qd,
  ...xU,
  ...vU
};
var Y$ = {
  [ut.FormData]: {
    name: "form-data",
    extensions: void 0
  },
  [ut["application/x-www-form-urlencoded"]]: {
    name: "x-www-form-urlencoded",
    extensions: void 0
  }
};
var q$ = {
  [ut.Binary]: {
    name: "Binary",
    extensions: void 0
  }
};
var Os = {
  ...Qd,
  ...Y$,
  ...q$
};
var U$ = Object.keys(Y$);
var H$ = Object.keys(q$);
function JC(t4) {
  return new TextEncoder().encode(t4);
}
function KC(t4) {
  return btoa(t4).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function yU(t4) {
  return btoa(String.fromCharCode(...new Uint8Array(t4))).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function bU(t4) {
  const e = new ArrayBuffer(t4.length), n = new Uint8Array(e);
  for (let r = 0, i = t4.length; r < i; r++)
    n[r] = t4.charCodeAt(r);
  return e;
}
var xO = /* @__PURE__ */ ((t4) => (t4.HS256 = "HS256", t4.HS384 = "HS384", t4.HS512 = "HS512", t4.RS256 = "RS256", t4.ES256 = "ES256", t4))(xO || {});
function ek(t4) {
  switch (t4) {
    case "HS256":
      return {
        name: "HMAC",
        hash: { name: "SHA-256" }
      };
    case "HS384":
      return {
        name: "HMAC",
        hash: { name: "SHA-384" }
      };
    case "HS512":
      return {
        name: "HMAC",
        hash: { name: "SHA-512" }
      };
    case "RS256":
      return {
        name: "RSASSA-PKCS1-v1_5",
        hash: { name: "SHA-256" }
      };
    case "ES256":
      return {
        name: "ECDSA",
        namedCurve: "P-256",
        hash: { name: "SHA-256" }
      };
    default:
      throw new Error(`Algorithm not implemented: ${t4}`);
  }
}
function J$(t4) {
  return t4 === "RS256" || t4 === "ES256";
}
async function SU(t4, e, n, r = crypto.subtle) {
  if (!r)
    throw new Error("`SubtleCrypto` interface is required for JWT signing.");
  e.startsWith("-----BEGIN") && (e = e.replace(/^-----(BEGIN|END)[\w\s]+-----$/gm, "").replace(/[^A-Za-z0-9+\/=]/gm, ""), e = atob(e));
  const i = J$(n);
  let o;
  try {
    o = await r.importKey(
      i ? "pkcs8" : "raw",
      i ? bU(e) : JC(e),
      ek(n),
      false,
      [
        "sign"
        /* Sign */
      ]
    );
  } catch (s) {
    throw false ? s : new Error("Error importing private key");
  }
  return await r.sign(ek(n), o, JC(t4));
}
async function wU(t4, e, n, r) {
  const i = {
    ...t4,
    iat: Math.floor(Date.now() / 1e3),
    exp: Math.floor(Date.now() / 1e3) + 3540
  }, o = KC(JSON.stringify(i)), a = `${KC(JSON.stringify({ alg: n, typ: "JWT", kid: r }))}.${o}`, l = yU(await SU(a, e, n));
  return [a, l].join(".");
}
function CU({ isOpen: t4, onClose: e, onSign: n }) {
  const [r, i] = fe(""), [o, s] = fe(xO.HS256), [a, l] = fe(""), [c, u] = fe(""), [f, d] = fe(""), h = async () => {
    try {
      const v = JSON.parse(r), y = await wU(v, a, o, c);
      d(""), n(y);
    } catch (v) {
      d(`Error signing JWT: ${v.message}`);
    }
  }, p = We(
    () => Object.keys(xO).map((v) => ({ label: v, value: v })),
    []
  ), O = J$(o), m = {
    bracketMatching: true,
    closeBrackets: true,
    tabSize: 2,
    foldGutter: false,
    lineNumbers: false,
    lintKeymap: true,
    drawSelection: false
  }, x = /* @__PURE__ */ g.jsxs(EU, { children: [
    /* @__PURE__ */ g.jsxs(wl, { children: [
      /* @__PURE__ */ g.jsx(Rl, { id: "signature-type-label", children: "Signature Type" }),
      /* @__PURE__ */ g.jsx(
        AU,
        {
          ariaLabeledBy: "signature-type-label",
          dataTestId: "jwt-signature-type-select",
          options: p,
          value: p.find((v) => v.value === o),
          onChange: ({ value: v }) => s(v)
        }
      )
    ] }),
    /* @__PURE__ */ g.jsxs(wl, { children: [
      /* @__PURE__ */ g.jsx(Rl, { id: "sign-key", required: true, children: O ? "Private Key" : "Secret" }),
      /* @__PURE__ */ g.jsx(tk, { children: /* @__PURE__ */ g.jsx(
        Sd,
        {
          "aria-labelledby": "sign-key",
          dataTestId: "sign-key-codemirror",
          placeholder: O ? "Enter private key" : "Enter secret",
          value: a,
          maxHeight: "170px",
          minHeight: "170px",
          onChange: (v) => l(v),
          extensions: Os[ut.Text].extensions,
          basicSetup: m
        }
      ) })
    ] }),
    /* @__PURE__ */ g.jsxs(wl, { children: [
      /* @__PURE__ */ g.jsx(Rl, { htmlFor: "key-id", children: "Key ID" }),
      /* @__PURE__ */ g.jsx(
        K$,
        {
          "data-testid": "key-id",
          id: "key-id",
          type: "text",
          value: c,
          onChange: (v) => u(v.target.value),
          placeholder: "Enter public key identifier"
        }
      )
    ] }),
    /* @__PURE__ */ g.jsxs(wl, { children: [
      /* @__PURE__ */ g.jsx(Rl, { id: "jwt-payload", required: true, children: "JWT Payload" }),
      /* @__PURE__ */ g.jsx(tk, { children: /* @__PURE__ */ g.jsx(
        Sd,
        {
          "aria-labelledby": "jwt-payload",
          dataTestId: "jwt-payload-codemirror",
          placeholder: "Enter JWT payload as JSON",
          value: r,
          maxHeight: "130px",
          minHeight: "130px",
          onChange: (v) => i(v),
          extensions: Os[ut.JSON].extensions,
          basicSetup: m
        }
      ) })
    ] }),
    f && /* @__PURE__ */ g.jsx(wl, { children: /* @__PURE__ */ g.jsx(TU, { children: f }) }),
    /* @__PURE__ */ g.jsxs(PU, { children: [
      /* @__PURE__ */ g.jsx(Button, { variant: "outlined", onClick: e, children: "Cancel" }),
      /* @__PURE__ */ g.jsx(Button, { variant: "primary", disabled: !a || !r, onClick: h, children: "Sign JWT" })
    ] })
  ] });
  return /* @__PURE__ */ g.jsx(kU, { isOpen: t4, onClose: e, title: "Sign JWT", content: x });
}
var kU = I(Uf)`
  ${E2} {
    min-width: auto;
    width: 600px;
  }

  ${T2} {
    padding-top: 0;
  }
`;
var tk = I.div`
  .codemirror-container .cm-editor {
    padding: 0;
    border: 1px solid var(--input-border-color);
    border-radius: var(--border-radius);
    cursor: text;
  }

  .codemirror-container .cm-placeholder {
    color: var(--input-content-placeholder-color);
    font-family: var(--input-font-family);
    font-size: var(--input-font-size);
  }

  .codemirror-container .cm-focused {
    border: var(--input-border-focus);
  }

  .cm-content {
    background-color: transparent;
  }
`;
var Rl = I.label`
  font-size: var(--font-size-base);

  &:before {
    content: ${(t4) => t4.required ? '"* "' : '""'};
    color: red;
  }
`;
var K$ = I.input`
  background-color: var(--input-bg-color);
  font-size: var(--input-font-size);
  font-family: var(--input-font-family);
  line-height: var(--input-line-height);
  padding: var(--input-padding);
  padding-horizontal: var(--input-padding-horizontal);
  padding-vertical: var(--input-padding-vertical);
  border: var(--input-border);
  border-radius: var(--border-radius);
  height: var(--control-height-base);

  &:hover {
    border: var(--input-border-hover);
  }

  &:focus {
    border: var(--input-border-focus);
    background-color: var(--input-bg-color);
  }

  &:focus-visible {
    outline: none;
  }

  &:disabled {
    color: var(--input-content-color-disabled);
    background-color: var(--input-bg-color-disabled);
    border: var(--input-border-disabled);
  }

  &::placeholder {
    color: var(--input-content-placeholder-color);
  }

  &.active {
    color: var(--input-content-color-active);
  }
`;
var AU = I(Mo)`
  [class*='menu'] {
    max-width: 100%;
    width: 100%;
  }

  [class*='control'] {
    max-width: 100%;
    height: var(--control-height-base);
    border: var(--input-border);
    border-radius: var(--border-radius);
  }

  [class*='control']:has(+ [class*='menu']) {
    border: var(--input-border-focus);
  }
`;
var PU = I.div`
  display: flex;
  flex-direction: row;
  justify-content: flex-end;
  width: 100%;
  gap: var(--spacing-xs);
`;
var EU = I.div`
  display: flex;
  flex-direction: column;
  gap: var(--spacing-base);
`;
var wl = I.div`
  ${Rl} {
    display: block;
    margin-bottom: var(--spacing-xs);
  }

  ${K$} {
    width: 100%;
    display: block;
  }
`;
var TU = I.div`
  color: var(--color-error-base);
`;
function ej({
  type: t4 = H.OAuth2,
  onSuccess: e,
  onError: n,
  onGenerateTokenClick: r,
  security: i,
  assertionType: o
}) {
  const {
    [t4]: {
      authRequestExtraParams: s,
      tokenRequestExtraParams: a,
      [o === mO ? ie.ClientCredentialsWithJwtAssertion : ie.ClientCredentials]: {
        clientId: l,
        clientSecret: c,
        tokenUrl: u,
        accessToken: f,
        scopes: d,
        clientAssertion: h
      }
    }
  } = i, { corsProxyUrl: p, isRequestEditable: O, tokenRequestError: m } = je(), x = hn(), v = x.variables.get(), y = async () => {
    r(), await hh.authorizeClientCredentials({
      clientId: qe(l.get(), v),
      clientSecret: qe(c.get(), v),
      scopes: Yd(d.get(), v),
      assertionType: o,
      clientAssertion: qe(h.get(), v),
      tokenUrl: qe(u.get(), v),
      corsProxyUrl: p.get(),
      extraTokenParams: qr(
        [...a.get()],
        v,
        Qr.URL
      ),
      extraTokenHeaders: qr(
        [...a.get()],
        v,
        Qr.Header
      ),
      extraTokenBody: qr(
        [...a.get()],
        v,
        Qr.Body
      ),
      successCallback: (k) => {
        e(), m.set(null), bn(k.access_token, f, x);
      },
      errorCallback: (k) => {
        n(), m.set(k.message), console.log(k);
      }
    });
  }, S = o === mO, b = S ? !l.get() || !u.get() || !h.get() : !l.get() || !u.get() || !c.get(), [w, C] = fe(false);
  return /* @__PURE__ */ g.jsxs($i, { withBorder: true, children: [
    /* @__PURE__ */ g.jsxs(st, { children: [
      /* @__PURE__ */ g.jsx(He, { required: true, children: "Client ID" }),
      /* @__PURE__ */ g.jsx(Qe, {}),
      /* @__PURE__ */ g.jsx(
        rt,
        {
          placeholder: "Client ID",
          value: l.get(),
          environment: x,
          editable: O.get(),
          onChange: (k) => l.set(k)
        }
      )
    ] }),
    /* @__PURE__ */ g.jsx(Fe, {}),
    S ? /* @__PURE__ */ g.jsxs(st, { children: [
      /* @__PURE__ */ g.jsx(He, { required: true, children: "JWT Client Assertion" }),
      /* @__PURE__ */ g.jsx(Qe, {}),
      /* @__PURE__ */ g.jsxs("div", { style: { display: "flex", alignItems: "center", width: "100%" }, children: [
        /* @__PURE__ */ g.jsx(
          rt,
          {
            placeholder: "JWT Assertion",
            value: h.get(),
            environment: x,
            editable: O.get(),
            onChange: (k) => h.set(k)
          }
        ),
        /* @__PURE__ */ g.jsx(
          Button,
          {
            variant: "text",
            size: "small",
            onClick: () => C(true),
            style: { marginLeft: "8px" },
            children: "Sign JWT"
          }
        )
      ] })
    ] }) : /* @__PURE__ */ g.jsxs(st, { children: [
      /* @__PURE__ */ g.jsx(He, { required: true, children: "Client secret" }),
      /* @__PURE__ */ g.jsx(Qe, {}),
      /* @__PURE__ */ g.jsx(
        rt,
        {
          placeholder: "Client Secret",
          value: c.get(),
          environment: x,
          editable: O.get(),
          onChange: (k) => c.set(k)
        }
      )
    ] }),
    /* @__PURE__ */ g.jsx(Fe, {}),
    /* @__PURE__ */ g.jsxs(st, { children: [
      /* @__PURE__ */ g.jsx(He, { children: "Scopes" }),
      /* @__PURE__ */ g.jsx(Qe, {}),
      /* @__PURE__ */ g.jsx(mx, { environment: x, scopes: d, editable: O.get() })
    ] }),
    /* @__PURE__ */ g.jsx(Fe, {}),
    /* @__PURE__ */ g.jsxs(st, { children: [
      /* @__PURE__ */ g.jsx(He, { required: true, children: "Access Token URL" }),
      /* @__PURE__ */ g.jsx(Qe, {}),
      /* @__PURE__ */ g.jsx(
        rt,
        {
          placeholder: "example.com",
          value: u.get(),
          environment: x,
          editable: O.get(),
          onChange: (k) => u.set(k)
        }
      )
    ] }),
    /* @__PURE__ */ g.jsx(Fe, {}),
    /* @__PURE__ */ g.jsx(
      ph,
      {
        authRequestExtraParameters: s,
        tokenRequestExtraParameters: a,
        environment: x,
        isRequestEditable: O.get(),
        hideAuthRequestExtraParameters: true
      }
    ),
    /* @__PURE__ */ g.jsx(Ic, { children: /* @__PURE__ */ g.jsx(
      Button,
      {
        variant: "secondary",
        onClick: y,
        disabled: b,
        size: "small",
        children: "Request token"
      }
    ) }),
    /* @__PURE__ */ g.jsx(
      CU,
      {
        isOpen: w,
        onClose: () => C(false),
        onSign: (k) => {
          h.set(k), C(false);
        }
      }
    )
  ] });
}
var IU = no(ej);
var $U = no((t4) => /* @__PURE__ */ g.jsx(
  ej,
  {
    ...t4,
    assertionType: "urn:ietf:params:oauth:client-assertion-type:jwt-bearer"
  }
));
var jU = [
  { label: "Auto", value: false },
  { label: "Manually", value: true }
];
function RU({ codeVerifier: t4, codeChallenge: e }) {
  const { isRequestEditable: n } = je(), [r, i] = fe(false), o = hn();
  _e(() => {
    r || (t4.set(""), e.set(""));
  }, [e, t4, r]);
  const s = Ue(
    ({ value: a }) => i(a),
    []
  );
  return /* @__PURE__ */ g.jsxs(g.Fragment, { children: [
    /* @__PURE__ */ g.jsxs(st, { children: [
      /* @__PURE__ */ g.jsx(He, { children: "Configure PKCE" }),
      /* @__PURE__ */ g.jsx(Qe, {}),
      /* @__PURE__ */ g.jsx(
        QU,
        {
          options: jU,
          value: r,
          onChange: s,
          size: "small"
        }
      )
    ] }),
    r && /* @__PURE__ */ g.jsxs(g.Fragment, { children: [
      /* @__PURE__ */ g.jsx(Fe, {}),
      /* @__PURE__ */ g.jsxs(st, { children: [
        /* @__PURE__ */ g.jsx(He, { children: "Code verifier" }),
        /* @__PURE__ */ g.jsx(Qe, {}),
        /* @__PURE__ */ g.jsx(
          rt,
          {
            placeholder: "Value",
            value: t4.get(),
            environment: o,
            editable: n.get(),
            onChange: (a) => t4.set(a)
          }
        )
      ] }),
      /* @__PURE__ */ g.jsx(Fe, {}),
      /* @__PURE__ */ g.jsxs(st, { children: [
        /* @__PURE__ */ g.jsx(He, { children: "Code challenge" }),
        /* @__PURE__ */ g.jsx(Qe, {}),
        /* @__PURE__ */ g.jsx(
          rt,
          {
            placeholder: "Value",
            value: e.get(),
            environment: o,
            editable: n.get(),
            onChange: (a) => e.set(a)
          }
        )
      ] })
    ] })
  ] });
}
var DU = no(RU);
var QU = I(Segmented)`
  margin: 8px 16px;
`;
function BU({
  type: t4,
  onError: e,
  onGenerateTokenClick: n,
  onSuccess: r,
  security: i
}) {
  const {
    [t4]: {
      authRequestExtraParams: o,
      tokenRequestExtraParams: s,
      [ie.AuthorizationCode]: {
        clientId: a,
        clientSecret: l,
        tokenUrl: c,
        authorizationUrl: u,
        callbackUrl: f,
        scopes: d,
        codeVerifier: h,
        codeChallenge: p,
        accessToken: O
      }
    }
  } = i, m = je(), { isRequestEditable: x } = m, { oAuth2RedirectURI: v } = m.get(), y = hn(), S = y.variables.get(), b = async () => {
    n(), await hh.authorizeAuthorizationCode({
      clientId: qe(a.get(), S),
      clientSecret: qe(l.get(), S),
      scopes: Yd(d.get(), S),
      codeChallenge: qe(p.get(), S),
      codeVerifier: qe(h.get(), S),
      authorizationUrl: qe(u.get(), S),
      extraAuthParams: qr([...o.get()], S),
      extraTokenBody: qr(
        [...s.get()],
        S,
        Qr.Body
      ),
      extraTokenHeaders: qr(
        [...s.get()],
        S,
        Qr.Header
      ),
      extraTokenParams: qr(
        [...s.get()],
        S,
        Qr.URL
      ),
      tokenUrl: qe(c.get(), S),
      redirectUri: qe(f.get(), S) || v,
      successCallback: (C) => {
        r(), bn(C.access_token, O, y);
      },
      errorCallback: (C) => {
        e(), console.log(C);
      }
    });
  }, w = !a.get() || !l.get() || !c.get() || !u.get();
  return /* @__PURE__ */ g.jsxs($i, { withBorder: true, children: [
    /* @__PURE__ */ g.jsxs(st, { children: [
      /* @__PURE__ */ g.jsx(He, { required: true, children: "Client ID" }),
      /* @__PURE__ */ g.jsx(Qe, {}),
      /* @__PURE__ */ g.jsx(
        rt,
        {
          placeholder: "Client ID",
          value: a.get(),
          environment: y,
          editable: x.get(),
          onChange: (C) => a.set(C)
        }
      )
    ] }),
    /* @__PURE__ */ g.jsx(Fe, {}),
    /* @__PURE__ */ g.jsxs(st, { children: [
      /* @__PURE__ */ g.jsx(He, { required: true, children: "Client secret" }),
      /* @__PURE__ */ g.jsx(Qe, {}),
      /* @__PURE__ */ g.jsx(
        rt,
        {
          placeholder: "Client Secret",
          value: l.get(),
          environment: y,
          editable: x.get(),
          onChange: (C) => l.set(C)
        }
      )
    ] }),
    /* @__PURE__ */ g.jsx(Fe, {}),
    /* @__PURE__ */ g.jsx(DU, { codeVerifier: h, codeChallenge: p }),
    /* @__PURE__ */ g.jsx(Fe, {}),
    /* @__PURE__ */ g.jsxs(st, { children: [
      /* @__PURE__ */ g.jsx(mP, { children: /* @__PURE__ */ g.jsx(He, { children: "Scopes" }) }),
      /* @__PURE__ */ g.jsx(Qe, {}),
      /* @__PURE__ */ g.jsx(mx, { environment: y, scopes: d, editable: x.get() })
    ] }),
    /* @__PURE__ */ g.jsx(Fe, {}),
    /* @__PURE__ */ g.jsxs(st, { children: [
      /* @__PURE__ */ g.jsx(He, { required: true, children: "Access Token URL" }),
      /* @__PURE__ */ g.jsx(Qe, {}),
      /* @__PURE__ */ g.jsx(
        rt,
        {
          placeholder: "example.com",
          value: c.get(),
          environment: y,
          editable: x.get(),
          onChange: (C) => c.set(C),
          dataTestId: "oauth2-access-token-url"
        }
      )
    ] }),
    /* @__PURE__ */ g.jsx(Fe, {}),
    /* @__PURE__ */ g.jsxs(st, { children: [
      /* @__PURE__ */ g.jsx(He, { required: true, children: "Authorization URL" }),
      /* @__PURE__ */ g.jsx(Qe, {}),
      /* @__PURE__ */ g.jsx(
        rt,
        {
          placeholder: "example.com",
          value: u.get(),
          environment: y,
          editable: x.get(),
          onChange: (C) => u.set(C),
          dataTestId: "oauth2-authorization-url"
        }
      )
    ] }),
    /* @__PURE__ */ g.jsx(Fe, {}),
    /* @__PURE__ */ g.jsxs(st, { children: [
      /* @__PURE__ */ g.jsx(He, { children: "Callback URL" }),
      /* @__PURE__ */ g.jsx(Qe, {}),
      /* @__PURE__ */ g.jsx(
        rt,
        {
          placeholder: "example.com",
          value: f.get(),
          environment: y,
          editable: x.get(),
          onChange: (C) => f.set(C)
        }
      )
    ] }),
    /* @__PURE__ */ g.jsx(Fe, {}),
    /* @__PURE__ */ g.jsx(
      ph,
      {
        authRequestExtraParameters: o,
        tokenRequestExtraParameters: s,
        environment: y,
        isRequestEditable: x.get()
      }
    ),
    /* @__PURE__ */ g.jsx(Ic, { children: /* @__PURE__ */ g.jsx(
      Button,
      {
        variant: "secondary",
        onClick: b,
        disabled: w,
        size: "small",
        children: "Generate token"
      }
    ) })
  ] });
}
var _U = no(BU);
function MU({
  type: t4,
  onError: e,
  onGenerateTokenClick: n,
  onSuccess: r,
  security: i
}) {
  const o = je(), {
    [t4]: {
      authRequestExtraParams: s,
      tokenRequestExtraParams: a,
      [ie.Implicit]: { clientId: l, authorizationUrl: c, callbackUrl: u, scopes: f, accessToken: d }
    }
  } = i, { isRequestEditable: h } = o, { oAuth2RedirectURI: p } = o.get(), O = hn(), m = O.variables.get(), x = () => {
    n(), hh.authorizeImplicit({
      clientId: qe(l.get(), m),
      scopes: Yd(f.get(), m),
      extraAuthParams: qr([...s.get()], m),
      authorizationUrl: qe(c.get(), m),
      redirectUri: qe(u.get(), m) || p,
      successCallback: (y) => {
        r(), bn(y.access_token, d, O);
      },
      errorCallback: (y) => {
        e(), console.log(y);
      }
    });
  }, v = !l.get() || !c.get();
  return /* @__PURE__ */ g.jsxs($i, { withBorder: true, children: [
    /* @__PURE__ */ g.jsxs(st, { children: [
      /* @__PURE__ */ g.jsx(He, { required: true, children: "Client ID" }),
      /* @__PURE__ */ g.jsx(Qe, {}),
      /* @__PURE__ */ g.jsx(
        rt,
        {
          placeholder: "Client ID",
          value: l.get(),
          environment: O,
          editable: h.get(),
          onChange: (y) => l.set(y)
        }
      )
    ] }),
    /* @__PURE__ */ g.jsx(Fe, {}),
    /* @__PURE__ */ g.jsxs(st, { children: [
      /* @__PURE__ */ g.jsx(mP, { children: /* @__PURE__ */ g.jsx(He, { children: "Scopes" }) }),
      /* @__PURE__ */ g.jsx(Qe, {}),
      /* @__PURE__ */ g.jsx(mx, { environment: O, scopes: f, editable: h.get() })
    ] }),
    /* @__PURE__ */ g.jsx(Fe, {}),
    /* @__PURE__ */ g.jsxs(st, { children: [
      /* @__PURE__ */ g.jsx(He, { required: true, children: "Authorization URL" }),
      /* @__PURE__ */ g.jsx(Qe, {}),
      /* @__PURE__ */ g.jsx(
        rt,
        {
          dataTestId: "implicit-authorization-url",
          placeholder: "example.com",
          value: c.get(),
          environment: O,
          editable: h.get(),
          onChange: (y) => c.set(y)
        }
      )
    ] }),
    /* @__PURE__ */ g.jsx(Fe, {}),
    /* @__PURE__ */ g.jsxs(st, { children: [
      /* @__PURE__ */ g.jsx(He, { children: "Callback URL" }),
      /* @__PURE__ */ g.jsx(Qe, {}),
      /* @__PURE__ */ g.jsx(
        rt,
        {
          placeholder: "example.com",
          value: u.get(),
          environment: O,
          editable: h.get(),
          onChange: (y) => u.set(y)
        }
      )
    ] }),
    /* @__PURE__ */ g.jsx(Fe, {}),
    /* @__PURE__ */ g.jsx(
      ph,
      {
        authRequestExtraParameters: s,
        tokenRequestExtraParameters: a,
        environment: O,
        isRequestEditable: h.get(),
        hideTokenRequestExtraParameters: true
      }
    ),
    /* @__PURE__ */ g.jsx(Ic, { children: /* @__PURE__ */ g.jsx(
      Button,
      {
        variant: "secondary",
        onClick: x,
        disabled: v,
        size: "small",
        children: "Generate token"
      }
    ) })
  ] });
}
var NU = no(MU);
function FU({
  type: t4,
  onSuccess: e,
  onError: n,
  onGenerateTokenClick: r,
  security: i
}) {
  const {
    [t4]: {
      authRequestExtraParams: o,
      tokenRequestExtraParams: s,
      [ie.Password]: {
        username: a,
        password: l,
        clientId: c,
        clientSecret: u,
        tokenUrl: f,
        accessToken: d
      }
    }
  } = i, { corsProxyUrl: h, isRequestEditable: p } = je(), O = hn(), m = O.variables.get(), x = async () => {
    r(), await hh.authorizePasswordGrant({
      username: qe(a.get(), m),
      password: qe(l.get(), m),
      clientId: qe(c.get(), m),
      clientSecret: qe(u.get(), m),
      tokenUrl: qe(f.get(), m),
      corsProxyUrl: h.get(),
      extraTokenParams: qr(
        [...s.get()],
        m,
        Qr.URL
      ),
      extraTokenHeaders: qr(
        [...s.get()],
        m,
        Qr.Header
      ),
      extraTokenBody: qr(
        [...s.get()],
        m,
        Qr.Body
      ),
      successCallback: (y) => {
        e(), bn(y.access_token, d, O);
      },
      errorCallback: (y) => {
        n(), console.log(y);
      }
    });
  }, v = !a.get() || !l.get() || !c.get() || !u.get() || !f.get();
  return /* @__PURE__ */ g.jsxs($i, { withBorder: true, children: [
    /* @__PURE__ */ g.jsxs(st, { children: [
      /* @__PURE__ */ g.jsx(He, { required: true, children: "Username" }),
      /* @__PURE__ */ g.jsx(Qe, {}),
      /* @__PURE__ */ g.jsx(
        rt,
        {
          placeholder: "Enter username",
          value: a.get(),
          environment: O,
          editable: p.get(),
          onChange: (y) => a.set(y)
        }
      )
    ] }),
    /* @__PURE__ */ g.jsx(Fe, {}),
    /* @__PURE__ */ g.jsxs(st, { children: [
      /* @__PURE__ */ g.jsx(He, { required: true, children: "Password" }),
      /* @__PURE__ */ g.jsx(Qe, {}),
      /* @__PURE__ */ g.jsx(
        rt,
        {
          placeholder: "Enter password",
          value: l.get(),
          environment: O,
          editable: p.get(),
          onChange: (y) => l.set(y)
        }
      )
    ] }),
    /* @__PURE__ */ g.jsx(Fe, {}),
    /* @__PURE__ */ g.jsxs(st, { children: [
      /* @__PURE__ */ g.jsx(He, { required: true, children: "Access Token URL" }),
      /* @__PURE__ */ g.jsx(Qe, {}),
      /* @__PURE__ */ g.jsx(
        rt,
        {
          placeholder: "example.com",
          value: f.get(),
          environment: O,
          editable: p.get(),
          onChange: (y) => f.set(y)
        }
      )
    ] }),
    /* @__PURE__ */ g.jsx(Fe, {}),
    /* @__PURE__ */ g.jsxs(st, { children: [
      /* @__PURE__ */ g.jsx(He, { required: true, children: "Client ID" }),
      /* @__PURE__ */ g.jsx(Qe, {}),
      /* @__PURE__ */ g.jsx(
        rt,
        {
          placeholder: "Client ID",
          value: c.get(),
          environment: O,
          editable: p.get(),
          onChange: (y) => c.set(y)
        }
      )
    ] }),
    /* @__PURE__ */ g.jsx(Fe, {}),
    /* @__PURE__ */ g.jsxs(st, { children: [
      /* @__PURE__ */ g.jsx(He, { required: true, children: "Client secret" }),
      /* @__PURE__ */ g.jsx(Qe, {}),
      /* @__PURE__ */ g.jsx(
        rt,
        {
          placeholder: "Client Secret",
          value: u.get(),
          environment: O,
          editable: p.get(),
          onChange: (y) => u.set(y)
        }
      )
    ] }),
    /* @__PURE__ */ g.jsx(Fe, {}),
    /* @__PURE__ */ g.jsx(
      ph,
      {
        authRequestExtraParameters: o,
        tokenRequestExtraParameters: s,
        environment: O,
        isRequestEditable: p.get(),
        hideAuthRequestExtraParameters: true
      }
    ),
    /* @__PURE__ */ g.jsx(Ic, { children: /* @__PURE__ */ g.jsx(
      Button,
      {
        variant: "secondary",
        onClick: x,
        disabled: v,
        size: "small",
        children: "Generate token"
      }
    ) })
  ] });
}
var ZU = no(FU);
function WU({ crossed: t4, onClick: e }) {
  return /* @__PURE__ */ g.jsx(VU, { variant: "text", onClick: e, children: t4 ? /* @__PURE__ */ g.jsx(ViewOffIcon, {}) : /* @__PURE__ */ g.jsx(ViewIcon, {}) });
}
var VU = I(Button)`
  padding: 5px;
`;
function zU({ security: t4, securityType: e }) {
  const { [H.OAuth2]: n, [H.OpenIDConnect]: r } = t4, i = e === H.OAuth2 ? n : r, [o, s] = fe(false), { grantType: a } = i, { accessToken: l } = i[a.get()];
  return /* @__PURE__ */ g.jsxs(LU, { children: [
    /* @__PURE__ */ g.jsx(XU, { type: o ? "text" : "password", value: l.get(), disabled: true }),
    /* @__PURE__ */ g.jsxs(GU, { children: [
      /* @__PURE__ */ g.jsx(
        WU,
        {
          crossed: o,
          onClick: () => s(!o)
        }
      ),
      /* @__PURE__ */ g.jsx(CopyButton, { data: l.get(), type: "icon" })
    ] })
  ] });
}
var LU = I.div`
  display: flex;
  padding: var(--spacing-xxs) var(--spacing-xs);
  justify-content: center;
  align-items: center;
  gap: var(--spacing-xs);
  margin: var(--spacing-base) 0;

  border-radius: var(--border-radius);
  border: 1px solid var(--border-color-secondary);
  background-color: var(--layer-color-ontonal);
  width: 55%;
`;
var XU = I.input`
  width: 100%;
  color: var(--text-color-secondary);
  border: none;
  background-color: transparent;
`;
var GU = I.div`
  display: flex;
  align-items: center;
  gap: var(--spacing-xs);
  padding-left: var(--spacing-xs);
  border-left: 1px solid var(--border-color-secondary);
  svg {
    cursor: pointer;
  }
`;
function YU({
  state: t4,
  security: e,
  securityType: n,
  errorMessage: r
}) {
  switch (t4) {
    case "loading":
      return {
        title: "Generating a token",
        description: "Almost there! Your token is currently being generated and will be ready in less than a minute.",
        buttonText: "Cancel generating",
        icon: /* @__PURE__ */ g.jsx(CircleDashIcon, { size: "24px", color: "--color-primary-base" })
      };
    case "success":
      return {
        title: "Token generated successfully",
        description: /* @__PURE__ */ g.jsx(zU, { security: e, securityType: n }),
        buttonText: "Proceed",
        icon: /* @__PURE__ */ g.jsx(CheckmarkIcon, { size: "24px", color: "--color-success-base" })
      };
    case "error":
      return {
        title: "Generating a token failed",
        description: /* @__PURE__ */ g.jsxs(g.Fragment, { children: [
          "An error occurred during token generation. Please check the accuracy of the entered data.",
          /* @__PURE__ */ g.jsx("br", {}),
          r
        ] }),
        buttonText: "Ok",
        icon: /* @__PURE__ */ g.jsx(CloseFilledIcon, { size: "24px", color: "--color-error-base" })
      };
  }
}
function qU({
  state: t4,
  onClick: e,
  security: n,
  securityType: r,
  errorMessage: i
}) {
  const { title: o, description: s, buttonText: a, icon: l } = YU({
    state: t4,
    security: n,
    securityType: r,
    errorMessage: i
  });
  return _e(() => {
    const c = (u) => {
      u.key === "Escape" && e();
    };
    return document.addEventListener("keydown", c), () => {
      document.removeEventListener("keydown", c);
    };
  }, [e]), /* @__PURE__ */ g.jsxs(JU, { children: [
    l,
    /* @__PURE__ */ g.jsx(KU, { children: o }),
    isString(s) ? /* @__PURE__ */ g.jsx(eH, { children: s }) : s,
    /* @__PURE__ */ g.jsx(Button, { onClick: e, children: a })
  ] });
}
var UU = no(
  qU
);
var HU = VR`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
  `;
var JU = I.div`
  display: flex;
  flex-direction: column;
  align-items: center;
  ${CircleDashIcon} {
    animation: ${HU} 3s linear infinite;
  }
`;
var KU = I.h6`
  font-size: var(--font-size-lg);
  font-weight: var(--font-weight-medium);
  line-height: var(--line-height-lg);
  margin: 0;
`;
var eH = I.p`
  font-size: var(--font-size-base);
  font-weight: var(--font-weight-regular);
  line-height: var(--line-height-base);
  color: var(--text-color-secondary);
  text-align: center;
  max-width: 48%;
`;
function tH({ onGenerateTokenClick: t4 }) {
  const [e, n] = fe("loading"), { sendEvent: r } = gt(), i = Ue(() => {
    t4(), n("loading"), r("oauth2_generate_token_clicked", {});
  }, [t4, r]), o = Ue(() => {
    n("success"), r("oauth2_generate_token_success", {});
  }, [r]), s = Ue(() => {
    n("error"), r("oauth2_generate_token_error", {});
  }, [r]);
  return {
    tokenState: e,
    handleGenerateTokenClick: i,
    handleTokenSuccess: o,
    handleTokenError: s
  };
}
var Vc = "Documented";
var nH = "Other";
function $h(t4, e) {
  if (!t4.length)
    return e;
  const n = e.filter(
    ({ value: i }) => !t4.includes(i)
  ), r = e.filter(
    ({ value: i }) => t4.includes(i)
  );
  return [
    {
      label: Vc,
      options: r
    },
    {
      label: nH,
      options: n
    }
  ];
}
var Vo = ({
  content: t4,
  placement: e,
  children: n,
  showArrow: r = true,
  className: i,
  mouseEnterDelay: o
}) => /* @__PURE__ */ g.jsx(
  Ga,
  {
    trigger: "hover",
    placement: e || "left",
    overlayStyle: { zIndex: "1000", position: "absolute" },
    overlay: typeof t4 == "string" ? /* @__PURE__ */ g.jsx(iH, { className: i, children: t4 }) : t4,
    destroyTooltipOnHide: true,
    showArrow: r && { content: /* @__PURE__ */ g.jsx(b2, {}) },
    mouseEnterDelay: o,
    children: /* @__PURE__ */ g.jsx(rH, { children: n })
  }
);
var rH = I.div`
  display: flex;
  align-items: center;
  max-width: 100%;
`;
var iH = I(No)`
  padding: var(--spacing-unit) var(--spacing-xs);
  font-size: var(--font-size-base);
  font-weight: var(--font-weight-regular);
  line-height: var(--line-height-base);
  font-style: normal;
  max-width: 200px;
`;
function jh({
  data: t4,
  getTooltipText: e
}) {
  return /* @__PURE__ */ g.jsxs(oH, { children: [
    /* @__PURE__ */ g.jsx(sH, { children: t4.label }),
    /* @__PURE__ */ g.jsx(Vo, { placement: "right", content: e(t4.label), children: /* @__PURE__ */ g.jsx(InformationIcon, {}) })
  ] });
}
var oH = I.div`
  display: flex;
  gap: var(--spacing-xs);
  width: 100%;
  margin-left: -4px;

  div svg {
    width: 14px;
    height: 14px;
  }
`;
var sH = I.span`
  text-transform: none;
  font-size: var(--font-size-sm);
  line-height: var(--line-height-sm);
  font-weight: var(--font-weight-regular);
`;
var aH = "Predefined security type from the openapi description.";
var lH = "Alternative security type types not predefined for this request.";
function cH(t4) {
  return t4 === Vc ? aH : lH;
}
function uH(t4) {
  return t4.map((e) => ({
    label: /* @__PURE__ */ g.jsx("div", { children: e }),
    value: e
  }));
}
function fH() {
  const t4 = Object.values(ie);
  return uH(t4);
}
var dH = {
  [ie.ClientCredentials]: IU,
  [ie.ClientCredentialsWithJwtAssertion]: $U,
  [ie.AuthorizationCode]: _U,
  [ie.Implicit]: NU,
  [ie.Password]: ZU
};
function tj({ security: t4, securityType: e = H.OAuth2 }) {
  const {
    [H.OAuth2]: n,
    [H.OpenIDConnect]: r,
    securitySchemeId: i
  } = t4, { operation: o, isRequestEditable: s, tokenRequestError: a } = je(), l = e === H.OAuth2 ? n : r, c = e === H.OAuth2 ? hq(o.get(), i.get()) : r.documentedOAuth2Types.get() || [], u = fH(), f = $h(c, u), d = hn(), { sendEvent: h } = gt(), p = Wg(), { tokenState: O, handleTokenSuccess: m, handleTokenError: x, handleGenerateTokenClick: v } = tH({ onGenerateTokenClick: p.handleOpen }), { grantType: y } = l, S = y.get(), { accessToken: b } = l[S], w = (T) => {
    b.set(T);
  }, C = ({ value: T }) => {
    y.set(T), h("security_oauth2_flow_changed", {
      name: T,
      isDocumented: c.includes(T)
    });
  }, k = dH[S];
  return /* @__PURE__ */ g.jsxs($i, { id: "oauth2-container", children: [
    /* @__PURE__ */ g.jsxs(st, { children: [
      /* @__PURE__ */ g.jsx(He, { children: "Access Token" }),
      /* @__PURE__ */ g.jsx(Qe, {}),
      /* @__PURE__ */ g.jsx(
        rt,
        {
          placeholder: "Enter your token or create a new one",
          value: b.get(),
          environment: d,
          editable: s.get(),
          onChange: w
        }
      )
    ] }),
    /* @__PURE__ */ g.jsx(Fe, {}),
    /* @__PURE__ */ g.jsxs(A2, { title: "Configure New Token", expanded: true, children: [
      /* @__PURE__ */ g.jsx(Fe, {}),
      /* @__PURE__ */ g.jsxs(st, { children: [
        /* @__PURE__ */ g.jsx(He, { children: "Grant type" }),
        /* @__PURE__ */ g.jsx(Qe, {}),
        /* @__PURE__ */ g.jsx(
          hH,
          {
            dataTestId: "oauth2-grand-type-select",
            options: f,
            value: u.find(({ value: T }) => T === S),
            onChange: C,
            formatGroupLabel: (T) => /* @__PURE__ */ g.jsx(jh, { data: T, getTooltipText: cH })
          }
        )
      ] }),
      /* @__PURE__ */ g.jsx(Fe, {}),
      /* @__PURE__ */ g.jsx(
        k,
        {
          type: e,
          onGenerateTokenClick: v,
          onSuccess: m,
          onError: x,
          security: t4
        }
      )
    ] }),
    /* @__PURE__ */ g.jsx(
      Uf,
      {
        title: "Generate Token",
        content: /* @__PURE__ */ g.jsx(
          UU,
          {
            state: O,
            onClick: p.handleClose,
            security: t4,
            securityType: e,
            errorMessage: a.get()
          }
        ),
        isOpen: p.isOpen,
        onClose: p.handleClose,
        mountId: "oauth2-container"
      }
    )
  ] });
}
var hH = I(kg)`
  margin-left: var(--spacing-xs);
  padding-left: 0;
`;
var pH = "Predefined request data from the openapi description.";
var gH = "Alternative authorization types not predefined for this request.";
function mH(t4) {
  return t4.map((e) => ({
    label: /* @__PURE__ */ g.jsx("div", { children: e }),
    value: e
  }));
}
function OH() {
  const t4 = Object.values(H);
  return mH(t4);
}
function xH(t4) {
  return t4 === Vc ? pH : gH;
}
async function vH(t4) {
  return (await fetch(t4)).json();
}
function yH(t4) {
  return t4.userinfo_endpoint;
}
function bH(t4, e) {
  const n = ks()[H.OAuth2], r = (s, a) => {
    switch (a) {
      case ie.AuthorizationCode:
        return {
          ...n[ie.AuthorizationCode],
          accessToken: e[ie.AuthorizationCode].accessToken,
          clientId: e[ie.AuthorizationCode].clientId,
          clientSecret: e[ie.AuthorizationCode].clientSecret,
          tokenUrl: s.token_endpoint,
          authorizationUrl: s.authorization_endpoint,
          availableScopes: s.scopes_supported || [],
          scopes: Ef(s.scopes_supported || [])
        };
      case ie.Implicit:
        return {
          ...n[ie.Implicit],
          accessToken: e[ie.Implicit].accessToken,
          clientId: e[ie.Implicit].clientId,
          authorizationUrl: s.authorization_endpoint,
          availableScopes: s.scopes_supported || [],
          scopes: Ef(s.scopes_supported || [])
        };
      default:
        return {};
    }
  }, i = SH(t4);
  return {
    ...n,
    documentedOAuth2Types: i,
    grantType: i[0] || ie.AuthorizationCode,
    [ie.AuthorizationCode]: r(t4, ie.AuthorizationCode),
    [ie.Implicit]: r(t4, ie.Implicit)
  };
}
function SH(t4) {
  const e = t4.response_types_supported;
  return (e == null ? void 0 : e.map((n) => wH(n)).filter(Boolean)) || [];
}
function wH(t4) {
  switch (t4) {
    case "token":
      return ie.Implicit;
    case "code":
    case "id_token":
      return ie.AuthorizationCode;
    default:
      return null;
  }
}
function CH({ security: t4 }) {
  const [e, n] = fe(false), [r, i] = fe(false), { [H.OpenIDConnect]: o } = t4, s = je(), { isRequestEditable: a } = s, { openIdConnectUrl: l, userInfoUrl: c } = o, u = hn(), f = (O) => {
    n(false), l.set(O);
  }, d = (O) => {
    c.set(O);
  }, h = async (O) => {
    i(true), n(false);
    try {
      const m = await vH(O);
      o.set({
        ...o.get(),
        ...bH(m, o.get()),
        userInfoUrl: yH(m)
      });
    } catch (m) {
      console.log(m), n(!!m.message);
    }
    i(false);
  }, p = () => {
    h(Gt(l.get(), s));
  };
  return /* @__PURE__ */ g.jsxs($i, { id: "oidc-container", children: [
    /* @__PURE__ */ g.jsxs(st, { children: [
      /* @__PURE__ */ g.jsx(He, { children: "OpenId Connect URL" }),
      /* @__PURE__ */ g.jsx(Qe, {}),
      /* @__PURE__ */ g.jsx(
        rt,
        {
          placeholder: "Enter your OpenId Connect URL",
          value: l.get(),
          environment: u,
          onChange: f,
          editable: a.get(),
          dataTestId: "oidc-connect-url"
        }
      )
    ] }),
    /* @__PURE__ */ g.jsx(Fe, {}),
    /* @__PURE__ */ g.jsxs(AH, { children: [
      /* @__PURE__ */ g.jsx(
        Button,
        {
          variant: "secondary",
          onClick: p,
          icon: r ? /* @__PURE__ */ g.jsx(SpinnerIcon, {}) : void 0,
          disabled: !l.get(),
          size: "small",
          children: "Generate data"
        }
      ),
      e && /* @__PURE__ */ g.jsxs(kH, { "data-testid": "oidc-data-generate-error", children: [
        /* @__PURE__ */ g.jsx(InformationIcon, { color: "var(--color-error-base)" }),
        /* @__PURE__ */ g.jsx("span", { children: "Something is wrong!" })
      ] })
    ] }),
    /* @__PURE__ */ g.jsx(Fe, {}),
    /* @__PURE__ */ g.jsxs(st, { children: [
      /* @__PURE__ */ g.jsx(He, { children: "User Info URL" }),
      /* @__PURE__ */ g.jsx(Qe, {}),
      /* @__PURE__ */ g.jsx(
        rt,
        {
          placeholder: "Enter your User Info URL",
          value: c.get() || "",
          environment: u,
          editable: a.get(),
          onChange: d
        }
      )
    ] }),
    /* @__PURE__ */ g.jsx(Fe, {}),
    /* @__PURE__ */ g.jsx(tj, { security: t4, securityType: H.OpenIDConnect })
  ] });
}
var kH = I.div`
  display: flex;
  align-items: center;
  gap: var(--spacing-xs);
  font-size: var(--font-size-base);

  span {
    color: var(--color-error-base);
  }
`;
var AH = I(Ic)`
  margin-bottom: var(--spacing-md);
  display: flex;
  justify-content: flex-start;
  gap: var(--spacing-xs);
`;
function PH({ security: t4 }) {
  const { isRequestEditable: e } = je(), {
    [H.DigestAuth]: { username: n, password: r }
  } = t4, i = hn(), o = (s, a) => {
    a.dataset.name === "username" ? n.set(s) : r.set(s);
  };
  return /* @__PURE__ */ g.jsxs($i, { children: [
    /* @__PURE__ */ g.jsxs(st, { children: [
      /* @__PURE__ */ g.jsx(He, { children: "Username" }),
      /* @__PURE__ */ g.jsx(Qe, {}),
      /* @__PURE__ */ g.jsx(
        rt,
        {
          "data-name": "username",
          placeholder: "Username",
          value: n.get(),
          environment: i,
          editable: e.get(),
          onChange: o
        }
      )
    ] }),
    /* @__PURE__ */ g.jsx(Fe, {}),
    /* @__PURE__ */ g.jsxs(st, { children: [
      /* @__PURE__ */ g.jsx(He, { children: "Password" }),
      /* @__PURE__ */ g.jsx(Qe, {}),
      /* @__PURE__ */ g.jsx(
        rt,
        {
          "data-name": "password",
          placeholder: "Password",
          value: r.get(),
          environment: i,
          editable: e.get(),
          onChange: o
        }
      )
    ] }),
    /* @__PURE__ */ g.jsx(Fe, {})
  ] });
}
var EH = {
  [H.NoAuth]: null,
  [H.BasicAuth]: PN,
  [H.DigestAuth]: PH,
  [H.JWT]: EN,
  [H.APIKey]: AN,
  [H.OAuth2]: tj,
  [H.OpenIDConnect]: CH
};
var nk = Object.values(za).map((t4) => ({
  label: /* @__PURE__ */ g.jsx("div", { children: t4 }),
  value: t4
}));
function TH({ security: t4, additionalActions: e }) {
  const { securityType: n, securitySchemeId: r } = t4, { operation: i } = je(), { sendEvent: o } = gt(), s = fq(i.get(), r.get()) || [], a = OH(), l = $h(s, a), { location: c } = t4[H.APIKey], u = EH[n.get()], f = ({ value: d }) => {
    n.set(d), o("security_type_changed", {
      name: d,
      isDocumented: s.includes(d)
    });
  };
  return /* @__PURE__ */ g.jsxs(IH, { children: [
    /* @__PURE__ */ g.jsxs($H, { children: [
      /* @__PURE__ */ g.jsxs(rk, { children: [
        /* @__PURE__ */ g.jsx(He, { children: "Authorization type" }),
        /* @__PURE__ */ g.jsx(
          kg,
          {
            dataTestId: "security-type-select",
            options: l,
            value: a.find(({ value: d }) => d == n.get()),
            onChange: f,
            formatGroupLabel: (d) => /* @__PURE__ */ g.jsx(jh, { data: d, getTooltipText: xH }),
            menuAlignment: "right"
          }
        )
      ] }),
      /* @__PURE__ */ g.jsxs(gP, { children: [
        n.get() === H.APIKey && /* @__PURE__ */ g.jsxs(rk, { children: [
          /* @__PURE__ */ g.jsx(He, { children: "Add to" }),
          /* @__PURE__ */ g.jsx(
            kg,
            {
              dataTestId: "api-key-location-select",
              options: nk,
              value: nk.find(({ value: d }) => d === c.get()),
              onChange: ({ value: d }) => c.set(d)
            }
          )
        ] }),
        e && /* @__PURE__ */ g.jsxs(g.Fragment, { children: [
          /* @__PURE__ */ g.jsx(Qe, {}),
          /* @__PURE__ */ g.jsx(jH, { children: e })
        ] })
      ] })
    ] }),
    /* @__PURE__ */ g.jsx(Fe, {}),
    u && /* @__PURE__ */ g.jsx(u, { security: t4 })
  ] });
}
var IH = I.div`
  display: flex;
  flex-direction: column;
  border-top: 1px solid var(--border-color-secondary);
`;
var $H = I.div`
  display: flex;
  flex-direction: row;
  justify-content: space-between;
  align-items: center;
  height: 40px;
`;
var rk = I.div`
  display: flex;
  flex-direction: row;
  align-items: center;
  gap: var(--spacing-xs);
`;
var jH = I.div`
  display: flex;
  flex-direction: row;
  justify-content: center;
  align-items: center;
  width: 40px;
  height: 40px;
`;
function RH({ schemes: t4 }) {
  return /* @__PURE__ */ g.jsx(_H, { children: t4.map((e, n) => /* @__PURE__ */ g.jsxs(_r, { children: [
    /* @__PURE__ */ g.jsx("span", { children: e }),
    n !== t4.length - 1 ? /* @__PURE__ */ g.jsx(nj, { borderless: true, children: "and" }) : null
  ] }, `${e}_${crypto.randomUUID()}`)) });
}
function DH() {
  return /* @__PURE__ */ g.jsxs(MH, { children: [
    /* @__PURE__ */ g.jsx(nj, { borderless: true, children: "or" }),
    /* @__PURE__ */ g.jsx(NH, {})
  ] });
}
function QH({
  securitySchemeVariants: t4,
  selectedSecuritySchemeId: e
}) {
  const { sendEvent: n } = gt(), r = We(() => t4.get().map((o) => ({
    element: /* @__PURE__ */ g.jsx(RH, { schemes: o.schemes }),
    value: o.id,
    label: "Pick security schemes"
  })), [t4]), i = (o) => {
    n("security_scheme_changed", { schemeId: o }), e.set(o);
  };
  return /* @__PURE__ */ g.jsx(
    BH,
    {
      dataTestId: "security-scheme-select",
      options: r,
      value: { value: e.get(), label: "Pick security schemes" },
      onChange: (o) => i(o),
      placeholder: "Pick security schemes",
      icon: /* @__PURE__ */ g.jsx(ChevronDownIcon, {}),
      withArrow: false,
      alignment: "end",
      renderDivider: DH,
      hideCheckmarkIcon: true
    }
  );
}
var BH = I(Select)`
  display: flex;
  margin-right: var(--spacing-xxs);
  border-radius: var(--border-radius-md);
  height: 24px;
  min-width: 180px;
  max-width: 420px;
  --select-border: none;
  --dropdown-menu-min-width: 180px;
  --dropdown-menu-max-width: 420px;

  svg {
    width: 14px;
    height: 14px;
  }
`;
var _H = I.div`
  display: flex;
  gap: var(--spacing-xxs);
  align-items: center;
  flex-wrap: wrap;
  width: max-content;
`;
var MH = I.div`
  display: flex;
  align-items: center;
  padding: 0 var(--select-list-item-padding-horizontal);
  margin: calc(var(--spacing-xs) / 4) 0;
`;
var nj = I(Tag)`
  text-transform: none;
  --tag-border-radius: var(--border-radius);
  --tag-padding: calc(var(--spacing-xs) / 4) var(--spacing-xs);
`;
var NH = I.span`
  height: 1px;
  width: 100%;
  background-color: var(--bg-color-active);
`;
function FH() {
  const { sendEvent: t4 } = gt(), e = je(), {
    request: {
      security: { selectedSecuritySchemeId: n, securities: r, securitySchemeVariants: i }
    }
  } = e, o = i.get().length, s = We(
    () => rl(
      r,
      n.get()
    ),
    [r, n]
  ), a = () => {
    t4("add_security_clicked", { name }), r.set((c) => [
      ...c,
      { ...ks(), securitySchemeId: n.get() }
    ]);
  }, l = (c) => {
    t4("remove_security_clicked", { securityType: c.securityType.get() }), c.set(pt);
  };
  return /* @__PURE__ */ g.jsxs(g.Fragment, { children: [
    o > 1 && /* @__PURE__ */ g.jsxs(WH, { children: [
      /* @__PURE__ */ g.jsx(ZH, { children: "Security scheme" }),
      /* @__PURE__ */ g.jsx(
        QH,
        {
          securitySchemeVariants: i,
          selectedSecuritySchemeId: n
        }
      )
    ] }),
    /* @__PURE__ */ g.jsx(VH, { children: s.map((c, u) => /* @__PURE__ */ g.jsx(_r, { children: /* @__PURE__ */ g.jsx(
      TH,
      {
        security: c,
        additionalActions: /* @__PURE__ */ g.jsx(
          Nr,
          {
            variant: "text",
            disabled: s.length === 1,
            icon: /* @__PURE__ */ g.jsx(TrashCanIcon, {}),
            onClick: () => l(c)
          }
        )
      }
    ) }, `${c.securityType.get()}_${c.securitySchemeId.get()}_${u}`)) }),
    /* @__PURE__ */ g.jsx(Button, { variant: "secondary", icon: /* @__PURE__ */ g.jsx(AddIcon, {}), onClick: a, children: "Add security" })
  ] });
}
var ZH = I.div`
  font-size: var(--font-size-base);
  line-height: var(--line-height-base);
`;
var WH = I.div`
  display: flex;
  flex-direction: row;
  justify-content: space-between;
  align-items: center;
  gap: var(--spacing-xs);
`;
var VH = I.div`
  display: flex;
  width: 100%;
  margin: var(--spacing-xs) 0;
  flex-direction: column;
  gap: var(--spacing-md);
`;
function zH({
  onParameterChange: t4,
  files: e
}) {
  const n = Ke(null), r = (a) => {
    var l;
    (l = a.target.files) != null && l.length && t4(a.target.files);
  }, i = () => {
    n.current.click();
  }, o = Ue(() => {
    t4(null);
  }, [t4]), s = We(() => {
    if (!e)
      return null;
    if (e.length === 1)
      return /* @__PURE__ */ g.jsx(
        ik,
        {
          icon: /* @__PURE__ */ g.jsx(CloseIcon, {}),
          variant: "secondary",
          onClick: o,
          iconPosition: "right",
          size: "small",
          children: /* @__PURE__ */ g.jsx(ok, { children: e[0].name })
        }
      );
    if (e.length > 1)
      return /* @__PURE__ */ g.jsx(
        ik,
        {
          icon: /* @__PURE__ */ g.jsx(CloseIcon, {}),
          variant: "secondary",
          onClick: o,
          iconPosition: "right",
          size: "small",
          children: /* @__PURE__ */ g.jsxs(ok, { children: [
            e.length,
            " files"
          ] })
        }
      );
  }, [e, o]);
  return /* @__PURE__ */ g.jsx(LH, { children: /* @__PURE__ */ g.jsxs(XH, { children: [
    /* @__PURE__ */ g.jsx(GH, { children: s || /* @__PURE__ */ g.jsx(qH, { children: "Add files here" }) }),
    /* @__PURE__ */ g.jsxs(YH, { children: [
      /* @__PURE__ */ g.jsx(
        z8,
        {
          onClick: i,
          variant: "text",
          "data-testid": "add-button",
          icon: /* @__PURE__ */ g.jsx(AddIcon, { color: "--text-color-secondary" })
        }
      ),
      /* @__PURE__ */ g.jsx(
        "input",
        {
          "data-testid": "file-input",
          hidden: true,
          ref: n,
          type: "file",
          multiple: true,
          accept: "files/*",
          onChange: r
        }
      )
    ] })
  ] }) });
}
var LH = I.div`
  position: relative;
  display: flex;
  flex-grow: 1;
  height: 100%;
  min-height: 40px;
`;
var XH = I.div`
  position: absolute;
  display: flex;
  width: 100%;
`;
var GH = I.div`
  display: flex;
  width: calc(100% - 24px - var(--spacing-sm)); // 24px is the width of the icon
  padding: var(--input-padding) var(--spacing-sm);
`;
var YH = I.div`
  display: flex;
  justify-content: center;
  width: 24px;
  padding: var(--input-padding) var(--spacing-sm);
`;
var ik = I(Button)`
  width: 100%;
  align-self: flex-start;
  justify-content: flex-start;
`;
var ok = I.div`
  width: 100%;
  font-size: var(--font-size-base);
  font-weight: var(--font-weight-regular);
  line-height: var(--line-height-base);
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
`;
var qH = I.div`
  font-size: var(--font-size-base);
  color: var(--input-content-placeholder-color);
  background-color: var(--bg-color);
`;
var UH = ["text", "file"];
function HH({
  title: t4,
  enableInputTypeSelection: e = false,
  onParameterChange: n,
  actions: r,
  formElements: i,
  keyName: o,
  environment: s,
  editable: a = true
}) {
  const l = (u) => u === "file" ? /* @__PURE__ */ g.jsx(FileIcon, { size: "14px" }) : /* @__PURE__ */ g.jsx(CharacterIcon, { size: "14px" }), c = UH.map((u) => ({
    label: /* @__PURE__ */ g.jsxs(JH, { children: [
      l(u),
      /* @__PURE__ */ g.jsx(aJ, { children: u })
    ] }),
    value: u
  }));
  return /* @__PURE__ */ g.jsxs(KH, { children: [
    t4 && /* @__PURE__ */ g.jsx(eJ, { children: t4 }),
    /* @__PURE__ */ g.jsx(tJ, { children: i.map((u, f) => {
      const d = f === i.length - 1, { value: h, key: p, active: O, id: m, type: x, files: v } = u.get();
      return /* @__PURE__ */ g.jsxs(nJ, { children: [
        /* @__PURE__ */ g.jsx(rJ, { children: !d && /* @__PURE__ */ g.jsxs(g.Fragment, { children: [
          /* @__PURE__ */ g.jsx(
            iJ,
            {
              type: "checkbox",
              checked: O,
              onChange: ({ target: y }) => {
                u.active.set(y.checked), n(u, d);
              }
            }
          ),
          /* @__PURE__ */ g.jsx(oJ, { checked: O })
        ] }) }),
        /* @__PURE__ */ g.jsx(Qe, {}),
        /* @__PURE__ */ g.jsxs(g.Fragment, { children: [
          /* @__PURE__ */ g.jsx(
            rt,
            {
              placeholder: `${d ? "New " : ""}${o}`,
              value: p,
              environment: s,
              editable: a,
              onChange: (y) => {
                u.nested("key").set(y), n(u, d);
              }
            }
          ),
          e && /* @__PURE__ */ g.jsx(cJ, { children: /* @__PURE__ */ g.jsx(
            lJ,
            {
              options: c,
              value: {
                label: l(x),
                value: x,
                active: true
              },
              onChange: ({ value: y }) => u.nested("type").set(y),
              withArrow: false,
              size: "small"
            }
          ) })
        ] }),
        /* @__PURE__ */ g.jsx(Qe, {}),
        x === "file" ? /* @__PURE__ */ g.jsx(
          zH,
          {
            files: v,
            onParameterChange: (y) => {
              u.nested("files").set(y), n(u, d);
            }
          }
        ) : /* @__PURE__ */ g.jsx(
          rt,
          {
            placeholder: "Value",
            value: h,
            environment: s,
            editable: a,
            onChange: (y) => {
              u.nested("value").set(y), n(u, d);
            }
          }
        ),
        /* @__PURE__ */ g.jsx(Qe, {}),
        /* @__PURE__ */ g.jsx(sJ, { children: !d && r(f) })
      ] }, m);
    }) })
  ] });
}
var JH = I.div`
  display: flex;
  align-items: center;
`;
var KH = I.div`
  display: flex;
  flex-direction: column;
  gap: var(--spacing-xs);
`;
var eJ = I.div`
  font-size: var(--font-size-base);
  line-height: var(--line-height-base);
`;
var tJ = I.div`
  display: flex;
  flex-direction: column;
  border-top: 1px solid var(--border-color-secondary);
`;
var nJ = I.div`
  display: flex;
  flex-direction: row;
  border-bottom: 1px solid var(--border-color-secondary);
  align-items: center;
`;
var rJ = I.div`
  position: relative;
  display: flex;
  justify-content: center;
  width: 40px;
`;
var iJ = I.input`
  opacity: 0;
  position: absolute;
  width: 16px;
  left: 0;
  right: 0;
  margin-left: auto;
  margin-right: auto;

  &:checked {
    accent-color: black;
  }
`;
var oJ = I(CheckboxIcon)`
  left: 0;
  right: 0;
  margin-left: auto;
  margin-right: auto;

  &:focus {
    border: 2px solid var(--button-border-color-focused);
    border-radius: var(--border-radius);
  }

  svg {
    fill: ${({ checked: t4 }) => t4 ? "var(--color-primary-hover)" : "var(--bg-color)"};
    --checkbox-border-color: var(--border-color-secondary);
    --checkbox-mark-color: var(--bg-color);
  }
`;
var sJ = I.div`
  display: flex;
  justify-content: center;
  width: 40px;
`;
var aJ = I.span`
  font-size: var(--font-size-sm);
  padding: 0px var(--spacing-sm);
  margin: 0;
`;
var lJ = I(Mo)`
  position: absolute;
  display: flex;
  border-radius: var(--border-radius-md);

  [class*='menu'] {
    min-width: 120px;
  }

  [class*='IndicatorsContainer'] {
    display: none;
  }

  [class*='option'] {
    min-height: 24px;
  }

  [class*='singleValue'] {
    width: 16px;
    height: 16px;
    display: flex;
    align-items: center;
  }

  [class*='control'] {
    padding: 0px calc(var(--spacing-xs) / 2);
  }
`;
var cJ = I.div`
  display: flex;
  justify-content: center;
`;
function uJ({ type: t4 }) {
  const e = hn(), {
    request: { body: n },
    isRequestEditable: r
  } = je(), i = n.formData[t4];
  function o(a, l) {
    l && i.merge([na()]);
  }
  function s(a) {
    i[a].set(pt);
  }
  return /* @__PURE__ */ g.jsx(
    HH,
    {
      keyName: "Param",
      formElements: i,
      onParameterChange: o,
      environment: e,
      enableInputTypeSelection: t4 !== ut["application/x-www-form-urlencoded"],
      editable: r.get(),
      actions: (a) => /* @__PURE__ */ g.jsx(
        Nr,
        {
          onClick: () => s(a),
          variant: "text",
          icon: /* @__PURE__ */ g.jsx(TrashCanIcon, {})
        }
      )
    }
  );
}
var fJ = () => {
  const { body: t4 } = je().request, { binary: e } = t4, n = e.get(), [r, i] = fe(false), o = (l) => {
    var u;
    const c = (u = l.target.files) == null ? void 0 : u[0];
    if (c) {
      i(true);
      const f = new FileReader();
      f.onload = () => {
        i(false), e.set(c);
      }, f.readAsDataURL(c);
    }
  }, s = (l) => {
    if (l.key === "Enter") {
      l.preventDefault();
      const c = document.getElementById("file-input");
      c && c.click();
    }
  }, a = () => {
    e.set(null);
  };
  return r ? /* @__PURE__ */ g.jsxs(dJ, { children: [
    /* @__PURE__ */ g.jsx(SpinnerIcon, {}),
    "Loading..."
  ] }) : n && n.name ? /* @__PURE__ */ g.jsxs(hJ, { children: [
    /* @__PURE__ */ g.jsxs(pJ, { children: [
      /* @__PURE__ */ g.jsx(DocumentBlankIcon, { size: "16px" }),
      /* @__PURE__ */ g.jsx(gJ, { children: n.name })
    ] }),
    /* @__PURE__ */ g.jsx(Nr, { onClick: a, icon: /* @__PURE__ */ g.jsx(TrashCanIcon, {}) })
  ] }) : /* @__PURE__ */ g.jsx(rj, { children: !n && /* @__PURE__ */ g.jsxs(mJ, { tabIndex: 0, role: "button", onKeyDown: s, children: [
    /* @__PURE__ */ g.jsx("input", { id: "file-input", type: "file", onChange: o }),
    /* @__PURE__ */ g.jsx(CloudUploadIcon, {}),
    "Upload file"
  ] }) });
};
var rj = I.div`
  display: flex;
  align-items: center;
  justify-content: flex-start;
  width: 100%;
  padding: var(--spacing-base) 0;
`;
var dJ = I(rj)`
  font-size: var(--font-size-base);
  gap: var(--spacing-xs);
`;
var hJ = I.div`
  display: flex;
  align-items: center;
  justify-content: space-between;
  width: 100%;
`;
var pJ = I.div`
  display: flex;
  align-items: center;
  gap: var(--spacing-xs);
`;
var gJ = I.p`
  font-size: var(--font-size-base);
`;
var mJ = I.label`
  display: flex;
  align-items: center;
  gap: var(--spacing-xs);
  border: unset;
  cursor: pointer;
  font-size: var(--font-size-base);

  input[type='file'] {
    display: none;
  }

  &:focus {
    border: 1px solid var(--button-border-color-focused);
    border-radius: var(--border-radius-base);
  }
`;
var OJ = "Predefined body type from the openapi description.";
var xJ = "Alternative body type types not predefined for this request.";
function vJ(t4) {
  return t4 === Vc ? OJ : xJ;
}
function yJ(t4) {
  return t4.map((e) => {
    var n;
    return {
      label: /* @__PURE__ */ g.jsx("div", { children: ((n = Os[e]) == null ? void 0 : n.name) || e }),
      value: e
    };
  });
}
function bJ(t4) {
  return yJ(Object.keys(uv(t4)));
}
var Bd = "REPLAY_VARIABLE";
function SJ(t4) {
  try {
    const e = wJ(t4), n = JSON.parse(e), r = JSON.stringify(n, null, 2);
    return CJ(r);
  } catch (e) {
    return console.error({ error: e }), t4;
  }
}
function wJ(t4) {
  return t4.replace(
    new RegExp(`(?<!")${yA}(?!")`, "g"),
    `"${Bd}$&${Bd}"`
  );
}
function CJ(t4) {
  return t4.replace(new RegExp(`"${Bd}(.*?)${Bd}"`, "g"), "$1");
}
function kJ() {
  const { request: t4, operation: e, isRequestEditable: n } = je(), r = hn(), { sendEvent: i } = gt(), { content: o, type: s, activeExampleName: a } = t4.body, l = We(
    () => {
      var S, b;
      return e ? Object.keys(((b = (S = e.get()) == null ? void 0 : S.body) == null ? void 0 : b.mediaTypes) || {}) : [];
    },
    [e]
  ), c = bJ(e.get()), u = We(
    () => $h(l, c),
    [c, l]
  ), f = We(
    () => {
      var S, b, w;
      return OO((w = (b = (S = e.get()) == null ? void 0 : S.body) == null ? void 0 : b.mediaTypes) == null ? void 0 : w[s.get()]);
    },
    [e, s]
  ), d = We(
    () => f.map(({ name: S, value: b }) => ({
      element: /* @__PURE__ */ g.jsx("div", { children: S }),
      value: b,
      title: S
    })),
    [f]
  ), h = Ue(
    (S) => {
      o.set(S);
    },
    [o]
  ), p = Ue(
    (S) => {
      const { key: b, name: w } = f.find(
        (C) => JSON.stringify(C.value, null, 2) === JSON.stringify(S, null, 2)
      ) || {};
      a.set(b || f[0].key), o.set(typeof S != "string" ? JSON.stringify(S, null, 2) : S), i("request_body_example_changed", { name: w });
    },
    [a, o, f, i]
  ), O = Ue(
    ({ value: S }) => {
      var w, C, k;
      s.set(S);
      const [b] = OO(
        (k = (C = (w = e.get()) == null ? void 0 : w.body) == null ? void 0 : C.mediaTypes) == null ? void 0 : k[S]
      );
      if (b) {
        const { key: T, value: A } = b;
        a.set(T), o.set(
          typeof A != "string" ? JSON.stringify(A, null, 2) : A
        );
      }
      i("request_body_type_changed", {
        name: S,
        isDocumented: l.includes(S)
      });
    },
    [s, e, a, o, i, l]
  ), m = We(() => {
    var S;
    return [...((S = Os[s.value]) == null ? void 0 : S.extensions) || []];
  }, [s]), x = We(() => {
    var S;
    return [...((S = Os[s.value]) == null ? void 0 : S.stateExtensions) || []];
  }, [s]), v = Ue(() => {
    o.set(SJ(o.get()));
  }, [o]), y = Ue(() => {
    switch (true) {
      case U$.includes(s.value):
        return /* @__PURE__ */ g.jsx(uJ, { type: s.value });
      case H$.includes(s.value):
        return /* @__PURE__ */ g.jsx(sk, { children: /* @__PURE__ */ g.jsx(fJ, {}) });
      default:
        return /* @__PURE__ */ g.jsx(sk, { children: n.get() ? /* @__PURE__ */ g.jsx(
          Sd,
          {
            dataTestId: "request-body-tab-codemirror",
            value: o.get(),
            height: "200px",
            onChange: h,
            extensions: m,
            stateExtensions: x
          }
        ) : /* @__PURE__ */ g.jsx($J, { children: bA(
          o.get(),
          r.variables.get()
        ) }) });
    }
  }, [
    s,
    o,
    n,
    m,
    x,
    r,
    h
  ]);
  return /* @__PURE__ */ g.jsxs(AJ, { children: [
    /* @__PURE__ */ g.jsxs(TJ, { children: [
      /* @__PURE__ */ g.jsxs(IJ, { children: [
        /* @__PURE__ */ g.jsx(
          PJ,
          {
            dataTestId: "request-body-type-select",
            options: u,
            value: c.find(({ value: S }) => S === s.get()),
            onChange: O,
            formatGroupLabel: (S) => /* @__PURE__ */ g.jsx(jh, { data: S, getTooltipText: vJ })
          }
        ),
        s.value === "application/json" && o.get() && /* @__PURE__ */ g.jsx(Button, { variant: "ghost", onClick: v, children: "Prettify" })
      ] }),
      f.length ? /* @__PURE__ */ g.jsx(
        EJ,
        {
          options: d,
          value: { value: a.get(), label: "Pick an example" },
          onChange: (S) => p(S),
          placeholder: "Pick an example",
          icon: /* @__PURE__ */ g.jsx(ChevronSortIcon, {}),
          withArrow: false,
          alignment: "end"
        }
      ) : null
    ] }),
    y()
  ] });
}
var AJ = I.div`
  display: flex;
  flex-direction: column;
  border-top: 1px solid var(--border-color-secondary);
`;
var PJ = I(Mo)`
  display: flex;
  border-radius: var(--border-radius-md);

  [class*='menu'] {
    min-width: 224px;
  }

  svg {
    width: 12px;
    height: 12px;
  }
`;
var EJ = I(Select)`
  display: flex;
  border-radius: var(--border-radius-md);
  background-color: var(--bg-color-active);
  height: 24px;
  min-width: 158px;
  --select-border: none;
  --dropdown-menu-min-width: 158px;

  svg {
    width: 14px;
    height: 14px;
  }
`;
var TJ = I.div`
  display: flex;
  flex-direction: row;
  justify-content: space-between;
  align-items: center;
  height: 40px;

  div: {
    padding-left: 0;
  }
`;
var IJ = I.div`
  display: flex;
  flex-direction: row;
  align-items: center;
  gap: var(--spacing-xs);
`;
var sk = I.div`
  border-top: 1px solid var(--border-color-secondary);
`;
var $J = I.pre`
  color: var(--code-block-text-color);
  font-family: var(--font-family-monospaced);
  font-weight: var(--code-block-font-weight);
  font-size: var(--code-block-font-size);
  line-height: var(--code-block-line-height);
  padding: var(--spacing-sm) 0 var(--spacing-xs) calc(var(--spacing-sm) + 31px);
  margin: 0;
`;
function Cl({ type: t4, className: e }) {
  return t4 ? /* @__PURE__ */ g.jsx(jJ, { className: e, children: t4 }) : null;
}
var jJ = I.em`
  vertical-align: middle;
  color: var(--schema-type-text-color);
  font-size: var(--font-size-base);
  line-height: var(--line-height-base);
  font-style: normal;

  :after {
    content: ',';
  }

  &:last-of-type:after {
    content: '';
  }
`;
function ij() {
  return {
    async: false,
    baseUrl: null,
    breaks: false,
    extensions: null,
    gfm: true,
    headerIds: true,
    headerPrefix: "",
    highlight: null,
    langPrefix: "language-",
    mangle: true,
    pedantic: false,
    renderer: null,
    sanitize: false,
    sanitizer: null,
    silent: false,
    smartypants: false,
    tokenizer: null,
    walkTokens: null,
    xhtml: false
  };
}
var il = ij();
function RJ(t4) {
  il = t4;
}
var oj = /[&<>"']/;
var DJ = new RegExp(oj.source, "g");
var sj = /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/;
var QJ = new RegExp(sj.source, "g");
var BJ = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
var ak = (t4) => BJ[t4];
function wn(t4, e) {
  if (e) {
    if (oj.test(t4))
      return t4.replace(DJ, ak);
  } else if (sj.test(t4))
    return t4.replace(QJ, ak);
  return t4;
}
var _J = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;
function aj(t4) {
  return t4.replace(_J, (e, n) => (n = n.toLowerCase(), n === "colon" ? ":" : n.charAt(0) === "#" ? n.charAt(1) === "x" ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1)) : ""));
}
var MJ = /(^|[^\[])\^/g;
function $t(t4, e) {
  t4 = typeof t4 == "string" ? t4 : t4.source, e = e || "";
  const n = {
    replace: (r, i) => (i = i.source || i, i = i.replace(MJ, "$1"), t4 = t4.replace(r, i), n),
    getRegex: () => new RegExp(t4, e)
  };
  return n;
}
var NJ = /[^\w:]/g;
var FJ = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;
function lk(t4, e, n) {
  if (t4) {
    let r;
    try {
      r = decodeURIComponent(aj(n)).replace(NJ, "").toLowerCase();
    } catch {
      return null;
    }
    if (r.indexOf("javascript:") === 0 || r.indexOf("vbscript:") === 0 || r.indexOf("data:") === 0)
      return null;
  }
  e && !FJ.test(n) && (n = zJ(e, n));
  try {
    n = encodeURI(n).replace(/%25/g, "%");
  } catch {
    return null;
  }
  return n;
}
var Gu = {};
var ZJ = /^[^:]+:\/*[^/]*$/;
var WJ = /^([^:]+:)[\s\S]*$/;
var VJ = /^([^:]+:\/*[^/]*)[\s\S]*$/;
function zJ(t4, e) {
  Gu[" " + t4] || (ZJ.test(t4) ? Gu[" " + t4] = t4 + "/" : Gu[" " + t4] = Sf(t4, "/", true)), t4 = Gu[" " + t4];
  const n = t4.indexOf(":") === -1;
  return e.substring(0, 2) === "//" ? n ? e : t4.replace(WJ, "$1") + e : e.charAt(0) === "/" ? n ? e : t4.replace(VJ, "$1") + e : t4 + e;
}
var _d = { exec: function() {
} };
function ti(t4) {
  let e = 1, n, r;
  for (; e < arguments.length; e++) {
    n = arguments[e];
    for (r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (t4[r] = n[r]);
  }
  return t4;
}
function ck(t4, e) {
  const n = t4.replace(/\|/g, (o, s, a) => {
    let l = false, c = s;
    for (; --c >= 0 && a[c] === "\\"; )
      l = !l;
    return l ? "|" : " |";
  }), r = n.split(/ \|/);
  let i = 0;
  if (r[0].trim() || r.shift(), r.length > 0 && !r[r.length - 1].trim() && r.pop(), r.length > e)
    r.splice(e);
  else
    for (; r.length < e; )
      r.push("");
  for (; i < r.length; i++)
    r[i] = r[i].trim().replace(/\\\|/g, "|");
  return r;
}
function Sf(t4, e, n) {
  const r = t4.length;
  if (r === 0)
    return "";
  let i = 0;
  for (; i < r; ) {
    const o = t4.charAt(r - i - 1);
    if (o === e && !n)
      i++;
    else if (o !== e && n)
      i++;
    else
      break;
  }
  return t4.slice(0, r - i);
}
function LJ(t4, e) {
  if (t4.indexOf(e[1]) === -1)
    return -1;
  const n = t4.length;
  let r = 0, i = 0;
  for (; i < n; i++)
    if (t4[i] === "\\")
      i++;
    else if (t4[i] === e[0])
      r++;
    else if (t4[i] === e[1] && (r--, r < 0))
      return i;
  return -1;
}
function lj(t4) {
  t4 && t4.sanitize && !t4.silent && console.warn("marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options");
}
function uk(t4, e) {
  if (e < 1)
    return "";
  let n = "";
  for (; e > 1; )
    e & 1 && (n += t4), e >>= 1, t4 += t4;
  return n + t4;
}
function fk(t4, e, n, r) {
  const i = e.href, o = e.title ? wn(e.title) : null, s = t4[1].replace(/\\([\[\]])/g, "$1");
  if (t4[0].charAt(0) !== "!") {
    r.state.inLink = true;
    const a = {
      type: "link",
      raw: n,
      href: i,
      title: o,
      text: s,
      tokens: r.inlineTokens(s)
    };
    return r.state.inLink = false, a;
  }
  return {
    type: "image",
    raw: n,
    href: i,
    title: o,
    text: wn(s)
  };
}
function XJ(t4, e) {
  const n = t4.match(/^(\s+)(?:```)/);
  if (n === null)
    return e;
  const r = n[1];
  return e.split(`
`).map((i) => {
    const o = i.match(/^\s+/);
    if (o === null)
      return i;
    const [s] = o;
    return s.length >= r.length ? i.slice(r.length) : i;
  }).join(`
`);
}
var Ov = class {
  constructor(e) {
    this.options = e || il;
  }
  space(e) {
    const n = this.rules.block.newline.exec(e);
    if (n && n[0].length > 0)
      return {
        type: "space",
        raw: n[0]
      };
  }
  code(e) {
    const n = this.rules.block.code.exec(e);
    if (n) {
      const r = n[0].replace(/^ {1,4}/gm, "");
      return {
        type: "code",
        raw: n[0],
        codeBlockStyle: "indented",
        text: this.options.pedantic ? r : Sf(r, `
`)
      };
    }
  }
  fences(e) {
    const n = this.rules.block.fences.exec(e);
    if (n) {
      const r = n[0], i = XJ(r, n[3] || "");
      return {
        type: "code",
        raw: r,
        lang: n[2] ? n[2].trim().replace(this.rules.inline._escapes, "$1") : n[2],
        text: i
      };
    }
  }
  heading(e) {
    const n = this.rules.block.heading.exec(e);
    if (n) {
      let r = n[2].trim();
      if (/#$/.test(r)) {
        const i = Sf(r, "#");
        (this.options.pedantic || !i || / $/.test(i)) && (r = i.trim());
      }
      return {
        type: "heading",
        raw: n[0],
        depth: n[1].length,
        text: r,
        tokens: this.lexer.inline(r)
      };
    }
  }
  hr(e) {
    const n = this.rules.block.hr.exec(e);
    if (n)
      return {
        type: "hr",
        raw: n[0]
      };
  }
  blockquote(e) {
    const n = this.rules.block.blockquote.exec(e);
    if (n) {
      const r = n[0].replace(/^ *>[ \t]?/gm, ""), i = this.lexer.state.top;
      this.lexer.state.top = true;
      const o = this.lexer.blockTokens(r);
      return this.lexer.state.top = i, {
        type: "blockquote",
        raw: n[0],
        tokens: o,
        text: r
      };
    }
  }
  list(e) {
    let n = this.rules.block.list.exec(e);
    if (n) {
      let r, i, o, s, a, l, c, u, f, d, h, p, O = n[1].trim();
      const m = O.length > 1, x = {
        type: "list",
        raw: "",
        ordered: m,
        start: m ? +O.slice(0, -1) : "",
        loose: false,
        items: []
      };
      O = m ? `\\d{1,9}\\${O.slice(-1)}` : `\\${O}`, this.options.pedantic && (O = m ? O : "[*+-]");
      const v = new RegExp(`^( {0,3}${O})((?:[	 ][^\\n]*)?(?:\\n|$))`);
      for (; e && (p = false, !(!(n = v.exec(e)) || this.rules.block.hr.test(e))); ) {
        if (r = n[0], e = e.substring(r.length), u = n[2].split(`
`, 1)[0].replace(/^\t+/, (S) => " ".repeat(3 * S.length)), f = e.split(`
`, 1)[0], this.options.pedantic ? (s = 2, h = u.trimLeft()) : (s = n[2].search(/[^ ]/), s = s > 4 ? 1 : s, h = u.slice(s), s += n[1].length), l = false, !u && /^ *$/.test(f) && (r += f + `
`, e = e.substring(f.length + 1), p = true), !p) {
          const S = new RegExp(`^ {0,${Math.min(3, s - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`), b = new RegExp(`^ {0,${Math.min(3, s - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`), w = new RegExp(`^ {0,${Math.min(3, s - 1)}}(?:\`\`\`|~~~)`), C = new RegExp(`^ {0,${Math.min(3, s - 1)}}#`);
          for (; e && (d = e.split(`
`, 1)[0], f = d, this.options.pedantic && (f = f.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ")), !(w.test(f) || C.test(f) || S.test(f) || b.test(e))); ) {
            if (f.search(/[^ ]/) >= s || !f.trim())
              h += `
` + f.slice(s);
            else {
              if (l || u.search(/[^ ]/) >= 4 || w.test(u) || C.test(u) || b.test(u))
                break;
              h += `
` + f;
            }
            !l && !f.trim() && (l = true), r += d + `
`, e = e.substring(d.length + 1), u = f.slice(s);
          }
        }
        x.loose || (c ? x.loose = true : /\n *\n *$/.test(r) && (c = true)), this.options.gfm && (i = /^\[[ xX]\] /.exec(h), i && (o = i[0] !== "[ ] ", h = h.replace(/^\[[ xX]\] +/, ""))), x.items.push({
          type: "list_item",
          raw: r,
          task: !!i,
          checked: o,
          loose: false,
          text: h
        }), x.raw += r;
      }
      x.items[x.items.length - 1].raw = r.trimRight(), x.items[x.items.length - 1].text = h.trimRight(), x.raw = x.raw.trimRight();
      const y = x.items.length;
      for (a = 0; a < y; a++)
        if (this.lexer.state.top = false, x.items[a].tokens = this.lexer.blockTokens(x.items[a].text, []), !x.loose) {
          const S = x.items[a].tokens.filter((w) => w.type === "space"), b = S.length > 0 && S.some((w) => /\n.*\n/.test(w.raw));
          x.loose = b;
        }
      if (x.loose)
        for (a = 0; a < y; a++)
          x.items[a].loose = true;
      return x;
    }
  }
  html(e) {
    const n = this.rules.block.html.exec(e);
    if (n) {
      const r = {
        type: "html",
        raw: n[0],
        pre: !this.options.sanitizer && (n[1] === "pre" || n[1] === "script" || n[1] === "style"),
        text: n[0]
      };
      if (this.options.sanitize) {
        const i = this.options.sanitizer ? this.options.sanitizer(n[0]) : wn(n[0]);
        r.type = "paragraph", r.text = i, r.tokens = this.lexer.inline(i);
      }
      return r;
    }
  }
  def(e) {
    const n = this.rules.block.def.exec(e);
    if (n) {
      const r = n[1].toLowerCase().replace(/\s+/g, " "), i = n[2] ? n[2].replace(/^<(.*)>$/, "$1").replace(this.rules.inline._escapes, "$1") : "", o = n[3] ? n[3].substring(1, n[3].length - 1).replace(this.rules.inline._escapes, "$1") : n[3];
      return {
        type: "def",
        tag: r,
        raw: n[0],
        href: i,
        title: o
      };
    }
  }
  table(e) {
    const n = this.rules.block.table.exec(e);
    if (n) {
      const r = {
        type: "table",
        header: ck(n[1]).map((i) => ({ text: i })),
        align: n[2].replace(/^ *|\| *$/g, "").split(/ *\| */),
        rows: n[3] && n[3].trim() ? n[3].replace(/\n[ \t]*$/, "").split(`
`) : []
      };
      if (r.header.length === r.align.length) {
        r.raw = n[0];
        let i = r.align.length, o, s, a, l;
        for (o = 0; o < i; o++)
          /^ *-+: *$/.test(r.align[o]) ? r.align[o] = "right" : /^ *:-+: *$/.test(r.align[o]) ? r.align[o] = "center" : /^ *:-+ *$/.test(r.align[o]) ? r.align[o] = "left" : r.align[o] = null;
        for (i = r.rows.length, o = 0; o < i; o++)
          r.rows[o] = ck(r.rows[o], r.header.length).map((c) => ({ text: c }));
        for (i = r.header.length, s = 0; s < i; s++)
          r.header[s].tokens = this.lexer.inline(r.header[s].text);
        for (i = r.rows.length, s = 0; s < i; s++)
          for (l = r.rows[s], a = 0; a < l.length; a++)
            l[a].tokens = this.lexer.inline(l[a].text);
        return r;
      }
    }
  }
  lheading(e) {
    const n = this.rules.block.lheading.exec(e);
    if (n)
      return {
        type: "heading",
        raw: n[0],
        depth: n[2].charAt(0) === "=" ? 1 : 2,
        text: n[1],
        tokens: this.lexer.inline(n[1])
      };
  }
  paragraph(e) {
    const n = this.rules.block.paragraph.exec(e);
    if (n) {
      const r = n[1].charAt(n[1].length - 1) === `
` ? n[1].slice(0, -1) : n[1];
      return {
        type: "paragraph",
        raw: n[0],
        text: r,
        tokens: this.lexer.inline(r)
      };
    }
  }
  text(e) {
    const n = this.rules.block.text.exec(e);
    if (n)
      return {
        type: "text",
        raw: n[0],
        text: n[0],
        tokens: this.lexer.inline(n[0])
      };
  }
  escape(e) {
    const n = this.rules.inline.escape.exec(e);
    if (n)
      return {
        type: "escape",
        raw: n[0],
        text: wn(n[1])
      };
  }
  tag(e) {
    const n = this.rules.inline.tag.exec(e);
    if (n)
      return !this.lexer.state.inLink && /^<a /i.test(n[0]) ? this.lexer.state.inLink = true : this.lexer.state.inLink && /^<\/a>/i.test(n[0]) && (this.lexer.state.inLink = false), !this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(n[0]) ? this.lexer.state.inRawBlock = true : this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(n[0]) && (this.lexer.state.inRawBlock = false), {
        type: this.options.sanitize ? "text" : "html",
        raw: n[0],
        inLink: this.lexer.state.inLink,
        inRawBlock: this.lexer.state.inRawBlock,
        text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(n[0]) : wn(n[0]) : n[0]
      };
  }
  link(e) {
    const n = this.rules.inline.link.exec(e);
    if (n) {
      const r = n[2].trim();
      if (!this.options.pedantic && /^</.test(r)) {
        if (!/>$/.test(r))
          return;
        const s = Sf(r.slice(0, -1), "\\");
        if ((r.length - s.length) % 2 === 0)
          return;
      } else {
        const s = LJ(n[2], "()");
        if (s > -1) {
          const l = (n[0].indexOf("!") === 0 ? 5 : 4) + n[1].length + s;
          n[2] = n[2].substring(0, s), n[0] = n[0].substring(0, l).trim(), n[3] = "";
        }
      }
      let i = n[2], o = "";
      if (this.options.pedantic) {
        const s = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(i);
        s && (i = s[1], o = s[3]);
      } else
        o = n[3] ? n[3].slice(1, -1) : "";
      return i = i.trim(), /^</.test(i) && (this.options.pedantic && !/>$/.test(r) ? i = i.slice(1) : i = i.slice(1, -1)), fk(n, {
        href: i && i.replace(this.rules.inline._escapes, "$1"),
        title: o && o.replace(this.rules.inline._escapes, "$1")
      }, n[0], this.lexer);
    }
  }
  reflink(e, n) {
    let r;
    if ((r = this.rules.inline.reflink.exec(e)) || (r = this.rules.inline.nolink.exec(e))) {
      let i = (r[2] || r[1]).replace(/\s+/g, " ");
      if (i = n[i.toLowerCase()], !i) {
        const o = r[0].charAt(0);
        return {
          type: "text",
          raw: o,
          text: o
        };
      }
      return fk(r, i, r[0], this.lexer);
    }
  }
  emStrong(e, n, r = "") {
    let i = this.rules.inline.emStrong.lDelim.exec(e);
    if (!i || i[3] && r.match(/[\p{L}\p{N}]/u))
      return;
    const o = i[1] || i[2] || "";
    if (!o || o && (r === "" || this.rules.inline.punctuation.exec(r))) {
      const s = i[0].length - 1;
      let a, l, c = s, u = 0;
      const f = i[0][0] === "*" ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;
      for (f.lastIndex = 0, n = n.slice(-1 * e.length + s); (i = f.exec(n)) != null; ) {
        if (a = i[1] || i[2] || i[3] || i[4] || i[5] || i[6], !a)
          continue;
        if (l = a.length, i[3] || i[4]) {
          c += l;
          continue;
        } else if ((i[5] || i[6]) && s % 3 && !((s + l) % 3)) {
          u += l;
          continue;
        }
        if (c -= l, c > 0)
          continue;
        l = Math.min(l, l + c + u);
        const d = e.slice(0, s + i.index + (i[0].length - a.length) + l);
        if (Math.min(s, l) % 2) {
          const p = d.slice(1, -1);
          return {
            type: "em",
            raw: d,
            text: p,
            tokens: this.lexer.inlineTokens(p)
          };
        }
        const h = d.slice(2, -2);
        return {
          type: "strong",
          raw: d,
          text: h,
          tokens: this.lexer.inlineTokens(h)
        };
      }
    }
  }
  codespan(e) {
    const n = this.rules.inline.code.exec(e);
    if (n) {
      let r = n[2].replace(/\n/g, " ");
      const i = /[^ ]/.test(r), o = /^ /.test(r) && / $/.test(r);
      return i && o && (r = r.substring(1, r.length - 1)), r = wn(r, true), {
        type: "codespan",
        raw: n[0],
        text: r
      };
    }
  }
  br(e) {
    const n = this.rules.inline.br.exec(e);
    if (n)
      return {
        type: "br",
        raw: n[0]
      };
  }
  del(e) {
    const n = this.rules.inline.del.exec(e);
    if (n)
      return {
        type: "del",
        raw: n[0],
        text: n[2],
        tokens: this.lexer.inlineTokens(n[2])
      };
  }
  autolink(e, n) {
    const r = this.rules.inline.autolink.exec(e);
    if (r) {
      let i, o;
      return r[2] === "@" ? (i = wn(this.options.mangle ? n(r[1]) : r[1]), o = "mailto:" + i) : (i = wn(r[1]), o = i), {
        type: "link",
        raw: r[0],
        text: i,
        href: o,
        tokens: [
          {
            type: "text",
            raw: i,
            text: i
          }
        ]
      };
    }
  }
  url(e, n) {
    let r;
    if (r = this.rules.inline.url.exec(e)) {
      let i, o;
      if (r[2] === "@")
        i = wn(this.options.mangle ? n(r[0]) : r[0]), o = "mailto:" + i;
      else {
        let s;
        do
          s = r[0], r[0] = this.rules.inline._backpedal.exec(r[0])[0];
        while (s !== r[0]);
        i = wn(r[0]), r[1] === "www." ? o = "http://" + r[0] : o = r[0];
      }
      return {
        type: "link",
        raw: r[0],
        text: i,
        href: o,
        tokens: [
          {
            type: "text",
            raw: i,
            text: i
          }
        ]
      };
    }
  }
  inlineText(e, n) {
    const r = this.rules.inline.text.exec(e);
    if (r) {
      let i;
      return this.lexer.state.inRawBlock ? i = this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(r[0]) : wn(r[0]) : r[0] : i = wn(this.options.smartypants ? n(r[0]) : r[0]), {
        type: "text",
        raw: r[0],
        text: i
      };
    }
  }
};
var Te = {
  newline: /^(?: *(?:\n|$))+/,
  code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
  fences: /^ {0,3}(`{3,}(?=[^`\n]*\n)|~{3,})([^\n]*)\n(?:|([\s\S]*?)\n)(?: {0,3}\1[~`]* *(?=\n|$)|$)/,
  hr: /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/,
  heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
  blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
  list: /^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/,
  html: "^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))",
  def: /^ {0,3}\[(label)\]: *(?:\n *)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/,
  table: _d,
  lheading: /^((?:.|\n(?!\n))+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
  // regex template, placeholders will be replaced according to different paragraph
  // interruption rules of commonmark and the original markdown spec:
  _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,
  text: /^[^\n]+/
};
Te._label = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
Te._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
Te.def = $t(Te.def).replace("label", Te._label).replace("title", Te._title).getRegex();
Te.bullet = /(?:[*+-]|\d{1,9}[.)])/;
Te.listItemStart = $t(/^( *)(bull) */).replace("bull", Te.bullet).getRegex();
Te.list = $t(Te.list).replace(/bull/g, Te.bullet).replace("hr", "\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))").replace("def", "\\n+(?=" + Te.def.source + ")").getRegex();
Te._tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul";
Te._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/;
Te.html = $t(Te.html, "i").replace("comment", Te._comment).replace("tag", Te._tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
Te.paragraph = $t(Te._paragraph).replace("hr", Te.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", Te._tag).getRegex();
Te.blockquote = $t(Te.blockquote).replace("paragraph", Te.paragraph).getRegex();
Te.normal = ti({}, Te);
Te.gfm = ti({}, Te.normal, {
  table: "^ *([^\\n ].*\\|.*)\\n {0,3}(?:\\| *)?(:?-+:? *(?:\\| *:?-+:? *)*)(?:\\| *)?(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)"
  // Cells
});
Te.gfm.table = $t(Te.gfm.table).replace("hr", Te.hr).replace("heading", " {0,3}#{1,6} ").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", Te._tag).getRegex();
Te.gfm.paragraph = $t(Te._paragraph).replace("hr", Te.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("table", Te.gfm.table).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", Te._tag).getRegex();
Te.pedantic = ti({}, Te.normal, {
  html: $t(
    `^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`
  ).replace("comment", Te._comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
  heading: /^(#{1,6})(.*)(?:\n+|$)/,
  fences: _d,
  // fences not supported
  lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
  paragraph: $t(Te.normal._paragraph).replace("hr", Te.hr).replace("heading", ` *#{1,6} *[^
]`).replace("lheading", Te.lheading).replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").getRegex()
});
var pe = {
  escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
  autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
  url: _d,
  tag: "^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",
  // CDATA section
  link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
  reflink: /^!?\[(label)\]\[(ref)\]/,
  nolink: /^!?\[(ref)\](?:\[\])?/,
  reflinkSearch: "reflink|nolink(?!\\()",
  emStrong: {
    lDelim: /^(?:\*+(?:([punct_])|[^\s*]))|^_+(?:([punct*])|([^\s_]))/,
    //        (1) and (2) can only be a Right Delimiter. (3) and (4) can only be Left.  (5) and (6) can be either Left or Right.
    //          () Skip orphan inside strong                                      () Consume to delim     (1) #***                (2) a***#, a***                             (3) #***a, ***a                 (4) ***#              (5) #***#                 (6) a***a
    rDelimAst: /^(?:[^_*\\]|\\.)*?\_\_(?:[^_*\\]|\\.)*?\*(?:[^_*\\]|\\.)*?(?=\_\_)|(?:[^*\\]|\\.)+(?=[^*])|[punct_](\*+)(?=[\s]|$)|(?:[^punct*_\s\\]|\\.)(\*+)(?=[punct_\s]|$)|[punct_\s](\*+)(?=[^punct*_\s])|[\s](\*+)(?=[punct_])|[punct_](\*+)(?=[punct_])|(?:[^punct*_\s\\]|\\.)(\*+)(?=[^punct*_\s])/,
    rDelimUnd: /^(?:[^_*\\]|\\.)*?\*\*(?:[^_*\\]|\\.)*?\_(?:[^_*\\]|\\.)*?(?=\*\*)|(?:[^_\\]|\\.)+(?=[^_])|[punct*](\_+)(?=[\s]|$)|(?:[^punct*_\s\\]|\\.)(\_+)(?=[punct*\s]|$)|[punct*\s](\_+)(?=[^punct*_\s])|[\s](\_+)(?=[punct*])|[punct*](\_+)(?=[punct*])/
    // ^- Not allowed for _
  },
  code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
  br: /^( {2,}|\\)\n(?!\s*$)/,
  del: _d,
  text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
  punctuation: /^([\spunctuation])/
};
pe._punctuation = "!\"#$%&'()+\\-.,/:;<=>?@\\[\\]`^{|}~";
pe.punctuation = $t(pe.punctuation).replace(/punctuation/g, pe._punctuation).getRegex();
pe.blockSkip = /\[[^\]]*?\]\([^\)]*?\)|`[^`]*?`|<[^>]*?>/g;
pe.escapedEmSt = /(?:^|[^\\])(?:\\\\)*\\[*_]/g;
pe._comment = $t(Te._comment).replace("(?:-->|$)", "-->").getRegex();
pe.emStrong.lDelim = $t(pe.emStrong.lDelim).replace(/punct/g, pe._punctuation).getRegex();
pe.emStrong.rDelimAst = $t(pe.emStrong.rDelimAst, "g").replace(/punct/g, pe._punctuation).getRegex();
pe.emStrong.rDelimUnd = $t(pe.emStrong.rDelimUnd, "g").replace(/punct/g, pe._punctuation).getRegex();
pe._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g;
pe._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
pe._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
pe.autolink = $t(pe.autolink).replace("scheme", pe._scheme).replace("email", pe._email).getRegex();
pe._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;
pe.tag = $t(pe.tag).replace("comment", pe._comment).replace("attribute", pe._attribute).getRegex();
pe._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
pe._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/;
pe._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;
pe.link = $t(pe.link).replace("label", pe._label).replace("href", pe._href).replace("title", pe._title).getRegex();
pe.reflink = $t(pe.reflink).replace("label", pe._label).replace("ref", Te._label).getRegex();
pe.nolink = $t(pe.nolink).replace("ref", Te._label).getRegex();
pe.reflinkSearch = $t(pe.reflinkSearch, "g").replace("reflink", pe.reflink).replace("nolink", pe.nolink).getRegex();
pe.normal = ti({}, pe);
pe.pedantic = ti({}, pe.normal, {
  strong: {
    start: /^__|\*\*/,
    middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
    endAst: /\*\*(?!\*)/g,
    endUnd: /__(?!_)/g
  },
  em: {
    start: /^_|\*/,
    middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
    endAst: /\*(?!\*)/g,
    endUnd: /_(?!_)/g
  },
  link: $t(/^!?\[(label)\]\((.*?)\)/).replace("label", pe._label).getRegex(),
  reflink: $t(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", pe._label).getRegex()
});
pe.gfm = ti({}, pe.normal, {
  escape: $t(pe.escape).replace("])", "~|])").getRegex(),
  _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
  url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
  _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
  del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
  text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
});
pe.gfm.url = $t(pe.gfm.url, "i").replace("email", pe.gfm._extended_email).getRegex();
pe.breaks = ti({}, pe.gfm, {
  br: $t(pe.br).replace("{2,}", "*").getRegex(),
  text: $t(pe.gfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
});
function GJ(t4) {
  return t4.replace(/---/g, "\u2014").replace(/--/g, "\u2013").replace(/(^|[-\u2014/(\[{"\s])'/g, "$1\u2018").replace(/'/g, "\u2019").replace(/(^|[-\u2014/(\[{\u2018\s])"/g, "$1\u201C").replace(/"/g, "\u201D").replace(/\.{3}/g, "\u2026");
}
function dk(t4) {
  let e = "", n, r;
  const i = t4.length;
  for (n = 0; n < i; n++)
    r = t4.charCodeAt(n), Math.random() > 0.5 && (r = "x" + r.toString(16)), e += "&#" + r + ";";
  return e;
}
var eo = class {
  constructor(e) {
    this.tokens = [], this.tokens.links = /* @__PURE__ */ Object.create(null), this.options = e || il, this.options.tokenizer = this.options.tokenizer || new Ov(), this.tokenizer = this.options.tokenizer, this.tokenizer.options = this.options, this.tokenizer.lexer = this, this.inlineQueue = [], this.state = {
      inLink: false,
      inRawBlock: false,
      top: true
    };
    const n = {
      block: Te.normal,
      inline: pe.normal
    };
    this.options.pedantic ? (n.block = Te.pedantic, n.inline = pe.pedantic) : this.options.gfm && (n.block = Te.gfm, this.options.breaks ? n.inline = pe.breaks : n.inline = pe.gfm), this.tokenizer.rules = n;
  }
  /**
   * Expose Rules
   */
  static get rules() {
    return {
      block: Te,
      inline: pe
    };
  }
  /**
   * Static Lex Method
   */
  static lex(e, n) {
    return new eo(n).lex(e);
  }
  /**
   * Static Lex Inline Method
   */
  static lexInline(e, n) {
    return new eo(n).inlineTokens(e);
  }
  /**
   * Preprocessing
   */
  lex(e) {
    e = e.replace(/\r\n|\r/g, `
`), this.blockTokens(e, this.tokens);
    let n;
    for (; n = this.inlineQueue.shift(); )
      this.inlineTokens(n.src, n.tokens);
    return this.tokens;
  }
  /**
   * Lexing
   */
  blockTokens(e, n = []) {
    this.options.pedantic ? e = e.replace(/\t/g, "    ").replace(/^ +$/gm, "") : e = e.replace(/^( *)(\t+)/gm, (a, l, c) => l + "    ".repeat(c.length));
    let r, i, o, s;
    for (; e; )
      if (!(this.options.extensions && this.options.extensions.block && this.options.extensions.block.some((a) => (r = a.call({ lexer: this }, e, n)) ? (e = e.substring(r.raw.length), n.push(r), true) : false))) {
        if (r = this.tokenizer.space(e)) {
          e = e.substring(r.raw.length), r.raw.length === 1 && n.length > 0 ? n[n.length - 1].raw += `
` : n.push(r);
          continue;
        }
        if (r = this.tokenizer.code(e)) {
          e = e.substring(r.raw.length), i = n[n.length - 1], i && (i.type === "paragraph" || i.type === "text") ? (i.raw += `
` + r.raw, i.text += `
` + r.text, this.inlineQueue[this.inlineQueue.length - 1].src = i.text) : n.push(r);
          continue;
        }
        if (r = this.tokenizer.fences(e)) {
          e = e.substring(r.raw.length), n.push(r);
          continue;
        }
        if (r = this.tokenizer.heading(e)) {
          e = e.substring(r.raw.length), n.push(r);
          continue;
        }
        if (r = this.tokenizer.hr(e)) {
          e = e.substring(r.raw.length), n.push(r);
          continue;
        }
        if (r = this.tokenizer.blockquote(e)) {
          e = e.substring(r.raw.length), n.push(r);
          continue;
        }
        if (r = this.tokenizer.list(e)) {
          e = e.substring(r.raw.length), n.push(r);
          continue;
        }
        if (r = this.tokenizer.html(e)) {
          e = e.substring(r.raw.length), n.push(r);
          continue;
        }
        if (r = this.tokenizer.def(e)) {
          e = e.substring(r.raw.length), i = n[n.length - 1], i && (i.type === "paragraph" || i.type === "text") ? (i.raw += `
` + r.raw, i.text += `
` + r.raw, this.inlineQueue[this.inlineQueue.length - 1].src = i.text) : this.tokens.links[r.tag] || (this.tokens.links[r.tag] = {
            href: r.href,
            title: r.title
          });
          continue;
        }
        if (r = this.tokenizer.table(e)) {
          e = e.substring(r.raw.length), n.push(r);
          continue;
        }
        if (r = this.tokenizer.lheading(e)) {
          e = e.substring(r.raw.length), n.push(r);
          continue;
        }
        if (o = e, this.options.extensions && this.options.extensions.startBlock) {
          let a = 1 / 0;
          const l = e.slice(1);
          let c;
          this.options.extensions.startBlock.forEach(function(u) {
            c = u.call({ lexer: this }, l), typeof c == "number" && c >= 0 && (a = Math.min(a, c));
          }), a < 1 / 0 && a >= 0 && (o = e.substring(0, a + 1));
        }
        if (this.state.top && (r = this.tokenizer.paragraph(o))) {
          i = n[n.length - 1], s && i.type === "paragraph" ? (i.raw += `
` + r.raw, i.text += `
` + r.text, this.inlineQueue.pop(), this.inlineQueue[this.inlineQueue.length - 1].src = i.text) : n.push(r), s = o.length !== e.length, e = e.substring(r.raw.length);
          continue;
        }
        if (r = this.tokenizer.text(e)) {
          e = e.substring(r.raw.length), i = n[n.length - 1], i && i.type === "text" ? (i.raw += `
` + r.raw, i.text += `
` + r.text, this.inlineQueue.pop(), this.inlineQueue[this.inlineQueue.length - 1].src = i.text) : n.push(r);
          continue;
        }
        if (e) {
          const a = "Infinite loop on byte: " + e.charCodeAt(0);
          if (this.options.silent) {
            console.error(a);
            break;
          } else
            throw new Error(a);
        }
      }
    return this.state.top = true, n;
  }
  inline(e, n = []) {
    return this.inlineQueue.push({ src: e, tokens: n }), n;
  }
  /**
   * Lexing/Compiling
   */
  inlineTokens(e, n = []) {
    let r, i, o, s = e, a, l, c;
    if (this.tokens.links) {
      const u = Object.keys(this.tokens.links);
      if (u.length > 0)
        for (; (a = this.tokenizer.rules.inline.reflinkSearch.exec(s)) != null; )
          u.includes(a[0].slice(a[0].lastIndexOf("[") + 1, -1)) && (s = s.slice(0, a.index) + "[" + uk("a", a[0].length - 2) + "]" + s.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex));
    }
    for (; (a = this.tokenizer.rules.inline.blockSkip.exec(s)) != null; )
      s = s.slice(0, a.index) + "[" + uk("a", a[0].length - 2) + "]" + s.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
    for (; (a = this.tokenizer.rules.inline.escapedEmSt.exec(s)) != null; )
      s = s.slice(0, a.index + a[0].length - 2) + "++" + s.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex), this.tokenizer.rules.inline.escapedEmSt.lastIndex--;
    for (; e; )
      if (l || (c = ""), l = false, !(this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some((u) => (r = u.call({ lexer: this }, e, n)) ? (e = e.substring(r.raw.length), n.push(r), true) : false))) {
        if (r = this.tokenizer.escape(e)) {
          e = e.substring(r.raw.length), n.push(r);
          continue;
        }
        if (r = this.tokenizer.tag(e)) {
          e = e.substring(r.raw.length), i = n[n.length - 1], i && r.type === "text" && i.type === "text" ? (i.raw += r.raw, i.text += r.text) : n.push(r);
          continue;
        }
        if (r = this.tokenizer.link(e)) {
          e = e.substring(r.raw.length), n.push(r);
          continue;
        }
        if (r = this.tokenizer.reflink(e, this.tokens.links)) {
          e = e.substring(r.raw.length), i = n[n.length - 1], i && r.type === "text" && i.type === "text" ? (i.raw += r.raw, i.text += r.text) : n.push(r);
          continue;
        }
        if (r = this.tokenizer.emStrong(e, s, c)) {
          e = e.substring(r.raw.length), n.push(r);
          continue;
        }
        if (r = this.tokenizer.codespan(e)) {
          e = e.substring(r.raw.length), n.push(r);
          continue;
        }
        if (r = this.tokenizer.br(e)) {
          e = e.substring(r.raw.length), n.push(r);
          continue;
        }
        if (r = this.tokenizer.del(e)) {
          e = e.substring(r.raw.length), n.push(r);
          continue;
        }
        if (r = this.tokenizer.autolink(e, dk)) {
          e = e.substring(r.raw.length), n.push(r);
          continue;
        }
        if (!this.state.inLink && (r = this.tokenizer.url(e, dk))) {
          e = e.substring(r.raw.length), n.push(r);
          continue;
        }
        if (o = e, this.options.extensions && this.options.extensions.startInline) {
          let u = 1 / 0;
          const f = e.slice(1);
          let d;
          this.options.extensions.startInline.forEach(function(h) {
            d = h.call({ lexer: this }, f), typeof d == "number" && d >= 0 && (u = Math.min(u, d));
          }), u < 1 / 0 && u >= 0 && (o = e.substring(0, u + 1));
        }
        if (r = this.tokenizer.inlineText(o, GJ)) {
          e = e.substring(r.raw.length), r.raw.slice(-1) !== "_" && (c = r.raw.slice(-1)), l = true, i = n[n.length - 1], i && i.type === "text" ? (i.raw += r.raw, i.text += r.text) : n.push(r);
          continue;
        }
        if (e) {
          const u = "Infinite loop on byte: " + e.charCodeAt(0);
          if (this.options.silent) {
            console.error(u);
            break;
          } else
            throw new Error(u);
        }
      }
    return n;
  }
};
var xv = class {
  constructor(e) {
    this.options = e || il;
  }
  code(e, n, r) {
    const i = (n || "").match(/\S*/)[0];
    if (this.options.highlight) {
      const o = this.options.highlight(e, i);
      o != null && o !== e && (r = true, e = o);
    }
    return e = e.replace(/\n$/, "") + `
`, i ? '<pre><code class="' + this.options.langPrefix + wn(i) + '">' + (r ? e : wn(e, true)) + `</code></pre>
` : "<pre><code>" + (r ? e : wn(e, true)) + `</code></pre>
`;
  }
  /**
   * @param {string} quote
   */
  blockquote(e) {
    return `<blockquote>
${e}</blockquote>
`;
  }
  html(e) {
    return e;
  }
  /**
   * @param {string} text
   * @param {string} level
   * @param {string} raw
   * @param {any} slugger
   */
  heading(e, n, r, i) {
    if (this.options.headerIds) {
      const o = this.options.headerPrefix + i.slug(r);
      return `<h${n} id="${o}">${e}</h${n}>
`;
    }
    return `<h${n}>${e}</h${n}>
`;
  }
  hr() {
    return this.options.xhtml ? `<hr/>
` : `<hr>
`;
  }
  list(e, n, r) {
    const i = n ? "ol" : "ul", o = n && r !== 1 ? ' start="' + r + '"' : "";
    return "<" + i + o + `>
` + e + "</" + i + `>
`;
  }
  /**
   * @param {string} text
   */
  listitem(e) {
    return `<li>${e}</li>
`;
  }
  checkbox(e) {
    return "<input " + (e ? 'checked="" ' : "") + 'disabled="" type="checkbox"' + (this.options.xhtml ? " /" : "") + "> ";
  }
  /**
   * @param {string} text
   */
  paragraph(e) {
    return `<p>${e}</p>
`;
  }
  /**
   * @param {string} header
   * @param {string} body
   */
  table(e, n) {
    return n && (n = `<tbody>${n}</tbody>`), `<table>
<thead>
` + e + `</thead>
` + n + `</table>
`;
  }
  /**
   * @param {string} content
   */
  tablerow(e) {
    return `<tr>
${e}</tr>
`;
  }
  tablecell(e, n) {
    const r = n.header ? "th" : "td";
    return (n.align ? `<${r} align="${n.align}">` : `<${r}>`) + e + `</${r}>
`;
  }
  /**
   * span level renderer
   * @param {string} text
   */
  strong(e) {
    return `<strong>${e}</strong>`;
  }
  /**
   * @param {string} text
   */
  em(e) {
    return `<em>${e}</em>`;
  }
  /**
   * @param {string} text
   */
  codespan(e) {
    return `<code>${e}</code>`;
  }
  br() {
    return this.options.xhtml ? "<br/>" : "<br>";
  }
  /**
   * @param {string} text
   */
  del(e) {
    return `<del>${e}</del>`;
  }
  /**
   * @param {string} href
   * @param {string} title
   * @param {string} text
   */
  link(e, n, r) {
    if (e = lk(this.options.sanitize, this.options.baseUrl, e), e === null)
      return r;
    let i = '<a href="' + e + '"';
    return n && (i += ' title="' + n + '"'), i += ">" + r + "</a>", i;
  }
  /**
   * @param {string} href
   * @param {string} title
   * @param {string} text
   */
  image(e, n, r) {
    if (e = lk(this.options.sanitize, this.options.baseUrl, e), e === null)
      return r;
    let i = `<img src="${e}" alt="${r}"`;
    return n && (i += ` title="${n}"`), i += this.options.xhtml ? "/>" : ">", i;
  }
  text(e) {
    return e;
  }
};
var cj = class {
  // no need for block level renderers
  strong(e) {
    return e;
  }
  em(e) {
    return e;
  }
  codespan(e) {
    return e;
  }
  del(e) {
    return e;
  }
  html(e) {
    return e;
  }
  text(e) {
    return e;
  }
  link(e, n, r) {
    return "" + r;
  }
  image(e, n, r) {
    return "" + r;
  }
  br() {
    return "";
  }
};
var uj = class {
  constructor() {
    this.seen = {};
  }
  /**
   * @param {string} value
   */
  serialize(e) {
    return e.toLowerCase().trim().replace(/<[!\/a-z].*?>/ig, "").replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, "").replace(/\s/g, "-");
  }
  /**
   * Finds the next safe (unique) slug to use
   * @param {string} originalSlug
   * @param {boolean} isDryRun
   */
  getNextSafeSlug(e, n) {
    let r = e, i = 0;
    if (this.seen.hasOwnProperty(r)) {
      i = this.seen[e];
      do
        i++, r = e + "-" + i;
      while (this.seen.hasOwnProperty(r));
    }
    return n || (this.seen[e] = i, this.seen[r] = 0), r;
  }
  /**
   * Convert string to unique id
   * @param {object} [options]
   * @param {boolean} [options.dryrun] Generates the next unique slug without
   * updating the internal accumulator.
   */
  slug(e, n = {}) {
    const r = this.serialize(e);
    return this.getNextSafeSlug(r, n.dryrun);
  }
};
var ki = class {
  constructor(e) {
    this.options = e || il, this.options.renderer = this.options.renderer || new xv(), this.renderer = this.options.renderer, this.renderer.options = this.options, this.textRenderer = new cj(), this.slugger = new uj();
  }
  /**
   * Static Parse Method
   */
  static parse(e, n) {
    return new ki(n).parse(e);
  }
  /**
   * Static Parse Inline Method
   */
  static parseInline(e, n) {
    return new ki(n).parseInline(e);
  }
  /**
   * Parse Loop
   */
  parse(e, n = true) {
    let r = "", i, o, s, a, l, c, u, f, d, h, p, O, m, x, v, y, S, b, w;
    const C = e.length;
    for (i = 0; i < C; i++) {
      if (h = e[i], this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[h.type] && (w = this.options.extensions.renderers[h.type].call({ parser: this }, h), w !== false || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(h.type))) {
        r += w || "";
        continue;
      }
      switch (h.type) {
        case "space":
          continue;
        case "hr": {
          r += this.renderer.hr();
          continue;
        }
        case "heading": {
          r += this.renderer.heading(
            this.parseInline(h.tokens),
            h.depth,
            aj(this.parseInline(h.tokens, this.textRenderer)),
            this.slugger
          );
          continue;
        }
        case "code": {
          r += this.renderer.code(
            h.text,
            h.lang,
            h.escaped
          );
          continue;
        }
        case "table": {
          for (f = "", u = "", a = h.header.length, o = 0; o < a; o++)
            u += this.renderer.tablecell(
              this.parseInline(h.header[o].tokens),
              { header: true, align: h.align[o] }
            );
          for (f += this.renderer.tablerow(u), d = "", a = h.rows.length, o = 0; o < a; o++) {
            for (c = h.rows[o], u = "", l = c.length, s = 0; s < l; s++)
              u += this.renderer.tablecell(
                this.parseInline(c[s].tokens),
                { header: false, align: h.align[s] }
              );
            d += this.renderer.tablerow(u);
          }
          r += this.renderer.table(f, d);
          continue;
        }
        case "blockquote": {
          d = this.parse(h.tokens), r += this.renderer.blockquote(d);
          continue;
        }
        case "list": {
          for (p = h.ordered, O = h.start, m = h.loose, a = h.items.length, d = "", o = 0; o < a; o++)
            v = h.items[o], y = v.checked, S = v.task, x = "", v.task && (b = this.renderer.checkbox(y), m ? v.tokens.length > 0 && v.tokens[0].type === "paragraph" ? (v.tokens[0].text = b + " " + v.tokens[0].text, v.tokens[0].tokens && v.tokens[0].tokens.length > 0 && v.tokens[0].tokens[0].type === "text" && (v.tokens[0].tokens[0].text = b + " " + v.tokens[0].tokens[0].text)) : v.tokens.unshift({
              type: "text",
              text: b
            }) : x += b), x += this.parse(v.tokens, m), d += this.renderer.listitem(x, S, y);
          r += this.renderer.list(d, p, O);
          continue;
        }
        case "html": {
          r += this.renderer.html(h.text);
          continue;
        }
        case "paragraph": {
          r += this.renderer.paragraph(this.parseInline(h.tokens));
          continue;
        }
        case "text": {
          for (d = h.tokens ? this.parseInline(h.tokens) : h.text; i + 1 < C && e[i + 1].type === "text"; )
            h = e[++i], d += `
` + (h.tokens ? this.parseInline(h.tokens) : h.text);
          r += n ? this.renderer.paragraph(d) : d;
          continue;
        }
        default: {
          const k = 'Token with "' + h.type + '" type was not found.';
          if (this.options.silent) {
            console.error(k);
            return;
          } else
            throw new Error(k);
        }
      }
    }
    return r;
  }
  /**
   * Parse Inline Tokens
   */
  parseInline(e, n) {
    n = n || this.renderer;
    let r = "", i, o, s;
    const a = e.length;
    for (i = 0; i < a; i++) {
      if (o = e[i], this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[o.type] && (s = this.options.extensions.renderers[o.type].call({ parser: this }, o), s !== false || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(o.type))) {
        r += s || "";
        continue;
      }
      switch (o.type) {
        case "escape": {
          r += n.text(o.text);
          break;
        }
        case "html": {
          r += n.html(o.text);
          break;
        }
        case "link": {
          r += n.link(o.href, o.title, this.parseInline(o.tokens, n));
          break;
        }
        case "image": {
          r += n.image(o.href, o.title, o.text);
          break;
        }
        case "strong": {
          r += n.strong(this.parseInline(o.tokens, n));
          break;
        }
        case "em": {
          r += n.em(this.parseInline(o.tokens, n));
          break;
        }
        case "codespan": {
          r += n.codespan(o.text);
          break;
        }
        case "br": {
          r += n.br();
          break;
        }
        case "del": {
          r += n.del(this.parseInline(o.tokens, n));
          break;
        }
        case "text": {
          r += n.text(o.text);
          break;
        }
        default: {
          const l = 'Token with "' + o.type + '" type was not found.';
          if (this.options.silent) {
            console.error(l);
            return;
          } else
            throw new Error(l);
        }
      }
    }
    return r;
  }
};
function Ie(t4, e, n) {
  if (typeof t4 > "u" || t4 === null)
    throw new Error("marked(): input parameter is undefined or null");
  if (typeof t4 != "string")
    throw new Error("marked(): input parameter is of type " + Object.prototype.toString.call(t4) + ", string expected");
  if (typeof e == "function" && (n = e, e = null), e = ti({}, Ie.defaults, e || {}), lj(e), n) {
    const i = e.highlight;
    let o;
    try {
      o = eo.lex(t4, e);
    } catch (l) {
      return n(l);
    }
    const s = function(l) {
      let c;
      if (!l)
        try {
          e.walkTokens && Ie.walkTokens(o, e.walkTokens), c = ki.parse(o, e);
        } catch (u) {
          l = u;
        }
      return e.highlight = i, l ? n(l) : n(null, c);
    };
    if (!i || i.length < 3 || (delete e.highlight, !o.length))
      return s();
    let a = 0;
    Ie.walkTokens(o, function(l) {
      l.type === "code" && (a++, setTimeout(() => {
        i(l.text, l.lang, function(c, u) {
          if (c)
            return s(c);
          u != null && u !== l.text && (l.text = u, l.escaped = true), a--, a === 0 && s();
        });
      }, 0));
    }), a === 0 && s();
    return;
  }
  function r(i) {
    if (i.message += `
Please report this to https://github.com/markedjs/marked.`, e.silent)
      return "<p>An error occurred:</p><pre>" + wn(i.message + "", true) + "</pre>";
    throw i;
  }
  try {
    const i = eo.lex(t4, e);
    if (e.walkTokens) {
      if (e.async)
        return Promise.all(Ie.walkTokens(i, e.walkTokens)).then(() => ki.parse(i, e)).catch(r);
      Ie.walkTokens(i, e.walkTokens);
    }
    return ki.parse(i, e);
  } catch (i) {
    r(i);
  }
}
Ie.options = Ie.setOptions = function(t4) {
  return ti(Ie.defaults, t4), RJ(Ie.defaults), Ie;
};
Ie.getDefaults = ij;
Ie.defaults = il;
Ie.use = function(...t4) {
  const e = Ie.defaults.extensions || { renderers: {}, childTokens: {} };
  t4.forEach((n) => {
    const r = ti({}, n);
    if (r.async = Ie.defaults.async || r.async, n.extensions && (n.extensions.forEach((i) => {
      if (!i.name)
        throw new Error("extension name required");
      if (i.renderer) {
        const o = e.renderers[i.name];
        o ? e.renderers[i.name] = function(...s) {
          let a = i.renderer.apply(this, s);
          return a === false && (a = o.apply(this, s)), a;
        } : e.renderers[i.name] = i.renderer;
      }
      if (i.tokenizer) {
        if (!i.level || i.level !== "block" && i.level !== "inline")
          throw new Error("extension level must be 'block' or 'inline'");
        e[i.level] ? e[i.level].unshift(i.tokenizer) : e[i.level] = [i.tokenizer], i.start && (i.level === "block" ? e.startBlock ? e.startBlock.push(i.start) : e.startBlock = [i.start] : i.level === "inline" && (e.startInline ? e.startInline.push(i.start) : e.startInline = [i.start]));
      }
      i.childTokens && (e.childTokens[i.name] = i.childTokens);
    }), r.extensions = e), n.renderer) {
      const i = Ie.defaults.renderer || new xv();
      for (const o in n.renderer) {
        const s = i[o];
        i[o] = (...a) => {
          let l = n.renderer[o].apply(i, a);
          return l === false && (l = s.apply(i, a)), l;
        };
      }
      r.renderer = i;
    }
    if (n.tokenizer) {
      const i = Ie.defaults.tokenizer || new Ov();
      for (const o in n.tokenizer) {
        const s = i[o];
        i[o] = (...a) => {
          let l = n.tokenizer[o].apply(i, a);
          return l === false && (l = s.apply(i, a)), l;
        };
      }
      r.tokenizer = i;
    }
    if (n.walkTokens) {
      const i = Ie.defaults.walkTokens;
      r.walkTokens = function(o) {
        let s = [];
        return s.push(n.walkTokens.call(this, o)), i && (s = s.concat(i.call(this, o))), s;
      };
    }
    Ie.setOptions(r);
  });
};
Ie.walkTokens = function(t4, e) {
  let n = [];
  for (const r of t4)
    switch (n = n.concat(e.call(Ie, r)), r.type) {
      case "table": {
        for (const i of r.header)
          n = n.concat(Ie.walkTokens(i.tokens, e));
        for (const i of r.rows)
          for (const o of i)
            n = n.concat(Ie.walkTokens(o.tokens, e));
        break;
      }
      case "list": {
        n = n.concat(Ie.walkTokens(r.items, e));
        break;
      }
      default:
        Ie.defaults.extensions && Ie.defaults.extensions.childTokens && Ie.defaults.extensions.childTokens[r.type] ? Ie.defaults.extensions.childTokens[r.type].forEach(function(i) {
          n = n.concat(Ie.walkTokens(r[i], e));
        }) : r.tokens && (n = n.concat(Ie.walkTokens(r.tokens, e)));
    }
  return n;
};
Ie.parseInline = function(t4, e) {
  if (typeof t4 > "u" || t4 === null)
    throw new Error("marked.parseInline(): input parameter is undefined or null");
  if (typeof t4 != "string")
    throw new Error("marked.parseInline(): input parameter is of type " + Object.prototype.toString.call(t4) + ", string expected");
  e = ti({}, Ie.defaults, e || {}), lj(e);
  try {
    const n = eo.lexInline(t4, e);
    return e.walkTokens && Ie.walkTokens(n, e.walkTokens), ki.parseInline(n, e);
  } catch (n) {
    if (n.message += `
Please report this to https://github.com/markedjs/marked.`, e.silent)
      return "<p>An error occurred:</p><pre>" + wn(n.message + "", true) + "</pre>";
    throw n;
  }
};
Ie.Parser = ki;
Ie.parser = ki.parse;
Ie.Renderer = xv;
Ie.TextRenderer = cj;
Ie.Lexer = eo;
Ie.lexer = eo.lex;
Ie.Tokenizer = Ov;
Ie.Slugger = uj;
Ie.parse = Ie;
Ie.options;
Ie.setOptions;
Ie.use;
Ie.walkTokens;
Ie.parseInline;
ki.parse;
eo.lex;
function YJ(t4) {
  return Ie.parse(t4);
}
function qJ({ html: t4, rawMarkdown: e, parser: n }) {
  let r = t4;
  return !r && e && n && (r = n(e)), r ? /* @__PURE__ */ g.jsx(Markdown, { dangerouslySetInnerHTML: { __html: r || "" } }) : null;
}
function UJ({ description: t4, required: e, schema: n }) {
  var r;
  return /* @__PURE__ */ g.jsxs(HJ, { children: [
    /* @__PURE__ */ g.jsxs(JJ, { children: [
      n && /* @__PURE__ */ g.jsxs(g.Fragment, { children: [
        /* @__PURE__ */ g.jsx(Cl, { type: n.typePrefix + n.displayType }),
        /* @__PURE__ */ g.jsx(Cl, { type: n.displayFormat && `(${n.displayFormat})` }),
        /* @__PURE__ */ g.jsx(Cl, { type: n.contentEncoding }),
        /* @__PURE__ */ g.jsx(Cl, { type: n.title }),
        (r = n.constraints) == null ? void 0 : r.map((i) => /* @__PURE__ */ g.jsx(Cl, { type: i }, i))
      ] }),
      e && /* @__PURE__ */ g.jsx(eK, { children: "required" })
    ] }),
    /* @__PURE__ */ g.jsx(qJ, { rawMarkdown: t4, parser: YJ })
  ] });
}
var HJ = I(No)`
  padding: var(--spacing-unit) var(--spacing-xs);
  font-size: var(--font-size-base);
  font-weight: var(--font-weight-regular);
  line-height: var(--line-height-base);
  font-style: normal;
  width: 364px;
  max-height: 456px;
`;
var JJ = I.div`
  display: flex;
  align-items: center;
  gap: calc(var(--spacing-xxs) / 4) var(--spacing-xxs);
  flex-wrap: wrap;
  margin-bottom: calc(var(--spacing-xxs) / 2);
  position: relative;
`;
var KJ = I.span`
  vertical-align: middle;
  line-height: var(--schema-labels-line-height);
  font-size: var(--schema-property-labels-font-size);
  color: var(--schema-labels--text-color);
`;
var eK = I(KJ)`
  color: var(--schema-property-required-label-text-color);
  font-size: var(--font-size-base);
  line-height: var(--line-height-base);
`;
function vv({ paramName: t4, paramLocation: e }) {
  const n = je(), r = (a) => {
    var l;
    return (l = n.operation.get()) == null ? void 0 : l.parameters.find((c) => c.name === a && c.in === e);
  }, { description: i, required: o, schema: s } = r(t4) || {};
  return i ? /* @__PURE__ */ g.jsx(gP, { children: /* @__PURE__ */ g.jsx(
    Vo,
    {
      content: /* @__PURE__ */ g.jsx(
        UJ,
        {
          description: typeof i == "string" ? i : i.raw,
          required: !!o,
          schema: s
        }
      ),
      placement: "bottom",
      children: /* @__PURE__ */ g.jsx(Button, { size: "small", variant: "text", icon: /* @__PURE__ */ g.jsx(InformationIcon, {}) })
    }
  ) }) : null;
}
function tK() {
  const t4 = hn(), e = je(), {
    request: { queryParameters: n, url: r },
    isRequestEditable: i
  } = e, o = () => {
    r.set(SA(r.get(), n.get()));
  }, s = (l, c) => {
    c && n.merge([mn()]), o();
  }, a = (l) => {
    n[l].set(pt), o();
  };
  return /* @__PURE__ */ g.jsx(
    Sa,
    {
      keyName: "Parameters",
      elements: n,
      onParameterChange: s,
      title: "Query Parameters",
      environment: t4,
      renderDescription: (l) => /* @__PURE__ */ g.jsx(vv, { paramName: l, paramLocation: "query" }),
      editable: i.get(),
      actions: (l) => /* @__PURE__ */ g.jsx(
        Nr,
        {
          onClick: () => a(l),
          variant: "text",
          icon: /* @__PURE__ */ g.jsx(TrashCanIcon, {})
        }
      )
    }
  );
}
function nK() {
  const t4 = hn(), {
    request: { headers: e },
    isRequestEditable: n
  } = je();
  function r(o, s) {
    s && e.merge([mn()]);
  }
  function i(o) {
    e[o].set(pt);
  }
  return /* @__PURE__ */ g.jsx(
    Sa,
    {
      keyName: "Header",
      elements: e,
      onParameterChange: r,
      title: "Header Parameters",
      environment: t4,
      renderDescription: (o) => /* @__PURE__ */ g.jsx(vv, { paramName: o, paramLocation: "header" }),
      editable: n.get(),
      actions: (o) => /* @__PURE__ */ g.jsx(
        Nr,
        {
          onClick: () => i(o),
          variant: "text",
          icon: /* @__PURE__ */ g.jsx(TrashCanIcon, {})
        }
      )
    }
  );
}
function rK() {
  const t4 = hn(), {
    request: { cookies: e },
    isRequestEditable: n
  } = je();
  function r(o, s) {
    s && e.merge([mn()]);
  }
  function i(o) {
    e[o].set(pt);
  }
  return /* @__PURE__ */ g.jsx(
    Sa,
    {
      keyName: "Cookie",
      elements: e,
      onParameterChange: r,
      title: "Cookies",
      environment: t4,
      renderDescription: (o) => /* @__PURE__ */ g.jsx(vv, { paramName: o, paramLocation: "cookie" }),
      editable: n.get(),
      actions: (o) => /* @__PURE__ */ g.jsx(
        Nr,
        {
          onClick: () => i(o),
          variant: "text",
          icon: /* @__PURE__ */ g.jsx(TrashCanIcon, {})
        }
      )
    }
  );
}
var mo = {
  SECURITY: "Security",
  BODY: "Body",
  QUERY: "Query",
  HEADERS: "Headers",
  COOKIES: "Cookies"
};
var Ai = [
  {
    name: mo.SECURITY,
    content: FH,
    icon: /* @__PURE__ */ g.jsx(SecurityIcon, {})
  },
  {
    name: mo.BODY,
    content: kJ,
    icon: /* @__PURE__ */ g.jsx(CodeIcon, {})
  },
  {
    name: mo.QUERY,
    content: tK,
    icon: /* @__PURE__ */ g.jsx(DataFormatIcon, {})
  },
  {
    name: mo.HEADERS,
    content: nK,
    icon: /* @__PURE__ */ g.jsx(TableBuiltIcon, {})
  },
  {
    name: mo.COOKIES,
    content: rK,
    icon: /* @__PURE__ */ g.jsx(CookieIcon, {})
  }
];
var iK = Ai.findIndex((t4) => t4.name === mo.BODY);
var fj = Ai.findIndex((t4) => t4.name === mo.QUERY);
var oK = Ai.findIndex((t4) => t4.name === mo.SECURITY);
var sK = {
  requestController: void 0,
  request: {
    method: "GET",
    url: "",
    security: {
      securitySchemeVariants: [],
      selectedSecuritySchemeId: "",
      securities: [ks()]
    },
    body: po(),
    queryParameters: [mn()],
    headers: [mn()],
    cookies: [mn()]
  },
  isProcessingRequest: false,
  response: null,
  requestError: null,
  history: [],
  collections: [],
  operation: null,
  operationUrl: void 0,
  isLinked: true,
  environments: [lD],
  selectedEnvironmentId: null,
  corsProxyUrl: void 0,
  mockServer: void 0,
  appsLoadingState: fi.Idle,
  apps: [],
  apiId: void 0,
  requestActiveTabIdx: fj,
  oAuth2RedirectURI: void 0,
  isRequestEditable: true,
  tokenRequestError: null,
  definitionUrl: void 0,
  transactionSource: null,
  showUnsavedChangesModal: false,
  pendingTransaction: null,
  pendingTransactionSource: null,
  disableCollectionsTab: false,
  certificates: []
};
function zc() {
  return structuredClone(sK);
}
var aK = ZO(zc());
ZO(ks());
var dj = Ac(aK);
var lK = dj.Provider;
function je() {
  const t4 = Ii(dj);
  return YR(t4);
}
var hj = class {
  static save(e, n) {
    const r = this.get();
    r[e] = n;
    const i = JSON.stringify(r);
    sessionStorage.setItem(xp, i);
  }
  static get() {
    try {
      const e = sessionStorage.getItem(xp);
      if (e)
        return JSON.parse(e);
    } catch (e) {
      console.error("Error parsing serialized data:", e);
    }
    return {};
  }
  static getByKey(e) {
    return this.get()[e] || null;
  }
  static clear() {
    sessionStorage.removeItem(xp);
  }
};
function cK(t4, e) {
  const n = An(t4);
  return e.forEach((r) => {
    const i = n.find((o) => o.name === r.name);
    i ? i.variables = r.variables : n.push(r);
  }), n;
}
var Dl = class {
  static save(e) {
    const n = e.map((o) => {
      const s = o.variables.filter(
        (a) => a.type !== Tr.ServerUrl
      );
      return { ...o, variables: s };
    }), r = this.get(), i = cK(r, n);
    localStorage.setItem(vp, JSON.stringify(i));
  }
  static get() {
    try {
      const e = localStorage.getItem(vp);
      if (e)
        return JSON.parse(e);
    } catch (e) {
      console.error("Error parsing serialized data:", e);
    }
    return [];
  }
  static getEnvironmentByName(e) {
    var n;
    return ((n = this.get()) == null ? void 0 : n.find((r) => r.name === e)) || null;
  }
  static getEnvironmentVariableByName(e, n, r) {
    const i = this.getEnvironmentByName(e);
    return i ? r ? i == null ? void 0 : i.variables.find(
      (o) => o.name === n && o.type === r
    ) : i == null ? void 0 : i.variables.find((o) => o.name === n) : null;
  }
  static clear() {
    localStorage.removeItem(vp);
  }
};
function uK(t4, e) {
  const { servers: n, parameters: r } = t4, i = r.filter((s) => s.in === "path"), o = fK(t4);
  return n.map((s) => {
    const a = s.url, l = s.description || a, c = s.variables || {}, u = Object.entries(c).map(([O, m]) => {
      const x = Dl.getEnvironmentVariableByName(
        l,
        O,
        Tr.Server
      );
      return {
        id: crypto.randomUUID(),
        name: O,
        value: (x == null ? void 0 : x.value) || m.default || "",
        type: Tr.Server,
        canBeRemoved: false,
        canBeEdited: true,
        readonlyName: true
      };
    }), f = i.map(({ name: O }) => {
      const m = Dl.getEnvironmentVariableByName(
        l,
        O,
        Tr.Path
      );
      return {
        id: crypto.randomUUID(),
        name: O,
        value: (m == null ? void 0 : m.value) || "",
        type: Tr.Path,
        canBeRemoved: false,
        canBeEdited: true,
        readonlyName: true
      };
    }), d = o.map((O) => {
      const m = Dl.getEnvironmentVariableByName(
        l,
        O.name,
        Tr.Security
      );
      return {
        ...O,
        value: (m == null ? void 0 : m.value) || O.value || ""
      };
    }), h = Dl.getEnvironmentByName(l), p = (h == null ? void 0 : h.variables.filter(
      (O) => O.type === Tr.UserCreated
    )) || [];
    return {
      id: crypto.randomUUID(),
      name: l,
      url: a,
      state: Er.Normal,
      canBeRemoved: false,
      canBeEdited: false,
      variables: dK(
        [
          ...p,
          {
            id: crypto.randomUUID(),
            name: "server",
            value: Eh(a),
            type: Tr.ServerUrl,
            canBeRemoved: false,
            canBeEdited: false
          },
          ...u,
          ...f,
          ...d
        ],
        e == null ? void 0 : e[l]
      )
    };
  });
}
function fK(t4) {
  var i;
  const e = [], n = ((i = t4.security) == null ? void 0 : i.flat()) || [], r = /* @__PURE__ */ new Set();
  return n.forEach((o) => {
    const s = fv(o);
    if (r.has(s))
      return;
    const a = o.id;
    r.add(s), (s === H.BasicAuth || s === H.DigestAuth) && (e.push(zr(a + "_username" /* Username */, false)), e.push(zr(a + "_password" /* Password */))), s === H.JWT && e.push(zr(a + "_token" /* JWTToken */)), s === H.APIKey && e.push(zr(a + "" /* APIKey */)), s === H.OAuth2 && (e.push(zr(a + "_token" /* Token */)), dv(o).forEach((c) => {
      e.push(zr(a + "_client_id" /* ClientId */)), [ie.Implicit, ie.ClientCredentialsWithJwtAssertion].includes(c) || e.push(zr(a + "_client_secret" /* ClientSecret */)), c === ie.ClientCredentialsWithJwtAssertion && e.push(
        zr(a + "_client_assertion" /* ClientAssertion */)
      );
    })), s === H.OpenIDConnect && (e.push(zr(a + "_token" /* Token */)), e.push(zr(a + "_client_id" /* ClientId */)), e.push(zr(a + "_client_secret" /* ClientSecret */)));
  }), e;
}
function zr(t4, e) {
  return {
    id: crypto.randomUUID(),
    name: t4,
    value: "",
    type: Tr.Security,
    canBeRemoved: false,
    canBeEdited: true,
    isSecret: e === void 0 ? true : e
  };
}
function dK(t4, e) {
  return e ? t4.map((n) => {
    const r = e[n.name];
    return r !== void 0 ? {
      ...n,
      canBeRemoved: false,
      value: n.type === Tr.ServerUrl ? Eh(r) : r
    } : n;
  }) : t4;
}
var dn = /* @__PURE__ */ ((t4) => (t4.Folder = "folder", t4.Request = "request", t4))(dn || {});
var bt = /* @__PURE__ */ ((t4) => (t4.Normal = "Normal", t4.Edit = "Edit", t4.Draft = "Draft", t4))(bt || {});
function pj(t4, e) {
  let n = null;
  return e.forEach((r) => {
    if (r.type.get() === dn.Folder) {
      const i = r.nested("value"), o = pj(t4, i.items);
      o && (n = o);
    } else if (r.nested("value").id.get() === t4) {
      const i = r.nested("value");
      i && (n = i);
    }
  }), n;
}
function yv() {
  const { collections: t4, transactionSource: e } = je();
  return We(() => {
    const r = e.get();
    if (r)
      return pj(r.id, t4);
  }, [e, t4]);
}
function Rh() {
  const {
    request: t4,
    response: e,
    transactionSource: n,
    showUnsavedChangesModal: r,
    pendingTransaction: i,
    pendingTransactionSource: o
  } = je(), s = yv(), a = () => {
    var p;
    return ((p = n.get()) == null ? void 0 : p.type) === "collection" ? !Vg(
      Hf(t4.get({ noproxy: true, stealth: true })),
      Hf(s == null ? void 0 : s.get({ noproxy: true, stealth: true }).request)
    ) : false;
  }, l = (h, p) => {
    a() ? (r.set(true), i.set(h), o.set(p)) : (t4.set(An(h.request)), e.set(An(h.response)), n.set(p), i.set(null), o.set(null));
  }, c = (h, p) => {
    h && (t4.set(An(h.request)), e.set(An(h == null ? void 0 : h.response))), n.set(p);
  }, u = () => {
    r.set(false);
  }, f = () => {
    r.set(false), c(
      i.get(),
      o.get({ noproxy: true })
    );
  }, d = () => {
    r.set(false), s == null || s.merge({
      request: An(t4.get({ noproxy: true })),
      response: An(e.get({ noproxy: true }))
    }), c(
      i.get(),
      o.get({ noproxy: true })
    );
  };
  return {
    selectedTransaction: s,
    showUnsavedChangesModal: r,
    isTransactionChanged: a(),
    updateTransaction: l,
    onClose: u,
    onDiscard: f,
    onSave: d
  };
}
function hK(t4) {
  const { operation: e, request: n } = t4, r = n.body;
  uv(e.get({ noproxy: true }))[r.type.get({ noproxy: true })] || r.set(R$(e.get({ noproxy: true })));
}
function bv({ value: t4, disableDraft: e, ...n }) {
  const r = je(), { updateTransaction: i } = Rh(), {
    operation: o,
    corsProxyUrl: s,
    environments: a,
    operationUrl: l,
    mockServer: c,
    selectedEnvironmentId: u,
    apiId: f,
    oAuth2RedirectURI: d,
    definitionUrl: h,
    disableCollectionsTab: p,
    certificates: O
  } = r;
  return _e(() => {
    O.set(n.certificates || []);
  }, [n.certificates]), _e(() => {
    var x;
    const m = n.operationUrl && !e ? hj.getByKey(n.operationUrl) : null;
    if (t4) {
      const v = An(t4), y = uK(v, n.predefinedEnvValues), S = y.find(
        ({ name: w, url: C }) => C === (n == null ? void 0 : n.environment) || w === (n == null ? void 0 : n.environment)
      );
      o.set(v), a.set(y), S && u.set(S.id);
      const b = m ? {
        ...m,
        body: { ...m.body, activeExampleName: (x = v.body) == null ? void 0 : x.activeExampleName }
      } : cv(v);
      i({ request: b, response: null }, null);
    }
    s.set(n.corsProxyUrl ?? tq), l.set(n.operationUrl), c.set(n.mockServer), f.set(n.apiId), d.set(n.oAuth2RedirectURI), h.set(n.definitionUrl), p.set(n.disableCollectionsTab), $$(r), hK(r);
  }, [t4]), r;
}
var {
  createElement: Qa,
  createContext: pK,
  createRef: dae,
  forwardRef: gj,
  useCallback: er,
  useContext: mj,
  useEffect: ls,
  useImperativeHandle: Oj,
  useLayoutEffect: gK,
  useMemo: mK,
  useRef: vr,
  useState: Md
} = q;
var hk = q.useId;
var Dh = pK(null);
Dh.displayName = "PanelGroupContext";
var vc = gK;
var OK = typeof hk == "function" ? hk : () => null;
var xK = 0;
function Sv(t4 = null) {
  const e = OK(), n = vr(t4 || e || null);
  return n.current === null && (n.current = "" + xK++), t4 ?? n.current;
}
function xj({
  children: t4,
  className: e = "",
  collapsedSize: n,
  collapsible: r,
  defaultSize: i,
  forwardedRef: o,
  id: s,
  maxSize: a,
  minSize: l,
  onCollapse: c,
  onExpand: u,
  onResize: f,
  order: d,
  style: h,
  tagName: p = "div",
  ...O
}) {
  const m = mj(Dh);
  if (m === null)
    throw Error("Panel components must be rendered within a PanelGroup container");
  const {
    collapsePanel: x,
    expandPanel: v,
    getPanelSize: y,
    getPanelStyle: S,
    groupId: b,
    isPanelCollapsed: w,
    reevaluatePanelConstraints: C,
    registerPanel: k,
    resizePanel: T,
    unregisterPanel: A
  } = m, E = Sv(s), $ = vr({
    callbacks: {
      onCollapse: c,
      onExpand: u,
      onResize: f
    },
    constraints: {
      collapsedSize: n,
      collapsible: r,
      defaultSize: i,
      maxSize: a,
      minSize: l
    },
    id: E,
    idIsFromProps: s !== void 0,
    order: d
  });
  vr({
    didLogMissingDefaultSizeWarning: false
  }), vc(() => {
    const {
      callbacks: B,
      constraints: D
    } = $.current, N = {
      ...D
    };
    $.current.id = E, $.current.idIsFromProps = s !== void 0, $.current.order = d, B.onCollapse = c, B.onExpand = u, B.onResize = f, D.collapsedSize = n, D.collapsible = r, D.defaultSize = i, D.maxSize = a, D.minSize = l, (N.collapsedSize !== D.collapsedSize || N.collapsible !== D.collapsible || N.maxSize !== D.maxSize || N.minSize !== D.minSize) && C($.current, N);
  }), vc(() => {
    const B = $.current;
    return k(B), () => {
      A(B);
    };
  }, [d, E, k, A]), Oj(o, () => ({
    collapse: () => {
      x($.current);
    },
    expand: () => {
      v($.current);
    },
    getId() {
      return E;
    },
    getSize() {
      return y($.current);
    },
    isCollapsed() {
      return w($.current);
    },
    isExpanded() {
      return !w($.current);
    },
    resize: (B) => {
      T($.current, B);
    }
  }), [x, v, y, w, E, T]);
  const j = S($.current, i);
  return Qa(p, {
    ...O,
    children: t4,
    className: e,
    style: {
      ...j,
      ...h
    },
    // CSS selectors
    "data-panel": "",
    "data-panel-id": E,
    "data-panel-group-id": b,
    // e2e test attributes
    "data-panel-collapsible": void 0,
    "data-panel-size": void 0
  });
}
var vO = gj((t4, e) => Qa(xj, {
  ...t4,
  forwardedRef: e
}));
xj.displayName = "Panel";
vO.displayName = "forwardRef(Panel)";
function Ne(t4, e = "Assertion failed!") {
  if (!t4)
    throw console.error(e), Error(e);
}
var vj = 10;
function yc(t4, e, n = vj) {
  t4 = parseFloat(t4.toFixed(n)), e = parseFloat(e.toFixed(n));
  const r = t4 - e;
  return r === 0 ? 0 : r > 0 ? 1 : -1;
}
function Or(t4, e, n) {
  return yc(t4, e, n) === 0;
}
function Ks({
  panelConstraints: t4,
  panelIndex: e,
  size: n
}) {
  const r = t4[e];
  Ne(r != null);
  let {
    collapsedSize: i = 0,
    collapsible: o,
    maxSize: s = 100,
    minSize: a = 0
  } = r;
  if (yc(n, a) < 0)
    if (o) {
      const l = (i + a) / 2;
      yc(n, l) < 0 ? n = i : n = a;
    } else
      n = a;
  return n = Math.min(s, n), n = parseFloat(n.toFixed(vj)), n;
}
function Ql({
  delta: t4,
  layout: e,
  panelConstraints: n,
  pivotIndices: r,
  trigger: i
}) {
  if (Or(t4, 0))
    return e;
  const o = [...e], [s, a] = r;
  Ne(s != null), Ne(a != null);
  let l = 0;
  if (i === "keyboard") {
    {
      const u = t4 < 0 ? a : s, f = n[u];
      if (Ne(f), f.collapsible) {
        const d = e[u];
        Ne(d != null);
        const h = n[u];
        Ne(h);
        const {
          collapsedSize: p = 0,
          minSize: O = 0
        } = h;
        if (Or(d, p)) {
          const m = O - d;
          yc(m, Math.abs(t4)) > 0 && (t4 = t4 < 0 ? 0 - m : m);
        }
      }
    }
    {
      const u = t4 < 0 ? s : a, f = n[u];
      Ne(f);
      const {
        collapsible: d
      } = f;
      if (d) {
        const h = e[u];
        Ne(h != null);
        const p = n[u];
        Ne(p);
        const {
          collapsedSize: O = 0,
          minSize: m = 0
        } = p;
        if (Or(h, m)) {
          const x = h - O;
          yc(x, Math.abs(t4)) > 0 && (t4 = t4 < 0 ? 0 - x : x);
        }
      }
    }
  }
  {
    const u = t4 < 0 ? 1 : -1;
    let f = t4 < 0 ? a : s, d = 0;
    for (; ; ) {
      const p = e[f];
      Ne(p != null);
      const m = Ks({
        panelConstraints: n,
        panelIndex: f,
        size: 100
      }) - p;
      if (d += m, f += u, f < 0 || f >= n.length)
        break;
    }
    const h = Math.min(Math.abs(t4), Math.abs(d));
    t4 = t4 < 0 ? 0 - h : h;
  }
  {
    let f = t4 < 0 ? s : a;
    for (; f >= 0 && f < n.length; ) {
      const d = Math.abs(t4) - Math.abs(l), h = e[f];
      Ne(h != null);
      const p = h - d, O = Ks({
        panelConstraints: n,
        panelIndex: f,
        size: p
      });
      if (!Or(h, O) && (l += h - O, o[f] = O, l.toPrecision(3).localeCompare(Math.abs(t4).toPrecision(3), void 0, {
        numeric: true
      }) >= 0))
        break;
      t4 < 0 ? f-- : f++;
    }
  }
  if (Or(l, 0))
    return e;
  {
    const u = t4 < 0 ? a : s, f = e[u];
    Ne(f != null);
    const d = f + l, h = Ks({
      panelConstraints: n,
      panelIndex: u,
      size: d
    });
    if (o[u] = h, !Or(h, d)) {
      let p = d - h, m = t4 < 0 ? a : s;
      for (; m >= 0 && m < n.length; ) {
        const x = o[m];
        Ne(x != null);
        const v = x + p, y = Ks({
          panelConstraints: n,
          panelIndex: m,
          size: v
        });
        if (Or(x, y) || (p -= y - x, o[m] = y), Or(p, 0))
          break;
        t4 > 0 ? m-- : m++;
      }
    }
  }
  const c = o.reduce((u, f) => f + u, 0);
  return Or(c, 100) ? o : e;
}
function vK({
  layout: t4,
  panelsArray: e,
  pivotIndices: n
}) {
  let r = 0, i = 100, o = 0, s = 0;
  const a = n[0];
  Ne(a != null), e.forEach((f, d) => {
    const {
      constraints: h
    } = f, {
      maxSize: p = 100,
      minSize: O = 0
    } = h;
    d === a ? (r = O, i = p) : (o += O, s += p);
  });
  const l = Math.min(i, 100 - o), c = Math.max(r, 100 - s), u = t4[a];
  return {
    valueMax: l,
    valueMin: c,
    valueNow: u
  };
}
function bc(t4, e = document) {
  return Array.from(e.querySelectorAll(`[data-panel-resize-handle-id][data-panel-group-id="${t4}"]`));
}
function yj(t4, e, n = document) {
  const i = bc(t4, n).findIndex((o) => o.getAttribute("data-panel-resize-handle-id") === e);
  return i ?? null;
}
function bj(t4, e, n) {
  const r = yj(t4, e, n);
  return r != null ? [r, r + 1] : [-1, -1];
}
function Sj(t4, e = document) {
  var n;
  if (e instanceof HTMLElement && (e == null || (n = e.dataset) === null || n === void 0 ? void 0 : n.panelGroupId) == t4)
    return e;
  const r = e.querySelector(`[data-panel-group][data-panel-group-id="${t4}"]`);
  return r || null;
}
function Qh(t4, e = document) {
  const n = e.querySelector(`[data-panel-resize-handle-id="${t4}"]`);
  return n || null;
}
function yK(t4, e, n, r = document) {
  var i, o, s, a;
  const l = Qh(e, r), c = bc(t4, r), u = l ? c.indexOf(l) : -1, f = (i = (o = n[u]) === null || o === void 0 ? void 0 : o.id) !== null && i !== void 0 ? i : null, d = (s = (a = n[u + 1]) === null || a === void 0 ? void 0 : a.id) !== null && s !== void 0 ? s : null;
  return [f, d];
}
function bK({
  committedValuesRef: t4,
  eagerValuesRef: e,
  groupId: n,
  layout: r,
  panelDataArray: i,
  panelGroupElement: o,
  setLayout: s
}) {
  vr({
    didWarnAboutMissingResizeHandle: false
  }), vc(() => {
    if (!o)
      return;
    const a = bc(n, o);
    for (let l = 0; l < i.length - 1; l++) {
      const {
        valueMax: c,
        valueMin: u,
        valueNow: f
      } = vK({
        layout: r,
        panelsArray: i,
        pivotIndices: [l, l + 1]
      }), d = a[l];
      if (d != null) {
        const h = i[l];
        Ne(h), d.setAttribute("aria-controls", h.id), d.setAttribute("aria-valuemax", "" + Math.round(c)), d.setAttribute("aria-valuemin", "" + Math.round(u)), d.setAttribute("aria-valuenow", f != null ? "" + Math.round(f) : "");
      }
    }
    return () => {
      a.forEach((l, c) => {
        l.removeAttribute("aria-controls"), l.removeAttribute("aria-valuemax"), l.removeAttribute("aria-valuemin"), l.removeAttribute("aria-valuenow");
      });
    };
  }, [n, r, i, o]), ls(() => {
    if (!o)
      return;
    const a = e.current;
    Ne(a);
    const {
      panelDataArray: l
    } = a, c = Sj(n, o);
    Ne(c != null, `No group found for id "${n}"`);
    const u = bc(n, o);
    Ne(u);
    const f = u.map((d) => {
      const h = d.getAttribute("data-panel-resize-handle-id");
      Ne(h);
      const [p, O] = yK(n, h, l, o);
      if (p == null || O == null)
        return () => {
        };
      const m = (x) => {
        if (!x.defaultPrevented)
          switch (x.key) {
            case "Enter": {
              x.preventDefault();
              const v = l.findIndex((y) => y.id === p);
              if (v >= 0) {
                const y = l[v];
                Ne(y);
                const S = r[v], {
                  collapsedSize: b = 0,
                  collapsible: w,
                  minSize: C = 0
                } = y.constraints;
                if (S != null && w) {
                  const k = Ql({
                    delta: Or(S, b) ? C - b : b - S,
                    layout: r,
                    panelConstraints: l.map((T) => T.constraints),
                    pivotIndices: bj(n, h, o),
                    trigger: "keyboard"
                  });
                  r !== k && s(k);
                }
              }
              break;
            }
          }
      };
      return d.addEventListener("keydown", m), () => {
        d.removeEventListener("keydown", m);
      };
    });
    return () => {
      f.forEach((d) => d());
    };
  }, [o, t4, e, n, r, i, s]);
}
function pk(t4, e) {
  if (t4.length !== e.length)
    return false;
  for (let n = 0; n < t4.length; n++)
    if (t4[n] !== e[n])
      return false;
  return true;
}
function wj(t4) {
  return t4.type === "keydown";
}
function Cj(t4) {
  return t4.type.startsWith("mouse");
}
function kj(t4) {
  return t4.type.startsWith("touch");
}
function Aj(t4, e) {
  const n = t4 === "horizontal";
  if (Cj(e))
    return n ? e.clientX : e.clientY;
  if (kj(e)) {
    const r = e.touches[0];
    return Ne(r), n ? r.screenX : r.screenY;
  } else
    throw Error(`Unsupported event type "${e.type}"`);
}
function SK(t4, e, n, r, i) {
  const o = n === "horizontal", s = Qh(e, i);
  Ne(s);
  const a = s.getAttribute("data-panel-group-id");
  Ne(a);
  let {
    initialCursorPosition: l
  } = r;
  const c = Aj(n, t4), u = Sj(a, i);
  Ne(u);
  const f = u.getBoundingClientRect(), d = o ? f.width : f.height;
  return (c - l) / d * 100;
}
function wK(t4, e, n, r, i, o) {
  if (wj(t4)) {
    const s = n === "horizontal";
    let a = 0;
    t4.shiftKey ? a = 100 : i != null ? a = i : a = 10;
    let l = 0;
    switch (t4.key) {
      case "ArrowDown":
        l = s ? 0 : a;
        break;
      case "ArrowLeft":
        l = s ? -a : 0;
        break;
      case "ArrowRight":
        l = s ? a : 0;
        break;
      case "ArrowUp":
        l = s ? 0 : -a;
        break;
      case "End":
        l = 100;
        break;
      case "Home":
        l = -100;
        break;
    }
    return l;
  } else
    return r == null ? 0 : SK(t4, e, n, r, o);
}
function CK({
  panelDataArray: t4
}) {
  const e = Array(t4.length), n = t4.map((o) => o.constraints);
  let r = 0, i = 100;
  for (let o = 0; o < t4.length; o++) {
    const s = n[o];
    Ne(s);
    const {
      defaultSize: a
    } = s;
    a != null && (r++, e[o] = a, i -= a);
  }
  for (let o = 0; o < t4.length; o++) {
    const s = n[o];
    Ne(s);
    const {
      defaultSize: a
    } = s;
    if (a != null)
      continue;
    const l = t4.length - r, c = i / l;
    r++, e[o] = c, i -= c;
  }
  return e;
}
function Fs(t4, e, n) {
  e.forEach((r, i) => {
    const o = t4[i];
    Ne(o);
    const {
      callbacks: s,
      constraints: a,
      id: l
    } = o, {
      collapsedSize: c = 0,
      collapsible: u
    } = a, f = n[l];
    if (f == null || r !== f) {
      n[l] = r;
      const {
        onCollapse: d,
        onExpand: h,
        onResize: p
      } = s;
      p && p(r, f), u && (d || h) && (h && (f == null || f === c) && r !== c && h(), d && (f == null || f !== c) && r === c && d());
    }
  });
}
function Yu(t4, e) {
  if (t4.length !== e.length)
    return false;
  for (let n = 0; n < t4.length; n++)
    if (t4[n] != e[n])
      return false;
  return true;
}
function kK({
  defaultSize: t4,
  dragState: e,
  layout: n,
  panelData: r,
  panelIndex: i,
  precision: o = 3
}) {
  const s = n[i];
  let a;
  return s == null ? a = t4 ?? "1" : r.length === 1 ? a = "1" : a = s.toPrecision(o), {
    flexBasis: 0,
    flexGrow: a,
    flexShrink: 1,
    // Without this, Panel sizes may be unintentionally overridden by their content
    overflow: "hidden",
    // Disable pointer events inside of a panel during resize
    // This avoid edge cases like nested iframes
    pointerEvents: e !== null ? "none" : void 0
  };
}
var yO = null;
var os = null;
function Pj(t4) {
  switch (t4) {
    case "horizontal":
      return "ew-resize";
    case "horizontal-max":
      return "w-resize";
    case "horizontal-min":
      return "e-resize";
    case "vertical":
      return "ns-resize";
    case "vertical-max":
      return "n-resize";
    case "vertical-min":
      return "s-resize";
  }
}
function AK() {
  os !== null && (document.head.removeChild(os), yO = null, os = null);
}
function X0(t4) {
  if (yO === t4)
    return;
  yO = t4;
  const e = Pj(t4);
  os === null && (os = document.createElement("style"), document.head.appendChild(os)), os.innerHTML = `*{cursor: ${e}!important;}`;
}
function PK(t4, e = 10) {
  let n = null;
  return (...i) => {
    n !== null && clearTimeout(n), n = setTimeout(() => {
      t4(...i);
    }, e);
  };
}
function gk(t4) {
  try {
    if (typeof localStorage < "u")
      t4.getItem = (e) => localStorage.getItem(e), t4.setItem = (e, n) => {
        localStorage.setItem(e, n);
      };
    else
      throw new Error("localStorage not supported in this environment");
  } catch (e) {
    console.error(e), t4.getItem = () => null, t4.setItem = () => {
    };
  }
}
function Ej(t4) {
  return `react-resizable-panels:${t4}`;
}
function Tj(t4) {
  return t4.map((e) => {
    const {
      constraints: n,
      id: r,
      idIsFromProps: i,
      order: o
    } = e;
    return i ? r : o ? `${o}:${JSON.stringify(n)}` : JSON.stringify(n);
  }).sort((e, n) => e.localeCompare(n)).join(",");
}
function Ij(t4, e) {
  try {
    const n = Ej(t4), r = e.getItem(n);
    if (r) {
      const i = JSON.parse(r);
      if (typeof i == "object" && i != null)
        return i;
    }
  } catch {
  }
  return null;
}
function EK(t4, e, n) {
  var r, i;
  const o = (r = Ij(t4, n)) !== null && r !== void 0 ? r : {}, s = Tj(e);
  return (i = o[s]) !== null && i !== void 0 ? i : null;
}
function TK(t4, e, n, r, i) {
  var o;
  const s = Ej(t4), a = Tj(e), l = (o = Ij(t4, i)) !== null && o !== void 0 ? o : {};
  l[a] = {
    expandToSizes: Object.fromEntries(n.entries()),
    layout: r
  };
  try {
    i.setItem(s, JSON.stringify(l));
  } catch (c) {
    console.error(c);
  }
}
function mk({
  layout: t4,
  panelConstraints: e
}) {
  const n = [...t4], r = n.reduce((o, s) => o + s, 0);
  if (n.length !== e.length)
    throw Error(`Invalid ${e.length} panel layout: ${n.map((o) => `${o}%`).join(", ")}`);
  if (!Or(r, 100))
    for (let o = 0; o < e.length; o++) {
      const s = n[o];
      Ne(s != null);
      const a = 100 / r * s;
      n[o] = a;
    }
  let i = 0;
  for (let o = 0; o < e.length; o++) {
    const s = n[o];
    Ne(s != null);
    const a = Ks({
      panelConstraints: e,
      panelIndex: o,
      size: s
    });
    s != a && (i += s - a, n[o] = a);
  }
  if (!Or(i, 0))
    for (let o = 0; o < e.length; o++) {
      const s = n[o];
      Ne(s != null);
      const a = s + i, l = Ks({
        panelConstraints: e,
        panelIndex: o,
        size: a
      });
      if (s !== l && (i -= l - s, n[o] = l, Or(i, 0)))
        break;
    }
  return n;
}
var IK = 100;
var Bl = {
  getItem: (t4) => (gk(Bl), Bl.getItem(t4)),
  setItem: (t4, e) => {
    gk(Bl), Bl.setItem(t4, e);
  }
};
var Ok = {};
function $j({
  autoSaveId: t4 = null,
  children: e,
  className: n = "",
  direction: r,
  forwardedRef: i,
  id: o = null,
  onLayout: s = null,
  keyboardResizeBy: a = null,
  storage: l = Bl,
  style: c,
  tagName: u = "div",
  ...f
}) {
  const d = Sv(o), h = vr(null), [p, O] = Md(null), [m, x] = Md([]), v = vr({}), y = vr(/* @__PURE__ */ new Map()), S = vr(0), b = vr({
    autoSaveId: t4,
    direction: r,
    dragState: p,
    id: d,
    keyboardResizeBy: a,
    onLayout: s,
    storage: l
  }), w = vr({
    layout: m,
    panelDataArray: [],
    panelDataArrayChanged: false
  });
  vr({
    didLogIdAndOrderWarning: false,
    didLogPanelConstraintsWarning: false,
    prevPanelIds: []
  }), Oj(i, () => ({
    getId: () => b.current.id,
    getLayout: () => {
      const {
        layout: R
      } = w.current;
      return R;
    },
    setLayout: (R) => {
      const {
        onLayout: Q
      } = b.current, {
        layout: _,
        panelDataArray: G
      } = w.current, M = mk({
        layout: R,
        panelConstraints: G.map((K) => K.constraints)
      });
      pk(_, M) || (x(M), w.current.layout = M, Q && Q(M), Fs(G, M, v.current));
    }
  }), []), vc(() => {
    b.current.autoSaveId = t4, b.current.direction = r, b.current.dragState = p, b.current.id = d, b.current.onLayout = s, b.current.storage = l;
  }), bK({
    committedValuesRef: b,
    eagerValuesRef: w,
    groupId: d,
    layout: m,
    panelDataArray: w.current.panelDataArray,
    setLayout: x,
    panelGroupElement: h.current
  }), ls(() => {
    const {
      panelDataArray: R
    } = w.current;
    if (t4) {
      if (m.length === 0 || m.length !== R.length)
        return;
      let Q = Ok[t4];
      Q == null && (Q = PK(TK, IK), Ok[t4] = Q);
      const _ = [...R], G = new Map(y.current);
      Q(t4, _, G, m, l);
    }
  }, [t4, m, l]), ls(() => {
  });
  const C = er((R) => {
    const {
      onLayout: Q
    } = b.current, {
      layout: _,
      panelDataArray: G
    } = w.current;
    if (R.constraints.collapsible) {
      const M = G.map((te) => te.constraints), {
        collapsedSize: K = 0,
        panelSize: V,
        pivotIndices: ae
      } = Ho(G, R, _);
      if (Ne(V != null), V !== K) {
        y.current.set(R.id, V);
        const oe = Ls(G, R) === G.length - 1 ? V - K : K - V, Y = Ql({
          delta: oe,
          layout: _,
          panelConstraints: M,
          pivotIndices: ae,
          trigger: "imperative-api"
        });
        Yu(_, Y) || (x(Y), w.current.layout = Y, Q && Q(Y), Fs(G, Y, v.current));
      }
    }
  }, []), k = er((R) => {
    const {
      onLayout: Q
    } = b.current, {
      layout: _,
      panelDataArray: G
    } = w.current;
    if (R.constraints.collapsible) {
      const M = G.map((oe) => oe.constraints), {
        collapsedSize: K = 0,
        panelSize: V,
        minSize: ae = 0,
        pivotIndices: te
      } = Ho(G, R, _);
      if (V === K) {
        const oe = y.current.get(R.id), Y = oe != null && oe >= ae ? oe : ae, X = Ls(G, R) === G.length - 1 ? V - Y : Y - V, ee = Ql({
          delta: X,
          layout: _,
          panelConstraints: M,
          pivotIndices: te,
          trigger: "imperative-api"
        });
        Yu(_, ee) || (x(ee), w.current.layout = ee, Q && Q(ee), Fs(G, ee, v.current));
      }
    }
  }, []), T = er((R) => {
    const {
      layout: Q,
      panelDataArray: _
    } = w.current, {
      panelSize: G
    } = Ho(_, R, Q);
    return Ne(G != null), G;
  }, []), A = er((R, Q) => {
    const {
      panelDataArray: _
    } = w.current, G = Ls(_, R);
    return kK({
      defaultSize: Q,
      dragState: p,
      layout: m,
      panelData: _,
      panelIndex: G
    });
  }, [p, m]), E = er((R) => {
    const {
      layout: Q,
      panelDataArray: _
    } = w.current, {
      collapsedSize: G = 0,
      collapsible: M,
      panelSize: K
    } = Ho(_, R, Q);
    return M === true && K === G;
  }, []), $ = er((R) => {
    const {
      layout: Q,
      panelDataArray: _
    } = w.current, {
      collapsedSize: G = 0,
      collapsible: M,
      panelSize: K
    } = Ho(_, R, Q);
    return Ne(K != null), !M || K > G;
  }, []), j = er((R) => {
    const {
      panelDataArray: Q
    } = w.current;
    Q.push(R), Q.sort((_, G) => {
      const M = _.order, K = G.order;
      return M == null && K == null ? 0 : M == null ? -1 : K == null ? 1 : M - K;
    }), w.current.panelDataArrayChanged = true;
  }, []);
  vc(() => {
    if (w.current.panelDataArrayChanged) {
      w.current.panelDataArrayChanged = false;
      const {
        autoSaveId: R,
        onLayout: Q,
        storage: _
      } = b.current, {
        layout: G,
        panelDataArray: M
      } = w.current;
      let K = null;
      if (R) {
        const ae = EK(R, M, _);
        ae && (y.current = new Map(Object.entries(ae.expandToSizes)), K = ae.layout);
      }
      K == null && (K = CK({
        panelDataArray: M
      }));
      const V = mk({
        layout: K,
        panelConstraints: M.map((ae) => ae.constraints)
      });
      pk(G, V) || (x(V), w.current.layout = V, Q && Q(V), Fs(M, V, v.current));
    }
  });
  const B = er((R) => function(_) {
    _.preventDefault();
    const G = h.current;
    if (!G)
      return () => null;
    const {
      direction: M,
      dragState: K,
      id: V,
      keyboardResizeBy: ae,
      onLayout: te
    } = b.current, {
      layout: oe,
      panelDataArray: Y
    } = w.current, {
      initialLayout: he
    } = K ?? {}, X = bj(V, R, G);
    let ee = wK(_, R, M, K, ae, G);
    if (ee === 0)
      return;
    const de = M === "horizontal";
    document.dir === "rtl" && de && (ee = -ee);
    const ve = Y.map((Ee) => Ee.constraints), Re = Ql({
      delta: ee,
      layout: he ?? oe,
      panelConstraints: ve,
      pivotIndices: X,
      trigger: wj(_) ? "keyboard" : "mouse-or-touch"
    }), ye = !Yu(oe, Re);
    (Cj(_) || kj(_)) && S.current != ee && (S.current = ee, X0(ye ? de ? "horizontal" : "vertical" : de ? ee < 0 ? "horizontal-min" : "horizontal-max" : ee < 0 ? "vertical-min" : "vertical-max")), ye && (x(Re), w.current.layout = Re, te && te(Re), Fs(Y, Re, v.current));
  }, []), D = er((R, Q) => {
    const {
      onLayout: _
    } = b.current, {
      layout: G,
      panelDataArray: M
    } = w.current, K = M.map((he) => he.constraints), {
      panelSize: V,
      pivotIndices: ae
    } = Ho(M, R, G);
    Ne(V != null);
    const oe = Ls(M, R) === M.length - 1 ? V - Q : Q - V, Y = Ql({
      delta: oe,
      layout: G,
      panelConstraints: K,
      pivotIndices: ae,
      trigger: "imperative-api"
    });
    Yu(G, Y) || (x(Y), w.current.layout = Y, _ && _(Y), Fs(M, Y, v.current));
  }, []), N = er((R, Q) => {
    const {
      layout: _,
      panelDataArray: G
    } = w.current, {
      collapsedSize: M = 0,
      collapsible: K,
      defaultSize: V,
      maxSize: ae = 100,
      minSize: te = 0
    } = Q, {
      collapsedSize: oe = 0,
      collapsible: Y,
      defaultSize: he,
      maxSize: X = 100,
      minSize: ee = 0
    } = R.constraints, {
      panelSize: de
    } = Ho(G, R, _);
    Ne(de != null), K && Y && M !== oe && de === M ? D(R, oe) : de < ee ? D(R, ee) : de > X && D(R, X);
  }, [D]), z = er((R, Q) => {
    const {
      direction: _
    } = b.current, {
      layout: G
    } = w.current;
    if (!h.current)
      return;
    const M = Qh(R, h.current);
    Ne(M);
    const K = Aj(_, Q);
    O({
      dragHandleId: R,
      dragHandleRect: M.getBoundingClientRect(),
      initialCursorPosition: K,
      initialLayout: G
    });
  }, []), Z = er(() => {
    AK(), O(null);
  }, []), J = er((R) => {
    const {
      panelDataArray: Q
    } = w.current, _ = Ls(Q, R);
    _ >= 0 && (Q.splice(_, 1), delete v.current[R.id], w.current.panelDataArrayChanged = true);
  }, []), L = mK(() => ({
    collapsePanel: C,
    direction: r,
    dragState: p,
    expandPanel: k,
    getPanelSize: T,
    getPanelStyle: A,
    groupId: d,
    isPanelCollapsed: E,
    isPanelExpanded: $,
    reevaluatePanelConstraints: N,
    registerPanel: j,
    registerResizeHandle: B,
    resizePanel: D,
    startDragging: z,
    stopDragging: Z,
    unregisterPanel: J,
    panelGroupElement: h.current
  }), [C, p, r, k, T, A, d, E, $, N, j, B, D, z, Z, J]), W = {
    display: "flex",
    flexDirection: r === "horizontal" ? "row" : "column",
    height: "100%",
    overflow: "hidden",
    width: "100%"
  };
  return Qa(Dh.Provider, {
    value: L
  }, Qa(u, {
    ...f,
    children: e,
    className: n,
    style: {
      ...W,
      ...c
    },
    ref: h,
    // CSS selectors
    "data-panel-group": "",
    "data-panel-group-direction": r,
    "data-panel-group-id": d
  }));
}
var jj = gj((t4, e) => Qa($j, {
  ...t4,
  forwardedRef: e
}));
$j.displayName = "PanelGroup";
jj.displayName = "forwardRef(PanelGroup)";
function Ls(t4, e) {
  return t4.findIndex((n) => n === e || n.id === e.id);
}
function Ho(t4, e, n) {
  const r = Ls(t4, e), o = r === t4.length - 1 ? [r - 1, r] : [r, r + 1], s = n[r];
  return {
    ...e.constraints,
    panelSize: s,
    pivotIndices: o
  };
}
function $K({
  disabled: t4,
  handleId: e,
  resizeHandler: n,
  panelGroupElement: r
}) {
  ls(() => {
    if (t4 || n == null || r == null)
      return;
    const i = Qh(e, r);
    if (i == null)
      return;
    const o = (s) => {
      if (!s.defaultPrevented)
        switch (s.key) {
          case "ArrowDown":
          case "ArrowLeft":
          case "ArrowRight":
          case "ArrowUp":
          case "End":
          case "Home": {
            s.preventDefault(), n(s);
            break;
          }
          case "F6": {
            s.preventDefault();
            const a = i.getAttribute("data-panel-group-id");
            Ne(a);
            const l = bc(a, r), c = yj(a, e, r);
            Ne(c !== null);
            const u = s.shiftKey ? c > 0 ? c - 1 : l.length - 1 : c + 1 < l.length ? c + 1 : 0;
            l[u].focus();
            break;
          }
        }
    };
    return i.addEventListener("keydown", o), () => {
      i.removeEventListener("keydown", o);
    };
  }, [r, t4, e, n]);
}
function Rj({
  children: t4 = null,
  className: e = "",
  disabled: n = false,
  id: r,
  onDragging: i,
  style: o = {},
  tabIndex: s = 0,
  tagName: a = "div",
  ...l
}) {
  const c = vr(null), u = vr({
    onDragging: i
  });
  ls(() => {
    u.current.onDragging = i;
  });
  const f = mj(Dh);
  if (f === null)
    throw Error("PanelResizeHandle components must be rendered within a PanelGroup container");
  const {
    direction: d,
    dragState: h,
    groupId: p,
    registerResizeHandle: O,
    startDragging: m,
    stopDragging: x,
    panelGroupElement: v
  } = f, y = Sv(r), S = (h == null ? void 0 : h.dragHandleId) === y, [b, w] = Md(false), [C, k] = Md(null), T = er(() => {
    const E = c.current;
    Ne(E), E.blur(), x();
    const {
      onDragging: $
    } = u.current;
    $ && $(false);
  }, [x]);
  ls(() => {
    if (n)
      k(null);
    else {
      const E = O(y);
      k(() => E);
    }
  }, [n, y, O]), ls(() => {
    if (n || C == null || !S)
      return;
    const E = (D) => {
      C(D);
    }, $ = (D) => {
      C(D);
    }, j = c.current;
    Ne(j);
    const B = j.ownerDocument;
    return B.body.addEventListener("contextmenu", T), B.body.addEventListener("mousemove", E), B.body.addEventListener("touchmove", E), B.body.addEventListener("mouseleave", $), window.addEventListener("mouseup", T), window.addEventListener("touchend", T), () => {
      B.body.removeEventListener("contextmenu", T), B.body.removeEventListener("mousemove", E), B.body.removeEventListener("touchmove", E), B.body.removeEventListener("mouseleave", $), window.removeEventListener("mouseup", T), window.removeEventListener("touchend", T);
    };
  }, [d, n, S, C, T]), $K({
    disabled: n,
    handleId: y,
    resizeHandler: C,
    panelGroupElement: v
  });
  const A = {
    cursor: Pj(d),
    touchAction: "none",
    userSelect: "none"
  };
  return Qa(a, {
    ...l,
    children: t4,
    className: e,
    onBlur: () => w(false),
    onFocus: () => w(true),
    onMouseDown: (E) => {
      m(y, E.nativeEvent);
      const $ = u.current;
      Ne($);
      const {
        onDragging: j
      } = $;
      j && j(true);
    },
    onMouseUp: T,
    onTouchCancel: T,
    onTouchEnd: T,
    onTouchStart: (E) => {
      m(y, E.nativeEvent);
      const $ = u.current;
      Ne($);
      const {
        onDragging: j
      } = $;
      j && j(true);
    },
    ref: c,
    role: "separator",
    style: {
      ...A,
      ...o
    },
    tabIndex: s,
    // CSS selectors
    "data-panel-group-direction": d,
    "data-panel-group-id": p,
    "data-resize-handle": "",
    "data-resize-handle-active": S ? "pointer" : b ? "keyboard" : void 0,
    "data-panel-resize-handle-enabled": !n,
    "data-panel-resize-handle-id": y
  });
}
Rj.displayName = "PanelResizeHandle";
function jK({ onDoubleClick: t4, ...e }) {
  return /* @__PURE__ */ g.jsx(Rj, { ...e, children: /* @__PURE__ */ g.jsx(RK, { onDoubleClick: t4, children: /* @__PURE__ */ g.jsx(Fe, {}) }) });
}
var RK = I.div`
  display: flex;
  justify-content: center;
  padding: var(--spacing-xs) 0;

  &:hover {
    ${Fe} {
      border-bottom-color: var(--color-info-base);
    }
  }
`;
function DK() {
  var l;
  const t4 = Ke(null), [e, n] = fe(((l = t4.current) == null ? void 0 : l.isCollapsed()) || true), r = () => {
    t4.current && (t4.current.collapse(), n(true));
  }, i = () => {
    t4.current && (t4.current.expand(), n(false));
  };
  return { panelProps: {
    ref: t4,
    collapsible: true,
    onCollapse: r,
    onExpand: i
  }, panel: { isCollapsed: e, collapse: r, expand: i, toggle: () => {
    t4.current && (e ? t4.current.expand() : t4.current.collapse(), n(!e));
  } } };
}
var QK = 14;
var Dj = { exports: {} };
(function(t4, e) {
  (function(n, r) {
    t4.exports = r();
  })(Ze, function() {
    var n = 1e3, r = 6e4, i = 36e5, o = "millisecond", s = "second", a = "minute", l = "hour", c = "day", u = "week", f = "month", d = "quarter", h = "year", p = "date", O = "Invalid Date", m = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, x = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, v = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(B) {
      var D = ["th", "st", "nd", "rd"], N = B % 100;
      return "[" + B + (D[(N - 20) % 10] || D[N] || D[0]) + "]";
    } }, y = function(B, D, N) {
      var z = String(B);
      return !z || z.length >= D ? B : "" + Array(D + 1 - z.length).join(N) + B;
    }, S = { s: y, z: function(B) {
      var D = -B.utcOffset(), N = Math.abs(D), z = Math.floor(N / 60), Z = N % 60;
      return (D <= 0 ? "+" : "-") + y(z, 2, "0") + ":" + y(Z, 2, "0");
    }, m: function B(D, N) {
      if (D.date() < N.date())
        return -B(N, D);
      var z = 12 * (N.year() - D.year()) + (N.month() - D.month()), Z = D.clone().add(z, f), J = N - Z < 0, L = D.clone().add(z + (J ? -1 : 1), f);
      return +(-(z + (N - Z) / (J ? Z - L : L - Z)) || 0);
    }, a: function(B) {
      return B < 0 ? Math.ceil(B) || 0 : Math.floor(B);
    }, p: function(B) {
      return { M: f, y: h, w: u, d: c, D: p, h: l, m: a, s, ms: o, Q: d }[B] || String(B || "").toLowerCase().replace(/s$/, "");
    }, u: function(B) {
      return B === void 0;
    } }, b = "en", w = {};
    w[b] = v;
    var C = "$isDayjsObject", k = function(B) {
      return B instanceof $ || !(!B || !B[C]);
    }, T = function B(D, N, z) {
      var Z;
      if (!D)
        return b;
      if (typeof D == "string") {
        var J = D.toLowerCase();
        w[J] && (Z = J), N && (w[J] = N, Z = J);
        var L = D.split("-");
        if (!Z && L.length > 1)
          return B(L[0]);
      } else {
        var W = D.name;
        w[W] = D, Z = W;
      }
      return !z && Z && (b = Z), Z || !z && b;
    }, A = function(B, D) {
      if (k(B))
        return B.clone();
      var N = typeof D == "object" ? D : {};
      return N.date = B, N.args = arguments, new $(N);
    }, E = S;
    E.l = T, E.i = k, E.w = function(B, D) {
      return A(B, { locale: D.$L, utc: D.$u, x: D.$x, $offset: D.$offset });
    };
    var $ = function() {
      function B(N) {
        this.$L = T(N.locale, null, true), this.parse(N), this.$x = this.$x || N.x || {}, this[C] = true;
      }
      var D = B.prototype;
      return D.parse = function(N) {
        this.$d = function(z) {
          var Z = z.date, J = z.utc;
          if (Z === null)
            return /* @__PURE__ */ new Date(NaN);
          if (E.u(Z))
            return /* @__PURE__ */ new Date();
          if (Z instanceof Date)
            return new Date(Z);
          if (typeof Z == "string" && !/Z$/i.test(Z)) {
            var L = Z.match(m);
            if (L) {
              var W = L[2] - 1 || 0, R = (L[7] || "0").substring(0, 3);
              return J ? new Date(Date.UTC(L[1], W, L[3] || 1, L[4] || 0, L[5] || 0, L[6] || 0, R)) : new Date(L[1], W, L[3] || 1, L[4] || 0, L[5] || 0, L[6] || 0, R);
            }
          }
          return new Date(Z);
        }(N), this.init();
      }, D.init = function() {
        var N = this.$d;
        this.$y = N.getFullYear(), this.$M = N.getMonth(), this.$D = N.getDate(), this.$W = N.getDay(), this.$H = N.getHours(), this.$m = N.getMinutes(), this.$s = N.getSeconds(), this.$ms = N.getMilliseconds();
      }, D.$utils = function() {
        return E;
      }, D.isValid = function() {
        return this.$d.toString() !== O;
      }, D.isSame = function(N, z) {
        var Z = A(N);
        return this.startOf(z) <= Z && Z <= this.endOf(z);
      }, D.isAfter = function(N, z) {
        return A(N) < this.startOf(z);
      }, D.isBefore = function(N, z) {
        return this.endOf(z) < A(N);
      }, D.$g = function(N, z, Z) {
        return E.u(N) ? this[z] : this.set(Z, N);
      }, D.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
      }, D.valueOf = function() {
        return this.$d.getTime();
      }, D.startOf = function(N, z) {
        var Z = this, J = !!E.u(z) || z, L = E.p(N), W = function(ae, te) {
          var oe = E.w(Z.$u ? Date.UTC(Z.$y, te, ae) : new Date(Z.$y, te, ae), Z);
          return J ? oe : oe.endOf(c);
        }, R = function(ae, te) {
          return E.w(Z.toDate()[ae].apply(Z.toDate("s"), (J ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(te)), Z);
        }, Q = this.$W, _ = this.$M, G = this.$D, M = "set" + (this.$u ? "UTC" : "");
        switch (L) {
          case h:
            return J ? W(1, 0) : W(31, 11);
          case f:
            return J ? W(1, _) : W(0, _ + 1);
          case u:
            var K = this.$locale().weekStart || 0, V = (Q < K ? Q + 7 : Q) - K;
            return W(J ? G - V : G + (6 - V), _);
          case c:
          case p:
            return R(M + "Hours", 0);
          case l:
            return R(M + "Minutes", 1);
          case a:
            return R(M + "Seconds", 2);
          case s:
            return R(M + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, D.endOf = function(N) {
        return this.startOf(N, false);
      }, D.$set = function(N, z) {
        var Z, J = E.p(N), L = "set" + (this.$u ? "UTC" : ""), W = (Z = {}, Z[c] = L + "Date", Z[p] = L + "Date", Z[f] = L + "Month", Z[h] = L + "FullYear", Z[l] = L + "Hours", Z[a] = L + "Minutes", Z[s] = L + "Seconds", Z[o] = L + "Milliseconds", Z)[J], R = J === c ? this.$D + (z - this.$W) : z;
        if (J === f || J === h) {
          var Q = this.clone().set(p, 1);
          Q.$d[W](R), Q.init(), this.$d = Q.set(p, Math.min(this.$D, Q.daysInMonth())).$d;
        } else
          W && this.$d[W](R);
        return this.init(), this;
      }, D.set = function(N, z) {
        return this.clone().$set(N, z);
      }, D.get = function(N) {
        return this[E.p(N)]();
      }, D.add = function(N, z) {
        var Z, J = this;
        N = Number(N);
        var L = E.p(z), W = function(_) {
          var G = A(J);
          return E.w(G.date(G.date() + Math.round(_ * N)), J);
        };
        if (L === f)
          return this.set(f, this.$M + N);
        if (L === h)
          return this.set(h, this.$y + N);
        if (L === c)
          return W(1);
        if (L === u)
          return W(7);
        var R = (Z = {}, Z[a] = r, Z[l] = i, Z[s] = n, Z)[L] || 1, Q = this.$d.getTime() + N * R;
        return E.w(Q, this);
      }, D.subtract = function(N, z) {
        return this.add(-1 * N, z);
      }, D.format = function(N) {
        var z = this, Z = this.$locale();
        if (!this.isValid())
          return Z.invalidDate || O;
        var J = N || "YYYY-MM-DDTHH:mm:ssZ", L = E.z(this), W = this.$H, R = this.$m, Q = this.$M, _ = Z.weekdays, G = Z.months, M = Z.meridiem, K = function(te, oe, Y, he) {
          return te && (te[oe] || te(z, J)) || Y[oe].slice(0, he);
        }, V = function(te) {
          return E.s(W % 12 || 12, te, "0");
        }, ae = M || function(te, oe, Y) {
          var he = te < 12 ? "AM" : "PM";
          return Y ? he.toLowerCase() : he;
        };
        return J.replace(x, function(te, oe) {
          return oe || function(Y) {
            switch (Y) {
              case "YY":
                return String(z.$y).slice(-2);
              case "YYYY":
                return E.s(z.$y, 4, "0");
              case "M":
                return Q + 1;
              case "MM":
                return E.s(Q + 1, 2, "0");
              case "MMM":
                return K(Z.monthsShort, Q, G, 3);
              case "MMMM":
                return K(G, Q);
              case "D":
                return z.$D;
              case "DD":
                return E.s(z.$D, 2, "0");
              case "d":
                return String(z.$W);
              case "dd":
                return K(Z.weekdaysMin, z.$W, _, 2);
              case "ddd":
                return K(Z.weekdaysShort, z.$W, _, 3);
              case "dddd":
                return _[z.$W];
              case "H":
                return String(W);
              case "HH":
                return E.s(W, 2, "0");
              case "h":
                return V(1);
              case "hh":
                return V(2);
              case "a":
                return ae(W, R, true);
              case "A":
                return ae(W, R, false);
              case "m":
                return String(R);
              case "mm":
                return E.s(R, 2, "0");
              case "s":
                return String(z.$s);
              case "ss":
                return E.s(z.$s, 2, "0");
              case "SSS":
                return E.s(z.$ms, 3, "0");
              case "Z":
                return L;
            }
            return null;
          }(te) || L.replace(":", "");
        });
      }, D.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, D.diff = function(N, z, Z) {
        var J, L = this, W = E.p(z), R = A(N), Q = (R.utcOffset() - this.utcOffset()) * r, _ = this - R, G = function() {
          return E.m(L, R);
        };
        switch (W) {
          case h:
            J = G() / 12;
            break;
          case f:
            J = G();
            break;
          case d:
            J = G() / 3;
            break;
          case u:
            J = (_ - Q) / 6048e5;
            break;
          case c:
            J = (_ - Q) / 864e5;
            break;
          case l:
            J = _ / i;
            break;
          case a:
            J = _ / r;
            break;
          case s:
            J = _ / n;
            break;
          default:
            J = _;
        }
        return Z ? J : E.a(J);
      }, D.daysInMonth = function() {
        return this.endOf(f).$D;
      }, D.$locale = function() {
        return w[this.$L];
      }, D.locale = function(N, z) {
        if (!N)
          return this.$L;
        var Z = this.clone(), J = T(N, z, true);
        return J && (Z.$L = J), Z;
      }, D.clone = function() {
        return E.w(this.$d, this);
      }, D.toDate = function() {
        return new Date(this.valueOf());
      }, D.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, D.toISOString = function() {
        return this.$d.toISOString();
      }, D.toString = function() {
        return this.$d.toUTCString();
      }, B;
    }(), j = $.prototype;
    return A.prototype = j, [["$ms", o], ["$s", s], ["$m", a], ["$H", l], ["$W", c], ["$M", f], ["$y", h], ["$D", p]].forEach(function(B) {
      j[B[1]] = function(D) {
        return this.$g(D, B[0], B[1]);
      };
    }), A.extend = function(B, D) {
      return B.$i || (B(D, $, A), B.$i = true), A;
    }, A.locale = T, A.isDayjs = k, A.unix = function(B) {
      return A(1e3 * B);
    }, A.en = w[b], A.Ls = w, A.p = {}, A;
  });
})(Dj);
var BK = Dj.exports;
var Bh = /* @__PURE__ */ Za(BK);
function Qj({
  children: t4,
  controls: e,
  staticLabels: n,
  onClick: r,
  isStandAlone: i = false,
  showControlsOnHover: o = false,
  dataTestId: s
}) {
  const a = (l) => {
    (l.key === " " || l.key === "Enter") && (l.preventDefault(), r == null || r());
  };
  return /* @__PURE__ */ g.jsxs(
    MK,
    {
      tabIndex: 0,
      role: "listitem",
      onKeyDown: a,
      onClick: r,
      $standalone: i,
      "data-testid": s,
      children: [
        /* @__PURE__ */ g.jsx(NK, { className: "accordion-item-content", children: t4 }),
        /* @__PURE__ */ g.jsxs(wv, { children: [
          n && /* @__PURE__ */ g.jsx(_K, { children: n }),
          /* @__PURE__ */ g.jsx(Bj, { $showControlsOnHover: o, children: e })
        ] })
      ]
    }
  );
}
var wv = I.div`
  display: flex;
  flex-direction: row;
`;
var _K = I(wv)`
  gap: var(--spacing-xxs);
  width: max-content;
  align-items: center;
`;
var Bj = I(wv)`
  display: ${({ $showControlsOnHover: t4 }) => t4 ? "none" : "flex"};
  gap: var(--spacing-xxs);
`;
var MK = I.div`
  width: ${({ $standalone: t4 }) => t4 ? "100%" : "calc(100% + 24px)"};
  max-height: 100%;
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: var(--spacing-xxs);
  padding-left: var(--spacing-lg);
  margin-left: ${({ $standalone: t4 }) => t4 ? "0" : "-24px"};

  &:hover,
  &:focus,
  &:focus-within {
    background-color: var(--bg-color-hover);

    ${Bj} {
      display: flex;
    }
  }
`;
var NK = I.div`
  max-width: 30vw;
  display: flex;
  border-left: 1px solid var(--border-color-secondary);
  flex-direction: column;
  justify-content: center;
  align-items: flex-start;
  gap: 2px;
`;
var _j = { exports: {} };
(function(t4, e) {
  (function(n, r) {
    t4.exports = r();
  })(Ze, function() {
    return function(n, r, i) {
      var o = "h:mm A", s = { lastDay: "[Yesterday at] " + o, sameDay: "[Today at] " + o, nextDay: "[Tomorrow at] " + o, nextWeek: "dddd [at] " + o, lastWeek: "[Last] dddd [at] " + o, sameElse: "MM/DD/YYYY" };
      r.prototype.calendar = function(a, l) {
        var c = l || this.$locale().calendar || s, u = i(a || void 0).startOf("d"), f = this.diff(u, "d", true), d = "sameElse", h = f < -6 ? d : f < -1 ? "lastWeek" : f < 0 ? "lastDay" : f < 1 ? "sameDay" : f < 2 ? "nextDay" : f < 7 ? "nextWeek" : d, p = c[h] || s[h];
        return typeof p == "function" ? p.call(this, i()) : this.format(p);
      };
    };
  });
})(_j);
var FK = _j.exports;
var ZK = /* @__PURE__ */ Za(FK);
Bh.extend(ZK);
var xk = (t4, e) => Bh(t4).calendar(null, {
  sameDay: "[Today]",
  // The same day ( Today )
  lastDay: "[Yesterday]",
  // The day before ( Yesterday )
  lastWeek: "DD MMM",
  // Last week ( Last Monday )
  sameElse: "DD MMM"
  // Everything else ( Jun 14)
});
function WK(t4, e) {
  return t4.reduce(
    (r, i) => {
      const o = Bh(i[e]).format("YYYY-MM-DD");
      return r[o] || (r[o] = []), r[o].push(i), r;
    },
    {}
  );
}
function VK({
  onConfirm: t4,
  onCancel: e,
  confirmText: n = "Delete",
  cancelText: r = "Cancel",
  description: i = "Are you sure?"
}) {
  return /* @__PURE__ */ g.jsxs(zK, { children: [
    /* @__PURE__ */ g.jsx(WarningFilledIcon, { size: "16px", color: "--color-warning-base" }),
    /* @__PURE__ */ g.jsxs("div", { children: [
      /* @__PURE__ */ g.jsx("div", { children: i }),
      /* @__PURE__ */ g.jsxs(LK, { children: [
        /* @__PURE__ */ g.jsx(Button, { size: "small", variant: "text", onClick: e, "data-testid": "cancel-btn", children: r }),
        /* @__PURE__ */ g.jsx(
          Button,
          {
            size: "small",
            variant: "primary",
            tone: "danger",
            onClick: t4,
            "data-testid": "confirm-btn",
            children: n
          }
        )
      ] })
    ] })
  ] });
}
function Ba({
  children: t4,
  onConfirm: e,
  onCancel: n,
  trigger: r = ["click"],
  placement: i = "bottomRight",
  showArrow: o = true,
  onVisibilityChange: s,
  ...a
}) {
  const [l, c] = fe(false), u = Ke(null);
  _e(() => {
    s == null || s(l);
  }, [l, s]);
  const f = (p) => {
    p.stopPropagation(), e == null || e(), c(false);
  }, d = (p) => {
    p == null || p.stopPropagation(), n == null || n(), c(false);
  }, h = (p) => {
    p.stopPropagation(), c((O) => !O);
  };
  return l ? /* @__PURE__ */ g.jsx(
    Ga,
    {
      ref: u,
      trigger: r,
      showArrow: o && { content: /* @__PURE__ */ g.jsx(XK, {}) },
      placement: i,
      visible: l,
      overlayStyle: { zIndex: "1000", position: "absolute" },
      overlay: /* @__PURE__ */ g.jsx(Fo, { onClickOutside: d, children: /* @__PURE__ */ g.jsx(
        VK,
        {
          ...a,
          onCancel: d,
          onConfirm: f
        }
      ) }),
      children: /* @__PURE__ */ g.jsx("div", { onClick: h, children: t4 })
    }
  ) : /* @__PURE__ */ g.jsx("div", { onClick: h, children: t4 });
}
var zK = I(No)`
  display: flex;
  gap: var(--spacing-xs);
  width: 300px;
  padding: var(--spacing-base);
  border-radius: var(--border-radius-sm);
  color: var(--text-color-secondary);
  font-size: var(--font-size-base);
`;
var LK = I.div`
  display: flex;
  justify-content: flex-end;
  gap: var(--spacing-xs);
`;
var XK = I(b2)`
  left: -4px;
`;
function Lc({ onSearch: t4, value: e, className: n }) {
  const [r, i] = o4(), o = Ke(null), [s, a] = fe(false);
  _e(() => {
    a(e.length > 0);
  }, [e]);
  const l = () => {
    var u;
    (u = o.current) == null || u.focus();
  }, c = (u) => {
    i(() => {
      t4(u);
    });
  };
  return /* @__PURE__ */ g.jsxs(GK, { className: n, onClick: l, children: [
    /* @__PURE__ */ g.jsx(Mj, { children: /* @__PURE__ */ g.jsx(SearchIcon, { size: "14px", color: "--text-color-helper" }) }),
    /* @__PURE__ */ g.jsx(
      YK,
      {
        ref: o,
        placeholder: "Search",
        value: e,
        "data-testid": "search-input",
        onChange: (u) => c(u.target.value)
      }
    ),
    s && /* @__PURE__ */ g.jsx(qK, { children: /* @__PURE__ */ g.jsx(
      Button,
      {
        variant: "ghost",
        size: "small",
        icon: /* @__PURE__ */ g.jsx(CloseOutlineIcon, { color: "--icon-color-secondary" }),
        onClick: () => c("")
      }
    ) })
  ] });
}
var GK = I.div`
  display: flex;
  align-self: stretch;
  width: 100%;
  border: 1px solid transparent;
  padding-left: var(--spacing-base);

  &:focus-within,
  :active {
    border: var(--input-border-focus);
    border-radius: var(--border-radius);
  }
`;
var YK = I.input`
  font-size: var(--font-size-base);
  line-height: var(--line-height-base);
  padding-left: var(--spacing-base);
  border-radius: none;
  color: var(--input-content-color-active);
  background-color: transparent;
  border: none;
  outline: none;
  text-indent: var(--spacing-xs);
  padding-left: 0;
  width: 100%;
  height: 100%;
`;
var Mj = I.div`
  display: flex;
  align-items: center;
  height: 100%;
`;
var qK = I(Mj)`
  padding: 0 var(--spacing-xs);
`;
function Nj({
  className: t4 = "",
  value: e
}) {
  return /* @__PURE__ */ g.jsx(UK, { className: `${t4} tag-${e.toLowerCase()}`, children: e });
}
var UK = I.span`
  font-size: var(--font-size-sm);
  font-weight: var(--font-weight-semibold);
  line-height: var(--line-height-sm);
  color: var(--tag-color);
`;
var Cv = I.div`
  display: flex;
  flex-direction: column;
  width: 100%;
  height: 100%;
`;
var Xc = I.div`
  display: flex;
  flex-direction: row;
  flex-grow: 1;
  align-items: center;
  border-bottom: 1px solid var(--border-color-secondary);
  height: 40px;
  max-height: 40px;
  flex-shrink: 0;
`;
var HK = I.div`
  display: flex;
  flex-direction: row;
  justify-content: space-between;
  padding: 0 var(--spacing-base);
  border-bottom: 1px solid var(--border-color-secondary);
  height: 41px;
  max-height: 41px;
  flex-shrink: 0;
`;
var JK = I.div`
  display: flex;
  width: 100%;
  flex-direction: row;
  flex-grow: 1;
  align-items: center;
  gap: var(--spacing-xs);
  height: 40px;
  padding: 0 var(--spacing-base);

  ${Button} {
    padding: var(--spacing-xxs);

    svg {
      width: 14px;
      height: 14px;
      fill: var(--bg-color);
    }
  }
`;
var Fj = I.div`
  display: flex;
  flex-shrink: 0;
  align-items: center;
  padding: 0 var(--spacing-base);
`;
var _h = I.div`
  display: flex;
  flex-direction: column;
  overflow: auto;
  height: 100%;
`;
var Zj = I.div`
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  gap: var(--spacing-xs);
  font-size: var(--font-size-base);
  line-height: var(--line-height-base);
  text-align: center;
  h3 {
    margin: 0;
    line-height: var(--line-height-lg);
    font-weight: var(--font-weight-semibold);
  }
`;
var KK = I.div`
  display: flex;
  width: var(--spacing-base);
  height: var(--spacing-lg);
  justify-content: center;
  align-items: center;
`;
var bO = I(Nj)`
  display: flex;
  flex-shrink: 0;
  width: 55px;
  align-self: center;
  justify-content: center;
`;
function eee() {
  const { collections: t4 } = je();
  return Wj(t4);
}
function Wj(t4, e = "") {
  let n = [];
  return t4.filter((i) => i.get().type === dn.Folder).forEach((i) => {
    const o = i.get().value, s = i.nested("value"), a = e ? `${e} / ${o.name}` : o.name;
    n.push({ path: a, folder: s, treeItem: i }), o.items.length && (n = n.concat(Wj(s.items, a)));
  }), n;
}
var kv = (t4, e) => {
  const [n, r] = fe(t4), i = (a) => /^[a-zA-Z0-9 _\-]+$/.test(a), o = (a, l) => {
    var u;
    return ((u = l == null ? void 0 : l.get()) == null ? void 0 : u.filter(
      (f) => f.value.name.trim() === a.trim() && f.value.state === bt.Normal
    )).length <= 0;
  }, s = We(() => {
    const a = !i(n), l = e ? !o(n, e) : false;
    return a || l;
  }, [e, n]);
  return { newName: n, setNewName: r, isValidName: i, isUniqueName: o, disabled: s };
};
function Av({
  className: t4,
  defaultName: e,
  onChange: n,
  onSave: r,
  onCancel: i,
  level: o = 0,
  placeholder: s = "New Folder",
  siblingItems: a,
  icon: l
}) {
  const { newName: c, setNewName: u, disabled: f } = kv(e, a), d = Ke(null), h = c.trim();
  _e(() => {
    var m;
    (m = d.current) == null || m.focus();
  }, [d]);
  const p = Ue(
    (m) => {
      m.key === "Escape" && (i == null || i()), m.key === "Enter" && !f && r(h);
    },
    [i, r, h, f]
  ), O = (m) => {
    u(m.target.value), n == null || n(m);
  };
  return /* @__PURE__ */ g.jsx(Fo, { onClickOutside: i, children: /* @__PURE__ */ g.jsxs(tee, { $level: o, className: t4, onKeyDown: p, children: [
    /* @__PURE__ */ g.jsx(KK, { children: l }),
    /* @__PURE__ */ g.jsx(
      us,
      {
        ref: d,
        "data-testid": "edit-item-header-input",
        type: "text",
        placeholder: s,
        value: c,
        onChange: O
      }
    ),
    /* @__PURE__ */ g.jsx(
      vk,
      {
        "data-testid": "edit-item-header-save-button",
        variant: "primary",
        size: "small",
        onClick: () => r(c.trim()),
        disabled: f,
        icon: /* @__PURE__ */ g.jsx(CheckmarkIcon, {})
      }
    ),
    /* @__PURE__ */ g.jsx(
      vk,
      {
        "data-testid": "edit-item-header-cancel-button",
        variant: "text",
        size: "small",
        onClick: i,
        icon: /* @__PURE__ */ g.jsx(CloseIcon, {})
      }
    )
  ] }) });
}
var tee = I.div`
  display: flex;
  align-items: center;
  gap: 4px;
  align-self: stretch;
  padding: ${({ $level: t4 }) => `var(--spacing-xxs) var(--spacing-xs) var(--spacing-xxs) calc(var(--spacing-sm) - 1px + ${t4} * var(--spacing-base))`};

  background-color: var(--bg-color-active);
  height: 32px;
`;
var vk = I(Button)`
  border: none;

  & + & {
    margin-left: 0;
  }
`;
function _a(t4, e) {
  let n = e, r = 1;
  const i = new Set(t4.map((o) => o.value.name));
  for (; i.has(n); )
    r++, n = `${e} ${r}`;
  return n;
}
function nee({ transaction: t4, onClose: e }) {
  const { collections: n } = je(), r = eee(), [i, o] = fe("New Collection"), [s, a] = fe(null), [l, c] = fe(""), u = We(
    () => {
      var S;
      return (S = r.find((b) => b.folder.get().id === s)) == null ? void 0 : S.folder.items;
    },
    [s, r]
  ), {
    newName: f,
    setNewName: d,
    disabled: h
  } = kv("New Request", u), p = (r.length ? !s : !i.trim()) || h, O = We(
    () => r.filter((S) => S.path.toLowerCase().includes(l.toLowerCase())),
    [l, r]
  ), m = (S) => {
    c(S);
  }, x = () => {
    const S = {
      type: dn.Request,
      value: {
        id: crypto.randomUUID(),
        state: bt.Normal,
        name: f,
        request: t4.request,
        response: t4.response
      }
    };
    if (r.length) {
      const b = r.find((w) => w.folder.get().id === s);
      b && b.folder.items.merge([S]);
    } else {
      const b = {
        type: dn.Folder,
        value: {
          id: crypto.randomUUID(),
          state: bt.Normal,
          name: i,
          items: [S]
        }
      };
      n.merge([b, ...n.get()]);
    }
    e == null || e();
  }, v = () => {
    c("");
    const S = _a(n.get(), "New Collection");
    n.set((b) => [
      {
        type: dn.Folder,
        value: {
          id: crypto.randomUUID(),
          state: bt.Draft,
          name: S,
          items: []
        }
      },
      ...b
    ]);
  }, y = (S, b) => {
    S.length && b.name.set(S), b.state.set(bt.Normal);
  };
  return /* @__PURE__ */ g.jsxs(ree, { children: [
    /* @__PURE__ */ g.jsxs(iee, { children: [
      /* @__PURE__ */ g.jsx("h4", { children: "Save request" }),
      /* @__PURE__ */ g.jsx(Button, { variant: "text", onClick: () => e == null ? void 0 : e(), icon: /* @__PURE__ */ g.jsx(CloseIcon, {}) })
    ] }),
    /* @__PURE__ */ g.jsx(ia, { children: /* @__PURE__ */ g.jsx("b", { children: "Request name" }) }),
    /* @__PURE__ */ g.jsx(
      us,
      {
        type: "text",
        placeholder: "Enter name",
        value: f,
        onChange: (S) => d(S.target.value)
      }
    ),
    r.length ? /* @__PURE__ */ g.jsxs(g.Fragment, { children: [
      /* @__PURE__ */ g.jsx(ia, { children: /* @__PURE__ */ g.jsx("b", { children: "Save to" }) }),
      /* @__PURE__ */ g.jsxs(see, { children: [
        /* @__PURE__ */ g.jsx(fee, { value: l, onSearch: m }),
        /* @__PURE__ */ g.jsx(aee, { children: O.length ? O.map((S) => {
          const { id: b, name: w, state: C } = S.folder.get();
          return C !== bt.Normal ? /* @__PURE__ */ g.jsx(
            uee,
            {
              defaultName: w,
              siblingItems: n,
              onSave: (k) => y(k, S.folder),
              onCancel: () => S.treeItem.set(pt),
              icon: /* @__PURE__ */ g.jsx(FolderAddIcon, { size: "14px", color: "--icon-color-disabled" })
            }
          ) : /* @__PURE__ */ g.jsxs(lee, { onClick: () => a(b), children: [
            /* @__PURE__ */ g.jsx(hee, { children: s === b ? /* @__PURE__ */ g.jsx(CheckmarkIcon, { size: "14px" }) : /* @__PURE__ */ g.jsx(FolderIcon, { size: "14px" }) }),
            /* @__PURE__ */ g.jsx(pee, { title: S.path, children: S.path })
          ] }, b);
        }) : /* @__PURE__ */ g.jsx(dee, { children: "No collections found" }) })
      ] })
    ] }) : /* @__PURE__ */ g.jsxs(g.Fragment, { children: [
      /* @__PURE__ */ g.jsx(ia, { children: /* @__PURE__ */ g.jsx("b", { children: "Collection name" }) }),
      /* @__PURE__ */ g.jsx(
        us,
        {
          type: "text",
          placeholder: "New Collection",
          value: i,
          onChange: (S) => o(S.target.value)
        }
      )
    ] }),
    /* @__PURE__ */ g.jsxs(oee, { children: [
      /* @__PURE__ */ g.jsx(yk, { children: r.length ? /* @__PURE__ */ g.jsx(Button, { variant: "ghost", icon: /* @__PURE__ */ g.jsx(AddIcon, {}), onClick: v, children: "New Collection" }) : null }),
      /* @__PURE__ */ g.jsxs(yk, { children: [
        /* @__PURE__ */ g.jsx(
          Button,
          {
            variant: "outlined",
            size: "small",
            onClick: () => {
              e == null || e();
            },
            children: "Cancel"
          }
        ),
        /* @__PURE__ */ g.jsx(
          cee,
          {
            variant: "primary",
            size: "small",
            onClick: x,
            disabled: p,
            children: "Save"
          }
        )
      ] })
    ] })
  ] });
}
function Vj({ children: t4, transaction: e }) {
  const { collections: n } = je(), [r, i] = fe(false), o = () => {
    i((a) => !a);
  }, s = () => {
    n.forEach((a) => {
      a.get().value.state === bt.Draft && a.set(pt);
    }), i(false);
  };
  return r ? /* @__PURE__ */ g.jsx(
    Ga,
    {
      trigger: ["click"],
      showArrow: true,
      placement: "bottomRight",
      visible: r,
      overlayStyle: { zIndex: "1000", position: "absolute" },
      overlay: /* @__PURE__ */ g.jsx(Fo, { onClickOutside: s, children: /* @__PURE__ */ g.jsx(nee, { transaction: e, onClose: s }) }),
      children: /* @__PURE__ */ g.jsx("div", { onClick: o, children: t4 })
    }
  ) : /* @__PURE__ */ g.jsx("div", { onClick: o, children: t4 });
}
var ree = I(No)`
  display: flex;
  flex-direction: column;
  gap: var(--spacing-xs);
  width: 332px;
  padding: var(--spacing-base);
  border-radius: var(--border-radius-sm);
  color: var(--text-color-secondary);
  font-size: var(--font-size-base);

  ${ia} {
    margin-top: var(--spacing-xs);
  }
`;
var iee = I.div`
  display: flex;
  width: 100%;
  justify-content: space-between;

  h4 {
    margin: 0;
    line-height: var(--line-height-base);
  }
`;
var oee = I.div`
  display: flex;
  flex-direction: row;
  justify-content: space-between;
  gap: var(--spacing-xxs);
`;
var see = I.div`
  display: flex;
  flex-direction: column;
  border-radius: 4px;
  border: 1px solid var(--border-color-primary);
  width: 100%;
  min-height: 200px;
`;
var aee = I.div`
  display: flex;
  flex-grow: 1;
  flex-direction: column;
  max-height: 200px;
  overflow-y: auto;
  border-top: 1px solid var(--border-color-primary);
`;
var lee = I.div`
  display: flex;
  flex-shrink: 0;
  flex-direction: row;
  align-items: center;
  gap: var(--spacing-xs);
  padding: 0 var(--spacing-xs);
  color: var(--text-color-secondary);
  cursor: pointer;
  height: 32px;

  &:hover {
    background-color: var(--bg-color-hover);
  }
`;
var cee = I(Button)`
  border: none;

  & + & {
    margin-left: 0;
  }
`;
var yk = I.div``;
var uee = I(Av)`
  gap: var(--spacing-xs);
  padding: 0 var(--spacing-xs);
`;
var fee = I(Lc)`
  background-color: var(--layer-color);
  border-radius: 4px 4px 0 0;
  padding-left: var(--spacing-xs);
  height: 32px;
`;
var dee = I.div`
  display: flex;
  flex-grow: 1;
  justify-content: center;
  align-items: center;
  height: 100%;
  color: var(--text-color-helper);
  font-size: var(--font-size-base);
  font-weight: var(--font-weight-regular);
  line-height: var(--line-height-base);
`;
var hee = I.span`
  flex-shrink: 0;
`;
var pee = I.span`
  text-overflow: ellipsis;
  white-space: nowrap;
  overflow: hidden;
`;
function gee() {
  var x, v;
  const [t4, e] = fe(""), { history: n, requestError: r, disableCollectionsTab: i } = je(), { sendEvent: o } = gt(), { MobileHeader: s, isMobile: a, setActiveTab: l } = ni(), { updateTransaction: c } = Rh(), u = We(
    () => [...n.get()].sort((y, S) => S.date - y.date),
    [n]
  ), f = We(
    () => u.filter(
      (y) => y.request.url.toLowerCase().includes(t4.toLowerCase()) || y.request.method.toLowerCase().includes(t4.toLowerCase())
    ),
    [u, t4]
  ), d = We(
    () => WK(f, "date"),
    [f]
  ), h = (y) => {
    e(y);
  }, p = Ue(
    (y) => {
      const S = n.get().filter((b) => b.date !== y);
      n.set(An(S)), o("history_item_removed", {});
    },
    [n, o]
  ), O = Ue(() => {
    n.set([]), o("history_all_items_removed", {});
  }, [n, o]), m = Ue(
    (y) => {
      r.set(null), c({ request: y.request, response: y.response }, null), o("history_item_clicked", {}), l("Request");
    },
    [r, c, o, l]
  );
  return (x = n.get()) != null && x.length ? /* @__PURE__ */ g.jsxs(Cv, { children: [
    /* @__PURE__ */ g.jsx(s, {}),
    /* @__PURE__ */ g.jsxs(Xc, { children: [
      /* @__PURE__ */ g.jsx(Lc, { value: t4, onSearch: h }),
      /* @__PURE__ */ g.jsx(Qe, {}),
      /* @__PURE__ */ g.jsx(Fj, { children: /* @__PURE__ */ g.jsx(
        Ba,
        {
          description: "Are you sure to clear your whole history?",
          placement: "bottomRight",
          onConfirm: O,
          children: /* @__PURE__ */ g.jsx(
            Button,
            {
              "data-testid": "clear-history-button",
              disabled: !((v = n.get()) != null && v.length),
              variant: "text",
              size: "small",
              icon: /* @__PURE__ */ g.jsx(CleanIcon, {})
            }
          )
        }
      ) })
    ] }),
    /* @__PURE__ */ g.jsx(_h, { children: Object.entries(d).map((y, S) => {
      const [b, w] = y;
      return /* @__PURE__ */ g.jsx(
        dh,
        {
          title: xk(b),
          defaultExpanded: S === 0,
          children: w.map((C, k) => /* @__PURE__ */ g.jsx(
            mee,
            {
              "data-testid": `history-item-${k}`,
              children: /* @__PURE__ */ g.jsx(
                Qj,
                {
                  showControlsOnHover: !a,
                  onClick: () => m(C),
                  staticLabels: C.response ? /* @__PURE__ */ g.jsx(bee, { children: /* @__PURE__ */ g.jsx(
                    yee,
                    {
                      tabIndex: -1,
                      status: C.response.status.toString(),
                      children: C.response.status
                    }
                  ) }) : null,
                  controls: /* @__PURE__ */ g.jsxs(g.Fragment, { children: [
                    !i.get() && /* @__PURE__ */ g.jsx(Vj, { transaction: C, children: /* @__PURE__ */ g.jsx(Button, { icon: /* @__PURE__ */ g.jsx(BookmarkAddIcon, {}), size: "small" }) }),
                    /* @__PURE__ */ g.jsx(
                      Ba,
                      {
                        description: "Are you sure you to delete this request?",
                        placement: "bottomRight",
                        onConfirm: () => p(C.date),
                        children: /* @__PURE__ */ g.jsx(
                          Nr,
                          {
                            icon: /* @__PURE__ */ g.jsx(TrashCanIcon, {}),
                            size: "small",
                            "data-testid": `remove-history-item-${k}`
                          }
                        )
                      }
                    )
                  ] }),
                  children: /* @__PURE__ */ g.jsxs(Oee, { children: [
                    /* @__PURE__ */ g.jsx(bO, { value: C.request.method }),
                    /* @__PURE__ */ g.jsx(
                      xee,
                      {
                        mouseEnterDelay: 1,
                        placement: "bottom",
                        content: Bh(new Date(C.date)).format(
                          "MMM, DD, YYYY, hh:mm:ss A"
                        ),
                        children: /* @__PURE__ */ g.jsx(vee, { children: C.request.url })
                      }
                    )
                  ] }, C.date)
                }
              )
            },
            C.date
          ))
        },
        xk(b)
      );
    }) })
  ] }) : /* @__PURE__ */ g.jsxs(g.Fragment, { children: [
    /* @__PURE__ */ g.jsx(s, {}),
    /* @__PURE__ */ g.jsxs(Zj, { children: [
      /* @__PURE__ */ g.jsx("h3", { children: "You have not run any requests" }),
      "You'll see the full history of the request."
    ] })
  ] });
}
var mee = I.div`
  height: 32px;

  .accordion-item-content {
    max-width: calc(30vw - 100px);
  }
`;
var Oee = I.div`
  max-width: 100%;
  display: flex;
  flex-direction: row;
  flex-shrink: 0;
  gap: var(--spacing-xxs);
  padding: var(--spacing-sm) 0 var(--spacing-sm) var(--spacing-base);
  cursor: pointer;
  min-width: 0;
`;
var xee = I(Vo)`
  max-width: 100%;
  text-overflow: ellipsis;
  overflow: hidden;
  white-space: nowrap;
`;
var vee = I.div`
  font-size: var(--font-size-base);
  font-weight: var(--font-weight-regular);
  line-height: var(--line-height-base);
  color: var(--text-color-primary);
  max-width: 100%;
  text-overflow: ellipsis;
  overflow: hidden;
  white-space: nowrap;
`;
var yee = I(StatusCode)`
  font-size: var(--font-size-sm);
  line-height: var(--line-height-sm);
  font-weight: var(--font-weight-regular);
`;
var bee = I.span`
  height: var(--line-height-sm);
  background: var(--border-color-secondary);
  padding: 0 var(--spacing-xxs);
  font-size: var(--font-size-sm);
  line-height: var(--line-height-sm);
  border-radius: var(--border-radius);
  color: var(--text-color-secondary);
  display: inline-flex;
  word-break: var(--code-word-break);
  padding: var(--spacing-xs);
  margin-right: var(--spacing-xs);
`;
var See = "This environment is defined in the OpenAPI description and cannot be edited.";
var wee = "This variable is defined in the OpenAPI description and cannot be edited.";
var Cee = "This variable is defined in the OpenAPI description and cannot be deleted.";
var kee = 'Are you sure you want to delete "{name}" along with all its variables?';
function Aee() {
  return /* @__PURE__ */ g.jsx(Pee, { children: /* @__PURE__ */ g.jsx(IBMCloudHyperProtectCryptoServicesIcon, { size: "14px", color: "--color-info-base" }) });
}
var Pee = I.div`
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 10px;
  background-color: var(--color-info-bg);
  width: 20px;
  height: 20px;
`;
function Eee({ variable: t4, environment: e }) {
  const [n, r] = fe(false), [i, o] = fe(false), { sendEvent: s } = gt(), { name: a, value: l, readonlyName: c, isSecret: u, canBeRemoved: f, canBeEdited: d } = t4.get(), { name: h } = e.get(), p = (y) => {
    s("environment_variable_edited", {
      name: h,
      variable: a,
      changed: y.value !== l
    }), t4.set(y), r(false);
  }, O = () => {
    r(false), s("environment_variable_editing_cancelled", {
      name: h,
      variable: a
    });
  }, m = () => {
    s("environment_variable_secret_toggled", {
      name: h,
      variable: a,
      visible: !i
    }), o(!i);
  }, x = () => {
    r(true), s("environment_variable_editing_started", {
      name: h,
      variable: a
    });
  }, v = () => {
    t4.set(pt), s("environment_variable_removed", {
      name: h,
      variable: a
    });
  };
  return n ? /* @__PURE__ */ g.jsx(
    Dee,
    {
      variable: t4.get(),
      onSave: p,
      onCancel: O,
      readonlyName: c
    }
  ) : /* @__PURE__ */ g.jsx(
    Qj,
    {
      dataTestId: `environment-variable-${t4.get().name}`,
      controls: /* @__PURE__ */ g.jsxs(Tee, { children: [
        u && /* @__PURE__ */ g.jsx(
          oa,
          {
            onClick: m,
            variant: "text",
            size: "small",
            icon: i ? /* @__PURE__ */ g.jsx(ViewOffIcon, {}) : /* @__PURE__ */ g.jsx(ViewIcon, {})
          }
        ),
        d && /* @__PURE__ */ g.jsx(
          oa,
          {
            "data-testid": `edit-variable-btn-${t4.get().name}`,
            size: "small",
            variant: "text",
            icon: /* @__PURE__ */ g.jsx(EditIcon, {}),
            onClick: x
          }
        ),
        f && /* @__PURE__ */ g.jsx(
          Ba,
          {
            description: "Are you sure you to delete this environment variable?",
            onConfirm: v,
            children: /* @__PURE__ */ g.jsx(
              Nr,
              {
                "data-testid": `remove-variable-btn-${t4.get().name}`,
                icon: /* @__PURE__ */ g.jsx(TrashCanIcon, {})
              }
            )
          }
        ),
        (!d || !f) && /* @__PURE__ */ g.jsx(Vo, { content: d ? Cee : wee, children: /* @__PURE__ */ g.jsx(oa, { size: "small", variant: "text", icon: /* @__PURE__ */ g.jsx(InformationIcon, {}) }) })
      ] }),
      children: /* @__PURE__ */ g.jsxs(Iee, { children: [
        /* @__PURE__ */ g.jsxs($ee, { children: [
          /* @__PURE__ */ g.jsx(jee, { children: a }),
          u && /* @__PURE__ */ g.jsx(Aee, {})
        ] }),
        /* @__PURE__ */ g.jsx(Ree, { $isEmpty: !l, children: u && !i ? "\u2022\u2022\u2022\u2022\u2022" : Nl(l, e.variables) || "No value" })
      ] })
    }
  );
}
var Tee = I.div`
  display: flex;
  flex-direction: row;
  gap: var(--spacing-xxs);
  padding-right: var(--spacing-base);
`;
var Iee = I.div`
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: flex-start;
  padding-bottom: var(--spacing-xs);
  gap: 2px;
  flex: 1 0 0;
  width: 100%;
`;
var $ee = I.div`
  display: flex;
  align-items: center;
  width: 100%;
  gap: var(--spacing-xxs);
  color: var(--text-color-primary);
  font-size: var(--font-size-base);
  font-weight: var(--font-weight-regular);
  line-height: var(--line-height-base);
  padding-left: var(--spacing-base);
  padding-top: var(--spacing-xs);
`;
var jee = I.div`
  overflow: hidden;
  min-width: 0;
  text-overflow: ellipsis;
  white-space: nowrap;
`;
var Ree = I.span`
  color: ${({ $isEmpty: t4 }) => t4 ? "var(--color-warm-grey-5)" : "var(--text-color-secondary)"};
  font-size: var(--font-size-sm);
  font-weight: var(--font-weight-regular);
  line-height: var(--line-height-sm);
  padding-left: var(--spacing-base);
  word-wrap: break-word;
  max-width: 100%;
  overflow: hidden;
  text-overflow: ellipsis;
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
`;
var Dee = I(jc)`
  padding-left: 39px;
  margin-left: -23px;
`;
function Qee({
  defaultName: t4,
  onChange: e,
  onApplyNewName: n,
  onCancelEditing: r,
  icon: i,
  placeholder: o = "New Folder"
}) {
  const [s, a] = fe(t4), l = (u) => {
    a(u.target.value), e == null || e(u);
  }, c = s.trim();
  return /* @__PURE__ */ g.jsx(Fo, { onClickOutside: r, children: /* @__PURE__ */ g.jsxs(JK, { children: [
    i,
    /* @__PURE__ */ g.jsx(
      us,
      {
        "data-testid": "edit-item-header-input",
        type: "text",
        placeholder: o,
        value: s,
        onChange: l
      }
    ),
    /* @__PURE__ */ g.jsxs(Bee, { children: [
      /* @__PURE__ */ g.jsx(
        Button,
        {
          "data-testid": "edit-item-header-save-button",
          variant: "primary",
          onClick: () => n(c),
          disabled: !c,
          children: /* @__PURE__ */ g.jsx(CheckmarkIcon, {})
        }
      ),
      /* @__PURE__ */ g.jsx(Button, { variant: "text", onClick: r, icon: /* @__PURE__ */ g.jsx(CloseIcon, {}) })
    ] })
  ] }) });
}
var Bee = I.div`
  display: flex;
  gap: var(--spacing-xs);
`;
function _ee({ environment: t4, defaultExpanded: e }) {
  const [n, r] = fe(false), { sendEvent: i } = gt(), { state: o, canBeEdited: s, canBeRemoved: a, name: l } = t4.get(), c = () => {
    t4.set(pt), i("environment_creation_cancelled", {});
  }, u = () => {
    t4.state.set(Er.Normal), i("environment_editing_cancelled", { name: l });
  }, f = () => {
    t4.state.set(Er.Edit), i("environment_editing_started", { name: l });
  }, d = () => {
    t4.set(pt), i("environment_removed", { name: l });
  }, h = (x) => {
    o === Er.Draft ? i("environment_creation_finished", { name: x }) : i("environment_edited", { name: l, newName: x }), t4.state.set(Er.Normal), x.length && t4.name.set(x);
  }, p = () => {
    r(true), i("environment_variable_creation_started", { name: l });
  }, O = (x) => {
    t4.variables.set((v) => [x, ...v]), r(false), i("environment_variable_creation_finished", {
      name: l,
      variable: x.name,
      isSecret: x.isSecret
    });
  }, m = () => {
    r(false), i("environment_variable_creation_cancelled", { name: l });
  };
  return o === Er.Edit || o === Er.Draft ? /* @__PURE__ */ g.jsx(
    Qee,
    {
      placeholder: "New Environment",
      defaultName: l,
      onApplyNewName: h,
      onCancelEditing: o === Er.Draft ? c : u,
      icon: o === Er.Edit ? /* @__PURE__ */ g.jsx(ChevronRightIcon, { size: "14px", color: "--text-color-secondary" }) : /* @__PURE__ */ g.jsx(AddIcon, {})
    }
  ) : /* @__PURE__ */ g.jsx(g.Fragment, { children: /* @__PURE__ */ g.jsxs(
    dh,
    {
      dataTestId: `environment-${l}`,
      title: l,
      defaultExpanded: e,
      controls: /* @__PURE__ */ g.jsxs(Mee, { children: [
        s && /* @__PURE__ */ g.jsx(
          oa,
          {
            size: "small",
            variant: "text",
            icon: /* @__PURE__ */ g.jsx(EditIcon, {}),
            onClick: f,
            "data-testid": `edit-environment-${l}`
          }
        ),
        a && /* @__PURE__ */ g.jsx(
          Ba,
          {
            description: kee.replace("{name}", l),
            onConfirm: d,
            children: /* @__PURE__ */ g.jsx(
              Nr,
              {
                variant: "text",
                icon: /* @__PURE__ */ g.jsx(TrashCanIcon, {}),
                "data-testid": `remove-environment-${l}`
              }
            )
          }
        ),
        (!s || !a) && /* @__PURE__ */ g.jsx(Vo, { content: See, children: /* @__PURE__ */ g.jsx(oa, { size: "small", variant: "text", icon: /* @__PURE__ */ g.jsx(InformationIcon, {}) }) })
      ] }),
      children: [
        n ? /* @__PURE__ */ g.jsx(
          Zee,
          {
            variable: qf(),
            onSave: O,
            onCancel: m,
            isNew: true
          }
        ) : /* @__PURE__ */ g.jsx(
          Fee,
          {
            icon: /* @__PURE__ */ g.jsx(AddIcon, {}),
            variant: "secondary",
            onClick: p,
            iconPosition: "left",
            size: "small",
            children: "New variable"
          }
        ),
        t4.variables.map((x) => /* @__PURE__ */ g.jsx(_r, { children: /* @__PURE__ */ g.jsx(Eee, { variable: x, environment: t4 }) }, x.get().id))
      ]
    }
  ) });
}
var Mee = I.div`
  display: flex;
  flex-direction: row;
  gap: var(--spacing-xxs);
  align-items: center;
`;
var Nee = I(Button)`
  align-self: flex-start;
  margin: 0;
`;
var Fee = I(Nee)`
  margin: 8px 0 8px -7px;
  font-size: var(--font-size-base);
  font-weight: var(--font-weight-regular);
  line-height: var(--line-height-base);
`;
var Zee = I(jc)`
  padding-left: 39px;
  margin-left: -23px;
`;
function Wee() {
  const [t4, e] = fe(""), { environments: n, selectedEnvironmentId: r } = je(), { MobileHeader: i } = ni(), { sendEvent: o } = gt(), s = We(
    () => n.filter((c) => c.name.get().toLowerCase().includes(t4.toLowerCase())),
    [t4, n]
  ), a = () => {
    e(""), n.set((c) => [
      {
        id: crypto.randomUUID(),
        name: "",
        variables: [],
        state: Er.Draft,
        canBeRemoved: true,
        canBeEdited: true
      },
      ...c
    ]), o("environment_creation_started", {});
  }, l = (c) => {
    e(c);
  };
  return /* @__PURE__ */ g.jsxs(Cv, { children: [
    /* @__PURE__ */ g.jsx(i, {}),
    /* @__PURE__ */ g.jsxs(Xc, { children: [
      /* @__PURE__ */ g.jsx(Lc, { value: t4, onSearch: l }),
      /* @__PURE__ */ g.jsx(Qe, {}),
      /* @__PURE__ */ g.jsx(Fj, { children: /* @__PURE__ */ g.jsx(
        Button,
        {
          "data-testid": "add-environment-btn",
          variant: "text",
          disabled: !!n.find(({ state: c }) => c.get() === Er.Draft),
          onClick: a,
          size: "small",
          icon: /* @__PURE__ */ g.jsx(AddIcon, {})
        }
      ) })
    ] }),
    /* @__PURE__ */ g.jsx(_h, { children: s.map((c) => /* @__PURE__ */ g.jsx(
      _ee,
      {
        environment: c,
        defaultExpanded: c.get().id === r.get()
      },
      c.id.get()
    )) })
  ] });
}
function bk({ name: t4, value: e }) {
  const [n, r] = fe(false), { sendEvent: i } = gt(), o = () => {
    i("app_credential_visibility_toggled", { name: t4, visible: !n }), r(!n);
  }, s = () => {
    i("app_credential_copied", { name: t4 });
  };
  return /* @__PURE__ */ g.jsxs(Vee, { children: [
    /* @__PURE__ */ g.jsxs(zee, { children: [
      /* @__PURE__ */ g.jsx(Lee, { children: t4 }),
      /* @__PURE__ */ g.jsx(Xee, { children: n ? e : "\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022" })
    ] }),
    /* @__PURE__ */ g.jsxs(Gee, { children: [
      /* @__PURE__ */ g.jsx(
        Button,
        {
          variant: "text",
          size: "small",
          icon: n ? /* @__PURE__ */ g.jsx(ViewIcon, {}) : /* @__PURE__ */ g.jsx(ViewOffIcon, {}),
          onClick: o
        }
      ),
      /* @__PURE__ */ g.jsx(CopyButton, { toasterPlacement: "left", data: e, onCopyClick: s })
    ] })
  ] });
}
var Vee = I.div`
  display: flex;
  padding: var(--spacing-xs) var(--spacing-xs);
  align-items: flex-start;
  gap: var(--spacing-xs);
  align-self: stretch;
`;
var zee = I.div`
  display: flex;
  align-items: flex-start;
  gap: 10px;
  flex: 1 0 0;
`;
var Lee = I.div`
  display: -webkit-box;
  width: var(--64-px-4-rem-spacing-11, 64px);
  -webkit-box-orient: vertical;
  -webkit-line-clamp: 1;
  overflow: hidden;
  color: var(--text-color-primary);
  text-overflow: ellipsis;

  font-size: var(--font-size-sm);
  font-style: normal;
  font-weight: var(--font-weight-semibold);
  line-height: var(--line-height-sm);
`;
var Xee = I.div`
  flex: 1 0 0;
  color: var(--text-color-primary);
  font-size: var(--font-size-sm);
  font-style: normal;
  font-weight: var(--font-weight-regular);
  line-height: var(--line-height-sm);
`;
var Gee = I.div`
  display: flex;
  justify-content: flex-end;
  align-items: center;
  gap: var(--spacing-xxs);
`;
function Yee({ credential: t4, number: e }) {
  const {
    requestActiveTabIdx: n,
    request: {
      security: { securities: r, selectedSecuritySchemeId: i }
    }
  } = je(), o = hn(), { clientId: s, clientSecret: a, valueToUseInHeader: l } = t4, { sendEvent: c } = gt(), u = () => {
    n.set(oK);
    const d = rl(
      r,
      i.get()
    )[0];
    if (!d.get())
      return;
    const { securityType: h, ...p } = d, O = (m, x) => {
      if (m.get() === ie.AuthorizationCode) {
        const { clientId: v, clientSecret: y } = x[ie.AuthorizationCode];
        (s || a) && bn(s || a || "", v, o), a && bn(a, y, o);
      }
      if (m.get() === ie.Implicit) {
        const { clientId: v } = x[ie.Implicit];
        (s || a) && bn(s || a || "", v, o);
      }
      if (m.get() === ie.ClientCredentials) {
        const { clientId: v, clientSecret: y } = x[ie.ClientCredentials];
        (s || a) && bn(s || a || "", v, o), a && bn(a, y, o);
      }
      if (m.get() === ie.Password) {
        const { clientId: v, clientSecret: y } = x[ie.Password];
        (s || a) && bn(s || a || "", v, o), a && bn(a, y, o);
      }
    };
    if (h.get() === H.BasicAuth) {
      const { username: m, password: x } = p[H.BasicAuth];
      (s || a) && bn(s || a || "", m, o), a && bn(a, x, o);
    }
    if (h.get() === H.DigestAuth) {
      const { username: m, password: x } = p[H.DigestAuth];
      (s || a) && bn(s || a || "", m, o), a && bn(a, x, o);
    }
    if (h.get() === H.JWT) {
      const { token: m } = p[H.JWT];
      (s || a) && bn(s || a || "", m, o);
    }
    if (h.get() === H.APIKey) {
      const { key: m } = p[H.APIKey];
      bn(
        t4[l || "clientSecret"] || s || "",
        m,
        o
      );
    }
    if (h.get() === H.OAuth2) {
      const m = p[H.OAuth2], x = m.grantType;
      O(x, m);
    }
    if (h.get() === H.OpenIDConnect) {
      const m = p[H.OpenIDConnect], { grantType: x } = m;
      O(x, m);
    }
    c("apps_use_key_clicked", { number: e });
  };
  return /* @__PURE__ */ g.jsxs(qee, { children: [
    /* @__PURE__ */ g.jsxs(Uee, { children: [
      /* @__PURE__ */ g.jsx(Jee, { children: e.toString().padStart(2, "0") }),
      /* @__PURE__ */ g.jsxs(Hee, { children: [
        t4.stage && /* @__PURE__ */ g.jsx(Tag, { color: "gray", children: t4.stage }),
        /* @__PURE__ */ g.jsx(Tag, { color: "green", children: t4.status })
      ] })
    ] }),
    s && /* @__PURE__ */ g.jsx(bk, { name: "API key", value: s }),
    a && /* @__PURE__ */ g.jsx(bk, { name: s ? "Secret" : "API key", value: a }),
    /* @__PURE__ */ g.jsx(Kee, { children: /* @__PURE__ */ g.jsx(Button, { size: "small", variant: "secondary", onClick: u, children: "Use key" }) })
  ] });
}
var qee = I.div`
  display: flex;
  flex-direction: column;
  align-self: stretch;
  margin-top: var(--spacing-xs);
  border-radius: var(--border-radius-md);
  border: 1px solid var(--border-color-secondary);
  background: var(--bg-color);
  word-break: break-all;
  text-wrap: wrap;

  & > :not(:last-child) {
    border-bottom: 1px solid var(--border-color-secondary);
  }
`;
var Uee = I.div`
  display: flex;
  justify-content: space-between;
  padding: var(--spacing-xs) var(--spacing-xs);
  border-radius: var(--border-radius-md) var(--border-radius-md) 0 0;
  align-items: center;
  align-self: stretch;
  background: var(--layer-color);
`;
var Hee = I.div`
  display: flex;
  gap: var(--spacing-xxs);
`;
var Jee = I.div`
  color: var(--text-color-secondary, #3b3c45);
  font-size: var(--font-size-sm);
  font-style: normal;
  font-weight: var(--font-weight-regular);
  line-height: var(--line-height-sm);
`;
var Kee = I.div`
  display: flex;
  padding: var(--spacing-xs) var(--spacing-xs);
  border-radius: 0 0 var(--border-radius-md) var(--border-radius-md);
  justify-content: flex-end;
  align-items: center;
  align-self: stretch;
  background: var(--layer-color);
`;
function ete({ app: t4 }) {
  const [e, n] = fe(false), { title: r, credentials: i, id: o } = t4, s = i.get() || [], a = (l) => {
    l && !i.get() && (n(true), as(`/api/api-keys/apps/${o.get()}`).then((c) => c.json().then((u) => {
      c.ok && i.set(u.credentials);
    }).catch(() => console.log("Something went wrong")).finally(() => n(false))));
  };
  return /* @__PURE__ */ g.jsx(dh, { dataTestId: `app-${name}`, title: r.get(), onToggle: a, children: /* @__PURE__ */ g.jsx(tte, { children: e ? /* @__PURE__ */ g.jsx(nte, { children: /* @__PURE__ */ g.jsx(SpinnerIcon, { size: "16px", color: "--icon-color-additional" }) }) : s.length ? s.map((l, c) => /* @__PURE__ */ g.jsx(Yee, { credential: l, number: c + 1 }, l.id)) : /* @__PURE__ */ g.jsx(rte, { children: "There are no credentials yet." }) }) });
}
var tte = I.div`
  padding-bottom: var(--spacing-xxs);
  margin-left: -7px;
  padding-right: var(--spacing-base);
`;
var nte = I.div`
  display: flex;
  height: 224px;
  justify-content: center;
  align-items: center;
`;
var rte = I.div`
  display: flex;
  justify-content: center;
  align-items: center;
  height: 112px;
  font-size: var(--font-size-base);
  line-height: var(--line-height-base);
  color: var(--text-color-secondary);
`;
function ite() {
  const [t4, e] = fe(""), { apps: n, apiId: r, appsLoadingState: i } = je(), { MobileHeader: o } = ni(), { sendEvent: s } = gt(), a = () => {
    window.open("/apps", "_blank"), s("apps_request_access_clicked", {});
  };
  _e(() => ((i.get() === fi.Idle || i.get() === fi.Error) && (i.set(fi.Loading), as(`/api/api-keys/api-products/${r.get()}/access?expand=0`).then((u) => u.json().then((f) => {
    u.ok ? (n.set(f.apps || []), i.set(fi.Success)) : i.set(fi.Error);
  }).catch(() => i.set(fi.Error)))), () => {
    n.set([]), i.set(fi.Idle);
  }), [r]);
  const l = We(
    () => n.filter((u) => u.title.get().toLowerCase().includes(t4.toLowerCase())),
    [t4, n]
  ), c = (u) => {
    e(u);
  };
  return i.get() === fi.Loading ? /* @__PURE__ */ g.jsx(ste, { children: /* @__PURE__ */ g.jsx(SpinnerIcon, { size: "24px", color: "--icon-color-additional" }) }) : n.length ? /* @__PURE__ */ g.jsxs(ote, { children: [
    /* @__PURE__ */ g.jsx(o, {}),
    /* @__PURE__ */ g.jsx(Xc, { children: /* @__PURE__ */ g.jsx(Lc, { value: t4, onSearch: c }) }),
    /* @__PURE__ */ g.jsx(_h, { children: l.map((u) => /* @__PURE__ */ g.jsx(ete, { app: u }, u.get().id)) })
  ] }) : /* @__PURE__ */ g.jsxs(g.Fragment, { children: [
    /* @__PURE__ */ g.jsx(o, {}),
    /* @__PURE__ */ g.jsxs(Zj, { children: [
      "You don't have any apps with access to this API",
      /* @__PURE__ */ g.jsx(Button, { onClick: a, children: "Request access" })
    ] })
  ] });
}
var ote = I.div`
  display: flex;
  flex-direction: column;
  width: 100%;
`;
var ste = I.div`
  display: flex;
  justify-content: center;
  align-items: center;
  width: 100%;
  height: calc(100vh - 50px);
`;
function zj(t4) {
  return typeof t4 > "u" || t4 === null;
}
function ate(t4) {
  return typeof t4 == "object" && t4 !== null;
}
function lte(t4) {
  return Array.isArray(t4) ? t4 : zj(t4) ? [] : [t4];
}
function cte(t4, e) {
  var n, r, i, o;
  if (e)
    for (o = Object.keys(e), n = 0, r = o.length; n < r; n += 1)
      i = o[n], t4[i] = e[i];
  return t4;
}
function ute(t4, e) {
  var n = "", r;
  for (r = 0; r < e; r += 1)
    n += t4;
  return n;
}
function fte(t4) {
  return t4 === 0 && Number.NEGATIVE_INFINITY === 1 / t4;
}
var dte = zj;
var hte = ate;
var pte = lte;
var gte = ute;
var mte = fte;
var Ote = cte;
var fn = {
  isNothing: dte,
  isObject: hte,
  toArray: pte,
  repeat: gte,
  isNegativeZero: mte,
  extend: Ote
};
function Lj(t4, e) {
  var n = "", r = t4.reason || "(unknown reason)";
  return t4.mark ? (t4.mark.name && (n += 'in "' + t4.mark.name + '" '), n += "(" + (t4.mark.line + 1) + ":" + (t4.mark.column + 1) + ")", !e && t4.mark.snippet && (n += `

` + t4.mark.snippet), r + " " + n) : r;
}
function Sc(t4, e) {
  Error.call(this), this.name = "YAMLException", this.reason = t4, this.mark = e, this.message = Lj(this, false), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack || "";
}
Sc.prototype = Object.create(Error.prototype);
Sc.prototype.constructor = Sc;
Sc.prototype.toString = function(e) {
  return this.name + ": " + Lj(this, e);
};
var Xn = Sc;
function G0(t4, e, n, r, i) {
  var o = "", s = "", a = Math.floor(i / 2) - 1;
  return r - e > a && (o = " ... ", e = r - a + o.length), n - r > a && (s = " ...", n = r + a - s.length), {
    str: o + t4.slice(e, n).replace(/\t/g, "\u2192") + s,
    pos: r - e + o.length
    // relative position
  };
}
function Y0(t4, e) {
  return fn.repeat(" ", e - t4.length) + t4;
}
function xte(t4, e) {
  if (e = Object.create(e || null), !t4.buffer)
    return null;
  e.maxLength || (e.maxLength = 79), typeof e.indent != "number" && (e.indent = 1), typeof e.linesBefore != "number" && (e.linesBefore = 3), typeof e.linesAfter != "number" && (e.linesAfter = 2);
  for (var n = /\r?\n|\r|\0/g, r = [0], i = [], o, s = -1; o = n.exec(t4.buffer); )
    i.push(o.index), r.push(o.index + o[0].length), t4.position <= o.index && s < 0 && (s = r.length - 2);
  s < 0 && (s = r.length - 1);
  var a = "", l, c, u = Math.min(t4.line + e.linesAfter, i.length).toString().length, f = e.maxLength - (e.indent + u + 3);
  for (l = 1; l <= e.linesBefore && !(s - l < 0); l++)
    c = G0(
      t4.buffer,
      r[s - l],
      i[s - l],
      t4.position - (r[s] - r[s - l]),
      f
    ), a = fn.repeat(" ", e.indent) + Y0((t4.line - l + 1).toString(), u) + " | " + c.str + `
` + a;
  for (c = G0(t4.buffer, r[s], i[s], t4.position, f), a += fn.repeat(" ", e.indent) + Y0((t4.line + 1).toString(), u) + " | " + c.str + `
`, a += fn.repeat("-", e.indent + u + 3 + c.pos) + `^
`, l = 1; l <= e.linesAfter && !(s + l >= i.length); l++)
    c = G0(
      t4.buffer,
      r[s + l],
      i[s + l],
      t4.position - (r[s] - r[s + l]),
      f
    ), a += fn.repeat(" ", e.indent) + Y0((t4.line + l + 1).toString(), u) + " | " + c.str + `
`;
  return a.replace(/\n$/, "");
}
var vte = xte;
var yte = [
  "kind",
  "multi",
  "resolve",
  "construct",
  "instanceOf",
  "predicate",
  "represent",
  "representName",
  "defaultStyle",
  "styleAliases"
];
var bte = [
  "scalar",
  "sequence",
  "mapping"
];
function Ste(t4) {
  var e = {};
  return t4 !== null && Object.keys(t4).forEach(function(n) {
    t4[n].forEach(function(r) {
      e[String(r)] = n;
    });
  }), e;
}
function wte(t4, e) {
  if (e = e || {}, Object.keys(e).forEach(function(n) {
    if (yte.indexOf(n) === -1)
      throw new Xn('Unknown option "' + n + '" is met in definition of "' + t4 + '" YAML type.');
  }), this.options = e, this.tag = t4, this.kind = e.kind || null, this.resolve = e.resolve || function() {
    return true;
  }, this.construct = e.construct || function(n) {
    return n;
  }, this.instanceOf = e.instanceOf || null, this.predicate = e.predicate || null, this.represent = e.represent || null, this.representName = e.representName || null, this.defaultStyle = e.defaultStyle || null, this.multi = e.multi || false, this.styleAliases = Ste(e.styleAliases || null), bte.indexOf(this.kind) === -1)
    throw new Xn('Unknown kind "' + this.kind + '" is specified for "' + t4 + '" YAML type.');
}
var jn = wte;
function Sk(t4, e) {
  var n = [];
  return t4[e].forEach(function(r) {
    var i = n.length;
    n.forEach(function(o, s) {
      o.tag === r.tag && o.kind === r.kind && o.multi === r.multi && (i = s);
    }), n[i] = r;
  }), n;
}
function Cte() {
  var t4 = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {},
    multi: {
      scalar: [],
      sequence: [],
      mapping: [],
      fallback: []
    }
  }, e, n;
  function r(i) {
    i.multi ? (t4.multi[i.kind].push(i), t4.multi.fallback.push(i)) : t4[i.kind][i.tag] = t4.fallback[i.tag] = i;
  }
  for (e = 0, n = arguments.length; e < n; e += 1)
    arguments[e].forEach(r);
  return t4;
}
function SO(t4) {
  return this.extend(t4);
}
SO.prototype.extend = function(e) {
  var n = [], r = [];
  if (e instanceof jn)
    r.push(e);
  else if (Array.isArray(e))
    r = r.concat(e);
  else if (e && (Array.isArray(e.implicit) || Array.isArray(e.explicit)))
    e.implicit && (n = n.concat(e.implicit)), e.explicit && (r = r.concat(e.explicit));
  else
    throw new Xn("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
  n.forEach(function(o) {
    if (!(o instanceof jn))
      throw new Xn("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    if (o.loadKind && o.loadKind !== "scalar")
      throw new Xn("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
    if (o.multi)
      throw new Xn("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
  }), r.forEach(function(o) {
    if (!(o instanceof jn))
      throw new Xn("Specified list of YAML types (or a single Type object) contains a non-Type object.");
  });
  var i = Object.create(SO.prototype);
  return i.implicit = (this.implicit || []).concat(n), i.explicit = (this.explicit || []).concat(r), i.compiledImplicit = Sk(i, "implicit"), i.compiledExplicit = Sk(i, "explicit"), i.compiledTypeMap = Cte(i.compiledImplicit, i.compiledExplicit), i;
};
var Xj = SO;
var Gj = new jn("tag:yaml.org,2002:str", {
  kind: "scalar",
  construct: function(t4) {
    return t4 !== null ? t4 : "";
  }
});
var Yj = new jn("tag:yaml.org,2002:seq", {
  kind: "sequence",
  construct: function(t4) {
    return t4 !== null ? t4 : [];
  }
});
var qj = new jn("tag:yaml.org,2002:map", {
  kind: "mapping",
  construct: function(t4) {
    return t4 !== null ? t4 : {};
  }
});
var Uj = new Xj({
  explicit: [
    Gj,
    Yj,
    qj
  ]
});
function kte(t4) {
  if (t4 === null)
    return true;
  var e = t4.length;
  return e === 1 && t4 === "~" || e === 4 && (t4 === "null" || t4 === "Null" || t4 === "NULL");
}
function Ate() {
  return null;
}
function Pte(t4) {
  return t4 === null;
}
var Hj = new jn("tag:yaml.org,2002:null", {
  kind: "scalar",
  resolve: kte,
  construct: Ate,
  predicate: Pte,
  represent: {
    canonical: function() {
      return "~";
    },
    lowercase: function() {
      return "null";
    },
    uppercase: function() {
      return "NULL";
    },
    camelcase: function() {
      return "Null";
    },
    empty: function() {
      return "";
    }
  },
  defaultStyle: "lowercase"
});
function Ete(t4) {
  if (t4 === null)
    return false;
  var e = t4.length;
  return e === 4 && (t4 === "true" || t4 === "True" || t4 === "TRUE") || e === 5 && (t4 === "false" || t4 === "False" || t4 === "FALSE");
}
function Tte(t4) {
  return t4 === "true" || t4 === "True" || t4 === "TRUE";
}
function Ite(t4) {
  return Object.prototype.toString.call(t4) === "[object Boolean]";
}
var Jj = new jn("tag:yaml.org,2002:bool", {
  kind: "scalar",
  resolve: Ete,
  construct: Tte,
  predicate: Ite,
  represent: {
    lowercase: function(t4) {
      return t4 ? "true" : "false";
    },
    uppercase: function(t4) {
      return t4 ? "TRUE" : "FALSE";
    },
    camelcase: function(t4) {
      return t4 ? "True" : "False";
    }
  },
  defaultStyle: "lowercase"
});
function $te(t4) {
  return 48 <= t4 && t4 <= 57 || 65 <= t4 && t4 <= 70 || 97 <= t4 && t4 <= 102;
}
function jte(t4) {
  return 48 <= t4 && t4 <= 55;
}
function Rte(t4) {
  return 48 <= t4 && t4 <= 57;
}
function Dte(t4) {
  if (t4 === null)
    return false;
  var e = t4.length, n = 0, r = false, i;
  if (!e)
    return false;
  if (i = t4[n], (i === "-" || i === "+") && (i = t4[++n]), i === "0") {
    if (n + 1 === e)
      return true;
    if (i = t4[++n], i === "b") {
      for (n++; n < e; n++)
        if (i = t4[n], i !== "_") {
          if (i !== "0" && i !== "1")
            return false;
          r = true;
        }
      return r && i !== "_";
    }
    if (i === "x") {
      for (n++; n < e; n++)
        if (i = t4[n], i !== "_") {
          if (!$te(t4.charCodeAt(n)))
            return false;
          r = true;
        }
      return r && i !== "_";
    }
    if (i === "o") {
      for (n++; n < e; n++)
        if (i = t4[n], i !== "_") {
          if (!jte(t4.charCodeAt(n)))
            return false;
          r = true;
        }
      return r && i !== "_";
    }
  }
  if (i === "_")
    return false;
  for (; n < e; n++)
    if (i = t4[n], i !== "_") {
      if (!Rte(t4.charCodeAt(n)))
        return false;
      r = true;
    }
  return !(!r || i === "_");
}
function Qte(t4) {
  var e = t4, n = 1, r;
  if (e.indexOf("_") !== -1 && (e = e.replace(/_/g, "")), r = e[0], (r === "-" || r === "+") && (r === "-" && (n = -1), e = e.slice(1), r = e[0]), e === "0")
    return 0;
  if (r === "0") {
    if (e[1] === "b")
      return n * parseInt(e.slice(2), 2);
    if (e[1] === "x")
      return n * parseInt(e.slice(2), 16);
    if (e[1] === "o")
      return n * parseInt(e.slice(2), 8);
  }
  return n * parseInt(e, 10);
}
function Bte(t4) {
  return Object.prototype.toString.call(t4) === "[object Number]" && t4 % 1 === 0 && !fn.isNegativeZero(t4);
}
var Kj = new jn("tag:yaml.org,2002:int", {
  kind: "scalar",
  resolve: Dte,
  construct: Qte,
  predicate: Bte,
  represent: {
    binary: function(t4) {
      return t4 >= 0 ? "0b" + t4.toString(2) : "-0b" + t4.toString(2).slice(1);
    },
    octal: function(t4) {
      return t4 >= 0 ? "0o" + t4.toString(8) : "-0o" + t4.toString(8).slice(1);
    },
    decimal: function(t4) {
      return t4.toString(10);
    },
    /* eslint-disable max-len */
    hexadecimal: function(t4) {
      return t4 >= 0 ? "0x" + t4.toString(16).toUpperCase() : "-0x" + t4.toString(16).toUpperCase().slice(1);
    }
  },
  defaultStyle: "decimal",
  styleAliases: {
    binary: [2, "bin"],
    octal: [8, "oct"],
    decimal: [10, "dec"],
    hexadecimal: [16, "hex"]
  }
});
var _te = new RegExp(
  // 2.5e4, 2.5 and integers
  "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
);
function Mte(t4) {
  return !(t4 === null || !_te.test(t4) || // Quick hack to not allow integers end with `_`
  // Probably should update regexp & check speed
  t4[t4.length - 1] === "_");
}
function Nte(t4) {
  var e, n;
  return e = t4.replace(/_/g, "").toLowerCase(), n = e[0] === "-" ? -1 : 1, "+-".indexOf(e[0]) >= 0 && (e = e.slice(1)), e === ".inf" ? n === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY : e === ".nan" ? NaN : n * parseFloat(e, 10);
}
var Fte = /^[-+]?[0-9]+e/;
function Zte(t4, e) {
  var n;
  if (isNaN(t4))
    switch (e) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  else if (Number.POSITIVE_INFINITY === t4)
    switch (e) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  else if (Number.NEGATIVE_INFINITY === t4)
    switch (e) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  else if (fn.isNegativeZero(t4))
    return "-0.0";
  return n = t4.toString(10), Fte.test(n) ? n.replace("e", ".e") : n;
}
function Wte(t4) {
  return Object.prototype.toString.call(t4) === "[object Number]" && (t4 % 1 !== 0 || fn.isNegativeZero(t4));
}
var e5 = new jn("tag:yaml.org,2002:float", {
  kind: "scalar",
  resolve: Mte,
  construct: Nte,
  predicate: Wte,
  represent: Zte,
  defaultStyle: "lowercase"
});
var t5 = Uj.extend({
  implicit: [
    Hj,
    Jj,
    Kj,
    e5
  ]
});
var n5 = t5;
var r5 = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
);
var i5 = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
);
function Vte(t4) {
  return t4 === null ? false : r5.exec(t4) !== null || i5.exec(t4) !== null;
}
function zte(t4) {
  var e, n, r, i, o, s, a, l = 0, c = null, u, f, d;
  if (e = r5.exec(t4), e === null && (e = i5.exec(t4)), e === null)
    throw new Error("Date resolve error");
  if (n = +e[1], r = +e[2] - 1, i = +e[3], !e[4])
    return new Date(Date.UTC(n, r, i));
  if (o = +e[4], s = +e[5], a = +e[6], e[7]) {
    for (l = e[7].slice(0, 3); l.length < 3; )
      l += "0";
    l = +l;
  }
  return e[9] && (u = +e[10], f = +(e[11] || 0), c = (u * 60 + f) * 6e4, e[9] === "-" && (c = -c)), d = new Date(Date.UTC(n, r, i, o, s, a, l)), c && d.setTime(d.getTime() - c), d;
}
function Lte(t4) {
  return t4.toISOString();
}
var o5 = new jn("tag:yaml.org,2002:timestamp", {
  kind: "scalar",
  resolve: Vte,
  construct: zte,
  instanceOf: Date,
  represent: Lte
});
function Xte(t4) {
  return t4 === "<<" || t4 === null;
}
var s5 = new jn("tag:yaml.org,2002:merge", {
  kind: "scalar",
  resolve: Xte
});
var Pv = `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=
\r`;
function Gte(t4) {
  if (t4 === null)
    return false;
  var e, n, r = 0, i = t4.length, o = Pv;
  for (n = 0; n < i; n++)
    if (e = o.indexOf(t4.charAt(n)), !(e > 64)) {
      if (e < 0)
        return false;
      r += 6;
    }
  return r % 8 === 0;
}
function Yte(t4) {
  var e, n, r = t4.replace(/[\r\n=]/g, ""), i = r.length, o = Pv, s = 0, a = [];
  for (e = 0; e < i; e++)
    e % 4 === 0 && e && (a.push(s >> 16 & 255), a.push(s >> 8 & 255), a.push(s & 255)), s = s << 6 | o.indexOf(r.charAt(e));
  return n = i % 4 * 6, n === 0 ? (a.push(s >> 16 & 255), a.push(s >> 8 & 255), a.push(s & 255)) : n === 18 ? (a.push(s >> 10 & 255), a.push(s >> 2 & 255)) : n === 12 && a.push(s >> 4 & 255), new Uint8Array(a);
}
function qte(t4) {
  var e = "", n = 0, r, i, o = t4.length, s = Pv;
  for (r = 0; r < o; r++)
    r % 3 === 0 && r && (e += s[n >> 18 & 63], e += s[n >> 12 & 63], e += s[n >> 6 & 63], e += s[n & 63]), n = (n << 8) + t4[r];
  return i = o % 3, i === 0 ? (e += s[n >> 18 & 63], e += s[n >> 12 & 63], e += s[n >> 6 & 63], e += s[n & 63]) : i === 2 ? (e += s[n >> 10 & 63], e += s[n >> 4 & 63], e += s[n << 2 & 63], e += s[64]) : i === 1 && (e += s[n >> 2 & 63], e += s[n << 4 & 63], e += s[64], e += s[64]), e;
}
function Ute(t4) {
  return Object.prototype.toString.call(t4) === "[object Uint8Array]";
}
var a5 = new jn("tag:yaml.org,2002:binary", {
  kind: "scalar",
  resolve: Gte,
  construct: Yte,
  predicate: Ute,
  represent: qte
});
var Hte = Object.prototype.hasOwnProperty;
var Jte = Object.prototype.toString;
function Kte(t4) {
  if (t4 === null)
    return true;
  var e = [], n, r, i, o, s, a = t4;
  for (n = 0, r = a.length; n < r; n += 1) {
    if (i = a[n], s = false, Jte.call(i) !== "[object Object]")
      return false;
    for (o in i)
      if (Hte.call(i, o))
        if (!s)
          s = true;
        else
          return false;
    if (!s)
      return false;
    if (e.indexOf(o) === -1)
      e.push(o);
    else
      return false;
  }
  return true;
}
function ene(t4) {
  return t4 !== null ? t4 : [];
}
var l5 = new jn("tag:yaml.org,2002:omap", {
  kind: "sequence",
  resolve: Kte,
  construct: ene
});
var tne = Object.prototype.toString;
function nne(t4) {
  if (t4 === null)
    return true;
  var e, n, r, i, o, s = t4;
  for (o = new Array(s.length), e = 0, n = s.length; e < n; e += 1) {
    if (r = s[e], tne.call(r) !== "[object Object]" || (i = Object.keys(r), i.length !== 1))
      return false;
    o[e] = [i[0], r[i[0]]];
  }
  return true;
}
function rne(t4) {
  if (t4 === null)
    return [];
  var e, n, r, i, o, s = t4;
  for (o = new Array(s.length), e = 0, n = s.length; e < n; e += 1)
    r = s[e], i = Object.keys(r), o[e] = [i[0], r[i[0]]];
  return o;
}
var c5 = new jn("tag:yaml.org,2002:pairs", {
  kind: "sequence",
  resolve: nne,
  construct: rne
});
var ine = Object.prototype.hasOwnProperty;
function one(t4) {
  if (t4 === null)
    return true;
  var e, n = t4;
  for (e in n)
    if (ine.call(n, e) && n[e] !== null)
      return false;
  return true;
}
function sne(t4) {
  return t4 !== null ? t4 : {};
}
var u5 = new jn("tag:yaml.org,2002:set", {
  kind: "mapping",
  resolve: one,
  construct: sne
});
var Ev = n5.extend({
  implicit: [
    o5,
    s5
  ],
  explicit: [
    a5,
    l5,
    c5,
    u5
  ]
});
var _o = Object.prototype.hasOwnProperty;
var Nd = 1;
var f5 = 2;
var d5 = 3;
var Fd = 4;
var q0 = 1;
var ane = 2;
var wk = 3;
var lne = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var cne = /[\x85\u2028\u2029]/;
var une = /[,\[\]\{\}]/;
var h5 = /^(?:!|!!|![a-z\-]+!)$/i;
var p5 = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function Ck(t4) {
  return Object.prototype.toString.call(t4);
}
function Pi(t4) {
  return t4 === 10 || t4 === 13;
}
function cs(t4) {
  return t4 === 9 || t4 === 32;
}
function or(t4) {
  return t4 === 9 || t4 === 32 || t4 === 10 || t4 === 13;
}
function ea(t4) {
  return t4 === 44 || t4 === 91 || t4 === 93 || t4 === 123 || t4 === 125;
}
function fne(t4) {
  var e;
  return 48 <= t4 && t4 <= 57 ? t4 - 48 : (e = t4 | 32, 97 <= e && e <= 102 ? e - 97 + 10 : -1);
}
function dne(t4) {
  return t4 === 120 ? 2 : t4 === 117 ? 4 : t4 === 85 ? 8 : 0;
}
function hne(t4) {
  return 48 <= t4 && t4 <= 57 ? t4 - 48 : -1;
}
function kk(t4) {
  return t4 === 48 ? "\0" : t4 === 97 ? "\x07" : t4 === 98 ? "\b" : t4 === 116 || t4 === 9 ? "	" : t4 === 110 ? `
` : t4 === 118 ? "\v" : t4 === 102 ? "\f" : t4 === 114 ? "\r" : t4 === 101 ? "\x1B" : t4 === 32 ? " " : t4 === 34 ? '"' : t4 === 47 ? "/" : t4 === 92 ? "\\" : t4 === 78 ? "\x85" : t4 === 95 ? "\xA0" : t4 === 76 ? "\u2028" : t4 === 80 ? "\u2029" : "";
}
function pne(t4) {
  return t4 <= 65535 ? String.fromCharCode(t4) : String.fromCharCode(
    (t4 - 65536 >> 10) + 55296,
    (t4 - 65536 & 1023) + 56320
  );
}
var g5 = new Array(256);
var m5 = new Array(256);
for (Zs = 0; Zs < 256; Zs++)
  g5[Zs] = kk(Zs) ? 1 : 0, m5[Zs] = kk(Zs);
var Zs;
function gne(t4, e) {
  this.input = t4, this.filename = e.filename || null, this.schema = e.schema || Ev, this.onWarning = e.onWarning || null, this.legacy = e.legacy || false, this.json = e.json || false, this.listener = e.listener || null, this.implicitTypes = this.schema.compiledImplicit, this.typeMap = this.schema.compiledTypeMap, this.length = t4.length, this.position = 0, this.line = 0, this.lineStart = 0, this.lineIndent = 0, this.firstTabInLine = -1, this.documents = [];
}
function O5(t4, e) {
  var n = {
    name: t4.filename,
    buffer: t4.input.slice(0, -1),
    // omit trailing \0
    position: t4.position,
    line: t4.line,
    column: t4.position - t4.lineStart
  };
  return n.snippet = vte(n), new Xn(e, n);
}
function ke(t4, e) {
  throw O5(t4, e);
}
function Zd(t4, e) {
  t4.onWarning && t4.onWarning.call(null, O5(t4, e));
}
var Ak = {
  YAML: function(e, n, r) {
    var i, o, s;
    e.version !== null && ke(e, "duplication of %YAML directive"), r.length !== 1 && ke(e, "YAML directive accepts exactly one argument"), i = /^([0-9]+)\.([0-9]+)$/.exec(r[0]), i === null && ke(e, "ill-formed argument of the YAML directive"), o = parseInt(i[1], 10), s = parseInt(i[2], 10), o !== 1 && ke(e, "unacceptable YAML version of the document"), e.version = r[0], e.checkLineBreaks = s < 2, s !== 1 && s !== 2 && Zd(e, "unsupported YAML version of the document");
  },
  TAG: function(e, n, r) {
    var i, o;
    r.length !== 2 && ke(e, "TAG directive accepts exactly two arguments"), i = r[0], o = r[1], h5.test(i) || ke(e, "ill-formed tag handle (first argument) of the TAG directive"), _o.call(e.tagMap, i) && ke(e, 'there is a previously declared suffix for "' + i + '" tag handle'), p5.test(o) || ke(e, "ill-formed tag prefix (second argument) of the TAG directive");
    try {
      o = decodeURIComponent(o);
    } catch {
      ke(e, "tag prefix is malformed: " + o);
    }
    e.tagMap[i] = o;
  }
};
function Po(t4, e, n, r) {
  var i, o, s, a;
  if (e < n) {
    if (a = t4.input.slice(e, n), r)
      for (i = 0, o = a.length; i < o; i += 1)
        s = a.charCodeAt(i), s === 9 || 32 <= s && s <= 1114111 || ke(t4, "expected valid JSON character");
    else
      lne.test(a) && ke(t4, "the stream contains non-printable characters");
    t4.result += a;
  }
}
function Pk(t4, e, n, r) {
  var i, o, s, a;
  for (fn.isObject(n) || ke(t4, "cannot merge mappings; the provided source object is unacceptable"), i = Object.keys(n), s = 0, a = i.length; s < a; s += 1)
    o = i[s], _o.call(e, o) || (e[o] = n[o], r[o] = true);
}
function ta(t4, e, n, r, i, o, s, a, l) {
  var c, u;
  if (Array.isArray(i))
    for (i = Array.prototype.slice.call(i), c = 0, u = i.length; c < u; c += 1)
      Array.isArray(i[c]) && ke(t4, "nested arrays are not supported inside keys"), typeof i == "object" && Ck(i[c]) === "[object Object]" && (i[c] = "[object Object]");
  if (typeof i == "object" && Ck(i) === "[object Object]" && (i = "[object Object]"), i = String(i), e === null && (e = {}), r === "tag:yaml.org,2002:merge")
    if (Array.isArray(o))
      for (c = 0, u = o.length; c < u; c += 1)
        Pk(t4, e, o[c], n);
    else
      Pk(t4, e, o, n);
  else
    !t4.json && !_o.call(n, i) && _o.call(e, i) && (t4.line = s || t4.line, t4.lineStart = a || t4.lineStart, t4.position = l || t4.position, ke(t4, "duplicated mapping key")), i === "__proto__" ? Object.defineProperty(e, i, {
      configurable: true,
      enumerable: true,
      writable: true,
      value: o
    }) : e[i] = o, delete n[i];
  return e;
}
function Tv(t4) {
  var e;
  e = t4.input.charCodeAt(t4.position), e === 10 ? t4.position++ : e === 13 ? (t4.position++, t4.input.charCodeAt(t4.position) === 10 && t4.position++) : ke(t4, "a line break is expected"), t4.line += 1, t4.lineStart = t4.position, t4.firstTabInLine = -1;
}
function en(t4, e, n) {
  for (var r = 0, i = t4.input.charCodeAt(t4.position); i !== 0; ) {
    for (; cs(i); )
      i === 9 && t4.firstTabInLine === -1 && (t4.firstTabInLine = t4.position), i = t4.input.charCodeAt(++t4.position);
    if (e && i === 35)
      do
        i = t4.input.charCodeAt(++t4.position);
      while (i !== 10 && i !== 13 && i !== 0);
    if (Pi(i))
      for (Tv(t4), i = t4.input.charCodeAt(t4.position), r++, t4.lineIndent = 0; i === 32; )
        t4.lineIndent++, i = t4.input.charCodeAt(++t4.position);
    else
      break;
  }
  return n !== -1 && r !== 0 && t4.lineIndent < n && Zd(t4, "deficient indentation"), r;
}
function Mh(t4) {
  var e = t4.position, n;
  return n = t4.input.charCodeAt(e), !!((n === 45 || n === 46) && n === t4.input.charCodeAt(e + 1) && n === t4.input.charCodeAt(e + 2) && (e += 3, n = t4.input.charCodeAt(e), n === 0 || or(n)));
}
function Iv(t4, e) {
  e === 1 ? t4.result += " " : e > 1 && (t4.result += fn.repeat(`
`, e - 1));
}
function mne(t4, e, n) {
  var r, i, o, s, a, l, c, u, f = t4.kind, d = t4.result, h;
  if (h = t4.input.charCodeAt(t4.position), or(h) || ea(h) || h === 35 || h === 38 || h === 42 || h === 33 || h === 124 || h === 62 || h === 39 || h === 34 || h === 37 || h === 64 || h === 96 || (h === 63 || h === 45) && (i = t4.input.charCodeAt(t4.position + 1), or(i) || n && ea(i)))
    return false;
  for (t4.kind = "scalar", t4.result = "", o = s = t4.position, a = false; h !== 0; ) {
    if (h === 58) {
      if (i = t4.input.charCodeAt(t4.position + 1), or(i) || n && ea(i))
        break;
    } else if (h === 35) {
      if (r = t4.input.charCodeAt(t4.position - 1), or(r))
        break;
    } else {
      if (t4.position === t4.lineStart && Mh(t4) || n && ea(h))
        break;
      if (Pi(h))
        if (l = t4.line, c = t4.lineStart, u = t4.lineIndent, en(t4, false, -1), t4.lineIndent >= e) {
          a = true, h = t4.input.charCodeAt(t4.position);
          continue;
        } else {
          t4.position = s, t4.line = l, t4.lineStart = c, t4.lineIndent = u;
          break;
        }
    }
    a && (Po(t4, o, s, false), Iv(t4, t4.line - l), o = s = t4.position, a = false), cs(h) || (s = t4.position + 1), h = t4.input.charCodeAt(++t4.position);
  }
  return Po(t4, o, s, false), t4.result ? true : (t4.kind = f, t4.result = d, false);
}
function One(t4, e) {
  var n, r, i;
  if (n = t4.input.charCodeAt(t4.position), n !== 39)
    return false;
  for (t4.kind = "scalar", t4.result = "", t4.position++, r = i = t4.position; (n = t4.input.charCodeAt(t4.position)) !== 0; )
    if (n === 39)
      if (Po(t4, r, t4.position, true), n = t4.input.charCodeAt(++t4.position), n === 39)
        r = t4.position, t4.position++, i = t4.position;
      else
        return true;
    else
      Pi(n) ? (Po(t4, r, i, true), Iv(t4, en(t4, false, e)), r = i = t4.position) : t4.position === t4.lineStart && Mh(t4) ? ke(t4, "unexpected end of the document within a single quoted scalar") : (t4.position++, i = t4.position);
  ke(t4, "unexpected end of the stream within a single quoted scalar");
}
function xne(t4, e) {
  var n, r, i, o, s, a;
  if (a = t4.input.charCodeAt(t4.position), a !== 34)
    return false;
  for (t4.kind = "scalar", t4.result = "", t4.position++, n = r = t4.position; (a = t4.input.charCodeAt(t4.position)) !== 0; ) {
    if (a === 34)
      return Po(t4, n, t4.position, true), t4.position++, true;
    if (a === 92) {
      if (Po(t4, n, t4.position, true), a = t4.input.charCodeAt(++t4.position), Pi(a))
        en(t4, false, e);
      else if (a < 256 && g5[a])
        t4.result += m5[a], t4.position++;
      else if ((s = dne(a)) > 0) {
        for (i = s, o = 0; i > 0; i--)
          a = t4.input.charCodeAt(++t4.position), (s = fne(a)) >= 0 ? o = (o << 4) + s : ke(t4, "expected hexadecimal character");
        t4.result += pne(o), t4.position++;
      } else
        ke(t4, "unknown escape sequence");
      n = r = t4.position;
    } else
      Pi(a) ? (Po(t4, n, r, true), Iv(t4, en(t4, false, e)), n = r = t4.position) : t4.position === t4.lineStart && Mh(t4) ? ke(t4, "unexpected end of the document within a double quoted scalar") : (t4.position++, r = t4.position);
  }
  ke(t4, "unexpected end of the stream within a double quoted scalar");
}
function vne(t4, e) {
  var n = true, r, i, o, s = t4.tag, a, l = t4.anchor, c, u, f, d, h, p = /* @__PURE__ */ Object.create(null), O, m, x, v;
  if (v = t4.input.charCodeAt(t4.position), v === 91)
    u = 93, h = false, a = [];
  else if (v === 123)
    u = 125, h = true, a = {};
  else
    return false;
  for (t4.anchor !== null && (t4.anchorMap[t4.anchor] = a), v = t4.input.charCodeAt(++t4.position); v !== 0; ) {
    if (en(t4, true, e), v = t4.input.charCodeAt(t4.position), v === u)
      return t4.position++, t4.tag = s, t4.anchor = l, t4.kind = h ? "mapping" : "sequence", t4.result = a, true;
    n ? v === 44 && ke(t4, "expected the node content, but found ','") : ke(t4, "missed comma between flow collection entries"), m = O = x = null, f = d = false, v === 63 && (c = t4.input.charCodeAt(t4.position + 1), or(c) && (f = d = true, t4.position++, en(t4, true, e))), r = t4.line, i = t4.lineStart, o = t4.position, Ma(t4, e, Nd, false, true), m = t4.tag, O = t4.result, en(t4, true, e), v = t4.input.charCodeAt(t4.position), (d || t4.line === r) && v === 58 && (f = true, v = t4.input.charCodeAt(++t4.position), en(t4, true, e), Ma(t4, e, Nd, false, true), x = t4.result), h ? ta(t4, a, p, m, O, x, r, i, o) : f ? a.push(ta(t4, null, p, m, O, x, r, i, o)) : a.push(O), en(t4, true, e), v = t4.input.charCodeAt(t4.position), v === 44 ? (n = true, v = t4.input.charCodeAt(++t4.position)) : n = false;
  }
  ke(t4, "unexpected end of the stream within a flow collection");
}
function yne(t4, e) {
  var n, r, i = q0, o = false, s = false, a = e, l = 0, c = false, u, f;
  if (f = t4.input.charCodeAt(t4.position), f === 124)
    r = false;
  else if (f === 62)
    r = true;
  else
    return false;
  for (t4.kind = "scalar", t4.result = ""; f !== 0; )
    if (f = t4.input.charCodeAt(++t4.position), f === 43 || f === 45)
      q0 === i ? i = f === 43 ? wk : ane : ke(t4, "repeat of a chomping mode identifier");
    else if ((u = hne(f)) >= 0)
      u === 0 ? ke(t4, "bad explicit indentation width of a block scalar; it cannot be less than one") : s ? ke(t4, "repeat of an indentation width identifier") : (a = e + u - 1, s = true);
    else
      break;
  if (cs(f)) {
    do
      f = t4.input.charCodeAt(++t4.position);
    while (cs(f));
    if (f === 35)
      do
        f = t4.input.charCodeAt(++t4.position);
      while (!Pi(f) && f !== 0);
  }
  for (; f !== 0; ) {
    for (Tv(t4), t4.lineIndent = 0, f = t4.input.charCodeAt(t4.position); (!s || t4.lineIndent < a) && f === 32; )
      t4.lineIndent++, f = t4.input.charCodeAt(++t4.position);
    if (!s && t4.lineIndent > a && (a = t4.lineIndent), Pi(f)) {
      l++;
      continue;
    }
    if (t4.lineIndent < a) {
      i === wk ? t4.result += fn.repeat(`
`, o ? 1 + l : l) : i === q0 && o && (t4.result += `
`);
      break;
    }
    for (r ? cs(f) ? (c = true, t4.result += fn.repeat(`
`, o ? 1 + l : l)) : c ? (c = false, t4.result += fn.repeat(`
`, l + 1)) : l === 0 ? o && (t4.result += " ") : t4.result += fn.repeat(`
`, l) : t4.result += fn.repeat(`
`, o ? 1 + l : l), o = true, s = true, l = 0, n = t4.position; !Pi(f) && f !== 0; )
      f = t4.input.charCodeAt(++t4.position);
    Po(t4, n, t4.position, false);
  }
  return true;
}
function Ek(t4, e) {
  var n, r = t4.tag, i = t4.anchor, o = [], s, a = false, l;
  if (t4.firstTabInLine !== -1)
    return false;
  for (t4.anchor !== null && (t4.anchorMap[t4.anchor] = o), l = t4.input.charCodeAt(t4.position); l !== 0 && (t4.firstTabInLine !== -1 && (t4.position = t4.firstTabInLine, ke(t4, "tab characters must not be used in indentation")), !(l !== 45 || (s = t4.input.charCodeAt(t4.position + 1), !or(s)))); ) {
    if (a = true, t4.position++, en(t4, true, -1) && t4.lineIndent <= e) {
      o.push(null), l = t4.input.charCodeAt(t4.position);
      continue;
    }
    if (n = t4.line, Ma(t4, e, d5, false, true), o.push(t4.result), en(t4, true, -1), l = t4.input.charCodeAt(t4.position), (t4.line === n || t4.lineIndent > e) && l !== 0)
      ke(t4, "bad indentation of a sequence entry");
    else if (t4.lineIndent < e)
      break;
  }
  return a ? (t4.tag = r, t4.anchor = i, t4.kind = "sequence", t4.result = o, true) : false;
}
function bne(t4, e, n) {
  var r, i, o, s, a, l, c = t4.tag, u = t4.anchor, f = {}, d = /* @__PURE__ */ Object.create(null), h = null, p = null, O = null, m = false, x = false, v;
  if (t4.firstTabInLine !== -1)
    return false;
  for (t4.anchor !== null && (t4.anchorMap[t4.anchor] = f), v = t4.input.charCodeAt(t4.position); v !== 0; ) {
    if (!m && t4.firstTabInLine !== -1 && (t4.position = t4.firstTabInLine, ke(t4, "tab characters must not be used in indentation")), r = t4.input.charCodeAt(t4.position + 1), o = t4.line, (v === 63 || v === 58) && or(r))
      v === 63 ? (m && (ta(t4, f, d, h, p, null, s, a, l), h = p = O = null), x = true, m = true, i = true) : m ? (m = false, i = true) : ke(t4, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line"), t4.position += 1, v = r;
    else {
      if (s = t4.line, a = t4.lineStart, l = t4.position, !Ma(t4, n, f5, false, true))
        break;
      if (t4.line === o) {
        for (v = t4.input.charCodeAt(t4.position); cs(v); )
          v = t4.input.charCodeAt(++t4.position);
        if (v === 58)
          v = t4.input.charCodeAt(++t4.position), or(v) || ke(t4, "a whitespace character is expected after the key-value separator within a block mapping"), m && (ta(t4, f, d, h, p, null, s, a, l), h = p = O = null), x = true, m = false, i = false, h = t4.tag, p = t4.result;
        else if (x)
          ke(t4, "can not read an implicit mapping pair; a colon is missed");
        else
          return t4.tag = c, t4.anchor = u, true;
      } else if (x)
        ke(t4, "can not read a block mapping entry; a multiline key may not be an implicit key");
      else
        return t4.tag = c, t4.anchor = u, true;
    }
    if ((t4.line === o || t4.lineIndent > e) && (m && (s = t4.line, a = t4.lineStart, l = t4.position), Ma(t4, e, Fd, true, i) && (m ? p = t4.result : O = t4.result), m || (ta(t4, f, d, h, p, O, s, a, l), h = p = O = null), en(t4, true, -1), v = t4.input.charCodeAt(t4.position)), (t4.line === o || t4.lineIndent > e) && v !== 0)
      ke(t4, "bad indentation of a mapping entry");
    else if (t4.lineIndent < e)
      break;
  }
  return m && ta(t4, f, d, h, p, null, s, a, l), x && (t4.tag = c, t4.anchor = u, t4.kind = "mapping", t4.result = f), x;
}
function Sne(t4) {
  var e, n = false, r = false, i, o, s;
  if (s = t4.input.charCodeAt(t4.position), s !== 33)
    return false;
  if (t4.tag !== null && ke(t4, "duplication of a tag property"), s = t4.input.charCodeAt(++t4.position), s === 60 ? (n = true, s = t4.input.charCodeAt(++t4.position)) : s === 33 ? (r = true, i = "!!", s = t4.input.charCodeAt(++t4.position)) : i = "!", e = t4.position, n) {
    do
      s = t4.input.charCodeAt(++t4.position);
    while (s !== 0 && s !== 62);
    t4.position < t4.length ? (o = t4.input.slice(e, t4.position), s = t4.input.charCodeAt(++t4.position)) : ke(t4, "unexpected end of the stream within a verbatim tag");
  } else {
    for (; s !== 0 && !or(s); )
      s === 33 && (r ? ke(t4, "tag suffix cannot contain exclamation marks") : (i = t4.input.slice(e - 1, t4.position + 1), h5.test(i) || ke(t4, "named tag handle cannot contain such characters"), r = true, e = t4.position + 1)), s = t4.input.charCodeAt(++t4.position);
    o = t4.input.slice(e, t4.position), une.test(o) && ke(t4, "tag suffix cannot contain flow indicator characters");
  }
  o && !p5.test(o) && ke(t4, "tag name cannot contain such characters: " + o);
  try {
    o = decodeURIComponent(o);
  } catch {
    ke(t4, "tag name is malformed: " + o);
  }
  return n ? t4.tag = o : _o.call(t4.tagMap, i) ? t4.tag = t4.tagMap[i] + o : i === "!" ? t4.tag = "!" + o : i === "!!" ? t4.tag = "tag:yaml.org,2002:" + o : ke(t4, 'undeclared tag handle "' + i + '"'), true;
}
function wne(t4) {
  var e, n;
  if (n = t4.input.charCodeAt(t4.position), n !== 38)
    return false;
  for (t4.anchor !== null && ke(t4, "duplication of an anchor property"), n = t4.input.charCodeAt(++t4.position), e = t4.position; n !== 0 && !or(n) && !ea(n); )
    n = t4.input.charCodeAt(++t4.position);
  return t4.position === e && ke(t4, "name of an anchor node must contain at least one character"), t4.anchor = t4.input.slice(e, t4.position), true;
}
function Cne(t4) {
  var e, n, r;
  if (r = t4.input.charCodeAt(t4.position), r !== 42)
    return false;
  for (r = t4.input.charCodeAt(++t4.position), e = t4.position; r !== 0 && !or(r) && !ea(r); )
    r = t4.input.charCodeAt(++t4.position);
  return t4.position === e && ke(t4, "name of an alias node must contain at least one character"), n = t4.input.slice(e, t4.position), _o.call(t4.anchorMap, n) || ke(t4, 'unidentified alias "' + n + '"'), t4.result = t4.anchorMap[n], en(t4, true, -1), true;
}
function Ma(t4, e, n, r, i) {
  var o, s, a, l = 1, c = false, u = false, f, d, h, p, O, m;
  if (t4.listener !== null && t4.listener("open", t4), t4.tag = null, t4.anchor = null, t4.kind = null, t4.result = null, o = s = a = Fd === n || d5 === n, r && en(t4, true, -1) && (c = true, t4.lineIndent > e ? l = 1 : t4.lineIndent === e ? l = 0 : t4.lineIndent < e && (l = -1)), l === 1)
    for (; Sne(t4) || wne(t4); )
      en(t4, true, -1) ? (c = true, a = o, t4.lineIndent > e ? l = 1 : t4.lineIndent === e ? l = 0 : t4.lineIndent < e && (l = -1)) : a = false;
  if (a && (a = c || i), (l === 1 || Fd === n) && (Nd === n || f5 === n ? O = e : O = e + 1, m = t4.position - t4.lineStart, l === 1 ? a && (Ek(t4, m) || bne(t4, m, O)) || vne(t4, O) ? u = true : (s && yne(t4, O) || One(t4, O) || xne(t4, O) ? u = true : Cne(t4) ? (u = true, (t4.tag !== null || t4.anchor !== null) && ke(t4, "alias node should not have any properties")) : mne(t4, O, Nd === n) && (u = true, t4.tag === null && (t4.tag = "?")), t4.anchor !== null && (t4.anchorMap[t4.anchor] = t4.result)) : l === 0 && (u = a && Ek(t4, m))), t4.tag === null)
    t4.anchor !== null && (t4.anchorMap[t4.anchor] = t4.result);
  else if (t4.tag === "?") {
    for (t4.result !== null && t4.kind !== "scalar" && ke(t4, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + t4.kind + '"'), f = 0, d = t4.implicitTypes.length; f < d; f += 1)
      if (p = t4.implicitTypes[f], p.resolve(t4.result)) {
        t4.result = p.construct(t4.result), t4.tag = p.tag, t4.anchor !== null && (t4.anchorMap[t4.anchor] = t4.result);
        break;
      }
  } else if (t4.tag !== "!") {
    if (_o.call(t4.typeMap[t4.kind || "fallback"], t4.tag))
      p = t4.typeMap[t4.kind || "fallback"][t4.tag];
    else
      for (p = null, h = t4.typeMap.multi[t4.kind || "fallback"], f = 0, d = h.length; f < d; f += 1)
        if (t4.tag.slice(0, h[f].tag.length) === h[f].tag) {
          p = h[f];
          break;
        }
    p || ke(t4, "unknown tag !<" + t4.tag + ">"), t4.result !== null && p.kind !== t4.kind && ke(t4, "unacceptable node kind for !<" + t4.tag + '> tag; it should be "' + p.kind + '", not "' + t4.kind + '"'), p.resolve(t4.result, t4.tag) ? (t4.result = p.construct(t4.result, t4.tag), t4.anchor !== null && (t4.anchorMap[t4.anchor] = t4.result)) : ke(t4, "cannot resolve a node with !<" + t4.tag + "> explicit tag");
  }
  return t4.listener !== null && t4.listener("close", t4), t4.tag !== null || t4.anchor !== null || u;
}
function kne(t4) {
  var e = t4.position, n, r, i, o = false, s;
  for (t4.version = null, t4.checkLineBreaks = t4.legacy, t4.tagMap = /* @__PURE__ */ Object.create(null), t4.anchorMap = /* @__PURE__ */ Object.create(null); (s = t4.input.charCodeAt(t4.position)) !== 0 && (en(t4, true, -1), s = t4.input.charCodeAt(t4.position), !(t4.lineIndent > 0 || s !== 37)); ) {
    for (o = true, s = t4.input.charCodeAt(++t4.position), n = t4.position; s !== 0 && !or(s); )
      s = t4.input.charCodeAt(++t4.position);
    for (r = t4.input.slice(n, t4.position), i = [], r.length < 1 && ke(t4, "directive name must not be less than one character in length"); s !== 0; ) {
      for (; cs(s); )
        s = t4.input.charCodeAt(++t4.position);
      if (s === 35) {
        do
          s = t4.input.charCodeAt(++t4.position);
        while (s !== 0 && !Pi(s));
        break;
      }
      if (Pi(s))
        break;
      for (n = t4.position; s !== 0 && !or(s); )
        s = t4.input.charCodeAt(++t4.position);
      i.push(t4.input.slice(n, t4.position));
    }
    s !== 0 && Tv(t4), _o.call(Ak, r) ? Ak[r](t4, r, i) : Zd(t4, 'unknown document directive "' + r + '"');
  }
  if (en(t4, true, -1), t4.lineIndent === 0 && t4.input.charCodeAt(t4.position) === 45 && t4.input.charCodeAt(t4.position + 1) === 45 && t4.input.charCodeAt(t4.position + 2) === 45 ? (t4.position += 3, en(t4, true, -1)) : o && ke(t4, "directives end mark is expected"), Ma(t4, t4.lineIndent - 1, Fd, false, true), en(t4, true, -1), t4.checkLineBreaks && cne.test(t4.input.slice(e, t4.position)) && Zd(t4, "non-ASCII line breaks are interpreted as content"), t4.documents.push(t4.result), t4.position === t4.lineStart && Mh(t4)) {
    t4.input.charCodeAt(t4.position) === 46 && (t4.position += 3, en(t4, true, -1));
    return;
  }
  if (t4.position < t4.length - 1)
    ke(t4, "end of the stream or a document separator is expected");
  else
    return;
}
function x5(t4, e) {
  t4 = String(t4), e = e || {}, t4.length !== 0 && (t4.charCodeAt(t4.length - 1) !== 10 && t4.charCodeAt(t4.length - 1) !== 13 && (t4 += `
`), t4.charCodeAt(0) === 65279 && (t4 = t4.slice(1)));
  var n = new gne(t4, e), r = t4.indexOf("\0");
  for (r !== -1 && (n.position = r, ke(n, "null byte is not allowed in input")), n.input += "\0"; n.input.charCodeAt(n.position) === 32; )
    n.lineIndent += 1, n.position += 1;
  for (; n.position < n.length - 1; )
    kne(n);
  return n.documents;
}
function Ane(t4, e, n) {
  e !== null && typeof e == "object" && typeof n > "u" && (n = e, e = null);
  var r = x5(t4, n);
  if (typeof e != "function")
    return r;
  for (var i = 0, o = r.length; i < o; i += 1)
    e(r[i]);
}
function Pne(t4, e) {
  var n = x5(t4, e);
  if (n.length !== 0) {
    if (n.length === 1)
      return n[0];
    throw new Xn("expected a single document in the stream, but found more");
  }
}
var Ene = Ane;
var Tne = Pne;
var v5 = {
  loadAll: Ene,
  load: Tne
};
var y5 = Object.prototype.toString;
var b5 = Object.prototype.hasOwnProperty;
var $v = 65279;
var Ine = 9;
var wc = 10;
var $ne = 13;
var jne = 32;
var Rne = 33;
var Dne = 34;
var wO = 35;
var Qne = 37;
var Bne = 38;
var _ne = 39;
var Mne = 42;
var S5 = 44;
var Nne = 45;
var Wd = 58;
var Fne = 61;
var Zne = 62;
var Wne = 63;
var Vne = 64;
var w5 = 91;
var C5 = 93;
var zne = 96;
var k5 = 123;
var Lne = 124;
var A5 = 125;
var Zn = {};
Zn[0] = "\\0";
Zn[7] = "\\a";
Zn[8] = "\\b";
Zn[9] = "\\t";
Zn[10] = "\\n";
Zn[11] = "\\v";
Zn[12] = "\\f";
Zn[13] = "\\r";
Zn[27] = "\\e";
Zn[34] = '\\"';
Zn[92] = "\\\\";
Zn[133] = "\\N";
Zn[160] = "\\_";
Zn[8232] = "\\L";
Zn[8233] = "\\P";
var Xne = [
  "y",
  "Y",
  "yes",
  "Yes",
  "YES",
  "on",
  "On",
  "ON",
  "n",
  "N",
  "no",
  "No",
  "NO",
  "off",
  "Off",
  "OFF"
];
var Gne = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
function Yne(t4, e) {
  var n, r, i, o, s, a, l;
  if (e === null)
    return {};
  for (n = {}, r = Object.keys(e), i = 0, o = r.length; i < o; i += 1)
    s = r[i], a = String(e[s]), s.slice(0, 2) === "!!" && (s = "tag:yaml.org,2002:" + s.slice(2)), l = t4.compiledTypeMap.fallback[s], l && b5.call(l.styleAliases, a) && (a = l.styleAliases[a]), n[s] = a;
  return n;
}
function qne(t4) {
  var e, n, r;
  if (e = t4.toString(16).toUpperCase(), t4 <= 255)
    n = "x", r = 2;
  else if (t4 <= 65535)
    n = "u", r = 4;
  else if (t4 <= 4294967295)
    n = "U", r = 8;
  else
    throw new Xn("code point within a string may not be greater than 0xFFFFFFFF");
  return "\\" + n + fn.repeat("0", r - e.length) + e;
}
var Une = 1;
var Cc = 2;
function Hne(t4) {
  this.schema = t4.schema || Ev, this.indent = Math.max(1, t4.indent || 2), this.noArrayIndent = t4.noArrayIndent || false, this.skipInvalid = t4.skipInvalid || false, this.flowLevel = fn.isNothing(t4.flowLevel) ? -1 : t4.flowLevel, this.styleMap = Yne(this.schema, t4.styles || null), this.sortKeys = t4.sortKeys || false, this.lineWidth = t4.lineWidth || 80, this.noRefs = t4.noRefs || false, this.noCompatMode = t4.noCompatMode || false, this.condenseFlow = t4.condenseFlow || false, this.quotingType = t4.quotingType === '"' ? Cc : Une, this.forceQuotes = t4.forceQuotes || false, this.replacer = typeof t4.replacer == "function" ? t4.replacer : null, this.implicitTypes = this.schema.compiledImplicit, this.explicitTypes = this.schema.compiledExplicit, this.tag = null, this.result = "", this.duplicates = [], this.usedDuplicates = null;
}
function Tk(t4, e) {
  for (var n = fn.repeat(" ", e), r = 0, i = -1, o = "", s, a = t4.length; r < a; )
    i = t4.indexOf(`
`, r), i === -1 ? (s = t4.slice(r), r = a) : (s = t4.slice(r, i + 1), r = i + 1), s.length && s !== `
` && (o += n), o += s;
  return o;
}
function CO(t4, e) {
  return `
` + fn.repeat(" ", t4.indent * e);
}
function Jne(t4, e) {
  var n, r, i;
  for (n = 0, r = t4.implicitTypes.length; n < r; n += 1)
    if (i = t4.implicitTypes[n], i.resolve(e))
      return true;
  return false;
}
function Vd(t4) {
  return t4 === jne || t4 === Ine;
}
function kc(t4) {
  return 32 <= t4 && t4 <= 126 || 161 <= t4 && t4 <= 55295 && t4 !== 8232 && t4 !== 8233 || 57344 <= t4 && t4 <= 65533 && t4 !== $v || 65536 <= t4 && t4 <= 1114111;
}
function Ik(t4) {
  return kc(t4) && t4 !== $v && t4 !== $ne && t4 !== wc;
}
function $k(t4, e, n) {
  var r = Ik(t4), i = r && !Vd(t4);
  return (
    // ns-plain-safe
    (n ? (
      // c = flow-in
      r
    ) : r && t4 !== S5 && t4 !== w5 && t4 !== C5 && t4 !== k5 && t4 !== A5) && t4 !== wO && !(e === Wd && !i) || Ik(e) && !Vd(e) && t4 === wO || e === Wd && i
  );
}
function Kne(t4) {
  return kc(t4) && t4 !== $v && !Vd(t4) && t4 !== Nne && t4 !== Wne && t4 !== Wd && t4 !== S5 && t4 !== w5 && t4 !== C5 && t4 !== k5 && t4 !== A5 && t4 !== wO && t4 !== Bne && t4 !== Mne && t4 !== Rne && t4 !== Lne && t4 !== Fne && t4 !== Zne && t4 !== _ne && t4 !== Dne && t4 !== Qne && t4 !== Vne && t4 !== zne;
}
function ere(t4) {
  return !Vd(t4) && t4 !== Wd;
}
function _l(t4, e) {
  var n = t4.charCodeAt(e), r;
  return n >= 55296 && n <= 56319 && e + 1 < t4.length && (r = t4.charCodeAt(e + 1), r >= 56320 && r <= 57343) ? (n - 55296) * 1024 + r - 56320 + 65536 : n;
}
function P5(t4) {
  var e = /^\n* /;
  return e.test(t4);
}
var E5 = 1;
var kO = 2;
var T5 = 3;
var I5 = 4;
var Xs = 5;
function tre(t4, e, n, r, i, o, s, a) {
  var l, c = 0, u = null, f = false, d = false, h = r !== -1, p = -1, O = Kne(_l(t4, 0)) && ere(_l(t4, t4.length - 1));
  if (e || s)
    for (l = 0; l < t4.length; c >= 65536 ? l += 2 : l++) {
      if (c = _l(t4, l), !kc(c))
        return Xs;
      O = O && $k(c, u, a), u = c;
    }
  else {
    for (l = 0; l < t4.length; c >= 65536 ? l += 2 : l++) {
      if (c = _l(t4, l), c === wc)
        f = true, h && (d = d || // Foldable line = too long, and not more-indented.
        l - p - 1 > r && t4[p + 1] !== " ", p = l);
      else if (!kc(c))
        return Xs;
      O = O && $k(c, u, a), u = c;
    }
    d = d || h && l - p - 1 > r && t4[p + 1] !== " ";
  }
  return !f && !d ? O && !s && !i(t4) ? E5 : o === Cc ? Xs : kO : n > 9 && P5(t4) ? Xs : s ? o === Cc ? Xs : kO : d ? I5 : T5;
}
function nre(t4, e, n, r, i) {
  t4.dump = function() {
    if (e.length === 0)
      return t4.quotingType === Cc ? '""' : "''";
    if (!t4.noCompatMode && (Xne.indexOf(e) !== -1 || Gne.test(e)))
      return t4.quotingType === Cc ? '"' + e + '"' : "'" + e + "'";
    var o = t4.indent * Math.max(1, n), s = t4.lineWidth === -1 ? -1 : Math.max(Math.min(t4.lineWidth, 40), t4.lineWidth - o), a = r || t4.flowLevel > -1 && n >= t4.flowLevel;
    function l(c) {
      return Jne(t4, c);
    }
    switch (tre(
      e,
      a,
      t4.indent,
      s,
      l,
      t4.quotingType,
      t4.forceQuotes && !r,
      i
    )) {
      case E5:
        return e;
      case kO:
        return "'" + e.replace(/'/g, "''") + "'";
      case T5:
        return "|" + jk(e, t4.indent) + Rk(Tk(e, o));
      case I5:
        return ">" + jk(e, t4.indent) + Rk(Tk(rre(e, s), o));
      case Xs:
        return '"' + ire(e) + '"';
      default:
        throw new Xn("impossible error: invalid scalar style");
    }
  }();
}
function jk(t4, e) {
  var n = P5(t4) ? String(e) : "", r = t4[t4.length - 1] === `
`, i = r && (t4[t4.length - 2] === `
` || t4 === `
`), o = i ? "+" : r ? "" : "-";
  return n + o + `
`;
}
function Rk(t4) {
  return t4[t4.length - 1] === `
` ? t4.slice(0, -1) : t4;
}
function rre(t4, e) {
  for (var n = /(\n+)([^\n]*)/g, r = function() {
    var c = t4.indexOf(`
`);
    return c = c !== -1 ? c : t4.length, n.lastIndex = c, Dk(t4.slice(0, c), e);
  }(), i = t4[0] === `
` || t4[0] === " ", o, s; s = n.exec(t4); ) {
    var a = s[1], l = s[2];
    o = l[0] === " ", r += a + (!i && !o && l !== "" ? `
` : "") + Dk(l, e), i = o;
  }
  return r;
}
function Dk(t4, e) {
  if (t4 === "" || t4[0] === " ")
    return t4;
  for (var n = / [^ ]/g, r, i = 0, o, s = 0, a = 0, l = ""; r = n.exec(t4); )
    a = r.index, a - i > e && (o = s > i ? s : a, l += `
` + t4.slice(i, o), i = o + 1), s = a;
  return l += `
`, t4.length - i > e && s > i ? l += t4.slice(i, s) + `
` + t4.slice(s + 1) : l += t4.slice(i), l.slice(1);
}
function ire(t4) {
  for (var e = "", n = 0, r, i = 0; i < t4.length; n >= 65536 ? i += 2 : i++)
    n = _l(t4, i), r = Zn[n], !r && kc(n) ? (e += t4[i], n >= 65536 && (e += t4[i + 1])) : e += r || qne(n);
  return e;
}
function ore(t4, e, n) {
  var r = "", i = t4.tag, o, s, a;
  for (o = 0, s = n.length; o < s; o += 1)
    a = n[o], t4.replacer && (a = t4.replacer.call(n, String(o), a)), (to(t4, e, a, false, false) || typeof a > "u" && to(t4, e, null, false, false)) && (r !== "" && (r += "," + (t4.condenseFlow ? "" : " ")), r += t4.dump);
  t4.tag = i, t4.dump = "[" + r + "]";
}
function Qk(t4, e, n, r) {
  var i = "", o = t4.tag, s, a, l;
  for (s = 0, a = n.length; s < a; s += 1)
    l = n[s], t4.replacer && (l = t4.replacer.call(n, String(s), l)), (to(t4, e + 1, l, true, true, false, true) || typeof l > "u" && to(t4, e + 1, null, true, true, false, true)) && ((!r || i !== "") && (i += CO(t4, e)), t4.dump && wc === t4.dump.charCodeAt(0) ? i += "-" : i += "- ", i += t4.dump);
  t4.tag = o, t4.dump = i || "[]";
}
function sre(t4, e, n) {
  var r = "", i = t4.tag, o = Object.keys(n), s, a, l, c, u;
  for (s = 0, a = o.length; s < a; s += 1)
    u = "", r !== "" && (u += ", "), t4.condenseFlow && (u += '"'), l = o[s], c = n[l], t4.replacer && (c = t4.replacer.call(n, l, c)), to(t4, e, l, false, false) && (t4.dump.length > 1024 && (u += "? "), u += t4.dump + (t4.condenseFlow ? '"' : "") + ":" + (t4.condenseFlow ? "" : " "), to(t4, e, c, false, false) && (u += t4.dump, r += u));
  t4.tag = i, t4.dump = "{" + r + "}";
}
function are(t4, e, n, r) {
  var i = "", o = t4.tag, s = Object.keys(n), a, l, c, u, f, d;
  if (t4.sortKeys === true)
    s.sort();
  else if (typeof t4.sortKeys == "function")
    s.sort(t4.sortKeys);
  else if (t4.sortKeys)
    throw new Xn("sortKeys must be a boolean or a function");
  for (a = 0, l = s.length; a < l; a += 1)
    d = "", (!r || i !== "") && (d += CO(t4, e)), c = s[a], u = n[c], t4.replacer && (u = t4.replacer.call(n, c, u)), to(t4, e + 1, c, true, true, true) && (f = t4.tag !== null && t4.tag !== "?" || t4.dump && t4.dump.length > 1024, f && (t4.dump && wc === t4.dump.charCodeAt(0) ? d += "?" : d += "? "), d += t4.dump, f && (d += CO(t4, e)), to(t4, e + 1, u, true, f) && (t4.dump && wc === t4.dump.charCodeAt(0) ? d += ":" : d += ": ", d += t4.dump, i += d));
  t4.tag = o, t4.dump = i || "{}";
}
function Bk(t4, e, n) {
  var r, i, o, s, a, l;
  for (i = n ? t4.explicitTypes : t4.implicitTypes, o = 0, s = i.length; o < s; o += 1)
    if (a = i[o], (a.instanceOf || a.predicate) && (!a.instanceOf || typeof e == "object" && e instanceof a.instanceOf) && (!a.predicate || a.predicate(e))) {
      if (n ? a.multi && a.representName ? t4.tag = a.representName(e) : t4.tag = a.tag : t4.tag = "?", a.represent) {
        if (l = t4.styleMap[a.tag] || a.defaultStyle, y5.call(a.represent) === "[object Function]")
          r = a.represent(e, l);
        else if (b5.call(a.represent, l))
          r = a.represent[l](e, l);
        else
          throw new Xn("!<" + a.tag + '> tag resolver accepts not "' + l + '" style');
        t4.dump = r;
      }
      return true;
    }
  return false;
}
function to(t4, e, n, r, i, o, s) {
  t4.tag = null, t4.dump = n, Bk(t4, n, false) || Bk(t4, n, true);
  var a = y5.call(t4.dump), l = r, c;
  r && (r = t4.flowLevel < 0 || t4.flowLevel > e);
  var u = a === "[object Object]" || a === "[object Array]", f, d;
  if (u && (f = t4.duplicates.indexOf(n), d = f !== -1), (t4.tag !== null && t4.tag !== "?" || d || t4.indent !== 2 && e > 0) && (i = false), d && t4.usedDuplicates[f])
    t4.dump = "*ref_" + f;
  else {
    if (u && d && !t4.usedDuplicates[f] && (t4.usedDuplicates[f] = true), a === "[object Object]")
      r && Object.keys(t4.dump).length !== 0 ? (are(t4, e, t4.dump, i), d && (t4.dump = "&ref_" + f + t4.dump)) : (sre(t4, e, t4.dump), d && (t4.dump = "&ref_" + f + " " + t4.dump));
    else if (a === "[object Array]")
      r && t4.dump.length !== 0 ? (t4.noArrayIndent && !s && e > 0 ? Qk(t4, e - 1, t4.dump, i) : Qk(t4, e, t4.dump, i), d && (t4.dump = "&ref_" + f + t4.dump)) : (ore(t4, e, t4.dump), d && (t4.dump = "&ref_" + f + " " + t4.dump));
    else if (a === "[object String]")
      t4.tag !== "?" && nre(t4, t4.dump, e, o, l);
    else {
      if (a === "[object Undefined]")
        return false;
      if (t4.skipInvalid)
        return false;
      throw new Xn("unacceptable kind of an object to dump " + a);
    }
    t4.tag !== null && t4.tag !== "?" && (c = encodeURI(
      t4.tag[0] === "!" ? t4.tag.slice(1) : t4.tag
    ).replace(/!/g, "%21"), t4.tag[0] === "!" ? c = "!" + c : c.slice(0, 18) === "tag:yaml.org,2002:" ? c = "!!" + c.slice(18) : c = "!<" + c + ">", t4.dump = c + " " + t4.dump);
  }
  return true;
}
function lre(t4, e) {
  var n = [], r = [], i, o;
  for (AO(t4, n, r), i = 0, o = r.length; i < o; i += 1)
    e.duplicates.push(n[r[i]]);
  e.usedDuplicates = new Array(o);
}
function AO(t4, e, n) {
  var r, i, o;
  if (t4 !== null && typeof t4 == "object")
    if (i = e.indexOf(t4), i !== -1)
      n.indexOf(i) === -1 && n.push(i);
    else if (e.push(t4), Array.isArray(t4))
      for (i = 0, o = t4.length; i < o; i += 1)
        AO(t4[i], e, n);
    else
      for (r = Object.keys(t4), i = 0, o = r.length; i < o; i += 1)
        AO(t4[r[i]], e, n);
}
function cre(t4, e) {
  e = e || {};
  var n = new Hne(e);
  n.noRefs || lre(t4, n);
  var r = t4;
  return n.replacer && (r = n.replacer.call({ "": r }, "", r)), to(n, 0, r, true, true) ? n.dump + `
` : "";
}
var ure = cre;
var fre = {
  dump: ure
};
function jv(t4, e) {
  return function() {
    throw new Error("Function yaml." + t4 + " is removed in js-yaml 4. Use yaml." + e + " instead, which is now safe by default.");
  };
}
var dre = jn;
var hre = Xj;
var pre = Uj;
var gre = t5;
var mre = n5;
var Ore = Ev;
var xre = v5.load;
var vre = v5.loadAll;
var yre = fre.dump;
var bre = Xn;
var Sre = {
  binary: a5,
  float: e5,
  map: qj,
  null: Hj,
  pairs: c5,
  set: u5,
  timestamp: o5,
  bool: Jj,
  int: Kj,
  merge: s5,
  omap: l5,
  seq: Yj,
  str: Gj
};
var wre = jv("safeLoad", "load");
var Cre = jv("safeLoadAll", "loadAll");
var kre = jv("safeDump", "dump");
var $5 = {
  Type: dre,
  Schema: hre,
  FAILSAFE_SCHEMA: pre,
  JSON_SCHEMA: gre,
  CORE_SCHEMA: mre,
  DEFAULT_SCHEMA: Ore,
  load: xre,
  loadAll: vre,
  dump: yre,
  YAMLException: bre,
  types: Sre,
  safeLoad: wre,
  safeLoadAll: Cre,
  safeDump: kre
};
function Are({ onImport: t4, onAddFolder: e }) {
  return /* @__PURE__ */ g.jsxs(Pre, { children: [
    /* @__PURE__ */ g.jsx(Ere, { children: "Save requests or import them from Arazzo files" }),
    /* @__PURE__ */ g.jsxs(Tre, { children: [
      /* @__PURE__ */ g.jsx(Button, { icon: /* @__PURE__ */ g.jsx(AddIcon, {}), onClick: e, children: "Create new collection" }),
      /* @__PURE__ */ g.jsx(Button, { icon: /* @__PURE__ */ g.jsx(DownloadIcon, {}), onClick: t4, children: "Import Arazzo Files" })
    ] })
  ] });
}
var Pre = I.div`
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100%;
  gap: var(--spacing-lg);
`;
var Ere = I.div`
  max-width: 50%;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  text-align: center;
`;
var Tre = I.div`
  display: flex;
  align-items: center;
  justify-content: center;
  gap: var(--spacing-xs);
`;
function Ire() {
  return /* @__PURE__ */ g.jsx($re, { children: "No results found" });
}
var $re = I.div`
  height: 100%;
  display: flex;
  justify-content: center;
  color: var(--text-color-helper);
  margin-top: 20vh;
`;
var jre = xs(
  ({
    children: t4,
    controls: e,
    icon: n,
    title: r,
    dataTestId: i,
    defaultExpanded: o = false,
    level: s = 0,
    active: a,
    ...l
  }, c) => {
    const [u, f] = fe(o), d = () => {
      const h = !u;
      f(h), l.onToggle && l.onToggle(h);
    };
    return $O(c, () => ({
      setIsExpanded: f
    })), /* @__PURE__ */ g.jsxs(Rre, { ...l, "data-testid": i, children: [
      /* @__PURE__ */ g.jsxs(Bre, { tabIndex: 0, $level: s, $active: a, onClick: d, children: [
        /* @__PURE__ */ g.jsxs(Mre, { children: [
          /* @__PURE__ */ g.jsx(_re, { children: n || (u ? /* @__PURE__ */ g.jsx(ChevronDownIcon, { size: "14px", color: "--text-color-secondary" }) : /* @__PURE__ */ g.jsx(ChevronRightIcon, { size: "14px", color: "--text-color-secondary" })) }),
          /* @__PURE__ */ g.jsx(Dre, { children: r })
        ] }),
        e && /* @__PURE__ */ g.jsx(PO, { onClick: (h) => h.stopPropagation(), children: e })
      ] }),
      /* @__PURE__ */ g.jsx(Qre, { $isExpanded: u, $level: s, children: t4 })
    ] });
  }
);
var Rre = I.div`
  display: inline-grid;
  width: 100%;
  flex-direction: column;
  flex-shrink: 0;
  color: var(--text-color-secondary);
  font-size: var(--font-size-base);
  line-height: var(--line-height-base);
  cursor: pointer;
`;
var Dre = I.div`
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
`;
var Qre = I.div`
  display: ${({ $isExpanded: t4 }) => t4 ? "flex" : "none"};
  position: relative;
  flex-direction: column;
  height: ${({ $isExpanded: t4 }) => t4 ? "auto" : "0"};
  overflow-x: visible;

  &::before {
    content: '';
    display: block;
    height: 100%;
    position: absolute;
    left: ${({ $level: t4 }) => `calc(var(--spacing-sm) + 5.5px + ${t4} * var(--spacing-base))`};
    top: 0;
    border-left: 1px solid var(--border-color-secondary);
  }
`;
var PO = I.div`
  display: none;
  padding-right: var(--spacing-xs);
`;
var Bre = I.div`
  width: 100%;
  display: flex;
  flex-direction: row;
  justify-content: space-between;
  align-items: center;
  flex-grow: 1;
  height: 32px;
  padding: ${({ $level: t4 }) => `var(--spacing-xxs) var(--spacing-xs) var(--spacing-xxs) calc(var(--spacing-sm) - 1px + ${t4} * var(--spacing-base))`};
  min-width: 0;

  ${({ $active: t4 }) => t4 && `
    ${PO} {
      display: flex;
    }
  `}

  &:hover {
    ${PO} {
      display: flex;
    }
  }

  ${({ $active: t4 }) => t4 && `
    background-color: var(--bg-color-hover);
  `}

  &:hover {
    background-color: var(--bg-color-hover);
  }
`;
var _re = I.div`
  display: flex;
  align-items: center;
  min-width: 14px;
`;
var Mre = I.div`
  display: flex;
  flex-grow: 1;
  flex-direction: row;
  align-items: center;
  gap: var(--spacing-xxs);
  min-width: 0;
`;
function Nre(t4, e) {
  const { definitionUrl: n, environments: r, selectedEnvironmentId: i } = e, o = M$(
    i || "",
    r
  ), s = rie(n || ""), a = j5(
    t4.items.get(),
    o.variables
  );
  return {
    arazzo: "1.0.0",
    info: { title: t4.name.get(), version: "1.0.0" },
    sourceDescriptions: [
      {
        name: s,
        url: n,
        type: "openapi",
        "x-serverUrl": o.url
      }
    ],
    workflows: [
      {
        workflowId: Rv(t4.name.get()),
        steps: a
      }
    ]
  };
}
function j5(t4, e) {
  return t4.flatMap(
    (n) => n.type === dn.Folder ? Fre(n.value, e) : [Zre(n.value, e)]
  );
}
function Fre(t4, e) {
  return j5(t4.items, e).map((n) => ({
    ...n,
    stepId: `${Rv(t4.name)}/${n.stepId}`
  }));
}
function Zre(t4, e) {
  var a;
  const n = t4.name, r = Rv(n), i = Vre(t4.request, e), o = Xre(t4.request), s = {
    stepId: r,
    description: n,
    "x-operation": {
      path: iie(t4.request.url),
      method: (a = t4.request.method) == null ? void 0 : a.toLowerCase()
    },
    "x-replay": {
      securities: o,
      path: t4.request.url,
      parameters: Wre(t4.request)
    },
    parameters: i
  };
  if (tie(t4.request.body)) {
    const l = nie(t4.request.body), c = qe(l, e);
    s.requestBody = {
      contentType: t4.request.body.type,
      payload: c
    }, s["x-replay"].body = l;
  }
  return s;
}
function Wre(t4) {
  return [
    ...U0(t4.cookies, "cookie"),
    ...U0(t4.queryParameters, "query"),
    ...U0(t4.headers, "header")
  ];
}
function U0(t4, e) {
  return t4.filter(({ key: n }) => n).map(({ key: n, value: r }) => ({ in: e, name: n, value: r }));
}
function Vre(t4, e) {
  return [
    ...EO(t4.cookies, "cookie", e),
    ...EO(t4.queryParameters, "query", e),
    ...Lre(t4, e),
    ...zre(t4, e)
  ];
}
function EO(t4, e, n) {
  return t4.filter(({ key: r }) => r).map(({ key: r, value: i }) => {
    const o = qe(r, n), s = qe(i, n);
    return { in: e, name: o, value: s };
  });
}
function zre(t4, e) {
  const n = t4.url.split("?")[0];
  return Va(n).filter(({ content: r }) => r !== px).map(({ content: r }) => {
    var i;
    return {
      in: "path",
      name: r,
      value: ((i = e.find(({ name: o }) => o === r)) == null ? void 0 : i.value) || ""
    };
  });
}
function Lre(t4, e) {
  return [
    ...EO(t4.headers, "header", e),
    ...oie(
      t4.security.securities,
      e,
      t4
    )
  ];
}
function Xre(t4) {
  return t4.security.securities.map((e) => {
    const { securityType: n, ...r } = e;
    switch (n) {
      case H.BasicAuth:
        return Gre(r[H.BasicAuth]);
      case H.DigestAuth:
        return Yre(r[H.DigestAuth]);
      case H.JWT:
        return qre(r[H.JWT]);
      case H.APIKey:
        return Ure(r[H.APIKey]);
      case H.OAuth2:
        return Hre(r[H.OAuth2]);
      case H.OpenIDConnect:
        return Jre(r[H.OpenIDConnect]);
      default:
        return Kre();
    }
  });
}
function Gre(t4) {
  return {
    type: H.BasicAuth,
    data: {
      username: t4.username,
      password: t4.password
    }
  };
}
function Yre(t4) {
  return {
    type: H.DigestAuth,
    data: {
      username: t4.username,
      password: t4.password
    }
  };
}
function qre(t4) {
  return {
    type: H.JWT,
    data: {
      token: t4.token
    }
  };
}
function Ure(t4) {
  return {
    type: H.APIKey,
    data: {
      name: t4.name,
      key: t4.key,
      location: t4.location
    }
  };
}
function Hre(t4) {
  return {
    type: H.OAuth2,
    data: R5(t4)
  };
}
function Jre(t4) {
  return {
    type: H.OpenIDConnect,
    data: {
      ...R5(t4),
      ...t4.openIdConnectUrl && { openIdConnectUrl: t4.openIdConnectUrl },
      ...t4.userInfoUrl && { userInfoUrl: t4.userInfoUrl }
    }
  };
}
function Kre() {
  return {
    type: H.NoAuth
  };
}
function R5(t4) {
  var i;
  const e = _k(t4.tokenRequestExtraParams), n = _k(t4.authRequestExtraParams), r = {
    [t4.grantType]: t4[t4.grantType],
    scopes: eie(
      (i = t4[t4.grantType]) == null ? void 0 : i.scopes
    ),
    grantType: t4.grantType
  };
  return {
    ...e.length > 0 && { tokenRequestExtraParams: e },
    ...n.length > 0 && { authRequestExtraParams: n },
    ...r
  };
}
function _k(t4 = []) {
  return t4.filter(({ value: e }) => e).map(({ id: e, ...n }) => n);
}
function eie(t4 = []) {
  return t4.filter(({ value: e }) => e).map(({ id: e, key: n, ...r }) => r);
}
function tie(t4) {
  const { content: e, formData: n } = t4;
  return !!e || Object.values(n).some((r) => r.length > 1);
}
function nie(t4) {
  switch (t4.type) {
    case ut.JSON:
    case ut.XML:
    case ut.HTML:
    case ut.Text:
      return JSON.stringify(t4.content);
    case ut.FormData:
    case ut["application/x-www-form-urlencoded"]:
      const e = t4.formData[t4.type].filter(({ key: n, type: r }) => n && r === "text").map(({ key: n, type: r, value: i }) => ({ key: n, type: r, value: i }));
      return JSON.stringify(e);
    default:
      return "";
  }
}
function rie(t4) {
  return t4.substring(
    t4.lastIndexOf("/") + 1,
    t4.lastIndexOf(".")
  );
}
function Rv(t4) {
  return t4.replace(/[^A-Za-z0-9_\-]+/g, "-");
}
function iie(t4) {
  const e = t4.indexOf("?");
  let n = t4.substring(0, e !== -1 ? e : t4.length);
  return n = n.replace(/\{\{server\}\}/g, "").replace(/\{\{([^{}]+)\}\}/g, "{$1}"), n;
}
function oie(t4, e, n) {
  return t4.map((r) => {
    const { securityType: i, ...o } = r;
    switch (i) {
      case H.BasicAuth:
        return sie(o[H.BasicAuth], e);
      case H.DigestAuth:
        return aie(n, e);
      case H.JWT:
        return lie(o[H.JWT], e);
      case H.OAuth2:
      case H.OpenIDConnect:
        return cie(i, o, e);
      case H.APIKey:
        return uie(o[H.APIKey], e);
      default:
        return null;
    }
  }).filter(Boolean);
}
function sie(t4, e) {
  const { username: n, password: r } = t4, i = qe(n, e), o = qe(r, e);
  return Nh("Authorization", `Basic ${btoa(`${i}:${o}`)}`);
}
function aie(t4, e) {
  return Nh("Authorization", _$(t4, e));
}
function lie(t4, e) {
  const n = qe(t4.token, e);
  return Nh("Authorization", `Bearer ${n}`);
}
function cie(t4, e, n) {
  const {
    grantType: r,
    [r]: { accessToken: i }
  } = e[t4], o = qe(i, n);
  return Nh("Authorization", `Bearer ${o}`);
}
function uie(t4, e) {
  const { name: n, key: r, location: i } = t4, o = qe(r, e), s = qe(n, e);
  return n && r ? { in: i.toLowerCase(), name: s, value: o } : null;
}
function Nh(t4, e) {
  return { in: "header", name: t4, value: e };
}
async function fie(t4, e = {}, n) {
  return window.__TAURI_INTERNALS__.invoke(t4, e, n);
}
var Mk;
(function(t4) {
  t4[t4.Audio = 1] = "Audio", t4[t4.Cache = 2] = "Cache", t4[t4.Config = 3] = "Config", t4[t4.Data = 4] = "Data", t4[t4.LocalData = 5] = "LocalData", t4[t4.Document = 6] = "Document", t4[t4.Download = 7] = "Download", t4[t4.Picture = 8] = "Picture", t4[t4.Public = 9] = "Public", t4[t4.Video = 10] = "Video", t4[t4.Resource = 11] = "Resource", t4[t4.Temp = 12] = "Temp", t4[t4.AppConfig = 13] = "AppConfig", t4[t4.AppData = 14] = "AppData", t4[t4.AppLocalData = 15] = "AppLocalData", t4[t4.AppCache = 16] = "AppCache", t4[t4.AppLog = 17] = "AppLog", t4[t4.Desktop = 18] = "Desktop", t4[t4.Executable = 19] = "Executable", t4[t4.Font = 20] = "Font", t4[t4.Home = 21] = "Home", t4[t4.Runtime = 22] = "Runtime", t4[t4.Template = 23] = "Template";
})(Mk || (Mk = {}));
var Nk;
(function(t4) {
  t4[t4.Start = 0] = "Start", t4[t4.Current = 1] = "Current", t4[t4.End = 2] = "End";
})(Nk || (Nk = {}));
async function die(t4, e, n) {
  if (t4 instanceof URL && t4.protocol !== "file:")
    throw new TypeError("Must be a file URL.");
  const r = new TextEncoder();
  await fie("plugin:fs|write_text_file", r.encode(e), {
    headers: {
      path: t4 instanceof URL ? t4.toString() : t4,
      options: JSON.stringify(n)
    }
  });
}
async function D5(t4, e = {}, n) {
  return window.__TAURI_INTERNALS__.invoke(t4, e, n);
}
async function hie(t4 = {}) {
  return typeof t4 == "object" && Object.freeze(t4), await D5("plugin:dialog|open", { options: t4 });
}
async function pie(t4 = {}) {
  return typeof t4 == "object" && Object.freeze(t4), await D5("plugin:dialog|save", { options: t4 });
}
async function gie(t4, e) {
  (window == null ? void 0 : window.__TAURI__) ? await Oie(t4, e) : mie(t4, e);
}
function mie(t4, e) {
  const n = new Blob([t4], { type: "text/yaml" }), r = URL.createObjectURL(n), i = document.createElement("a");
  i.href = r, i.download = `${e}.yaml`, document.body.appendChild(i), i.click(), document.body.removeChild(i), URL.revokeObjectURL(r);
}
async function Oie(t4, e) {
  try {
    const n = await pie({
      title: "Save your file",
      defaultPath: e,
      filters: [
        { name: "YAML files", extensions: ["yaml", "yml"] },
        { name: "JSON files", extensions: ["json"] }
      ]
    });
    if (!n)
      return;
    await die(n, t4);
  } catch (n) {
    console.error("Error saving the file:", n);
  }
}
function xie({ folder: t4, level: e, siblingItems: n, expanded: r, onRemove: i }) {
  const o = je(), { sendEvent: s } = gt(), a = Ke(null), { state: l, name: c } = t4.get(), [u, f] = fe(false), d = We(
    () => t4.items.get().some((b) => b.value.state === bt.Draft),
    [t4.items]
  ), h = () => {
    t4.state.set(bt.Normal), s("collections_folder_editing_cancelled", { name: t4.name.get() });
  }, p = (b) => {
    t4.state.get() === bt.Draft ? s("collections_folder_creation_finished", { name: b }) : s("collections_folder_edited", { name: t4.name.get(), newName: b }), b.length && t4.name.set(b), t4.state.set(bt.Normal);
  }, O = () => {
    var w;
    if (d)
      return;
    (w = a.current) == null || w.setIsExpanded(true);
    const b = _a(t4.items.get(), "New Folder");
    t4.items.set((C) => [
      {
        type: dn.Folder,
        value: {
          id: crypto.randomUUID(),
          state: bt.Draft,
          name: b,
          items: []
        }
      },
      ...C
    ]), s("collections_folder_creation_started", {});
  }, m = () => {
    var w;
    if (d)
      return;
    (w = a.current) == null || w.setIsExpanded(true);
    const b = _a(t4.items.get(), "New Request");
    t4.items.set((C) => [
      ...C,
      {
        type: dn.Request,
        value: {
          id: crypto.randomUUID(),
          state: bt.Draft,
          name: b,
          request: zc().request,
          response: null
        }
      }
    ]), s("collections_request_creation_started", {});
  }, x = () => {
    t4.state.set(bt.Edit), s("collections_folder_editing_started", { name: t4.name.get() });
  }, v = async () => {
    const b = Nre(t4, o.get()), w = $5.dump(b);
    await gie(w, b.workflows[0].workflowId), s("collections_export_clicked", { name: t4.name });
  }, y = () => /* @__PURE__ */ g.jsxs(g.Fragment, { children: [
    /* @__PURE__ */ g.jsx(Ws, { variant: "text", size: "small", icon: /* @__PURE__ */ g.jsx(DocumentAddIcon, {}), onClick: m }),
    /* @__PURE__ */ g.jsx(Ws, { variant: "text", size: "small", icon: /* @__PURE__ */ g.jsx(ExportIcon, {}), onClick: v }),
    /* @__PURE__ */ g.jsx(
      Dropdown,
      {
        trigger: /* @__PURE__ */ g.jsx(Ws, { variant: "text", size: "small", icon: /* @__PURE__ */ g.jsx(OverflowMenuVerticalIcon, {}) }),
        alignment: "end",
        children: /* @__PURE__ */ g.jsxs(DropdownMenu, { children: [
          /* @__PURE__ */ g.jsxs(kl, { onClick: O, children: [
            /* @__PURE__ */ g.jsx(FolderAddIcon, { size: "14px" }),
            "New Folder"
          ] }),
          /* @__PURE__ */ g.jsxs(kl, { onClick: x, children: [
            /* @__PURE__ */ g.jsx(EditIcon, { size: "14px" }),
            "Edit"
          ] }),
          /* @__PURE__ */ g.jsx(
            Ba,
            {
              description: "Are you sure you want to delete this collection?",
              onConfirm: i,
              onVisibilityChange: f,
              children: /* @__PURE__ */ g.jsxs(kl, { children: [
                /* @__PURE__ */ g.jsx(TrashCanIcon, { size: "14px" }),
                "Delete"
              ] })
            }
          )
        ] })
      }
    )
  ] }), S = () => /* @__PURE__ */ g.jsxs(g.Fragment, { children: [
    /* @__PURE__ */ g.jsx(Ws, { variant: "text", size: "small", icon: /* @__PURE__ */ g.jsx(DocumentAddIcon, {}), onClick: m }),
    /* @__PURE__ */ g.jsx(Ws, { variant: "text", size: "small", icon: /* @__PURE__ */ g.jsx(FolderAddIcon, {}), onClick: O }),
    /* @__PURE__ */ g.jsx(
      Dropdown,
      {
        trigger: /* @__PURE__ */ g.jsx(Ws, { variant: "text", size: "small", icon: /* @__PURE__ */ g.jsx(OverflowMenuVerticalIcon, {}) }),
        alignment: "end",
        children: /* @__PURE__ */ g.jsxs(DropdownMenu, { children: [
          /* @__PURE__ */ g.jsxs(kl, { onClick: x, children: [
            /* @__PURE__ */ g.jsx(EditIcon, { size: "14px" }),
            "Edit"
          ] }),
          /* @__PURE__ */ g.jsx(
            Ba,
            {
              description: "Are you sure you want to delete this folder?",
              onConfirm: i,
              onVisibilityChange: f,
              children: /* @__PURE__ */ g.jsxs(kl, { children: [
                /* @__PURE__ */ g.jsx(TrashCanIcon, { size: "14px" }),
                "Delete"
              ] })
            }
          )
        ] })
      }
    )
  ] });
  return l !== bt.Normal ? /* @__PURE__ */ g.jsx(
    Av,
    {
      siblingItems: n,
      defaultName: c,
      level: e,
      onSave: p,
      onCancel: l === bt.Draft ? i : h,
      placeholder: e === 0 ? "New Collection" : "New Folder",
      icon: /* @__PURE__ */ g.jsx(FolderAddIcon, { size: "14px", color: "--icon-color-disabled" })
    }
  ) : /* @__PURE__ */ g.jsx(
    jre,
    {
      ref: a,
      title: c,
      level: e,
      active: u,
      defaultExpanded: r,
      controls: /* @__PURE__ */ g.jsx(vie, { children: e === 0 ? y() : S() }),
      children: /* @__PURE__ */ g.jsxs(yie, { children: [
        t4.items.length ? null : /* @__PURE__ */ g.jsxs(bie, { $level: e + 1, children: [
          "This ",
          e === 0 ? "collection" : "folder",
          " is empty"
        ] }),
        t4.items.map((b) => /* @__PURE__ */ g.jsx(
          _5,
          {
            item: b,
            itemList: t4.items,
            level: e + 1
          },
          b.get().value.id
        ))
      ] })
    }
  );
}
var vie = I.div`
  display: flex;
  flex-direction: row;
  gap: var(--spacing-xxs);
`;
var yie = I.div`
  display: flex;
  width: 100%;
  flex-direction: column;
  justify-content: center;
  align-items: flex-start;
  gap: 2px;
  flex: 1 0 0;
`;
var bie = I.div`
  display: flex;
  align-items: center;
  height: 32px;
  font-size: var(--font-size-base);
  color: var(--text-color-description);
  padding: ${({ $level: t4 }) => `var(--spacing-xxs) var(--spacing-xs) var(--spacing-xxs) calc(var(--spacing-sm) - 1px + ${t4} * var(--spacing-base))`};
`;
var Ws = I(Button)`
  & + & {
    margin-left: 0;
  }
`;
var kl = I.span`
  gap: var(--spacing-xs);
  display: flex;
  padding: var(--spacing-xs) var(--spacing-md);
  align-items: center;
  width: 156px;
  height: 32px;
  border-radius: var(--border-radius);

  &:hover {
    background-color: var(--bg-color-hover);
  }
`;
function Sie({
  children: t4,
  controls: e,
  onClick: n,
  level: r = 0,
  active: i,
  showControlsOnHover: o = false,
  dataTestId: s
}) {
  const a = (l) => {
    (l.key === " " || l.key === "Enter") && (l.preventDefault(), n == null || n());
  };
  return /* @__PURE__ */ g.jsxs(
    wie,
    {
      tabIndex: 0,
      role: "listitem",
      onKeyDown: a,
      onClick: n,
      "data-testid": s,
      $level: r,
      $active: !!i,
      children: [
        /* @__PURE__ */ g.jsx(Cie, { className: "accordion-item-content", children: t4 }),
        /* @__PURE__ */ g.jsx(Q5, { children: /* @__PURE__ */ g.jsx(B5, { $showControlsOnHover: o, onClick: (l) => l.stopPropagation(), children: e }) })
      ]
    }
  );
}
var Q5 = I.div`
  display: flex;
  flex-direction: row;
`;
var B5 = I(Q5)`
  display: ${({ $showControlsOnHover: t4 }) => t4 ? "none" : "flex"};
  padding-right: var(--spacing-xs);
`;
var wie = I.div`
  width: 100%;
  height: 32px;
  max-height: 100%;
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: var(--spacing-xxs);
  padding: ${({ $level: t4 }) => `var(--spacing-xxs) var(--spacing-xs) var(--spacing-xxs) calc(var(--spacing-sm) - 1px + ${t4} * var(--spacing-base))`};

  &:hover {
    background-color: var(--bg-color-hover);

    ${B5} {
      display: flex;
    }
  }

  &:hover,
  &:not(:hover) {
    ${({ $active: t4 }) => t4 && " background-color: var(--bg-color-active);"}
  }
`;
var Cie = I.div`
  max-width: 30vw;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: flex-start;
  gap: 2px;
`;
function kie({
  defaultName: t4,
  onChange: e,
  onSave: n,
  onCancel: r,
  before: i,
  level: o = 0,
  placeholder: s = "New Request",
  siblingItems: a
}) {
  const { newName: l, setNewName: c, disabled: u } = kv(t4, a), f = Ke(null), d = l.trim();
  _e(() => {
    var O;
    (O = f.current) == null || O.focus();
  }, [f]);
  const h = Ue(
    (O) => {
      O.key === "Escape" && (r == null || r()), O.key === "Enter" && !u && n(d);
    },
    [r, n, d, u]
  ), p = (O) => {
    c(O.target.value), e == null || e(O);
  };
  return /* @__PURE__ */ g.jsx(Fo, { onClickOutside: r, children: /* @__PURE__ */ g.jsxs(Aie, { $level: o, onKeyDown: h, children: [
    i,
    /* @__PURE__ */ g.jsx(
      us,
      {
        ref: f,
        "data-testid": "edit-item-header-input",
        type: "text",
        placeholder: s,
        value: l,
        onChange: p
      }
    ),
    /* @__PURE__ */ g.jsx(
      Fk,
      {
        "data-testid": "edit-item-header-save-button",
        variant: "primary",
        size: "small",
        onClick: () => n(d),
        disabled: u,
        icon: /* @__PURE__ */ g.jsx(CheckmarkIcon, {})
      }
    ),
    /* @__PURE__ */ g.jsx(
      Fk,
      {
        "data-testid": "edit-item-header-cancel-button",
        variant: "text",
        size: "small",
        onClick: r,
        icon: /* @__PURE__ */ g.jsx(CloseIcon, {})
      }
    )
  ] }) });
}
var Aie = I.div`
  display: flex;
  align-items: center;
  gap: 4px;
  align-self: stretch;
  padding: ${({ $level: t4 }) => `var(--spacing-xxs) var(--spacing-xs) var(--spacing-xxs) calc(var(--spacing-sm) - 1px + ${t4} * var(--spacing-base))`};

  background-color: var(--bg-color-active);
  height: 32px;
`;
var Fk = I(Button)`
  border: none;

  & + & {
    margin-left: 0;
  }
`;
function Pie({ item: t4, level: e, siblingItems: n, onRemove: r }) {
  var O;
  const { requestError: i, transactionSource: o } = je(), { updateTransaction: s } = Rh(), { sendEvent: a } = gt(), { state: l, name: c } = t4.get(), u = () => {
    t4.state.set(bt.Normal), a("collections_request_editing_cancelled", { name: t4.name.get() });
  }, f = (m) => {
    m.length && t4.name.set(m), t4.state.set(bt.Normal), a("collections_request_edited", { name: t4.name.get(), newName: m });
  }, d = () => {
    i.set(null), s(
      {
        request: t4.request.get({ noproxy: true }),
        response: t4.response.get({ noproxy: true })
      },
      {
        id: t4.id.get(),
        type: "collection",
        name: t4.name.get()
      }
    ), a("collections_request_clicked", { name: t4.name.get() });
  }, h = () => {
    t4.state.set(bt.Edit), a("collections_request_editing_started", { name: t4.name.get() });
  }, p = ((O = o.get()) == null ? void 0 : O.id) === t4.id.get();
  return l === bt.Edit ? /* @__PURE__ */ g.jsx(
    kie,
    {
      defaultName: c,
      before: /* @__PURE__ */ g.jsx(bO, { value: t4.request.method.get() }),
      level: e,
      siblingItems: n,
      onSave: f,
      onCancel: u
    }
  ) : l === bt.Draft ? /* @__PURE__ */ g.jsx(
    Av,
    {
      siblingItems: n,
      defaultName: c,
      level: e,
      onSave: f,
      onCancel: r,
      placeholder: "New Request",
      icon: /* @__PURE__ */ g.jsx(DocumentAddIcon, { size: "14px", color: "--icon-color-disabled" })
    }
  ) : /* @__PURE__ */ g.jsx(
    Sie,
    {
      level: e,
      active: p,
      showControlsOnHover: true,
      onClick: d,
      controls: /* @__PURE__ */ g.jsxs(Eie, { children: [
        /* @__PURE__ */ g.jsx(Zk, { variant: "text", size: "small", onClick: h, icon: /* @__PURE__ */ g.jsx(EditIcon, {}) }),
        /* @__PURE__ */ g.jsx(
          Zk,
          {
            variant: "text",
            size: "small",
            onClick: r,
            icon: /* @__PURE__ */ g.jsx(TrashCanIcon, { color: "--color-error-base" })
          }
        )
      ] }),
      children: /* @__PURE__ */ g.jsxs(Tie, { children: [
        /* @__PURE__ */ g.jsx(bO, { value: t4.request.method.get() }),
        /* @__PURE__ */ g.jsx(Iie, { children: t4.name.get() })
      ] }, `${t4.id}`)
    }
  );
}
var Eie = I.div`
  display: flex;
  flex-direction: row;
  gap: var(--spacing-xxs);
`;
var Tie = I.div`
  width: 100%;
  display: flex;
  flex-direction: row;
  flex-shrink: 0;
  gap: var(--spacing-xxs);
  cursor: pointer;
  min-width: 0;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
  align-items: center;
`;
var Iie = I.span`
  font-size: var(--font-size-base);
  font-weight: var(--font-weight-regular);
  line-height: var(--line-height-base);
  color: var(--text-color-primary);
  text-overflow: ellipsis;
  overflow: hidden;
  white-space: nowrap;
`;
var Zk = I(Button)`
  & + & {
    margin-left: 0;
  }
`;
function _5({ item: t4, level: e, itemList: n, expanded: r }) {
  const { transactionSource: i } = je(), o = yv(), { sendEvent: s } = gt(), a = () => {
    t4.get().value.state === bt.Draft ? s("collections_folder_creation_cancelled", {}) : s("collections_folder_removed", { name: t4.get().value.name }), c(t4.get({ noproxy: true }).value) && i.set(null), t4.set(pt);
  }, l = () => {
    const u = t4.get({ noproxy: true }).value;
    t4.get().value.state === bt.Draft ? s("collections_request_creation_cancelled", {}) : s("collections_request_removed", { name: u.name }), (o == null ? void 0 : o.get().id) === u.id && i.set(null), t4.set(pt);
  }, c = (u) => u.items.some((f) => f.type === dn.Folder ? c(f.value) : (o == null ? void 0 : o.get().id) === f.value.id);
  return t4.get().type === dn.Folder ? /* @__PURE__ */ g.jsx(
    xie,
    {
      folder: t4.nested("value"),
      siblingItems: n,
      onRemove: a,
      level: e,
      expanded: r
    }
  ) : /* @__PURE__ */ g.jsx(
    Pie,
    {
      item: t4.nested("value"),
      siblingItems: n,
      level: e,
      onRemove: l
    }
  );
}
async function $ie() {
  const t4 = document.createElement("input");
  return t4.type = "file", t4.accept = ".json, .yaml, .yml", new Promise((e, n) => {
    const r = (i) => {
      var c;
      const s = (c = i.target.files) == null ? void 0 : c[0];
      if (!s) {
        n(new Error("No file selected."));
        return;
      }
      const a = s.name.toLowerCase();
      if (!a.endsWith(".json") && !a.endsWith(".yaml") && !a.endsWith(".yml")) {
        n(new Error("Please select a JSON, YAML, or YML file."));
        return;
      }
      const l = new FileReader();
      l.onload = (u) => {
        var d;
        const f = (d = u.target) == null ? void 0 : d.result;
        typeof f == "string" ? e(f) : n(new Error("Failed to read file content."));
      }, l.onerror = () => {
        n(new Error("Error reading file."));
      }, l.readAsText(s), t4.removeEventListener("change", r);
    };
    t4.addEventListener("change", r), t4.click();
  });
}
var TO = /* @__PURE__ */ ((t4) => (t4[t4.NoRequestItemsError = 0] = "NoRequestItemsError", t4[t4.RequestItemsParseError = 1] = "RequestItemsParseError", t4))(TO || {});
function jie(t4) {
  const e = {
    type: dn.Folder,
    value: {
      id: crypto.randomUUID(),
      state: bt.Normal,
      name: IO(t4.workflows[0].workflowId),
      items: Rie(t4.workflows[0].steps)
    }
  }, n = M5(e);
  return n === 0 ? {
    data: null,
    error: 0
    /* NoRequestItemsError */
  } : n < t4.workflows[0].steps.length ? {
    data: e,
    error: 1
    /* RequestItemsParseError */
  } : { data: e };
}
function Rie(t4) {
  const e = [];
  return t4.forEach((n) => {
    const r = n.stepId.split("/");
    let i = e;
    r.forEach((o, s) => {
      if (s === r.length - 1) {
        const a = Die(n, i);
        a && i.push(a);
      } else
        i = Qie(i, o).value.items;
    });
  }), e;
}
function Die(t4, e) {
  var n;
  try {
    const r = _a(e, t4.description);
    return {
      type: dn.Request,
      value: {
        id: crypto.randomUUID(),
        state: bt.Normal,
        name: r,
        request: {
          method: t4["x-operation"].method.toUpperCase(),
          url: t4["x-replay"].path,
          security: Bie(t4["x-replay"].securities),
          body: _ie({
            contentType: (n = t4.requestBody) == null ? void 0 : n.contentType,
            payload: t4["x-replay"].body
          }),
          queryParameters: H0(t4["x-replay"].parameters, "query"),
          headers: H0(t4["x-replay"].parameters, "header"),
          cookies: H0(t4["x-replay"].parameters, "cookie")
        },
        response: null
      }
    };
  } catch {
    return null;
  }
}
function Qie(t4, e) {
  let n = t4.find(
    (r) => r.type === dn.Folder && r.value.name === IO(e)
  );
  return n || (n = {
    type: dn.Folder,
    value: {
      id: crypto.randomUUID(),
      state: bt.Normal,
      name: IO(e),
      items: []
    }
  }, t4.push(n)), n;
}
function Bie(t4) {
  return {
    securitySchemeVariants: [],
    selectedSecuritySchemeId: "",
    securities: t4.map((e) => {
      const n = ks(), r = e.type;
      return {
        ...n,
        securityType: e.type,
        [e.type]: {
          ...n[r],
          ...e.data
        }
      };
    })
  };
}
function _ie(t4) {
  if (!(t4 != null && t4.payload) || !(t4 != null && t4.contentType))
    return {
      ...po(),
      type: ut.Text
    };
  const { contentType: e, payload: n } = t4;
  switch (e) {
    case ut.JSON:
    case ut.HTML:
    case ut.XML:
    case ut.Text:
      return {
        ...po(),
        type: e,
        content: JSON.parse(n)
      };
    case ut.FormData:
      return {
        ...po(),
        type: e,
        formData: {
          "multipart/form-data": Wk(n),
          "application/x-www-form-urlencoded": []
        }
      };
    case ut["application/x-www-form-urlencoded"]:
      return {
        ...po(),
        type: e,
        formData: {
          "multipart/form-data": [],
          "application/x-www-form-urlencoded": Wk(n)
        }
      };
    default:
      return {
        ...po(),
        type: ut.Text
      };
  }
}
function Wk(t4) {
  return JSON.parse(t4).map((e) => ({
    id: crypto.randomUUID(),
    key: e.key,
    value: e.value,
    active: true,
    type: "text"
  }));
}
function H0(t4, e) {
  const n = t4.filter(({ in: r }) => r === e).map(({ value: r, name: i }) => ({
    id: crypto.randomUUID(),
    key: i,
    active: true,
    value: r
  }));
  return n.push(mn()), n;
}
function IO(t4) {
  return t4.replace(/-/g, " ");
}
function M5(t4) {
  return t4.type === dn.Request ? 1 : t4.type === dn.Folder ? t4.value.items.reduce((n, r) => n + M5(r), 0) : 0;
}
function Vk({
  icon: t4,
  title: e,
  description: n,
  cancelButtonLabel: r,
  submitButtonLabel: i,
  onClose: o,
  onSubmit: s
}) {
  return /* @__PURE__ */ g.jsxs(g.Fragment, { children: [
    /* @__PURE__ */ g.jsxs(Mie, { children: [
      t4,
      /* @__PURE__ */ g.jsx(Nie, { children: e }),
      /* @__PURE__ */ g.jsx(Fie, { children: n })
    ] }),
    /* @__PURE__ */ g.jsxs(Zie, { children: [
      /* @__PURE__ */ g.jsx(Button, { variant: "outlined", onClick: o, children: r }),
      /* @__PURE__ */ g.jsx(Button, { variant: "primary", onClick: s, children: i })
    ] })
  ] });
}
var Mie = I.div`
  display: flex;
  flex-direction: column;
  align-items: center;
  margin-bottom: var(--spacing-xxl);
`;
var Nie = I.h6`
  font-size: var(--font-size-lg);
  font-weight: var(--font-weight-medium);
  line-height: var(--line-height-lg);
  margin: var(--spacing-sm) 0;
`;
var Fie = I.p`
  font-size: var(--font-size-base);
  font-weight: var(--font-weight-regular);
  line-height: var(--line-height-base);
  color: var(--text-color-secondary);
  text-align: center;
  max-width: 35%;
  margin: 0;
`;
var Zie = I.div`
  display: flex;
  justify-content: flex-end;
  gap: var(--spacing-xs);
`;
function Wie() {
  const [t4, e] = fe(""), { collections: n } = je(), r = Wg(), i = Wg(), { sendEvent: o } = gt(), [s, a] = fe(null), l = We(
    () => n.get().some((O) => O.value.state === bt.Draft),
    [n]
  ), c = We(
    () => n.filter((O) => t4 ? O.get().value.name.toLowerCase().includes(t4.toLowerCase()) : true),
    [n, t4]
  ), u = We(
    () => c.sort((O) => {
      const { value: m, type: x } = O.get();
      return x === dn.Folder ? m.state === bt.Draft ? -1 : 0 : 1;
    }),
    [c]
  ), f = () => {
    if (l)
      return;
    e("");
    const O = _a(n.get(), "New Collection");
    n.set((m) => [
      ...m,
      {
        type: dn.Folder,
        value: {
          id: crypto.randomUUID(),
          state: bt.Draft,
          name: O,
          items: []
        }
      }
    ]), o("collections_folder_creation_started", {});
  }, d = (O) => {
    e(O);
  }, h = async () => {
    r.handleClose(), i.handleClose();
    try {
      const O = await $ie(), m = $5.load(O), { data: x, error: v } = jie(m);
      x && (x.value.name = _a(n.get(), x.value.name)), v === TO.RequestItemsParseError ? (a(x), i.handleOpen(), o("collections_file_import_warning", {})) : v === TO.NoRequestItemsError ? (r.handleOpen(), o("collections_file_import_error", {})) : x && (n.set((y) => [...y, x]), o("collections_file_imported", {}));
    } catch (O) {
      r.handleOpen(), o("collections_file_import_error", { error: O.message });
    }
  }, p = () => {
    s && (n.set((O) => [...O, s]), i.handleClose(), a(null), o("collections_accept_valid_items_clicked", {}));
  };
  return /* @__PURE__ */ g.jsxs(Cv, { children: [
    /* @__PURE__ */ g.jsx(Xc, { children: /* @__PURE__ */ g.jsx(Lc, { value: t4, onSearch: d }) }),
    /* @__PURE__ */ g.jsxs(HK, { children: [
      /* @__PURE__ */ g.jsx(Button, { variant: "ghost", icon: /* @__PURE__ */ g.jsx(AddIcon, {}), onClick: f, children: "Create new collection" }),
      /* @__PURE__ */ g.jsx(Button, { variant: "ghost", icon: /* @__PURE__ */ g.jsx(DownloadIcon, {}), onClick: h, children: "Import Arazzo Files" })
    ] }),
    /* @__PURE__ */ g.jsxs(_h, { children: [
      !u.length && !t4 ? /* @__PURE__ */ g.jsx(Are, { onImport: h, onAddFolder: f }) : null,
      !u.length && t4 ? /* @__PURE__ */ g.jsx(Ire, {}) : null,
      u.map(
        (O, m) => O.get() && /* @__PURE__ */ g.jsx(
          _5,
          {
            item: O,
            itemList: n,
            level: 0,
            expanded: m == 0
          },
          O.get().value.id
        )
      )
    ] }),
    /* @__PURE__ */ g.jsx(
      Uf,
      {
        title: "Import Arazzo Files",
        content: /* @__PURE__ */ g.jsx(
          Vk,
          {
            icon: /* @__PURE__ */ g.jsx(CloseFilledIcon, { color: "--color-raspberry-6", size: "21px" }),
            title: "File error",
            description: "Something went wrong!",
            submitButtonLabel: "Ok",
            cancelButtonLabel: "Choose another file",
            onClose: h,
            onSubmit: r.handleClose
          }
        ),
        isOpen: r.isOpen,
        onClose: r.handleClose,
        mountId: "import-container"
      }
    ),
    /* @__PURE__ */ g.jsx(
      Uf,
      {
        title: "Import Arazzo Files",
        content: /* @__PURE__ */ g.jsx(
          Vk,
          {
            icon: /* @__PURE__ */ g.jsx(WarningFilledIcon, { color: "--color-carrot-6", size: "21px" }),
            title: "Warning",
            description: "Some items in your file are not valid. Only valid items will be uploaded.",
            submitButtonLabel: "Import valid items",
            cancelButtonLabel: "Cancel",
            onClose: i.handleClose,
            onSubmit: p
          }
        ),
        isOpen: i.isOpen,
        onClose: i.handleClose,
        mountId: "import-container"
      }
    )
  ] });
}
var Dv = (t4, e = false, n = false) => {
  const r = [];
  return e && r.push({
    key: "Request",
    label: "Request",
    children: /* @__PURE__ */ g.jsx(Bv, {})
  }), r.push({
    key: "History",
    label: "History",
    children: /* @__PURE__ */ g.jsx(gee, {}),
    flexDirection: "column"
  }), n || r.push({
    key: "Collections",
    label: "Collections",
    children: /* @__PURE__ */ g.jsx(Wie, {}),
    flexDirection: "column"
  }), r.push({
    key: "Environments",
    label: "Environments",
    children: /* @__PURE__ */ g.jsx(Wee, {}),
    flexDirection: "column"
  }), t4 || r.push({
    key: "Apps",
    label: "Apps",
    children: /* @__PURE__ */ g.jsx(ite, {}),
    flexDirection: "column"
  }), { tabsParams: r };
};
var N5 = Ac({
  isMobile: false,
  activeTab: "Request",
  MobileHeader: () => null,
  setActiveTab: () => null,
  closeButton: null
});
var sr = 800;
var F5 = ({ children: t4, closeButton: e = null }) => {
  const { apiId: n } = je(), { sendEvent: r } = gt(), [i, o] = fe(
    document.documentElement.clientWidth < sr
  ), { tabsParams: s } = Dv(n.get(), i), [a, l] = fe("Request"), c = Ue(
    (f) => {
      r("mobile_tab_changed", { name: f });
    },
    [r]
  ), u = s.map((f) => ({
    label: f.label,
    value: f.key,
    active: false
  }));
  return _e(() => {
    o(document.documentElement.clientWidth < sr);
    const f = () => {
      o(document.documentElement.clientWidth < sr);
    };
    return window.addEventListener("resize", f), () => window.removeEventListener("resize", f);
  }, []), /* @__PURE__ */ g.jsx(
    N5.Provider,
    {
      value: {
        isMobile: i,
        closeButton: e,
        MobileHeader: ({ children: f, hide: d = false }) => d || !i ? null : /* @__PURE__ */ g.jsx(zie, { children: i ? /* @__PURE__ */ g.jsxs(g.Fragment, { children: [
          i && /* @__PURE__ */ g.jsx(
            Mo,
            {
              dataTestId: "mobile-select-panel",
              options: u,
              value: u.find((h) => h.value === a),
              onChange: ({ value: h }) => {
                l(h), c(h);
              }
            }
          ),
          f,
          /* @__PURE__ */ g.jsx(Vie, { children: e })
        ] }) : f }),
        activeTab: a,
        setActiveTab: l
      },
      children: t4
    }
  );
};
var Vie = I.div`
  flex: 1;
  display: flex;
  justify-content: flex-end;

  div {
    top: 0;
    left: 0;
  }
`;
var zie = I(Xc)`
  padding: var(--spacing-xs);
  max-height: 40px;
  flex: 1;
  display: flex;
  gap: 12px;
  align-items: center;
`;
var ni = () => Ii(N5);
var Lie = ({ activeTab: t4, onChange: e }) => {
  const { isMobile: n } = ni();
  if (!n)
    return null;
  const r = Ai.find(({ name: i }) => i === (t4 == null ? void 0 : t4.name));
  return /* @__PURE__ */ g.jsx(Gie, { children: /* @__PURE__ */ g.jsx(
    Xie,
    {
      dataTestId: "request-tab-change-select",
      options: Ai.map(({ name: i }) => ({ element: i, label: i, value: i })),
      value: r == null ? void 0 : r.name,
      onChange: (i) => {
        const o = Ai.findIndex(({ name: s }) => s === i);
        o !== -1 && e(o);
      }
    }
  ) });
};
var Xie = I(Select)`
  border-radius: var(--border-radius-md);
  background-color: var(--bg-color-active);
`;
var Gie = I.div`
  display: flex;
  padding: var(--spacing-xs) var(--spacing-xs) var(--spacing-xs) var(--spacing-sm);
  border-bottom: 1px solid var(--border-color-secondary);
`;
var Yie = ({
  activeTab: t4,
  onTabChange: e
}) => {
  const { isMobile: n } = ni();
  return n ? null : /* @__PURE__ */ g.jsx(Hie, { children: Ai.map((r, i) => /* @__PURE__ */ g.jsx(_r, { children: t4.name === r.name ? /* @__PURE__ */ g.jsx(zk, { icon: r.icon, iconPosition: "left", children: r.name }) : /* @__PURE__ */ g.jsx(
    zk,
    {
      variant: "text",
      icon: r.icon,
      onClick: () => e(i),
      iconPosition: "left",
      children: r.name
    }
  ) }, r.name)) });
};
function qie() {
  const { operation: t4, requestActiveTabIdx: e } = je(), { sendEvent: n } = gt(), [r, i] = fe(Ai[e.get()]);
  _e(() => {
    var a;
    const s = (a = t4.get()) == null ? void 0 : a.body;
    e.set(s ? iK : fj);
  }, [t4]), _e(() => {
    i(Ai[e.get()]);
  }, [e]);
  const o = (s) => {
    const a = Ai[s];
    e.set(s), n("request_tab_changed", { name: a.name });
  };
  return /* @__PURE__ */ g.jsxs(Uie, { children: [
    /* @__PURE__ */ g.jsx(Lie, { activeTab: r, onChange: o }),
    /* @__PURE__ */ g.jsx(Yie, { activeTab: r, onTabChange: o }),
    /* @__PURE__ */ g.jsx(Jie, { children: /* @__PURE__ */ g.jsx(r.content, {}) })
  ] });
}
var Uie = I.div`
  display: flex;
  flex-direction: column;
  gap: var(--spacing-sm);
  height: 100%;
  overflow: auto;
`;
var Hie = I.div`
  display: flex;
  flex-direction: row;
  gap: 2px;
  padding: var(--spacing-xs) var(--spacing-lg);

  @media (max-width: ${sr}px) {
    padding: var(--spacing-xs);
  }
  overflow: auto;
`;
var zk = I(Button)`
  margin: 0;
  --button-icon-width: 16px;
  --button-icon-height: 16px;
`;
var Jie = I.div`
  overflow: auto;
  padding: 0 var(--spacing-lg);
  flex: 1;
  height: 100%;

  @media (max-width: ${sr}px) {
    padding: 0 var(--spacing-sm);
  }
`;
function Kie({ color: t4, className: e, ...n }) {
  return /* @__PURE__ */ g.jsx(
    eoe,
    {
      "data-testid": "badge",
      className: e,
      $backgroundColor: t4,
      ...n
    }
  );
}
var eoe = I.div`
  border: 1px solid var(--border-color-secondary);
  border-radius: var(--border-radius);
  background-color: ${(t4) => t4.$backgroundColor};
  width: 6px;
  height: 6px;
`;
function Lk({ isLinked: t4, onReset: e, url: n, operationName: r }) {
  const { sendEvent: i } = gt(), { isMobile: o } = ni(), s = () => {
    i("open_operation_url", { operationName: r, url: n }), n && window.open(n, "_blank");
  };
  return /* @__PURE__ */ g.jsxs(toe, { "data-testid": "request-status", children: [
    /* @__PURE__ */ g.jsx(
      Vo,
      {
        placement: "bottom",
        content: "This request has predefined data from OpenAPI definition",
        children: /* @__PURE__ */ g.jsx(
          noe,
          {
            color: t4 ? "var(--color-success-base)" : "var(--icon-color-disabled)",
            "data-testid": "linked-badge"
          }
        )
      }
    ),
    /* @__PURE__ */ g.jsx(Qe, {}),
    /* @__PURE__ */ g.jsx(
      ioe,
      {
        variant: "link",
        size: "small",
        onClick: s,
        icon: /* @__PURE__ */ g.jsx(ArrowUpRightIcon, {}),
        iconPosition: "right",
        children: r
      }
    ),
    !t4 && /* @__PURE__ */ g.jsxs(g.Fragment, { children: [
      /* @__PURE__ */ g.jsx(Qe, {}),
      /* @__PURE__ */ g.jsx(
        roe,
        {
          variant: "ghost",
          size: "small",
          icon: /* @__PURE__ */ g.jsx(RestartIcon, {}),
          onClick: e,
          iconPosition: "left",
          children: !o && "Reset request"
        }
      )
    ] })
  ] });
}
var toe = I.div`
  display: flex;
  height: var(--spacing-lg);
  align-items: center;
  border-radius: var(--border-radius);
  border: 1px solid var(--border-color-secondary);
  background-color: transparent;
`;
var noe = I(Kie)`
  margin: var(--spacing-xs) var(--spacing-xs);
`;
var roe = I(Button)`
  padding: 0 var(--spacing-xs);
`;
var ioe = I(Button)`
  padding: 0 var(--spacing-xs);
`;
var ooe = "Predefined request method from the openapi description.";
var soe = "Alternative request method types not predefined for this request.";
function aoe(t4) {
  return t4 === Vc ? ooe : soe;
}
function loe(t4) {
  return t4.map((e) => ({
    label: /* @__PURE__ */ g.jsx(Nj, { value: e }),
    value: e
  }));
}
function coe() {
  return loe(eq);
}
function uoe({
  requestName: t4,
  onClose: e,
  onDiscard: n,
  onSave: r
}) {
  const i = Ke(null);
  return useOutsideClick(i, e), useFocusTrap(i), /* @__PURE__ */ g.jsx(doe, { children: /* @__PURE__ */ g.jsxs(foe, { ref: i, tabIndex: 0, children: [
    /* @__PURE__ */ g.jsx(hoe, { onClick: e, "data-testid": "close", variant: "ghost", icon: /* @__PURE__ */ g.jsx(CloseIcon, {}) }),
    /* @__PURE__ */ g.jsx(poe, { children: "Unsaved changes" }),
    /* @__PURE__ */ g.jsxs(goe, { children: [
      "Do you want to save changes in ",
      t4 ? /* @__PURE__ */ g.jsxs(moe, { children: [
        "\u201C",
        t4,
        "\u201D"
      ] }) : "",
      " request?"
    ] }),
    /* @__PURE__ */ g.jsxs(Ooe, { children: [
      /* @__PURE__ */ g.jsx(Button, { onClick: n, variant: "secondary", children: "Don't save" }),
      /* @__PURE__ */ g.jsxs(xoe, { children: [
        /* @__PURE__ */ g.jsx(Button, { onClick: e, variant: "outlined", children: "Cancel" }),
        /* @__PURE__ */ g.jsx(Button, { onClick: r, variant: "primary", children: "Save changes" })
      ] })
    ] })
  ] }) });
}
var foe = I.div`
  background: var(--bg-color);
  box-shadow: var(--bg-raised-shadow);
  border-radius: var(--border-radius-lg);
  padding: var(--spacing-lg);
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  position: absolute;
  width: 500px;
  max-width: 100%;
  height: auto;
  max-height: 600px;
  overflow-y: scroll;
  left: 50%;
  top: 100px;
  transform: translateX(-50%);
  .tag-grey span {
    font-size: var(--font-size-base);
    line-height: var(--line-height-base);
  }
`;
var doe = I.div`
  background: var(--bg-color-modal-overlay);
  position: fixed;
  width: 100vw;
  height: 100vh;
  z-index: var(--z-index-popover);
  left: 0;
  top: 0;
  pointer-events: auto;
`;
var hoe = I(Button)`
  position: absolute;
  right: var(--spacing-md);
  top: var(--spacing-md);
`;
var poe = I(Typography)`
  display: flex;
  align-items: center;
  font-size: var(--font-size-xl);
  font-weight: var(--font-weight-semibold);
  line-height: var(--line-height-xl);
  margin-bottom: var(--spacing-base);
  svg {
    margin-right: var(--spacing-xs);
  }
`;
var goe = I.div`
  color: var(--text-color-secondary);
  font-size: var(--font-size-lg);
  line-height: var(--line-height-lg);
  margin-bottom: var(--spacing-base);
`;
var moe = I.span`
  font-weight: var(--font-weight-semibold);
`;
var Ooe = I.div`
  display: flex;
  align-self: stretch;
  justify-content: space-between;
`;
var xoe = I.div`
  display: flex;
  gap: var(--spacing-xs);
`;
function Z5() {
  var ae;
  const t4 = je(), e = hn(), { sendEvent: n } = gt(), r = yv(), { isTransactionChanged: i, onClose: o, onDiscard: s, onSave: a, updateTransaction: l } = Rh(), { isMobile: c, MobileHeader: u } = ni(), {
    request: f,
    response: d,
    operation: h,
    environments: p,
    selectedEnvironmentId: O,
    isLinked: m,
    operationUrl: x,
    isProcessingRequest: v,
    isRequestEditable: y,
    transactionSource: S,
    showUnsavedChangesModal: b,
    disableCollectionsTab: w
  } = t4, { method: C, url: k, body: T, headers: A, cookies: E, queryParameters: $, security: j } = f, B = h.get(), D = We(
    () => [B == null ? void 0 : B.method.toLocaleUpperCase()],
    [B == null ? void 0 : B.method]
  ), N = coe(), z = We(
    () => $h(D, N),
    [N, D]
  ), Z = [
    { label: "Edit", value: true },
    { label: "Preview", value: false }
  ], J = We(
    () => p.map((te) => ({
      label: /* @__PURE__ */ g.jsx("div", { children: te.get().name }),
      value: te.get().id
    })),
    [p]
  ), L = Ue(() => p.find((te) => te.get().id === O.get()), [p, O]);
  _e(() => {
    const te = L();
    p.length && (!O.get() || !te) && O.set(p[0].get().id);
  }, [p]), _e(() => {
    m.set(Kq(t4.get()));
  }, [C, k, T, A, E, $, j]), _e(() => {
    const te = x.get();
    te && hj.save(te, f.get());
  }, [f]);
  const W = () => {
    const te = B;
    te && l({ request: cv(te), response: null }, null), $$(t4), m.set(true), n("reset_request", {});
  }, R = ({ value: te }) => {
    var oe;
    O.set(te), n("change_environment", {
      name: (oe = p.find((Y) => Y.get().id === te)) == null ? void 0 : oe.get().name
    });
  }, Q = ({ value: te }) => {
    C.set(te), n("change_request_method", { name: te });
  }, _ = () => {
    qq(t4), n("request_sent", {
      url: k.get(),
      method: C.get(),
      resolvedUrl: Gt(k.get(), t4)
    });
  }, G = (te) => {
    const Y = [
      ...oU(te) || [],
      ...$.get({ noproxy: true }).filter((he) => !he.active),
      mn()
    ];
    $.set(Y);
  }, M = {
    request: An(f.get({ noproxy: true })),
    response: An(d.get({ noproxy: true }))
  }, K = () => {
    r == null || r.merge(M), S.set(S.get({ noproxy: true }));
  }, V = B && x.get();
  return /* @__PURE__ */ g.jsxs(voe, { "data-testid": "request-container", children: [
    /* @__PURE__ */ g.jsx(u, { children: V && /* @__PURE__ */ g.jsx(
      Lk,
      {
        operationName: B.name,
        onReset: W,
        isLinked: m.get({ noproxy: true }),
        url: x.get({ noproxy: true })
      }
    ) }),
    !c && /* @__PURE__ */ g.jsxs(yoe, { children: [
      /* @__PURE__ */ g.jsx(Soe, { children: "Request" }),
      V && /* @__PURE__ */ g.jsx(
        Lk,
        {
          operationName: B.name,
          onReset: W,
          isLinked: m.get({ noproxy: true }),
          url: x.get({ noproxy: true })
        }
      ),
      !w.get() && /* @__PURE__ */ g.jsxs(Eoe, { children: [
        /* @__PURE__ */ g.jsx(
          Button,
          {
            variant: "text",
            size: "small",
            icon: /* @__PURE__ */ g.jsx(SaveIcon, {}),
            disabled: !i,
            onClick: K,
            children: "Save changes"
          }
        ),
        /* @__PURE__ */ g.jsx(Qe, {}),
        /* @__PURE__ */ g.jsx(Vj, { transaction: M, children: /* @__PURE__ */ g.jsx(Button, { variant: "text", size: "small", children: "Save as" }) })
      ] })
    ] }),
    /* @__PURE__ */ g.jsxs(boe, { children: [
      /* @__PURE__ */ g.jsxs(Aoe, { children: [
        "Environment:",
        /* @__PURE__ */ g.jsx(
          koe,
          {
            dataTestId: "environment-select",
            options: J,
            value: J.find(({ value: te }) => te === O.get()),
            onChange: R
          }
        )
      ] }),
      /* @__PURE__ */ g.jsxs(Poe, { children: [
        /* @__PURE__ */ g.jsx(
          Segmented,
          {
            size: "small",
            options: Z,
            value: y.get(),
            onChange: ({ value: te }) => y.set(te)
          }
        ),
        /* @__PURE__ */ g.jsx(
          CopyButton,
          {
            data: y.get() ? k.get() : Gt(k.get(), t4),
            variant: "secondary",
            toasterPlacement: "left"
          }
        )
      ] })
    ] }),
    /* @__PURE__ */ g.jsxs(woe, { children: [
      /* @__PURE__ */ g.jsx(
        Coe,
        {
          dataTestId: "request-method-select",
          options: z,
          value: N.find(({ value: te }) => te === C.get()),
          onChange: Q,
          formatGroupLabel: (te) => /* @__PURE__ */ g.jsx(jh, { data: te, getTooltipText: aoe })
        }
      ),
      /* @__PURE__ */ g.jsx(
        rt,
        {
          dataTestId: "url-input",
          value: k.get(),
          environment: e,
          placeholder: "Enter your URL to submit the request",
          editable: y.get(),
          onChange: (te) => {
            k.set(te), G(te);
          }
        }
      ),
      /* @__PURE__ */ g.jsx(
        Button,
        {
          variant: "primary",
          size: c ? "medium" : "small ",
          icon: v.get() ? /* @__PURE__ */ g.jsx(CircleDashIcon, {}) : /* @__PURE__ */ g.jsx(ArrowRightIcon, {}),
          iconPosition: "right",
          disabled: !k.get() || v.get(),
          onClick: _,
          children: c ? null : v.get() ? "Sending" : "Send"
        }
      )
    ] }),
    /* @__PURE__ */ g.jsx(qie, {}),
    b.get() && /* @__PURE__ */ g.jsx(
      uoe,
      {
        requestName: (ae = S.get()) == null ? void 0 : ae.name,
        onClose: o,
        onDiscard: s,
        onSave: a
      }
    )
  ] });
}
var voe = I.div`
  display: flex;
  flex-direction: column;
  height: 100%;
`;
var yoe = I.div`
  display: flex;
  padding: var(--spacing-sm) var(--spacing-xs) var(--spacing-sm) var(--spacing-lg);
  align-items: center;
  gap: var(--spacing-xs);
  border-bottom: 1px solid var(--border-color-secondary);
`;
var boe = I.div`
  display: flex;
  padding: var(--spacing-xs) var(--spacing-xs) var(--spacing-xs) var(--spacing-lg);
  align-items: center;
  justify-content: space-between;
  gap: var(--spacing-xs);
  border-bottom: 1px solid var(--border-color-secondary);
  min-height: 40px;
  font-size: var(--font-size-base);
  line-height: var(--line-height-base);

  @media (max-width: ${sr}px) {
    padding: var(--spacing-xs);
  }
`;
var Soe = I.div`
  display: flex;
  align-items: center;

  color: var(--text-color-primary);
  font-size: var(--font-size-lg);
  font-weight: var(--font-weight-semibold);
  line-height: var(--line-height-lg);
`;
var woe = I.div`
  display: flex;
  flex-direction: row;
  align-items: center;
  border-bottom: 1px solid var(--border-color-secondary);
  padding: 0 var(--spacing-xs) 0 var(--spacing-base);
  gap: var(--spacing-xxs);

  @media (max-width: ${sr}px) {
    padding: 0 var(--spacing-xs);
  }
`;
var Coe = I(Mo)`
  display: flex;
  border-radius: 0;
  border-right: 1px solid var(--border-color-secondary);
  height: 100%;

  [class*='control'] {
    width: 110px;
  }

  [class*='menu'] {
    width: 110px;
  }

  [class*='MenuList'] {
    max-height: 320px;
  }

  svg {
    width: 12px;
    height: 12px;
  }

  @media (max-width: ${sr}px) {
    [class*='control'] {
      width: 80px;
    }

    [class*='menu'] {
      width: 110px;
      top: 30px;
      position: absolute;
      z-index: 103;
    }

    [class*='MenuList'] {
      max-height: 180px;
    }
  }
`;
var koe = I(Mo)`
  display: flex;
  border-radius: var(--border-radius-md);

  [class*='control'] {
    padding: 0;
    font-size: var(--font-size-base);
    font-style: normal;
    font-weight: var(--font-weight-regular);
    line-height: var(--line-height-base);
  }

  [class*='menu'] {
    min-width: 164px;
    z-index: 101;
  }

  @media (max-width: ${sr}px) {
    [class*='menu'] {
      max-width: calc(100vw - 110px);
      z-index: 101;
    }
  }

  svg {
    width: 14px;
    height: 14px;
  }
`;
var Aoe = I.div`
  display: flex;
  align-items: center;
  gap: var(--spacing-xs);
  @media (max-width: ${sr}px) {
    padding-left: var(--spacing-xs);
  }
`;
var Poe = I.div`
  display: flex;
  align-items: center;
  gap: var(--spacing-xs);
`;
var Eoe = I.div`
  display: flex;
  gap: calc(var(--spacing-xxs) / 2);
  flex-grow: 1;
  justify-content: end;
`;
function Toe(t4, e = 2) {
  if (t4 === 0)
    return "0 B";
  const n = 1024, r = e < 0 ? 0 : e, i = ["B", "kB", "MB", "GB", "TB", "PB"], o = Math.floor(Math.log(t4) / Math.log(n));
  return parseFloat((t4 / Math.pow(n, o)).toFixed(r)) + " " + i[o];
}
function W5({ panel: t4, response: e }) {
  const n = e == null ? void 0 : e.get();
  return /* @__PURE__ */ g.jsxs(Ioe, { children: [
    /* @__PURE__ */ g.jsxs($oe, { children: [
      /* @__PURE__ */ g.jsx(
        Roe,
        {
          size: "small",
          icon: t4.isCollapsed ? /* @__PURE__ */ g.jsx(ChevronRightIcon, { size: "14px", color: "--button-content-color" }) : /* @__PURE__ */ g.jsx(ChevronDownIcon, { size: "14px", color: "--button-content-color" }),
          onClick: () => t4.isCollapsed ? t4.expand() : t4.collapse()
        }
      ),
      /* @__PURE__ */ g.jsx(joe, { children: "Response" })
    ] }),
    n && /* @__PURE__ */ g.jsxs(Doe, { children: [
      /* @__PURE__ */ g.jsxs(J0, { children: [
        /* @__PURE__ */ g.jsx(StatusCode, { status: String(n.status) }),
        n.status
      ] }),
      /* @__PURE__ */ g.jsxs(J0, { children: [
        /* @__PURE__ */ g.jsx(TimeIcon, {}),
        n.duration,
        " ms"
      ] }),
      /* @__PURE__ */ g.jsxs(J0, { children: [
        /* @__PURE__ */ g.jsx(FileStorageIcon, {}),
        Toe(n.size)
      ] })
    ] })
  ] });
}
var Ioe = I.div`
  display: flex;
  justify-content: space-between;
`;
var $oe = I.div`
  display: flex;
  justify-content: space-between;
  gap: var(--spacing-xs);
  align-items: center;
`;
var joe = I.div`
  display: flex;
  align-items: center;
  flex: 1 0 0;
  color: var(--text-color-primary);
  font-size: var(--font-size-lg);
  font-weight: var(--font-weight-semibold);
  line-height: var(--line-height-lg);
`;
var Roe = I(Button)`
  height: var(--line-height-lg);
  width: var(--line-height-lg);
`;
var Doe = I.div`
  display: flex;
  align-items: center;
  gap: var(--spacing-sm);
`;
var J0 = I.div`
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: var(--spacing-xs);
  font-size: var(--font-size-base);
  line-height: var(--line-height-base);
  color: var(--text-color-primary);
  background-color: var(--layer-color);
  padding: var(--spacing-xs) var(--spacing-sm);
  border-radius: var(--border-radius-md);

  @media (max-width: ${sr}px) {
    background: none;
    text-wrap: nowrap;
    gap: var(--spacing-xs);
    padding: 0;
  }
`;
function Qoe(t4) {
  try {
    return JSON.stringify(JSON.parse(t4), null, 2);
  } catch {
    return t4;
  }
}
var Boe = (t4) => {
  var e;
  return (e = t4 == null ? void 0 : t4.find(([n]) => n.toLowerCase() === "content-type")) == null ? void 0 : e[1].split(";")[0];
};
var _oe = (t4) => {
  switch (true) {
    case t4.includes("json"):
      return $r.JSON;
    case t4.includes("xml"):
      return $r.XML;
    case t4.includes("html"):
      return $r.HTML;
    case t4.includes("image"):
      return $r.Image;
    default:
      return $r.Text;
  }
};
var Qv = I.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-size: var(--font-size-base);
  font-weight: var(--font-weight-regular);
  line-height: var(--line-height-base);
  font-style: normal;
  border-top: 1px solid var(--border-color-secondary);
  min-height: 40px;
  min-width: 500px;
`;
var V5 = I.div`
  display: flex;
  flex-direction: column;
  border-top: 1px solid var(--border-color-secondary);
  min-width: 500px;
  overflow-x: auto;
`;
var z5 = I.div`
  display: grid;
  grid-template-columns: 1fr 1fr 40px;
  align-items: center;
  border-bottom: 1px solid var(--border-color-secondary);
`;
var L5 = I.div`
  display: flex;
  flex-grow: 1;
  align-items: center;
  padding: 0;
  height: 40px;
  border-right: 1px solid var(--border-color-secondary);
  color: var(--text-color-primary);
  font-size: var(--font-size-base);
  font-weight: var(--font-weight-regular);
  line-height: var(--line-height-base);
  overflow: auto;
`;
var Fh = I.div`
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  gap: var(--spacing-xs);
  font-size: var(--font-size-base);
  line-height: var(--line-height-base);
  color: var(--text-color-description);
  text-align: center;
`;
var X5 = I.div`
  display: flex;
  align-items: center;
  justify-content: center;
  width: 40px;
`;
var G5 = I.div`
  display: flex;
  flex-grow: 1;
  align-items: center;
  padding: 0 var(--spacing-base);
  height: 40px;
  border-right: 1px solid var(--border-color-secondary);
  color: var(--text-color-primary);
  font-size: var(--font-size-base);
  font-weight: var(--font-weight-regular);
  line-height: var(--line-height-base);
  overflow: hidden;
  text-overflow: ellipsis;
`;
var Y5 = I.div`
  max-width: 100%;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
`;
function Moe(t4) {
  let e = "";
  const n = new Uint8Array(t4), r = n.byteLength;
  for (let i = 0; i < r; i++)
    e += String.fromCharCode(n[i]);
  return window.btoa(e);
}
var Noe = ({ arrayBuffer: t4 }) => /* @__PURE__ */ g.jsx(Foe, { children: /* @__PURE__ */ g.jsx(
  "img",
  {
    src: `data:image/png;base64,${Moe(t4)}`,
    className: "mx-auto",
    alt: "Response Image"
  }
) });
var Foe = I.div`
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100%;
`;
function Zoe() {
  var u, f;
  const { response: t4 } = je(), { sendEvent: e } = gt(), n = ((u = t4.get()) == null ? void 0 : u.body) || "", r = ((f = t4.get()) == null ? void 0 : f.arrayBuffer) || new ArrayBuffer(0), [i, o] = fe($r.Text), s = Object.keys(Xu).map((d) => ({
    element: /* @__PURE__ */ g.jsx("div", { children: Xu[d].name }),
    label: Xu[d].name,
    value: d
  }));
  _e(() => {
    var h;
    const d = Boe((h = t4.get()) == null ? void 0 : h.headers);
    if (d) {
      const p = _oe(d);
      o(p);
    } else
      o($r.Text);
  }, [t4]);
  const a = i === $r.JSON ? Qoe(n) : n, l = (d) => {
    o(d), e("response_body_format_changed", { name: d });
  }, c = () => {
    e("response_body_copied", {});
  };
  return /* @__PURE__ */ g.jsxs(Woe, { children: [
    /* @__PURE__ */ g.jsxs(Qv, { children: [
      /* @__PURE__ */ g.jsxs(Voe, { children: [
        "Response body",
        /* @__PURE__ */ g.jsx(
          zoe,
          {
            options: s,
            value: { value: i, label: Xu[i].name },
            onChange: (d) => l(d)
          }
        )
      ] }),
      /* @__PURE__ */ g.jsx(X5, { children: /* @__PURE__ */ g.jsx(CopyButton, { toasterPlacement: "left", data: a, onCopyClick: c }) })
    ] }),
    /* @__PURE__ */ g.jsx(Fe, {}),
    Qd[i] ? /* @__PURE__ */ g.jsx(
      Sd,
      {
        readOnly: true,
        dataTestId: "response-body-tab-codemirror",
        value: a,
        extensions: Qd[i].extensions
      }
    ) : i === $r.Image ? /* @__PURE__ */ g.jsx(Noe, { arrayBuffer: r }) : i === $r.HTML ? /* @__PURE__ */ g.jsx(
      "iframe",
      {
        srcDoc: a,
        style: { width: "100%", height: "100%", border: "none" },
        title: "HTML Content",
        sandbox: "allow-same-origin"
      }
    ) : /* @__PURE__ */ g.jsx("div", { children: "No content available" })
  ] });
}
var Woe = I.div`
  display: flex;
  flex-direction: column;
  overflow: auto;
  border-bottom: 1px solid var(--border-color-secondary);
  height: 100%;
`;
var Voe = I.div`
  display: flex;
  flex-direction: row;
  align-items: center;
`;
var zoe = I(Select)`
  display: flex;
  border-radius: var(--border-radius-md);
  --select-border: none;
  --select-input-padding: var(--select-input-padding-vertical) var(--spacing-xs);

  svg {
    width: 12px;
    height: 12px;
  }
`;
function Loe() {
  const { response: t4 } = je(), { sendEvent: e } = gt(), n = We(() => {
    var s;
    return ((s = t4.get()) == null ? void 0 : s.headers) || [];
  }, [t4]), r = We(
    () => n.map(([s, a]) => `${s}: ${a}`).join(`
`),
    [n]
  ), i = () => {
    e("response_header_copied", {});
  }, o = () => {
    e("response_all_headers_copied", {});
  };
  return /* @__PURE__ */ g.jsxs(Xoe, { children: [
    /* @__PURE__ */ g.jsxs(Qv, { children: [
      /* @__PURE__ */ g.jsx(Yoe, { children: "Header list" }),
      /* @__PURE__ */ g.jsx(X5, { children: /* @__PURE__ */ g.jsx(
        CopyButton,
        {
          toasterPlacement: "left",
          data: r,
          onCopyClick: o
        }
      ) })
    ] }),
    /* @__PURE__ */ g.jsx(V5, { children: n.map(([s, a]) => /* @__PURE__ */ g.jsxs(z5, { children: [
      /* @__PURE__ */ g.jsx(L5, { "data-testid": `response-header-key-${s}`, children: s }),
      /* @__PURE__ */ g.jsx(G5, { "data-testid": `response-header-value-${s}`, children: /* @__PURE__ */ g.jsx(Vo, { mouseEnterDelay: 1, placement: "top", content: a, showArrow: false, children: /* @__PURE__ */ g.jsx(Y5, { children: a }) }) }),
      /* @__PURE__ */ g.jsx(
        Goe,
        {
          toasterPlacement: "left",
          data: a,
          onCopyClick: i
        }
      )
    ] }, s)) })
  ] });
}
var Xoe = I.div`
  display: flex;
  flex-direction: column;
  overflow: auto;
`;
var Goe = I(CopyButton)`
  justify-self: center;
`;
var Yoe = I.span``;
function qoe() {
  var n;
  const { response: t4 } = je(), e = (n = t4.get()) == null ? void 0 : n.cookies;
  return e != null && e.length ? /* @__PURE__ */ g.jsxs(Uoe, { children: [
    /* @__PURE__ */ g.jsx(Qv, { children: "Cookies list" }),
    /* @__PURE__ */ g.jsx(V5, { children: (e || []).map(([r, i]) => /* @__PURE__ */ g.jsxs(z5, { children: [
      /* @__PURE__ */ g.jsx(L5, { children: r }),
      /* @__PURE__ */ g.jsx(Hoe, { children: /* @__PURE__ */ g.jsx(
        Vo,
        {
          mouseEnterDelay: 1,
          placement: "top",
          content: /* @__PURE__ */ g.jsx(Joe, { children: i }),
          showArrow: false,
          children: /* @__PURE__ */ g.jsx(Y5, { children: i })
        }
      ) })
    ] }, r)) })
  ] }) : /* @__PURE__ */ g.jsx(Fh, { children: "No cookies were received from the server." });
}
var Uoe = I.div`
  display: flex;
  flex-direction: column;
  overflow: auto;
  height: 100%;
`;
var Hoe = I(G5)`
  border-right: none;
`;
var Joe = I(No)`
  padding: var(--spacing-unit) var(--spacing-xs);
  font-size: var(--font-size-base);
  font-weight: var(--font-weight-regular);
  line-height: var(--line-height-base);
  word-break: break-word;
  overflow-wrap: break-word;
  max-width: 400px;
`;
var Xk = [
  {
    name: "Body",
    content: /* @__PURE__ */ g.jsx(Zoe, {}),
    icon: /* @__PURE__ */ g.jsx(CodeIcon, {})
  },
  {
    name: "Headers",
    content: /* @__PURE__ */ g.jsx(Loe, {}),
    icon: /* @__PURE__ */ g.jsx(TableBuiltIcon, {})
  },
  {
    name: "Cookies",
    content: /* @__PURE__ */ g.jsx(qoe, {}),
    icon: /* @__PURE__ */ g.jsx(CookieIcon, {})
  }
];
function Koe() {
  const { sendEvent: t4 } = gt(), [e, n] = fe(Xk[0]), r = (i) => {
    n(i), t4("response_tab_changed", { name: i.name });
  };
  return /* @__PURE__ */ g.jsxs(ese, { children: [
    /* @__PURE__ */ g.jsx(tse, { children: Xk.map((i) => /* @__PURE__ */ g.jsx(_r, { children: e === i ? /* @__PURE__ */ g.jsx(Gk, { icon: i.icon, iconPosition: "left", children: i.name }) : /* @__PURE__ */ g.jsx(
      Gk,
      {
        icon: i.icon,
        variant: "text",
        onClick: () => r(i),
        iconPosition: "left",
        children: i.name
      }
    ) }, i.name)) }),
    e.content
  ] });
}
var ese = I.div`
  display: flex;
  flex-direction: column;
  padding: var(--spacing-base) 0 var(--spacing-unit) 0;
  gap: var(--spacing-sm);
  height: calc(100% - 38px);
`;
var tse = I.div`
  display: flex;
  flex-direction: row;
  gap: 2px;
`;
var Gk = I(Button)`
  font-size: var(--font-size-base);
  font-weight: var(--font-weight-regular);
  line-height: var(--line-height-base);
  padding: var(--spacing-xxs) var(--spacing-base);
  margin: 0;
`;
function nse({ onClose: t4 }) {
  return /* @__PURE__ */ g.jsxs(Fh, { children: [
    /* @__PURE__ */ g.jsx(Spinner, { size: "20px", color: "--color-info-base" }),
    /* @__PURE__ */ g.jsx(sse, { children: "Sending request ..." }),
    /* @__PURE__ */ g.jsx(Button, { onClick: t4, children: "Cancel request" })
  ] });
}
function rse() {
  return /* @__PURE__ */ g.jsxs(Fh, { "data-testid": "empty-response", children: [
    "No response received yet.",
    /* @__PURE__ */ g.jsx("br", {}),
    "Click \u201CSend\u201D to start a request and see the response here!"
  ] });
}
function ise() {
  return /* @__PURE__ */ g.jsxs(Fh, { children: [
    /* @__PURE__ */ g.jsx("h3", { children: "Could not get a response." }),
    "Something went wrong, please review",
    /* @__PURE__ */ g.jsx("br", {}),
    "your request and try again"
  ] });
}
function q5({ panel: t4 }) {
  const { response: e, requestError: n, isProcessingRequest: r, requestController: i } = je(), o = r.get();
  function s() {
    var a;
    (a = i == null ? void 0 : i.get()) == null || a.abort();
  }
  return /* @__PURE__ */ g.jsxs(ose, { "data-testid": "response-container", isCollapsed: t4.isCollapsed, children: [
    /* @__PURE__ */ g.jsx(W5, { panel: t4, response: e }),
    o && /* @__PURE__ */ g.jsx(nse, { onClose: s }),
    !o && n.get() && /* @__PURE__ */ g.jsx(ise, {}),
    !o && !e.get() && !t4.isCollapsed && !n.get() && /* @__PURE__ */ g.jsx(rse, {}),
    !o && e.get() && !t4.isCollapsed && !n.get() && /* @__PURE__ */ g.jsx(Koe, {})
  ] });
}
var ose = I.div`
  padding: 0 var(--spacing-lg) var(--spacing-sm);
  height: 100%;

  @media (max-width: ${sr}px) {
    padding: var(--spacing-xs) var(--spacing-sm);
    background-color: var(--bg-color);
  }
`;
var sse = I.h5`
  margin: 0;
  font-size: var(--font-size-base);
  color: var(--text-color-primary);
  font-weight: var(--font-weight-semibold);
`;
function ase(t4) {
  _e(() => {
    Dl.save(t4.get());
  }, [t4]);
}
var lse = () => {
  const [t4, e] = fe(true);
  return /* @__PURE__ */ g.jsxs(g.Fragment, { children: [
    /* @__PURE__ */ g.jsx(use, { isCollapsed: t4, children: /* @__PURE__ */ g.jsx(Z5, {}) }),
    /* @__PURE__ */ g.jsx(cse, { isCollapsed: t4, children: /* @__PURE__ */ g.jsx(
      q5,
      {
        panel: {
          isCollapsed: t4,
          expand: () => {
            e(!t4);
          },
          collapse: () => {
            e(!t4);
          },
          toggle: () => {
          }
        }
      }
    ) })
  ] });
};
var cse = I.div`
  height: ${({ isCollapsed: t4 }) => t4 ? "40px" : "100%"};
  z-index: 102;
`;
var use = I.div`
  height: ${({ isCollapsed: t4 }) => t4 ? "calc(100vh - 40px)" : "321px"};
  z-index: 100;
`;
function Bv() {
  const { response: t4, environments: e } = je(), n = t4.get(), r = [50, 50], i = Ke(null), [o, s] = fe(true), a = DK(), { isMobile: l } = ni();
  ase(e), _e(() => {
    var u, f;
    n && o && (((u = i.current) == null ? void 0 : u.getLayout()[1]) || 0) === 25 && ((f = i.current) == null || f.setLayout(r));
  }, [n, o]);
  const c = () => {
    var u;
    (u = i.current) == null || u.setLayout(r);
  };
  return /* @__PURE__ */ g.jsx(fse, { autoSaveId: "mainPanelResponsible", direction: "vertical", ref: i, children: l ? /* @__PURE__ */ g.jsx(lse, {}) : /* @__PURE__ */ g.jsxs(g.Fragment, { children: [
    /* @__PURE__ */ g.jsx(vO, { defaultSize: 75, children: /* @__PURE__ */ g.jsx(Z5, {}) }),
    !l && /* @__PURE__ */ g.jsx(
      jK,
      {
        onClick: () => s(false),
        onDoubleClick: c
      }
    ),
    a.panel.isCollapsed && /* @__PURE__ */ g.jsx(dse, { children: /* @__PURE__ */ g.jsx(W5, { panel: a.panel, response: t4 }) }),
    /* @__PURE__ */ g.jsx(
      vO,
      {
        ...a.panelProps,
        minSize: QK,
        defaultSize: 25,
        children: /* @__PURE__ */ g.jsx(q5, { panel: a.panel })
      }
    )
  ] }) });
}
var fse = I(jj)`
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  width: 55%;
`;
var dse = I.div`
  padding: 0 var(--spacing-lg) var(--spacing-sm);

  @media (max-width: ${sr}px) {
    padding: var(--spacing-xs) var(--spacing-sm);
  }
`;
var hse = class {
  static save(e) {
    localStorage.setItem(Op, JSON.stringify(e));
  }
  static get() {
    try {
      const e = localStorage.getItem(Op);
      if (e)
        return JSON.parse(e);
    } catch (e) {
      console.error("Error parsing serialized data:", e);
    }
    return [];
  }
  static clear() {
    localStorage.removeItem(Op);
  }
};
var pse = class {
  static save(e) {
    localStorage.setItem(mp, JSON.stringify(e));
  }
  static get() {
    try {
      const e = localStorage.getItem(mp);
      if (e)
        return JSON.parse(e);
    } catch (e) {
      console.error("Error parsing serialized data:", e);
    }
    return [];
  }
  static clear() {
    localStorage.removeItem(mp);
  }
};
function U5(t4, e) {
  useMount(() => {
    const n = t4.get();
    e.set(n);
  }), _e(() => {
    t4.save(e.get());
  }, [t4, e]);
}
function gse(t4) {
  U5(pse, t4);
}
function mse(t4) {
  U5(hse, t4);
}
var { Tab: Ose, TabContent: xse, TabList: vse, Tabs: yse } = default_exports.components;
function bse() {
  const { history: t4, collections: e, apiId: n, disableCollectionsTab: r } = je(), { sendEvent: i } = gt(), [o, s] = fe(true), { tabsParams: a } = Dv(n.get(), false, r.get());
  gse(t4), mse(e);
  const l = Ue(
    (u) => {
      i("side_panel_tab_changed", { name: u });
    },
    [i]
  ), c = () => {
    s(!o), i("side_panel_toggled", { expanded: !o });
  };
  return /* @__PURE__ */ g.jsxs(Sse, { $expanded: o, children: [
    o && /* @__PURE__ */ g.jsx(wse, { children: a.map(({ key: u, ...f }) => /* @__PURE__ */ Xi(kse, { ...f, key: u, onClick: () => l(f.label) })) }),
    /* @__PURE__ */ g.jsx(Cse, { variant: "text", onClick: c, children: o ? /* @__PURE__ */ g.jsx(SidePanelOpenIcon, {}) : /* @__PURE__ */ g.jsx(SidePanelCloseIcon, {}) })
  ] });
}
var Sse = I.div`
  display: flex;
  flex-direction: row;
  border-left: 1px solid var(--border-color-secondary);
  min-width: ${({ $expanded: t4 }) => t4 ? "45%" : "48px"};
  width: ${({ $expanded: t4 }) => t4 ? "45%" : "48px"};
  height: 100%;
  transition: width 0.2s ease-in-out;

  svg {
    fill: var(--text-color-primary);
  }
`;
var wse = I(yse)`
  flex-grow: 1;
  margin-right: -48px;
  margin-top: 0;
  margin-bottom: 0;
  --md-tabs-content-padding: 0;
  display: flex;
  flex-direction: column;

  ${vse} {
    margin: 0;
    height: 49px;
    font-size: var(--font-size-lg);
    line-height: calc(var(--line-height-lg) - 1px);
    border-bottom: 1px solid var(--border-color-secondary);
    padding: 0 0 0 var(--spacing-base);
    --md-tabs-tab-font-weight: var(--font-weight-regular);
    --md-tabs-active-tab-border-width: 0 0 1px 0;
    --md-tabs-active-tab-font-weight: var(--font-weight-regular);
    --md-tabs-hover-tab-font-weight: var(--font-weight-regular);
    --md-tabs-tab-text-color: var(--text-color-secondary);
    --md-tabs-hover-tab-border-width: 0;
  }

  ${xse} {
    overflow: auto;
    height: 100%;
  }

  ${Ose} {
    font-size: var(--font-size-lg);
    font-weight: var(--font-weight-regular);
    line-height: var(--line-height-lg);
    padding: var(--spacing-sm) 0;
    margin-right: var(--spacing-base);
    margin-bottom: -1px;
    --md-tabs-tab-text-color: var(--text-color-secondary);
    --md-tabs-active-tab-border-width: 0 0 1px 0;
    --md-tabs-hover-tab-border-width: 0 0 1px 0;
    --md-tabs-active-tab-background-color: transparent;
    --md-tabs-tab-font-weight: var(--font-weight-regular);
  }

  li[class^='Tab__TabItem'] {
    margin-right: var(--spacing-base);
    font-weight: var(--font-weight-regular);
  }

  ol[class^='Tabs__TabList'] {
    padding: 0 0 0 var(--spacing-base);
  }
`;
var Cse = I(Button)`
  align-self: flex-start;
  margin: 12px;
  padding: 4px;
`;
var kse = I.li``;
var Ase = ({ error: t4 }) => /* @__PURE__ */ g.jsxs(Pse, { children: [
  /* @__PURE__ */ g.jsx(Ese, { children: "An Error Has Occurred" }),
  /* @__PURE__ */ g.jsx(Tse, { children: t4 == null ? void 0 : t4.message }),
  /* @__PURE__ */ g.jsx(Ise, { children: t4 == null ? void 0 : t4.stack })
] });
var Pse = I.div`
  padding: var(--spacing-xs) var(--spacing-xl);
`;
var Ese = I.h2`
  color: var(--color-error-base);
`;
var Tse = I.h4`
  color: var(--text-color-secondary);
`;
var Ise = I.pre`
  white-space: break-spaces;
`;
var jse = I.div`
  display: flex;
  justify-content: center;
  align-items: center;
  width: 80vw;
  height: 100vh;
  background-color: var(--bg-color);
`;
var Rse = I.div`
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: var(--spacing-base);
`;
var Dse = I.div`
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: var(--spacing-xxs);
  width: 488px;
`;
var Qse = I.div`
  color: var(--text-color-primary);
  font-size: var(--font-size-xl);
  font-style: normal;
  font-weight: var(--font-weight-semibold);
  line-height: var(--line-height-xl);
`;
var Bse = I.div`
  color: var(--text-color-primary);
  font-size: var(--font-size-lg);
  font-style: normal;
  font-weight: var(--font-weight-regular);
  line-height: var(--line-height-lg);
  text-align: center;
`;
var H5 = class extends q.Component {
  constructor(e) {
    super(e), this.state = { error: void 0 }, this.onUnhandledError = this.onUnhandledError.bind(this), this.onUnhandledPromiseRejection = this.onUnhandledPromiseRejection.bind(this);
  }
  onUnhandledError({ error: e }) {
    var n, r;
    (r = (n = this.props).onError) == null || r.call(n, e);
  }
  onUnhandledPromiseRejection(e) {
    var n, r;
    (r = (n = this.props).onError) == null || r.call(n, e.reason);
  }
  componentDidMount() {
    window.addEventListener("error", this.onUnhandledError), window.addEventListener("unhandledrejection", this.onUnhandledPromiseRejection);
  }
  componentWillUnmount() {
    window.removeEventListener("error", this.onUnhandledError), window.removeEventListener("unhandledrejection", this.onUnhandledPromiseRejection);
  }
  componentDidCatch(e, n) {
    var i, o;
    const r = {
      error: {
        message: e.message,
        stack: n.componentStack ?? void 0
      }
    };
    this.setState(r), (o = (i = this.props).onError) == null || o.call(i, r.error);
  }
  render() {
    return this.state.error ? false ? /* @__PURE__ */ g.jsx($se, {}) : /* @__PURE__ */ g.jsx(Ase, { error: this.state.error }) : this.props.children;
  }
};
var _se = () => {
  const { apiId: t4 } = je(), { isMobile: e, activeTab: n } = ni(), { tabsParams: r } = Dv(t4.get(), e);
  return r.filter(({ key: i }) => i === n).map(({ children: i, key: o, flexDirection: s = "row" }) => /* @__PURE__ */ g.jsx(Mse, { isActive: o === n, flexDirection: s, children: i }, o));
};
var Mse = I.div`
  flex: 1;
  flex-direction: ${({ flexDirection: t4 }) => t4};
  padding: 0;
  display: ${({ isActive: t4 }) => t4 ? "flex" : "none"};
`;
var Nse = ({ className: t4 }) => {
  const { operationUrl: e } = je().get(), { sendEvent: n } = gt(), { isMobile: r, closeButton: i } = ni();
  return /* @__PURE__ */ g.jsxs(g.Fragment, { children: [
    /* @__PURE__ */ g.jsx(GlobalStyle, {}),
    !r && i,
    /* @__PURE__ */ g.jsx(Zse, { className: t4, isMobile: r, children: /* @__PURE__ */ g.jsx(
      H5,
      {
        onError: (o) => n("unhandled_error", { ...o, operationUrl: e }),
        children: r ? /* @__PURE__ */ g.jsx(_se, {}) : /* @__PURE__ */ g.jsxs(g.Fragment, { children: [
          /* @__PURE__ */ g.jsx(Bv, {}),
          /* @__PURE__ */ g.jsx(bse, {})
        ] })
      }
    ) })
  ] });
};
function J5({ className: t4 }) {
  return /* @__PURE__ */ g.jsx(Nse, { className: t4 });
}
function Fse({ className: t4 }) {
  return /* @__PURE__ */ g.jsx(F5, { children: /* @__PURE__ */ g.jsx(J5, { className: t4 }) });
}
var Zse = I.div`
  display: flex;
  height: 100vh;
  background-color: var(--bg-color);
  flex-direction: ${({ isMobile: t4 }) => t4 ? "column" : "row"};
`;
function Wse(t4) {
  const e = F$(t4), n = gv(t4), r = aU(t4), i = iU(t4), o = t4.request.get().body.activeExampleName, s = t4.request.get().body.type, a = mv(t4);
  return {
    requestValues: {
      cookie: r,
      header: e,
      query: i,
      body: n
    },
    activeExampleName: o,
    activeMimeName: s,
    environment: (a == null ? void 0 : a.name) || (a == null ? void 0 : a.url),
    activeSecuritySchemeIds: t4.request.security.get().selectedSecuritySchemeId.split("_"),
    environments: Object.fromEntries(
      Object.entries(t4.environments.get()).map(([, l]) => [
        l.name,
        {
          ...Object.fromEntries(l.variables.map(({ name: c, value: u }) => [c, u])),
          server: l.url || ""
        }
      ])
    )
  };
}
var K5 = I.div`
  display: flex;
  justify-content: center;
  align-items: center;
  border-radius: var(--border-radius);
  background-color: var(--button-bg-color-secondary);
  width: 24px;
  height: 24px;
  cursor: pointer;
`;
var Vse = I(K5)`
  position: relative;
  right: 12px;
  top: 12px;
  align-self: flex-start;
`;
var zse = xs(
  (t4, e) => {
    const { isMobile: n } = ni();
    return n ? /* @__PURE__ */ g.jsx(K5, { ref: e, ...t4 }) : /* @__PURE__ */ g.jsx(Vse, { ref: e, ...t4 });
  }
);
var Lse = (t4) => {
  const e = Ke(null);
  return _e(() => {
    e.current && e.current.focus();
  }, []), /* @__PURE__ */ g.jsx(zse, { role: "button", tabIndex: 0, ref: e, ...t4, children: /* @__PURE__ */ g.jsx(e4, {}) });
};
var e4 = I(CloseIcon)`
  width: 14px;
  height: 14px;
`;
function hae(t4) {
  return bv(t4), /* @__PURE__ */ g.jsx(jO, { children: /* @__PURE__ */ g.jsx(Fse, {}) });
}
function pae({ onClose: t4, onLoad: e, onRequestChange: n, ...r }) {
  const { sendEvent: i } = gt(), o = je(), s = bv(r), a = Ue(() => {
    var c;
    if (n) {
      const u = s.isLinked.get(), f = Wse(s);
      n(u ? f : { requestValues: {} });
    }
    i("replay_closed", { operationName: (c = r.value) == null ? void 0 : c.name }), t4(), o.set(zc());
  }, [t4, n, s, r.value, i, o]);
  _e(() => {
    var c;
    e == null || e(), i("replay_opened", { operationName: (c = r.value) == null ? void 0 : c.name });
  }, []);
  const l = (c) => {
    c.key === "Enter" && (c.preventDefault(), a());
  };
  return /* @__PURE__ */ g.jsx(jO, { children: /* @__PURE__ */ g.jsx(
    F5,
    {
      closeButton: /* @__PURE__ */ g.jsx(Lse, { onClick: a, onKeyDown: l, children: /* @__PURE__ */ g.jsx(e4, {}) }),
      children: /* @__PURE__ */ g.jsx(P2, { onClick: a, children: /* @__PURE__ */ g.jsx(Xse, {}) })
    }
  ) });
}
var Xse = I(J5)`
  width: 80vw;

  @media (max-width: ${sr}px) {
    width: 100vw;
  }
`;
function gae(t4) {
  const { sendEvent: e } = gt(), n = We(() => ZO(zc()), []);
  return /* @__PURE__ */ g.jsx(lK, { value: n, children: /* @__PURE__ */ g.jsx(
    H5,
    {
      onError: (r) => e("unhandled_error", { ...r, isEmbedded: true }),
      children: /* @__PURE__ */ g.jsx(Gse, { ...t4 })
    }
  ) });
}
function Gse(t4) {
  return bv({ ...t4, disableDraft: true }), /* @__PURE__ */ g.jsx(jO, { children: /* @__PURE__ */ g.jsx(Yse, { children: /* @__PURE__ */ g.jsx(Bv, {}) }) });
}
var Yse = I.div`
  display: flex;
  max-height: 80vh;
  height: 800px;
  width: 100%;
`;
async function qse({
  name: t4,
  extensions: e,
  multiple: n = false
}) {
  if (window == null ? void 0 : window.__TAURI__) {
    const i = await hie({
      multiple: n,
      filters: [
        {
          name: t4,
          extensions: e
        }
      ]
    });
    return Array.isArray(i) ? i[0] : i;
  } else
    return Use(e, n);
}
function Use(t4, e) {
  return new Promise((n) => {
    const r = document.createElement("input");
    r.type = "file", r.style.display = "none", r.multiple = e, r.accept = t4.join(","), document.body.appendChild(r), r.addEventListener("change", (i) => {
      var o;
      n(((o = i.target.files) == null ? void 0 : o[0].name) || null), document.body.removeChild(r);
    }), r.click();
  });
}
var mae = { openFile: qse };
export {
  gae as EmbeddedReplay,
  Uf as Modal,
  hae as Replay,
  pae as ReplayOverlay,
  mae as utils
};
/*! Bundled license information:

@redocly/replay/dist/replay.js:
  (**
   * @license React
   * react-jsx-runtime.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

@redocly/replay/dist/replay.js:
  (**
   * @license React
   * react-jsx-runtime.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

@redocly/replay/dist/replay.js:
  (**
   * @license React
   * react-is.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

@redocly/replay/dist/replay.js:
  (**
   * @license React
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

@redocly/replay/dist/replay.js:
  (** @license React v16.13.1
   * react-is.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

@redocly/replay/dist/replay.js:
  (** @license React v16.13.1
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

@redocly/replay/dist/replay.js:
  (* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
   * @license MIT *)
  (*!
  	Copyright (c) 2018 Jed Watson.
  	Licensed under the MIT License (MIT), see
  	http://jedwatson.github.io/classnames
  *)
  (** @preserve
  			(c) 2012 by Cédric Mesnil. All rights reserved.
  
  			Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
  
  			    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
  			    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
  
  			THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  			*)
  (** @preserve
   * Counter block mode compatible with  Dr Brian Gladman fileenc.c
   * derived from CryptoJS.mode.CTR
   * Jan Hruby jhruby.web@gmail.com
   *)
  (*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT *)
*/
