import { createRequire as topLevelCreateRequire } from 'module';
 const require = topLevelCreateRequire(import.meta.url);
import {
  components,
  custom_components_exports,
  w as w2,
  x as x3
} from "./chunks/chunk-TL5RDG3G.js";
import {
  r
} from "./chunks/chunk-EBJ2N3O4.js";
import {
  I
} from "./chunks/chunk-JDENUEPH.js";
import {
  D,
  E,
  E2,
  E3,
  E4,
  F,
  I as I2,
  N,
  P as P3,
  R,
  R2,
  S,
  Sr,
  b,
  c,
  e,
  f as f2,
  g,
  i,
  m,
  n as n3,
  o,
  p,
  p2,
  p3,
  p4,
  r as r2,
  s,
  s2,
  s3,
  t as t2,
  te,
  w,
  w2 as w3,
  w3 as w4,
  x
} from "./chunks/chunk-JJ5XY26P.js";
import {
  P2 as P,
  P3 as P2,
  f,
  n,
  n2,
  t,
  x2
} from "./chunks/chunk-7WVTT2DN.js";
import {
  Admonition2 as Admonition,
  GlobalStyle,
  Menu,
  PageLayout,
  RootLayout,
  SidebarActions,
  VersionPicker,
  WarningFilledIcon,
  default_exports,
  init_Admonition,
  init_Menu,
  init_PageLayout,
  init_RootLayout,
  init_SidebarActions,
  init_VersionPicker,
  init_WarningFilledIcon,
  init_default,
  init_src,
  init_styles
} from "./chunks/chunk-EAFIJ2VV.js";
import "./chunks/chunk-AB7LF64Z.js";
import "./chunks/chunk-Q6LZZN6W.js";
import {
  ArrowLeftIcon,
  init_ArrowLeftIcon
} from "./chunks/chunk-WLDWULA7.js";
import "./chunks/chunk-GHSOG4VG.js";
import "./chunks/chunk-D237NEF2.js";
import {
  Sidebar,
  Tag,
  init_Sidebar
} from "./chunks/chunk-2J7OHCSZ.js";
import "./chunks/chunk-XQXU7C5Q.js";
import {
  Button,
  init_Button
} from "./chunks/chunk-SX3NFZJN.js";
import {
  ThemeDataContext,
  Ue,
  fe,
  init_hooks,
  init_styled_components_esm,
  styled_components_esm_default,
  useOutsideClick,
  useRecentSearches,
  useThemeConfig
} from "./chunks/chunk-WNBJGIID.js";
import {
  LayoutVariant,
  init_lib_esm
} from "./chunks/chunk-R4PATEVC.js";
import {
  __commonJS,
  __esm,
  __export,
  __require,
  __toCommonJS,
  __toESM
} from "./chunks/chunk-35AYGKFE.js";

// node_modules/anser/lib/index.js
var require_lib = __commonJS({
  "node_modules/anser/lib/index.js"(exports, module) {
    "use strict";
    var _createClass = function() {
      function defineProperties(target, props) {
        for (var i4 = 0; i4 < props.length; i4++) {
          var descriptor = props[i4];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var ANSI_COLORS = [[{ color: "0, 0, 0", "class": "ansi-black" }, { color: "187, 0, 0", "class": "ansi-red" }, { color: "0, 187, 0", "class": "ansi-green" }, { color: "187, 187, 0", "class": "ansi-yellow" }, { color: "0, 0, 187", "class": "ansi-blue" }, { color: "187, 0, 187", "class": "ansi-magenta" }, { color: "0, 187, 187", "class": "ansi-cyan" }, { color: "255,255,255", "class": "ansi-white" }], [{ color: "85, 85, 85", "class": "ansi-bright-black" }, { color: "255, 85, 85", "class": "ansi-bright-red" }, { color: "0, 255, 0", "class": "ansi-bright-green" }, { color: "255, 255, 85", "class": "ansi-bright-yellow" }, { color: "85, 85, 255", "class": "ansi-bright-blue" }, { color: "255, 85, 255", "class": "ansi-bright-magenta" }, { color: "85, 255, 255", "class": "ansi-bright-cyan" }, { color: "255, 255, 255", "class": "ansi-bright-white" }]];
    var linkRegex = /(https?:\/\/(?:[A-Za-z0-9#;/?:@=+$',_.!~*()[\]-]|&amp;|%[A-Fa-f0-9]{2})+)/gm;
    var Anser = function() {
      _createClass(Anser2, null, [{
        key: "escapeForHtml",
        /**
         * Anser.escapeForHtml
         * Escape the input HTML.
         *
         * This does the minimum escaping of text to make it compliant with HTML.
         * In particular, the '&','<', and '>' characters are escaped. This should
         * be run prior to `ansiToHtml`.
         *
         * @name Anser.escapeForHtml
         * @function
         * @param {String} txt The input text (containing the ANSI snippets).
         * @returns {String} The escaped html.
         */
        value: function escapeForHtml(txt) {
          return new Anser2().escapeForHtml(txt);
        }
        /**
         * Anser.linkify
         * Adds the links in the HTML.
         *
         * This replaces any links in the text with anchor tags that display the
         * link. You should apply this after you have run `ansiToHtml` on the text.
         *
         * @name Anser.linkify
         * @function
         * @param {String} txt The input text.
         * @returns {String} The HTML containing the <a> tags (unescaped).
         */
      }, {
        key: "linkify",
        value: function linkify(txt) {
          return new Anser2().linkify(txt);
        }
        /**
         * Anser.ansiToHtml
         * This replaces ANSI terminal escape codes with SPAN tags that wrap the
         * content.
         *
         * This function only interprets ANSI SGR (Select Graphic Rendition) codes
         * that can be represented in HTML.
         * For example, cursor movement codes are ignored and hidden from output.
         * The default style uses colors that are very close to the prescribed
         * standard. The standard assumes that the text will have a black
         * background. These colors are set as inline styles on the SPAN tags.
         *
         * Another option is to set `use_classes: true` in the options argument.
         * This will instead set classes on the spans so the colors can be set via
         * CSS. The class names used are of the format `ansi-*-fg/bg` and
         * `ansi-bright-*-fg/bg` where `*` is the color name,
         * i.e black/red/green/yellow/blue/magenta/cyan/white.
         *
         * @name Anser.ansiToHtml
         * @function
         * @param {String} txt The input text.
         * @param {Object} options The options passed to the ansiToHTML method.
         * @returns {String} The HTML output.
         */
      }, {
        key: "ansiToHtml",
        value: function ansiToHtml(txt, options) {
          return new Anser2().ansiToHtml(txt, options);
        }
        /**
         * Anser.ansiToJson
         * Converts ANSI input into JSON output.
         *
         * @name Anser.ansiToJson
         * @function
         * @param {String} txt The input text.
         * @param {Object} options The options passed to the ansiToHTML method.
         * @returns {String} The HTML output.
         */
      }, {
        key: "ansiToJson",
        value: function ansiToJson(txt, options) {
          return new Anser2().ansiToJson(txt, options);
        }
        /**
         * Anser.ansiToText
         * Converts ANSI input into text output.
         *
         * @name Anser.ansiToText
         * @function
         * @param {String} txt The input text.
         * @returns {String} The text output.
         */
      }, {
        key: "ansiToText",
        value: function ansiToText(txt) {
          return new Anser2().ansiToText(txt);
        }
        /**
         * Anser
         * The `Anser` class.
         *
         * @name Anser
         * @function
         * @returns {Anser}
         */
      }]);
      function Anser2() {
        _classCallCheck(this, Anser2);
        this.fg = this.bg = this.fg_truecolor = this.bg_truecolor = null;
        this.bright = 0;
        this.decorations = [];
      }
      _createClass(Anser2, [{
        key: "setupPalette",
        value: function setupPalette() {
          this.PALETTE_COLORS = [];
          for (var i4 = 0; i4 < 2; ++i4) {
            for (var j = 0; j < 8; ++j) {
              this.PALETTE_COLORS.push(ANSI_COLORS[i4][j].color);
            }
          }
          var levels = [0, 95, 135, 175, 215, 255];
          var format = function format2(r8, g7, b5) {
            return levels[r8] + ", " + levels[g7] + ", " + levels[b5];
          };
          var r7 = void 0, g6 = void 0, b4 = void 0;
          for (var _r = 0; _r < 6; ++_r) {
            for (var _g = 0; _g < 6; ++_g) {
              for (var _b = 0; _b < 6; ++_b) {
                this.PALETTE_COLORS.push(format(_r, _g, _b));
              }
            }
          }
          var level = 8;
          for (var _i = 0; _i < 24; ++_i, level += 10) {
            this.PALETTE_COLORS.push(format(level, level, level));
          }
        }
        /**
         * escapeForHtml
         * Escapes the input text.
         *
         * @name escapeForHtml
         * @function
         * @param {String} txt The input text.
         * @returns {String} The escpaed HTML output.
         */
      }, {
        key: "escapeForHtml",
        value: function escapeForHtml(txt) {
          return txt.replace(/[&<>\"]/gm, function(str) {
            return str == "&" ? "&amp;" : str == '"' ? "&quot;" : str == "<" ? "&lt;" : str == ">" ? "&gt;" : "";
          });
        }
        /**
         * linkify
         * Adds HTML link elements.
         *
         * @name linkify
         * @function
         * @param {String} txt The input text.
         * @returns {String} The HTML output containing link elements.
         */
      }, {
        key: "linkify",
        value: function linkify(txt) {
          return txt.replace(linkRegex, function(str) {
            return '<a href="' + str + '">' + str + "</a>";
          });
        }
        /**
         * ansiToHtml
         * Converts ANSI input into HTML output.
         *
         * @name ansiToHtml
         * @function
         * @param {String} txt The input text.
         * @param {Object} options The options passed ot the `process` method.
         * @returns {String} The HTML output.
         */
      }, {
        key: "ansiToHtml",
        value: function ansiToHtml(txt, options) {
          return this.process(txt, options, true);
        }
        /**
         * ansiToJson
         * Converts ANSI input into HTML output.
         *
         * @name ansiToJson
         * @function
         * @param {String} txt The input text.
         * @param {Object} options The options passed ot the `process` method.
         * @returns {String} The JSON output.
         */
      }, {
        key: "ansiToJson",
        value: function ansiToJson(txt, options) {
          options = options || {};
          options.json = true;
          options.clearLine = false;
          return this.process(txt, options, true);
        }
        /**
         * ansiToText
         * Converts ANSI input into HTML output.
         *
         * @name ansiToText
         * @function
         * @param {String} txt The input text.
         * @returns {String} The text output.
         */
      }, {
        key: "ansiToText",
        value: function ansiToText(txt) {
          return this.process(txt, {}, false);
        }
        /**
         * process
         * Processes the input.
         *
         * @name process
         * @function
         * @param {String} txt The input text.
         * @param {Object} options An object passed to `processChunk` method, extended with:
         *
         *  - `json` (Boolean): If `true`, the result will be an object.
         *  - `use_classes` (Boolean): If `true`, HTML classes will be appended to the HTML output.
         *
         * @param {Boolean} markup
         */
      }, {
        key: "process",
        value: function process2(txt, options, markup) {
          var _this = this;
          var self2 = this;
          var raw_text_chunks = txt.split(/\033\[/);
          var first_chunk = raw_text_chunks.shift();
          if (options === void 0 || options === null) {
            options = {};
          }
          options.clearLine = /\r/.test(txt);
          var color_chunks = raw_text_chunks.map(function(chunk) {
            return _this.processChunk(chunk, options, markup);
          });
          if (options && options.json) {
            var first = self2.processChunkJson("");
            first.content = first_chunk;
            first.clearLine = options.clearLine;
            color_chunks.unshift(first);
            if (options.remove_empty) {
              color_chunks = color_chunks.filter(function(c5) {
                return !c5.isEmpty();
              });
            }
            return color_chunks;
          } else {
            color_chunks.unshift(first_chunk);
          }
          return color_chunks.join("");
        }
        /**
         * processChunkJson
         * Processes the current chunk into json output.
         *
         * @name processChunkJson
         * @function
         * @param {String} text The input text.
         * @param {Object} options An object containing the following fields:
         *
         *  - `json` (Boolean): If `true`, the result will be an object.
         *  - `use_classes` (Boolean): If `true`, HTML classes will be appended to the HTML output.
         *
         * @param {Boolean} markup If false, the colors will not be parsed.
         * @return {Object} The result object:
         *
         *  - `content` (String): The text.
         *  - `fg` (String|null): The foreground color.
         *  - `bg` (String|null): The background color.
         *  - `fg_truecolor` (String|null): The foreground true color (if 16m color is enabled).
         *  - `bg_truecolor` (String|null): The background true color (if 16m color is enabled).
         *  - `clearLine` (Boolean): `true` if a carriageReturn \r was fount at end of line.
         *  - `was_processed` (Bolean): `true` if the colors were processed, `false` otherwise.
         *  - `isEmpty` (Function): A function returning `true` if the content is empty, or `false` otherwise.
         *
         */
      }, {
        key: "processChunkJson",
        value: function processChunkJson(text, options, markup) {
          options = typeof options == "undefined" ? {} : options;
          var use_classes = options.use_classes = typeof options.use_classes != "undefined" && options.use_classes;
          var key = options.key = use_classes ? "class" : "color";
          var result = {
            content: text,
            fg: null,
            bg: null,
            fg_truecolor: null,
            bg_truecolor: null,
            isInverted: false,
            clearLine: options.clearLine,
            decoration: null,
            decorations: [],
            was_processed: false,
            isEmpty: function isEmpty() {
              return !result.content;
            }
          };
          var matches = text.match(/^([!\x3c-\x3f]*)([\d;]*)([\x20-\x2c]*[\x40-\x7e])([\s\S]*)/m);
          if (!matches)
            return result;
          var orig_txt = result.content = matches[4];
          var nums = matches[2].split(";");
          if (matches[1] !== "" || matches[3] !== "m") {
            return result;
          }
          if (!markup) {
            return result;
          }
          var self2 = this;
          while (nums.length > 0) {
            var num_str = nums.shift();
            var num = parseInt(num_str);
            if (isNaN(num) || num === 0) {
              self2.fg = self2.bg = null;
              self2.decorations = [];
            } else if (num === 1) {
              self2.decorations.push("bold");
            } else if (num === 2) {
              self2.decorations.push("dim");
            } else if (num === 3) {
              self2.decorations.push("italic");
            } else if (num === 4) {
              self2.decorations.push("underline");
            } else if (num === 5) {
              self2.decorations.push("blink");
            } else if (num === 7) {
              self2.decorations.push("reverse");
            } else if (num === 8) {
              self2.decorations.push("hidden");
            } else if (num === 9) {
              self2.decorations.push("strikethrough");
            } else if (num === 21) {
              self2.removeDecoration("bold");
            } else if (num === 22) {
              self2.removeDecoration("bold");
              self2.removeDecoration("dim");
            } else if (num === 23) {
              self2.removeDecoration("italic");
            } else if (num === 24) {
              self2.removeDecoration("underline");
            } else if (num === 25) {
              self2.removeDecoration("blink");
            } else if (num === 27) {
              self2.removeDecoration("reverse");
            } else if (num === 28) {
              self2.removeDecoration("hidden");
            } else if (num === 29) {
              self2.removeDecoration("strikethrough");
            } else if (num === 39) {
              self2.fg = null;
            } else if (num === 49) {
              self2.bg = null;
            } else if (num >= 30 && num < 38) {
              self2.fg = ANSI_COLORS[0][num % 10][key];
            } else if (num >= 90 && num < 98) {
              self2.fg = ANSI_COLORS[1][num % 10][key];
            } else if (num >= 40 && num < 48) {
              self2.bg = ANSI_COLORS[0][num % 10][key];
            } else if (num >= 100 && num < 108) {
              self2.bg = ANSI_COLORS[1][num % 10][key];
            } else if (num === 38 || num === 48) {
              var is_foreground = num === 38;
              if (nums.length >= 1) {
                var mode = nums.shift();
                if (mode === "5" && nums.length >= 1) {
                  var palette_index = parseInt(nums.shift());
                  if (palette_index >= 0 && palette_index <= 255) {
                    if (!use_classes) {
                      if (!this.PALETTE_COLORS) {
                        self2.setupPalette();
                      }
                      if (is_foreground) {
                        self2.fg = this.PALETTE_COLORS[palette_index];
                      } else {
                        self2.bg = this.PALETTE_COLORS[palette_index];
                      }
                    } else {
                      var klass = palette_index >= 16 ? "ansi-palette-" + palette_index : ANSI_COLORS[palette_index > 7 ? 1 : 0][palette_index % 8]["class"];
                      if (is_foreground) {
                        self2.fg = klass;
                      } else {
                        self2.bg = klass;
                      }
                    }
                  }
                } else if (mode === "2" && nums.length >= 3) {
                  var r7 = parseInt(nums.shift());
                  var g6 = parseInt(nums.shift());
                  var b4 = parseInt(nums.shift());
                  if (r7 >= 0 && r7 <= 255 && g6 >= 0 && g6 <= 255 && b4 >= 0 && b4 <= 255) {
                    var color = r7 + ", " + g6 + ", " + b4;
                    if (!use_classes) {
                      if (is_foreground) {
                        self2.fg = color;
                      } else {
                        self2.bg = color;
                      }
                    } else {
                      if (is_foreground) {
                        self2.fg = "ansi-truecolor";
                        self2.fg_truecolor = color;
                      } else {
                        self2.bg = "ansi-truecolor";
                        self2.bg_truecolor = color;
                      }
                    }
                  }
                }
              }
            }
          }
          if (self2.fg === null && self2.bg === null && self2.decorations.length === 0) {
            return result;
          } else {
            var styles = [];
            var classes = [];
            var data = {};
            result.fg = self2.fg;
            result.bg = self2.bg;
            result.fg_truecolor = self2.fg_truecolor;
            result.bg_truecolor = self2.bg_truecolor;
            result.decorations = self2.decorations;
            result.decoration = self2.decorations.slice(-1).pop() || null;
            result.was_processed = true;
            return result;
          }
        }
        /**
         * processChunk
         * Processes the current chunk of text.
         *
         * @name processChunk
         * @function
         * @param {String} text The input text.
         * @param {Object} options An object containing the following fields:
         *
         *  - `json` (Boolean): If `true`, the result will be an object.
         *  - `use_classes` (Boolean): If `true`, HTML classes will be appended to the HTML output.
         *
         * @param {Boolean} markup If false, the colors will not be parsed.
         * @return {Object|String} The result (object if `json` is wanted back or string otherwise).
         */
      }, {
        key: "processChunk",
        value: function processChunk(text, options, markup) {
          var _this2 = this;
          options = options || {};
          var jsonChunk = this.processChunkJson(text, options, markup);
          var use_classes = options.use_classes;
          jsonChunk.decorations = jsonChunk.decorations.filter(function(decoration) {
            if (decoration === "reverse") {
              if (!jsonChunk.fg) {
                jsonChunk.fg = ANSI_COLORS[0][7][use_classes ? "class" : "color"];
              }
              if (!jsonChunk.bg) {
                jsonChunk.bg = ANSI_COLORS[0][0][use_classes ? "class" : "color"];
              }
              var tmpFg = jsonChunk.fg;
              jsonChunk.fg = jsonChunk.bg;
              jsonChunk.bg = tmpFg;
              var tmpFgTrue = jsonChunk.fg_truecolor;
              jsonChunk.fg_truecolor = jsonChunk.bg_truecolor;
              jsonChunk.bg_truecolor = tmpFgTrue;
              jsonChunk.isInverted = true;
              return false;
            }
            return true;
          });
          if (options.json) {
            return jsonChunk;
          }
          if (jsonChunk.isEmpty()) {
            return "";
          }
          if (!jsonChunk.was_processed) {
            return jsonChunk.content;
          }
          var colors = [];
          var decorations = [];
          var textDecorations = [];
          var data = {};
          var render_data = function render_data2(data2) {
            var fragments = [];
            var key = void 0;
            for (key in data2) {
              if (data2.hasOwnProperty(key)) {
                fragments.push("data-" + key + '="' + _this2.escapeForHtml(data2[key]) + '"');
              }
            }
            return fragments.length > 0 ? " " + fragments.join(" ") : "";
          };
          if (jsonChunk.isInverted) {
            data["ansi-is-inverted"] = "true";
          }
          if (jsonChunk.fg) {
            if (use_classes) {
              colors.push(jsonChunk.fg + "-fg");
              if (jsonChunk.fg_truecolor !== null) {
                data["ansi-truecolor-fg"] = jsonChunk.fg_truecolor;
                jsonChunk.fg_truecolor = null;
              }
            } else {
              colors.push("color:rgb(" + jsonChunk.fg + ")");
            }
          }
          if (jsonChunk.bg) {
            if (use_classes) {
              colors.push(jsonChunk.bg + "-bg");
              if (jsonChunk.bg_truecolor !== null) {
                data["ansi-truecolor-bg"] = jsonChunk.bg_truecolor;
                jsonChunk.bg_truecolor = null;
              }
            } else {
              colors.push("background-color:rgb(" + jsonChunk.bg + ")");
            }
          }
          jsonChunk.decorations.forEach(function(decoration) {
            if (use_classes) {
              decorations.push("ansi-" + decoration);
              return;
            }
            if (decoration === "bold") {
              decorations.push("font-weight:bold");
            } else if (decoration === "dim") {
              decorations.push("opacity:0.5");
            } else if (decoration === "italic") {
              decorations.push("font-style:italic");
            } else if (decoration === "hidden") {
              decorations.push("visibility:hidden");
            } else if (decoration === "strikethrough") {
              textDecorations.push("line-through");
            } else {
              textDecorations.push(decoration);
            }
          });
          if (textDecorations.length) {
            decorations.push("text-decoration:" + textDecorations.join(" "));
          }
          if (use_classes) {
            return '<span class="' + colors.concat(decorations).join(" ") + '"' + render_data(data) + ">" + jsonChunk.content + "</span>";
          } else {
            return '<span style="' + colors.concat(decorations).join(";") + '"' + render_data(data) + ">" + jsonChunk.content + "</span>";
          }
        }
      }, {
        key: "removeDecoration",
        value: function removeDecoration(decoration) {
          var index = this.decorations.indexOf(decoration);
          if (index >= 0) {
            this.decorations.splice(index, 1);
          }
        }
      }]);
      return Anser2;
    }();
    module.exports = Anser;
  }
});

// node_modules/escape-carriage/index.js
var require_escape_carriage = __commonJS({
  "node_modules/escape-carriage/index.js"(exports, module) {
    function escapeCarriageReturn(txt) {
      if (!txt)
        return "";
      if (!/\r/.test(txt))
        return txt;
      txt = txt.replace(/\r+\n/gm, "\n");
      while (/\r./.test(txt)) {
        txt = txt.replace(/^([^\r\n]*)\r+([^\r\n]+)/gm, function(_2, base, insert) {
          return insert + base.slice(insert.length);
        });
      }
      return txt;
    }
    function findLongestString(arr) {
      var longest = 0;
      for (var i4 = 0; i4 < arr.length; i4++) {
        if (arr[longest].length <= arr[i4].length) {
          longest = i4;
        }
      }
      return longest;
    }
    function escapeSingleLineSafe(txt) {
      if (!/\r/.test(txt))
        return txt;
      var arr = txt.split("\r");
      var res = [];
      while (arr.length > 0) {
        var longest = findLongestString(arr);
        res.push(arr[longest]);
        arr = arr.slice(longest + 1);
      }
      return res.join("\r");
    }
    function escapeCarriageReturnSafe(txt) {
      if (!txt)
        return "";
      if (!/\r/.test(txt))
        return txt;
      if (!/\n/.test(txt))
        return escapeSingleLineSafe(txt);
      txt = txt.replace(/\r+\n/gm, "\n");
      var idx = txt.lastIndexOf("\n");
      return escapeCarriageReturn(txt.slice(0, idx)) + "\n" + escapeSingleLineSafe(txt.slice(idx + 1));
    }
    module.exports = escapeCarriageReturn;
    module.exports.escapeCarriageReturn = escapeCarriageReturn;
    module.exports.escapeCarriageReturnSafe = escapeCarriageReturnSafe;
  }
});

// node_modules/@cocalc/ansi-to-react/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/@cocalc/ansi-to-react/lib/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o4, m2, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      var desc = Object.getOwnPropertyDescriptor(m2, k3);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k3];
        } };
      }
      Object.defineProperty(o4, k22, desc);
    } : function(o4, m2, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      o4[k22] = m2[k3];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o4, v4) {
      Object.defineProperty(o4, "default", { enumerable: true, value: v4 });
    } : function(o4, v4) {
      o4["default"] = v4;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k3 in mod)
          if (k3 !== "default" && Object.prototype.hasOwnProperty.call(mod, k3))
            __createBinding(result, mod, k3);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var anser_1 = __importDefault(require_lib());
    var escape_carriage_1 = require_escape_carriage();
    var React = __importStar(__require("react"));
    function ansiToJSON(input, use_classes = false) {
      input = (0, escape_carriage_1.escapeCarriageReturn)(fixBackspace(input));
      return anser_1.default.ansiToJson(input, {
        json: true,
        remove_empty: true,
        use_classes
      });
    }
    function createClass(bundle) {
      let classNames = "";
      if (bundle.bg) {
        classNames += `${bundle.bg}-bg `;
      }
      if (bundle.fg) {
        classNames += `${bundle.fg}-fg `;
      }
      if (bundle.decoration) {
        classNames += `ansi-${bundle.decoration} `;
      }
      if (classNames === "") {
        return null;
      }
      classNames = classNames.substring(0, classNames.length - 1);
      return classNames;
    }
    function createStyle(bundle) {
      const style = {};
      if (bundle.bg) {
        style.backgroundColor = `rgb(${bundle.bg})`;
      }
      if (bundle.fg) {
        style.color = `rgb(${bundle.fg})`;
      }
      switch (bundle.decoration) {
        case "bold":
          style.fontWeight = "bold";
          break;
        case "dim":
          style.opacity = "0.5";
          break;
        case "italic":
          style.fontStyle = "italic";
          break;
        case "hidden":
          style.visibility = "hidden";
          break;
        case "strikethrough":
          style.textDecoration = "line-through";
          break;
        case "underline":
          style.textDecoration = "underline";
          break;
        case "blink":
          style.textDecoration = "blink";
          break;
        default:
          break;
      }
      return style;
    }
    function convertBundleIntoReact(linkify, useClasses, bundle, key) {
      const style = useClasses ? null : createStyle(bundle);
      const className = useClasses ? createClass(bundle) : null;
      if (!linkify) {
        return React.createElement("span", { style, key, className }, bundle.content);
      }
      const content = [];
      const linkRegex = /(\s|^)(https?:\/\/(?:www\.|(?!www))[^\s.]+\.[^\s]{2,}|www\.[^\s]+\.[^\s]{2,})/g;
      let index = 0;
      let match;
      while ((match = linkRegex.exec(bundle.content)) !== null) {
        const [, pre, url] = match;
        const startIndex = match.index + pre.length;
        if (startIndex > index) {
          content.push(bundle.content.substring(index, startIndex));
        }
        const href = url.startsWith("www.") ? `http://${url}` : url;
        content.push(React.createElement("a", {
          key: index,
          href,
          target: "_blank"
        }, `${url}`));
        index = linkRegex.lastIndex;
      }
      if (index < bundle.content.length) {
        content.push(bundle.content.substring(index));
      }
      return React.createElement("span", { style, key, className }, content);
    }
    function Ansi(props) {
      const { className, useClasses, children, linkify } = props;
      return React.createElement("code", { className }, ansiToJSON(children !== null && children !== void 0 ? children : "", useClasses !== null && useClasses !== void 0 ? useClasses : false).map(convertBundleIntoReact.bind(null, linkify !== null && linkify !== void 0 ? linkify : false, useClasses !== null && useClasses !== void 0 ? useClasses : false)));
    }
    exports.default = Ansi;
    function fixBackspace(txt) {
      let tmp = txt;
      do {
        txt = tmp;
        tmp = txt.replace(/[^\n]\x08/gm, "");
      } while (tmp.length < txt.length);
      return txt;
    }
  }
});

// node_modules/@opentelemetry/api/build/esm/platform/node/globalThis.js
var _globalThis;
var init_globalThis = __esm({
  "node_modules/@opentelemetry/api/build/esm/platform/node/globalThis.js"() {
    _globalThis = typeof globalThis === "object" ? globalThis : global;
  }
});

// node_modules/@opentelemetry/api/build/esm/platform/node/index.js
var init_node = __esm({
  "node_modules/@opentelemetry/api/build/esm/platform/node/index.js"() {
    init_globalThis();
  }
});

// node_modules/@opentelemetry/api/build/esm/platform/index.js
var init_platform = __esm({
  "node_modules/@opentelemetry/api/build/esm/platform/index.js"() {
    init_node();
  }
});

// node_modules/@opentelemetry/api/build/esm/version.js
var VERSION;
var init_version = __esm({
  "node_modules/@opentelemetry/api/build/esm/version.js"() {
    VERSION = "1.9.0";
  }
});

// node_modules/@opentelemetry/api/build/esm/internal/semver.js
function _makeCompatibilityCheck(ownVersion) {
  var acceptedVersions = /* @__PURE__ */ new Set([ownVersion]);
  var rejectedVersions = /* @__PURE__ */ new Set();
  var myVersionMatch = ownVersion.match(re);
  if (!myVersionMatch) {
    return function() {
      return false;
    };
  }
  var ownVersionParsed = {
    major: +myVersionMatch[1],
    minor: +myVersionMatch[2],
    patch: +myVersionMatch[3],
    prerelease: myVersionMatch[4]
  };
  if (ownVersionParsed.prerelease != null) {
    return function isExactmatch(globalVersion) {
      return globalVersion === ownVersion;
    };
  }
  function _reject(v4) {
    rejectedVersions.add(v4);
    return false;
  }
  function _accept(v4) {
    acceptedVersions.add(v4);
    return true;
  }
  return function isCompatible2(globalVersion) {
    if (acceptedVersions.has(globalVersion)) {
      return true;
    }
    if (rejectedVersions.has(globalVersion)) {
      return false;
    }
    var globalVersionMatch = globalVersion.match(re);
    if (!globalVersionMatch) {
      return _reject(globalVersion);
    }
    var globalVersionParsed = {
      major: +globalVersionMatch[1],
      minor: +globalVersionMatch[2],
      patch: +globalVersionMatch[3],
      prerelease: globalVersionMatch[4]
    };
    if (globalVersionParsed.prerelease != null) {
      return _reject(globalVersion);
    }
    if (ownVersionParsed.major !== globalVersionParsed.major) {
      return _reject(globalVersion);
    }
    if (ownVersionParsed.major === 0) {
      if (ownVersionParsed.minor === globalVersionParsed.minor && ownVersionParsed.patch <= globalVersionParsed.patch) {
        return _accept(globalVersion);
      }
      return _reject(globalVersion);
    }
    if (ownVersionParsed.minor <= globalVersionParsed.minor) {
      return _accept(globalVersion);
    }
    return _reject(globalVersion);
  };
}
var re, isCompatible;
var init_semver = __esm({
  "node_modules/@opentelemetry/api/build/esm/internal/semver.js"() {
    init_version();
    re = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
    isCompatible = _makeCompatibilityCheck(VERSION);
  }
});

// node_modules/@opentelemetry/api/build/esm/internal/global-utils.js
function registerGlobal(type, instance, diag3, allowOverride) {
  var _a3;
  if (allowOverride === void 0) {
    allowOverride = false;
  }
  var api = _global[GLOBAL_OPENTELEMETRY_API_KEY] = (_a3 = _global[GLOBAL_OPENTELEMETRY_API_KEY]) !== null && _a3 !== void 0 ? _a3 : {
    version: VERSION
  };
  if (!allowOverride && api[type]) {
    var err = new Error("@opentelemetry/api: Attempted duplicate registration of API: " + type);
    diag3.error(err.stack || err.message);
    return false;
  }
  if (api.version !== VERSION) {
    var err = new Error("@opentelemetry/api: Registration of version v" + api.version + " for " + type + " does not match previously registered API v" + VERSION);
    diag3.error(err.stack || err.message);
    return false;
  }
  api[type] = instance;
  diag3.debug("@opentelemetry/api: Registered a global for " + type + " v" + VERSION + ".");
  return true;
}
function getGlobal(type) {
  var _a3, _b;
  var globalVersion = (_a3 = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _a3 === void 0 ? void 0 : _a3.version;
  if (!globalVersion || !isCompatible(globalVersion)) {
    return;
  }
  return (_b = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _b === void 0 ? void 0 : _b[type];
}
function unregisterGlobal(type, diag3) {
  diag3.debug("@opentelemetry/api: Unregistering a global for " + type + " v" + VERSION + ".");
  var api = _global[GLOBAL_OPENTELEMETRY_API_KEY];
  if (api) {
    delete api[type];
  }
}
var major, GLOBAL_OPENTELEMETRY_API_KEY, _global;
var init_global_utils = __esm({
  "node_modules/@opentelemetry/api/build/esm/internal/global-utils.js"() {
    init_platform();
    init_version();
    init_semver();
    major = VERSION.split(".")[0];
    GLOBAL_OPENTELEMETRY_API_KEY = Symbol.for("opentelemetry.js.api." + major);
    _global = _globalThis;
  }
});

// node_modules/@opentelemetry/api/build/esm/diag/ComponentLogger.js
function logProxy(funcName, namespace, args) {
  var logger = getGlobal("diag");
  if (!logger) {
    return;
  }
  args.unshift(namespace);
  return logger[funcName].apply(logger, __spreadArray([], __read(args), false));
}
var __read, __spreadArray, DiagComponentLogger;
var init_ComponentLogger = __esm({
  "node_modules/@opentelemetry/api/build/esm/diag/ComponentLogger.js"() {
    init_global_utils();
    __read = function(o4, n9) {
      var m2 = typeof Symbol === "function" && o4[Symbol.iterator];
      if (!m2)
        return o4;
      var i4 = m2.call(o4), r7, ar = [], e7;
      try {
        while ((n9 === void 0 || n9-- > 0) && !(r7 = i4.next()).done)
          ar.push(r7.value);
      } catch (error) {
        e7 = { error };
      } finally {
        try {
          if (r7 && !r7.done && (m2 = i4["return"]))
            m2.call(i4);
        } finally {
          if (e7)
            throw e7.error;
        }
      }
      return ar;
    };
    __spreadArray = function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i4 = 0, l5 = from.length, ar; i4 < l5; i4++) {
          if (ar || !(i4 in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i4);
            ar[i4] = from[i4];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    DiagComponentLogger = /** @class */
    function() {
      function DiagComponentLogger2(props) {
        this._namespace = props.namespace || "DiagComponentLogger";
      }
      DiagComponentLogger2.prototype.debug = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy("debug", this._namespace, args);
      };
      DiagComponentLogger2.prototype.error = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy("error", this._namespace, args);
      };
      DiagComponentLogger2.prototype.info = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy("info", this._namespace, args);
      };
      DiagComponentLogger2.prototype.warn = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy("warn", this._namespace, args);
      };
      DiagComponentLogger2.prototype.verbose = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy("verbose", this._namespace, args);
      };
      return DiagComponentLogger2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/diag/types.js
var DiagLogLevel;
var init_types = __esm({
  "node_modules/@opentelemetry/api/build/esm/diag/types.js"() {
    (function(DiagLogLevel2) {
      DiagLogLevel2[DiagLogLevel2["NONE"] = 0] = "NONE";
      DiagLogLevel2[DiagLogLevel2["ERROR"] = 30] = "ERROR";
      DiagLogLevel2[DiagLogLevel2["WARN"] = 50] = "WARN";
      DiagLogLevel2[DiagLogLevel2["INFO"] = 60] = "INFO";
      DiagLogLevel2[DiagLogLevel2["DEBUG"] = 70] = "DEBUG";
      DiagLogLevel2[DiagLogLevel2["VERBOSE"] = 80] = "VERBOSE";
      DiagLogLevel2[DiagLogLevel2["ALL"] = 9999] = "ALL";
    })(DiagLogLevel || (DiagLogLevel = {}));
  }
});

// node_modules/@opentelemetry/api/build/esm/diag/internal/logLevelLogger.js
function createLogLevelDiagLogger(maxLevel, logger) {
  if (maxLevel < DiagLogLevel.NONE) {
    maxLevel = DiagLogLevel.NONE;
  } else if (maxLevel > DiagLogLevel.ALL) {
    maxLevel = DiagLogLevel.ALL;
  }
  logger = logger || {};
  function _filterFunc(funcName, theLevel) {
    var theFunc = logger[funcName];
    if (typeof theFunc === "function" && maxLevel >= theLevel) {
      return theFunc.bind(logger);
    }
    return function() {
    };
  }
  return {
    error: _filterFunc("error", DiagLogLevel.ERROR),
    warn: _filterFunc("warn", DiagLogLevel.WARN),
    info: _filterFunc("info", DiagLogLevel.INFO),
    debug: _filterFunc("debug", DiagLogLevel.DEBUG),
    verbose: _filterFunc("verbose", DiagLogLevel.VERBOSE)
  };
}
var init_logLevelLogger = __esm({
  "node_modules/@opentelemetry/api/build/esm/diag/internal/logLevelLogger.js"() {
    init_types();
  }
});

// node_modules/@opentelemetry/api/build/esm/api/diag.js
var __read2, __spreadArray2, API_NAME, DiagAPI;
var init_diag = __esm({
  "node_modules/@opentelemetry/api/build/esm/api/diag.js"() {
    init_ComponentLogger();
    init_logLevelLogger();
    init_types();
    init_global_utils();
    __read2 = function(o4, n9) {
      var m2 = typeof Symbol === "function" && o4[Symbol.iterator];
      if (!m2)
        return o4;
      var i4 = m2.call(o4), r7, ar = [], e7;
      try {
        while ((n9 === void 0 || n9-- > 0) && !(r7 = i4.next()).done)
          ar.push(r7.value);
      } catch (error) {
        e7 = { error };
      } finally {
        try {
          if (r7 && !r7.done && (m2 = i4["return"]))
            m2.call(i4);
        } finally {
          if (e7)
            throw e7.error;
        }
      }
      return ar;
    };
    __spreadArray2 = function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i4 = 0, l5 = from.length, ar; i4 < l5; i4++) {
          if (ar || !(i4 in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i4);
            ar[i4] = from[i4];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    API_NAME = "diag";
    DiagAPI = /** @class */
    function() {
      function DiagAPI2() {
        function _logProxy(funcName) {
          return function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            var logger = getGlobal("diag");
            if (!logger)
              return;
            return logger[funcName].apply(logger, __spreadArray2([], __read2(args), false));
          };
        }
        var self2 = this;
        var setLogger = function(logger, optionsOrLogLevel) {
          var _a3, _b, _c;
          if (optionsOrLogLevel === void 0) {
            optionsOrLogLevel = { logLevel: DiagLogLevel.INFO };
          }
          if (logger === self2) {
            var err = new Error("Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation");
            self2.error((_a3 = err.stack) !== null && _a3 !== void 0 ? _a3 : err.message);
            return false;
          }
          if (typeof optionsOrLogLevel === "number") {
            optionsOrLogLevel = {
              logLevel: optionsOrLogLevel
            };
          }
          var oldLogger = getGlobal("diag");
          var newLogger = createLogLevelDiagLogger((_b = optionsOrLogLevel.logLevel) !== null && _b !== void 0 ? _b : DiagLogLevel.INFO, logger);
          if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {
            var stack = (_c = new Error().stack) !== null && _c !== void 0 ? _c : "<failed to generate stacktrace>";
            oldLogger.warn("Current logger will be overwritten from " + stack);
            newLogger.warn("Current logger will overwrite one already registered from " + stack);
          }
          return registerGlobal("diag", newLogger, self2, true);
        };
        self2.setLogger = setLogger;
        self2.disable = function() {
          unregisterGlobal(API_NAME, self2);
        };
        self2.createComponentLogger = function(options) {
          return new DiagComponentLogger(options);
        };
        self2.verbose = _logProxy("verbose");
        self2.debug = _logProxy("debug");
        self2.info = _logProxy("info");
        self2.warn = _logProxy("warn");
        self2.error = _logProxy("error");
      }
      DiagAPI2.instance = function() {
        if (!this._instance) {
          this._instance = new DiagAPI2();
        }
        return this._instance;
      };
      return DiagAPI2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/baggage/internal/baggage-impl.js
var __read3, __values, BaggageImpl;
var init_baggage_impl = __esm({
  "node_modules/@opentelemetry/api/build/esm/baggage/internal/baggage-impl.js"() {
    __read3 = function(o4, n9) {
      var m2 = typeof Symbol === "function" && o4[Symbol.iterator];
      if (!m2)
        return o4;
      var i4 = m2.call(o4), r7, ar = [], e7;
      try {
        while ((n9 === void 0 || n9-- > 0) && !(r7 = i4.next()).done)
          ar.push(r7.value);
      } catch (error) {
        e7 = { error };
      } finally {
        try {
          if (r7 && !r7.done && (m2 = i4["return"]))
            m2.call(i4);
        } finally {
          if (e7)
            throw e7.error;
        }
      }
      return ar;
    };
    __values = function(o4) {
      var s10 = typeof Symbol === "function" && Symbol.iterator, m2 = s10 && o4[s10], i4 = 0;
      if (m2)
        return m2.call(o4);
      if (o4 && typeof o4.length === "number")
        return {
          next: function() {
            if (o4 && i4 >= o4.length)
              o4 = void 0;
            return { value: o4 && o4[i4++], done: !o4 };
          }
        };
      throw new TypeError(s10 ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    BaggageImpl = /** @class */
    function() {
      function BaggageImpl2(entries) {
        this._entries = entries ? new Map(entries) : /* @__PURE__ */ new Map();
      }
      BaggageImpl2.prototype.getEntry = function(key) {
        var entry = this._entries.get(key);
        if (!entry) {
          return void 0;
        }
        return Object.assign({}, entry);
      };
      BaggageImpl2.prototype.getAllEntries = function() {
        return Array.from(this._entries.entries()).map(function(_a3) {
          var _b = __read3(_a3, 2), k3 = _b[0], v4 = _b[1];
          return [k3, v4];
        });
      };
      BaggageImpl2.prototype.setEntry = function(key, entry) {
        var newBaggage = new BaggageImpl2(this._entries);
        newBaggage._entries.set(key, entry);
        return newBaggage;
      };
      BaggageImpl2.prototype.removeEntry = function(key) {
        var newBaggage = new BaggageImpl2(this._entries);
        newBaggage._entries.delete(key);
        return newBaggage;
      };
      BaggageImpl2.prototype.removeEntries = function() {
        var e_1, _a3;
        var keys = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          keys[_i] = arguments[_i];
        }
        var newBaggage = new BaggageImpl2(this._entries);
        try {
          for (var keys_1 = __values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {
            var key = keys_1_1.value;
            newBaggage._entries.delete(key);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (keys_1_1 && !keys_1_1.done && (_a3 = keys_1.return))
              _a3.call(keys_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        return newBaggage;
      };
      BaggageImpl2.prototype.clear = function() {
        return new BaggageImpl2();
      };
      return BaggageImpl2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/baggage/internal/symbol.js
var baggageEntryMetadataSymbol;
var init_symbol = __esm({
  "node_modules/@opentelemetry/api/build/esm/baggage/internal/symbol.js"() {
    baggageEntryMetadataSymbol = Symbol("BaggageEntryMetadata");
  }
});

// node_modules/@opentelemetry/api/build/esm/baggage/utils.js
function createBaggage(entries) {
  if (entries === void 0) {
    entries = {};
  }
  return new BaggageImpl(new Map(Object.entries(entries)));
}
function baggageEntryMetadataFromString(str) {
  if (typeof str !== "string") {
    diag.error("Cannot create baggage metadata from unknown type: " + typeof str);
    str = "";
  }
  return {
    __TYPE__: baggageEntryMetadataSymbol,
    toString: function() {
      return str;
    }
  };
}
var diag;
var init_utils = __esm({
  "node_modules/@opentelemetry/api/build/esm/baggage/utils.js"() {
    init_diag();
    init_baggage_impl();
    init_symbol();
    diag = DiagAPI.instance();
  }
});

// node_modules/@opentelemetry/api/build/esm/context/context.js
function createContextKey(description) {
  return Symbol.for(description);
}
var BaseContext, ROOT_CONTEXT;
var init_context = __esm({
  "node_modules/@opentelemetry/api/build/esm/context/context.js"() {
    BaseContext = /** @class */
    function() {
      function BaseContext2(parentContext) {
        var self2 = this;
        self2._currentContext = parentContext ? new Map(parentContext) : /* @__PURE__ */ new Map();
        self2.getValue = function(key) {
          return self2._currentContext.get(key);
        };
        self2.setValue = function(key, value) {
          var context2 = new BaseContext2(self2._currentContext);
          context2._currentContext.set(key, value);
          return context2;
        };
        self2.deleteValue = function(key) {
          var context2 = new BaseContext2(self2._currentContext);
          context2._currentContext.delete(key);
          return context2;
        };
      }
      return BaseContext2;
    }();
    ROOT_CONTEXT = new BaseContext();
  }
});

// node_modules/@opentelemetry/api/build/esm/metrics/NoopMeter.js
var __extends, NoopMeter, NoopMetric, NoopCounterMetric, NoopUpDownCounterMetric, NoopGaugeMetric, NoopHistogramMetric, NoopObservableMetric, NoopObservableCounterMetric, NoopObservableGaugeMetric, NoopObservableUpDownCounterMetric, NOOP_METER, NOOP_COUNTER_METRIC, NOOP_GAUGE_METRIC, NOOP_HISTOGRAM_METRIC, NOOP_UP_DOWN_COUNTER_METRIC, NOOP_OBSERVABLE_COUNTER_METRIC, NOOP_OBSERVABLE_GAUGE_METRIC, NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC;
var init_NoopMeter = __esm({
  "node_modules/@opentelemetry/api/build/esm/metrics/NoopMeter.js"() {
    __extends = function() {
      var extendStatics = function(d5, b4) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d6, b5) {
          d6.__proto__ = b5;
        } || function(d6, b5) {
          for (var p9 in b5)
            if (Object.prototype.hasOwnProperty.call(b5, p9))
              d6[p9] = b5[p9];
        };
        return extendStatics(d5, b4);
      };
      return function(d5, b4) {
        if (typeof b4 !== "function" && b4 !== null)
          throw new TypeError("Class extends value " + String(b4) + " is not a constructor or null");
        extendStatics(d5, b4);
        function __() {
          this.constructor = d5;
        }
        d5.prototype = b4 === null ? Object.create(b4) : (__.prototype = b4.prototype, new __());
      };
    }();
    NoopMeter = /** @class */
    function() {
      function NoopMeter2() {
      }
      NoopMeter2.prototype.createGauge = function(_name, _options) {
        return NOOP_GAUGE_METRIC;
      };
      NoopMeter2.prototype.createHistogram = function(_name, _options) {
        return NOOP_HISTOGRAM_METRIC;
      };
      NoopMeter2.prototype.createCounter = function(_name, _options) {
        return NOOP_COUNTER_METRIC;
      };
      NoopMeter2.prototype.createUpDownCounter = function(_name, _options) {
        return NOOP_UP_DOWN_COUNTER_METRIC;
      };
      NoopMeter2.prototype.createObservableGauge = function(_name, _options) {
        return NOOP_OBSERVABLE_GAUGE_METRIC;
      };
      NoopMeter2.prototype.createObservableCounter = function(_name, _options) {
        return NOOP_OBSERVABLE_COUNTER_METRIC;
      };
      NoopMeter2.prototype.createObservableUpDownCounter = function(_name, _options) {
        return NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC;
      };
      NoopMeter2.prototype.addBatchObservableCallback = function(_callback, _observables) {
      };
      NoopMeter2.prototype.removeBatchObservableCallback = function(_callback) {
      };
      return NoopMeter2;
    }();
    NoopMetric = /** @class */
    function() {
      function NoopMetric2() {
      }
      return NoopMetric2;
    }();
    NoopCounterMetric = /** @class */
    function(_super) {
      __extends(NoopCounterMetric2, _super);
      function NoopCounterMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      NoopCounterMetric2.prototype.add = function(_value, _attributes) {
      };
      return NoopCounterMetric2;
    }(NoopMetric);
    NoopUpDownCounterMetric = /** @class */
    function(_super) {
      __extends(NoopUpDownCounterMetric2, _super);
      function NoopUpDownCounterMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      NoopUpDownCounterMetric2.prototype.add = function(_value, _attributes) {
      };
      return NoopUpDownCounterMetric2;
    }(NoopMetric);
    NoopGaugeMetric = /** @class */
    function(_super) {
      __extends(NoopGaugeMetric2, _super);
      function NoopGaugeMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      NoopGaugeMetric2.prototype.record = function(_value, _attributes) {
      };
      return NoopGaugeMetric2;
    }(NoopMetric);
    NoopHistogramMetric = /** @class */
    function(_super) {
      __extends(NoopHistogramMetric2, _super);
      function NoopHistogramMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      NoopHistogramMetric2.prototype.record = function(_value, _attributes) {
      };
      return NoopHistogramMetric2;
    }(NoopMetric);
    NoopObservableMetric = /** @class */
    function() {
      function NoopObservableMetric2() {
      }
      NoopObservableMetric2.prototype.addCallback = function(_callback) {
      };
      NoopObservableMetric2.prototype.removeCallback = function(_callback) {
      };
      return NoopObservableMetric2;
    }();
    NoopObservableCounterMetric = /** @class */
    function(_super) {
      __extends(NoopObservableCounterMetric2, _super);
      function NoopObservableCounterMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return NoopObservableCounterMetric2;
    }(NoopObservableMetric);
    NoopObservableGaugeMetric = /** @class */
    function(_super) {
      __extends(NoopObservableGaugeMetric2, _super);
      function NoopObservableGaugeMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return NoopObservableGaugeMetric2;
    }(NoopObservableMetric);
    NoopObservableUpDownCounterMetric = /** @class */
    function(_super) {
      __extends(NoopObservableUpDownCounterMetric2, _super);
      function NoopObservableUpDownCounterMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return NoopObservableUpDownCounterMetric2;
    }(NoopObservableMetric);
    NOOP_METER = new NoopMeter();
    NOOP_COUNTER_METRIC = new NoopCounterMetric();
    NOOP_GAUGE_METRIC = new NoopGaugeMetric();
    NOOP_HISTOGRAM_METRIC = new NoopHistogramMetric();
    NOOP_UP_DOWN_COUNTER_METRIC = new NoopUpDownCounterMetric();
    NOOP_OBSERVABLE_COUNTER_METRIC = new NoopObservableCounterMetric();
    NOOP_OBSERVABLE_GAUGE_METRIC = new NoopObservableGaugeMetric();
    NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC = new NoopObservableUpDownCounterMetric();
  }
});

// node_modules/@opentelemetry/api/build/esm/propagation/TextMapPropagator.js
var defaultTextMapGetter, defaultTextMapSetter;
var init_TextMapPropagator = __esm({
  "node_modules/@opentelemetry/api/build/esm/propagation/TextMapPropagator.js"() {
    defaultTextMapGetter = {
      get: function(carrier, key) {
        if (carrier == null) {
          return void 0;
        }
        return carrier[key];
      },
      keys: function(carrier) {
        if (carrier == null) {
          return [];
        }
        return Object.keys(carrier);
      }
    };
    defaultTextMapSetter = {
      set: function(carrier, key, value) {
        if (carrier == null) {
          return;
        }
        carrier[key] = value;
      }
    };
  }
});

// node_modules/@opentelemetry/api/build/esm/context/NoopContextManager.js
var __read4, __spreadArray3, NoopContextManager;
var init_NoopContextManager = __esm({
  "node_modules/@opentelemetry/api/build/esm/context/NoopContextManager.js"() {
    init_context();
    __read4 = function(o4, n9) {
      var m2 = typeof Symbol === "function" && o4[Symbol.iterator];
      if (!m2)
        return o4;
      var i4 = m2.call(o4), r7, ar = [], e7;
      try {
        while ((n9 === void 0 || n9-- > 0) && !(r7 = i4.next()).done)
          ar.push(r7.value);
      } catch (error) {
        e7 = { error };
      } finally {
        try {
          if (r7 && !r7.done && (m2 = i4["return"]))
            m2.call(i4);
        } finally {
          if (e7)
            throw e7.error;
        }
      }
      return ar;
    };
    __spreadArray3 = function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i4 = 0, l5 = from.length, ar; i4 < l5; i4++) {
          if (ar || !(i4 in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i4);
            ar[i4] = from[i4];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    NoopContextManager = /** @class */
    function() {
      function NoopContextManager2() {
      }
      NoopContextManager2.prototype.active = function() {
        return ROOT_CONTEXT;
      };
      NoopContextManager2.prototype.with = function(_context, fn, thisArg) {
        var args = [];
        for (var _i = 3; _i < arguments.length; _i++) {
          args[_i - 3] = arguments[_i];
        }
        return fn.call.apply(fn, __spreadArray3([thisArg], __read4(args), false));
      };
      NoopContextManager2.prototype.bind = function(_context, target) {
        return target;
      };
      NoopContextManager2.prototype.enable = function() {
        return this;
      };
      NoopContextManager2.prototype.disable = function() {
        return this;
      };
      return NoopContextManager2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/api/context.js
var __read5, __spreadArray4, API_NAME2, NOOP_CONTEXT_MANAGER, ContextAPI;
var init_context2 = __esm({
  "node_modules/@opentelemetry/api/build/esm/api/context.js"() {
    init_NoopContextManager();
    init_global_utils();
    init_diag();
    __read5 = function(o4, n9) {
      var m2 = typeof Symbol === "function" && o4[Symbol.iterator];
      if (!m2)
        return o4;
      var i4 = m2.call(o4), r7, ar = [], e7;
      try {
        while ((n9 === void 0 || n9-- > 0) && !(r7 = i4.next()).done)
          ar.push(r7.value);
      } catch (error) {
        e7 = { error };
      } finally {
        try {
          if (r7 && !r7.done && (m2 = i4["return"]))
            m2.call(i4);
        } finally {
          if (e7)
            throw e7.error;
        }
      }
      return ar;
    };
    __spreadArray4 = function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i4 = 0, l5 = from.length, ar; i4 < l5; i4++) {
          if (ar || !(i4 in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i4);
            ar[i4] = from[i4];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    API_NAME2 = "context";
    NOOP_CONTEXT_MANAGER = new NoopContextManager();
    ContextAPI = /** @class */
    function() {
      function ContextAPI2() {
      }
      ContextAPI2.getInstance = function() {
        if (!this._instance) {
          this._instance = new ContextAPI2();
        }
        return this._instance;
      };
      ContextAPI2.prototype.setGlobalContextManager = function(contextManager) {
        return registerGlobal(API_NAME2, contextManager, DiagAPI.instance());
      };
      ContextAPI2.prototype.active = function() {
        return this._getContextManager().active();
      };
      ContextAPI2.prototype.with = function(context2, fn, thisArg) {
        var _a3;
        var args = [];
        for (var _i = 3; _i < arguments.length; _i++) {
          args[_i - 3] = arguments[_i];
        }
        return (_a3 = this._getContextManager()).with.apply(_a3, __spreadArray4([context2, fn, thisArg], __read5(args), false));
      };
      ContextAPI2.prototype.bind = function(context2, target) {
        return this._getContextManager().bind(context2, target);
      };
      ContextAPI2.prototype._getContextManager = function() {
        return getGlobal(API_NAME2) || NOOP_CONTEXT_MANAGER;
      };
      ContextAPI2.prototype.disable = function() {
        this._getContextManager().disable();
        unregisterGlobal(API_NAME2, DiagAPI.instance());
      };
      return ContextAPI2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/trace_flags.js
var TraceFlags;
var init_trace_flags = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/trace_flags.js"() {
    (function(TraceFlags2) {
      TraceFlags2[TraceFlags2["NONE"] = 0] = "NONE";
      TraceFlags2[TraceFlags2["SAMPLED"] = 1] = "SAMPLED";
    })(TraceFlags || (TraceFlags = {}));
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/invalid-span-constants.js
var INVALID_SPANID, INVALID_TRACEID, INVALID_SPAN_CONTEXT;
var init_invalid_span_constants = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/invalid-span-constants.js"() {
    init_trace_flags();
    INVALID_SPANID = "0000000000000000";
    INVALID_TRACEID = "00000000000000000000000000000000";
    INVALID_SPAN_CONTEXT = {
      traceId: INVALID_TRACEID,
      spanId: INVALID_SPANID,
      traceFlags: TraceFlags.NONE
    };
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/NonRecordingSpan.js
var NonRecordingSpan;
var init_NonRecordingSpan = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/NonRecordingSpan.js"() {
    init_invalid_span_constants();
    NonRecordingSpan = /** @class */
    function() {
      function NonRecordingSpan2(_spanContext) {
        if (_spanContext === void 0) {
          _spanContext = INVALID_SPAN_CONTEXT;
        }
        this._spanContext = _spanContext;
      }
      NonRecordingSpan2.prototype.spanContext = function() {
        return this._spanContext;
      };
      NonRecordingSpan2.prototype.setAttribute = function(_key, _value) {
        return this;
      };
      NonRecordingSpan2.prototype.setAttributes = function(_attributes) {
        return this;
      };
      NonRecordingSpan2.prototype.addEvent = function(_name, _attributes) {
        return this;
      };
      NonRecordingSpan2.prototype.addLink = function(_link) {
        return this;
      };
      NonRecordingSpan2.prototype.addLinks = function(_links) {
        return this;
      };
      NonRecordingSpan2.prototype.setStatus = function(_status) {
        return this;
      };
      NonRecordingSpan2.prototype.updateName = function(_name) {
        return this;
      };
      NonRecordingSpan2.prototype.end = function(_endTime) {
      };
      NonRecordingSpan2.prototype.isRecording = function() {
        return false;
      };
      NonRecordingSpan2.prototype.recordException = function(_exception, _time) {
      };
      return NonRecordingSpan2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/context-utils.js
function getSpan(context2) {
  return context2.getValue(SPAN_KEY) || void 0;
}
function getActiveSpan() {
  return getSpan(ContextAPI.getInstance().active());
}
function setSpan(context2, span) {
  return context2.setValue(SPAN_KEY, span);
}
function deleteSpan(context2) {
  return context2.deleteValue(SPAN_KEY);
}
function setSpanContext(context2, spanContext) {
  return setSpan(context2, new NonRecordingSpan(spanContext));
}
function getSpanContext(context2) {
  var _a3;
  return (_a3 = getSpan(context2)) === null || _a3 === void 0 ? void 0 : _a3.spanContext();
}
var SPAN_KEY;
var init_context_utils = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/context-utils.js"() {
    init_context();
    init_NonRecordingSpan();
    init_context2();
    SPAN_KEY = createContextKey("OpenTelemetry Context Key SPAN");
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/spancontext-utils.js
function isValidTraceId(traceId) {
  return VALID_TRACEID_REGEX.test(traceId) && traceId !== INVALID_TRACEID;
}
function isValidSpanId(spanId) {
  return VALID_SPANID_REGEX.test(spanId) && spanId !== INVALID_SPANID;
}
function isSpanContextValid(spanContext) {
  return isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId);
}
function wrapSpanContext(spanContext) {
  return new NonRecordingSpan(spanContext);
}
var VALID_TRACEID_REGEX, VALID_SPANID_REGEX;
var init_spancontext_utils = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/spancontext-utils.js"() {
    init_invalid_span_constants();
    init_NonRecordingSpan();
    VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i;
    VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/NoopTracer.js
function isSpanContext(spanContext) {
  return typeof spanContext === "object" && typeof spanContext["spanId"] === "string" && typeof spanContext["traceId"] === "string" && typeof spanContext["traceFlags"] === "number";
}
var contextApi, NoopTracer;
var init_NoopTracer = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/NoopTracer.js"() {
    init_context2();
    init_context_utils();
    init_NonRecordingSpan();
    init_spancontext_utils();
    contextApi = ContextAPI.getInstance();
    NoopTracer = /** @class */
    function() {
      function NoopTracer2() {
      }
      NoopTracer2.prototype.startSpan = function(name, options, context2) {
        if (context2 === void 0) {
          context2 = contextApi.active();
        }
        var root = Boolean(options === null || options === void 0 ? void 0 : options.root);
        if (root) {
          return new NonRecordingSpan();
        }
        var parentFromContext = context2 && getSpanContext(context2);
        if (isSpanContext(parentFromContext) && isSpanContextValid(parentFromContext)) {
          return new NonRecordingSpan(parentFromContext);
        } else {
          return new NonRecordingSpan();
        }
      };
      NoopTracer2.prototype.startActiveSpan = function(name, arg2, arg3, arg4) {
        var opts;
        var ctx;
        var fn;
        if (arguments.length < 2) {
          return;
        } else if (arguments.length === 2) {
          fn = arg2;
        } else if (arguments.length === 3) {
          opts = arg2;
          fn = arg3;
        } else {
          opts = arg2;
          ctx = arg3;
          fn = arg4;
        }
        var parentContext = ctx !== null && ctx !== void 0 ? ctx : contextApi.active();
        var span = this.startSpan(name, opts, parentContext);
        var contextWithSpanSet = setSpan(parentContext, span);
        return contextApi.with(contextWithSpanSet, fn, void 0, span);
      };
      return NoopTracer2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/ProxyTracer.js
var NOOP_TRACER, ProxyTracer;
var init_ProxyTracer = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/ProxyTracer.js"() {
    init_NoopTracer();
    NOOP_TRACER = new NoopTracer();
    ProxyTracer = /** @class */
    function() {
      function ProxyTracer2(_provider, name, version, options) {
        this._provider = _provider;
        this.name = name;
        this.version = version;
        this.options = options;
      }
      ProxyTracer2.prototype.startSpan = function(name, options, context2) {
        return this._getTracer().startSpan(name, options, context2);
      };
      ProxyTracer2.prototype.startActiveSpan = function(_name, _options, _context, _fn) {
        var tracer = this._getTracer();
        return Reflect.apply(tracer.startActiveSpan, tracer, arguments);
      };
      ProxyTracer2.prototype._getTracer = function() {
        if (this._delegate) {
          return this._delegate;
        }
        var tracer = this._provider.getDelegateTracer(this.name, this.version, this.options);
        if (!tracer) {
          return NOOP_TRACER;
        }
        this._delegate = tracer;
        return this._delegate;
      };
      return ProxyTracer2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/NoopTracerProvider.js
var NoopTracerProvider;
var init_NoopTracerProvider = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/NoopTracerProvider.js"() {
    init_NoopTracer();
    NoopTracerProvider = /** @class */
    function() {
      function NoopTracerProvider2() {
      }
      NoopTracerProvider2.prototype.getTracer = function(_name, _version, _options) {
        return new NoopTracer();
      };
      return NoopTracerProvider2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/ProxyTracerProvider.js
var NOOP_TRACER_PROVIDER, ProxyTracerProvider;
var init_ProxyTracerProvider = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/ProxyTracerProvider.js"() {
    init_ProxyTracer();
    init_NoopTracerProvider();
    NOOP_TRACER_PROVIDER = new NoopTracerProvider();
    ProxyTracerProvider = /** @class */
    function() {
      function ProxyTracerProvider2() {
      }
      ProxyTracerProvider2.prototype.getTracer = function(name, version, options) {
        var _a3;
        return (_a3 = this.getDelegateTracer(name, version, options)) !== null && _a3 !== void 0 ? _a3 : new ProxyTracer(this, name, version, options);
      };
      ProxyTracerProvider2.prototype.getDelegate = function() {
        var _a3;
        return (_a3 = this._delegate) !== null && _a3 !== void 0 ? _a3 : NOOP_TRACER_PROVIDER;
      };
      ProxyTracerProvider2.prototype.setDelegate = function(delegate) {
        this._delegate = delegate;
      };
      ProxyTracerProvider2.prototype.getDelegateTracer = function(name, version, options) {
        var _a3;
        return (_a3 = this._delegate) === null || _a3 === void 0 ? void 0 : _a3.getTracer(name, version, options);
      };
      return ProxyTracerProvider2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/SamplingResult.js
var SamplingDecision;
var init_SamplingResult = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/SamplingResult.js"() {
    (function(SamplingDecision3) {
      SamplingDecision3[SamplingDecision3["NOT_RECORD"] = 0] = "NOT_RECORD";
      SamplingDecision3[SamplingDecision3["RECORD"] = 1] = "RECORD";
      SamplingDecision3[SamplingDecision3["RECORD_AND_SAMPLED"] = 2] = "RECORD_AND_SAMPLED";
    })(SamplingDecision || (SamplingDecision = {}));
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/span_kind.js
var SpanKind;
var init_span_kind = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/span_kind.js"() {
    (function(SpanKind2) {
      SpanKind2[SpanKind2["INTERNAL"] = 0] = "INTERNAL";
      SpanKind2[SpanKind2["SERVER"] = 1] = "SERVER";
      SpanKind2[SpanKind2["CLIENT"] = 2] = "CLIENT";
      SpanKind2[SpanKind2["PRODUCER"] = 3] = "PRODUCER";
      SpanKind2[SpanKind2["CONSUMER"] = 4] = "CONSUMER";
    })(SpanKind || (SpanKind = {}));
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/status.js
var SpanStatusCode;
var init_status = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/status.js"() {
    (function(SpanStatusCode2) {
      SpanStatusCode2[SpanStatusCode2["UNSET"] = 0] = "UNSET";
      SpanStatusCode2[SpanStatusCode2["OK"] = 1] = "OK";
      SpanStatusCode2[SpanStatusCode2["ERROR"] = 2] = "ERROR";
    })(SpanStatusCode || (SpanStatusCode = {}));
  }
});

// node_modules/@opentelemetry/api/build/esm/context-api.js
var context;
var init_context_api = __esm({
  "node_modules/@opentelemetry/api/build/esm/context-api.js"() {
    init_context2();
    context = ContextAPI.getInstance();
  }
});

// node_modules/@opentelemetry/api/build/esm/diag-api.js
var diag2;
var init_diag_api = __esm({
  "node_modules/@opentelemetry/api/build/esm/diag-api.js"() {
    init_diag();
    diag2 = DiagAPI.instance();
  }
});

// node_modules/@opentelemetry/api/build/esm/metrics/NoopMeterProvider.js
var NoopMeterProvider, NOOP_METER_PROVIDER;
var init_NoopMeterProvider = __esm({
  "node_modules/@opentelemetry/api/build/esm/metrics/NoopMeterProvider.js"() {
    init_NoopMeter();
    NoopMeterProvider = /** @class */
    function() {
      function NoopMeterProvider2() {
      }
      NoopMeterProvider2.prototype.getMeter = function(_name, _version, _options) {
        return NOOP_METER;
      };
      return NoopMeterProvider2;
    }();
    NOOP_METER_PROVIDER = new NoopMeterProvider();
  }
});

// node_modules/@opentelemetry/api/build/esm/api/metrics.js
var API_NAME3, MetricsAPI;
var init_metrics = __esm({
  "node_modules/@opentelemetry/api/build/esm/api/metrics.js"() {
    init_NoopMeterProvider();
    init_global_utils();
    init_diag();
    API_NAME3 = "metrics";
    MetricsAPI = /** @class */
    function() {
      function MetricsAPI2() {
      }
      MetricsAPI2.getInstance = function() {
        if (!this._instance) {
          this._instance = new MetricsAPI2();
        }
        return this._instance;
      };
      MetricsAPI2.prototype.setGlobalMeterProvider = function(provider) {
        return registerGlobal(API_NAME3, provider, DiagAPI.instance());
      };
      MetricsAPI2.prototype.getMeterProvider = function() {
        return getGlobal(API_NAME3) || NOOP_METER_PROVIDER;
      };
      MetricsAPI2.prototype.getMeter = function(name, version, options) {
        return this.getMeterProvider().getMeter(name, version, options);
      };
      MetricsAPI2.prototype.disable = function() {
        unregisterGlobal(API_NAME3, DiagAPI.instance());
      };
      return MetricsAPI2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/metrics-api.js
var metrics;
var init_metrics_api = __esm({
  "node_modules/@opentelemetry/api/build/esm/metrics-api.js"() {
    init_metrics();
    metrics = MetricsAPI.getInstance();
  }
});

// node_modules/@opentelemetry/api/build/esm/propagation/NoopTextMapPropagator.js
var NoopTextMapPropagator;
var init_NoopTextMapPropagator = __esm({
  "node_modules/@opentelemetry/api/build/esm/propagation/NoopTextMapPropagator.js"() {
    NoopTextMapPropagator = /** @class */
    function() {
      function NoopTextMapPropagator2() {
      }
      NoopTextMapPropagator2.prototype.inject = function(_context, _carrier) {
      };
      NoopTextMapPropagator2.prototype.extract = function(context2, _carrier) {
        return context2;
      };
      NoopTextMapPropagator2.prototype.fields = function() {
        return [];
      };
      return NoopTextMapPropagator2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/baggage/context-helpers.js
function getBaggage(context2) {
  return context2.getValue(BAGGAGE_KEY) || void 0;
}
function getActiveBaggage() {
  return getBaggage(ContextAPI.getInstance().active());
}
function setBaggage(context2, baggage) {
  return context2.setValue(BAGGAGE_KEY, baggage);
}
function deleteBaggage(context2) {
  return context2.deleteValue(BAGGAGE_KEY);
}
var BAGGAGE_KEY;
var init_context_helpers = __esm({
  "node_modules/@opentelemetry/api/build/esm/baggage/context-helpers.js"() {
    init_context2();
    init_context();
    BAGGAGE_KEY = createContextKey("OpenTelemetry Baggage Key");
  }
});

// node_modules/@opentelemetry/api/build/esm/api/propagation.js
var API_NAME4, NOOP_TEXT_MAP_PROPAGATOR, PropagationAPI;
var init_propagation = __esm({
  "node_modules/@opentelemetry/api/build/esm/api/propagation.js"() {
    init_global_utils();
    init_NoopTextMapPropagator();
    init_TextMapPropagator();
    init_context_helpers();
    init_utils();
    init_diag();
    API_NAME4 = "propagation";
    NOOP_TEXT_MAP_PROPAGATOR = new NoopTextMapPropagator();
    PropagationAPI = /** @class */
    function() {
      function PropagationAPI2() {
        this.createBaggage = createBaggage;
        this.getBaggage = getBaggage;
        this.getActiveBaggage = getActiveBaggage;
        this.setBaggage = setBaggage;
        this.deleteBaggage = deleteBaggage;
      }
      PropagationAPI2.getInstance = function() {
        if (!this._instance) {
          this._instance = new PropagationAPI2();
        }
        return this._instance;
      };
      PropagationAPI2.prototype.setGlobalPropagator = function(propagator) {
        return registerGlobal(API_NAME4, propagator, DiagAPI.instance());
      };
      PropagationAPI2.prototype.inject = function(context2, carrier, setter) {
        if (setter === void 0) {
          setter = defaultTextMapSetter;
        }
        return this._getGlobalPropagator().inject(context2, carrier, setter);
      };
      PropagationAPI2.prototype.extract = function(context2, carrier, getter) {
        if (getter === void 0) {
          getter = defaultTextMapGetter;
        }
        return this._getGlobalPropagator().extract(context2, carrier, getter);
      };
      PropagationAPI2.prototype.fields = function() {
        return this._getGlobalPropagator().fields();
      };
      PropagationAPI2.prototype.disable = function() {
        unregisterGlobal(API_NAME4, DiagAPI.instance());
      };
      PropagationAPI2.prototype._getGlobalPropagator = function() {
        return getGlobal(API_NAME4) || NOOP_TEXT_MAP_PROPAGATOR;
      };
      return PropagationAPI2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/propagation-api.js
var propagation;
var init_propagation_api = __esm({
  "node_modules/@opentelemetry/api/build/esm/propagation-api.js"() {
    init_propagation();
    propagation = PropagationAPI.getInstance();
  }
});

// node_modules/@opentelemetry/api/build/esm/api/trace.js
var API_NAME5, TraceAPI;
var init_trace = __esm({
  "node_modules/@opentelemetry/api/build/esm/api/trace.js"() {
    init_global_utils();
    init_ProxyTracerProvider();
    init_spancontext_utils();
    init_context_utils();
    init_diag();
    API_NAME5 = "trace";
    TraceAPI = /** @class */
    function() {
      function TraceAPI2() {
        this._proxyTracerProvider = new ProxyTracerProvider();
        this.wrapSpanContext = wrapSpanContext;
        this.isSpanContextValid = isSpanContextValid;
        this.deleteSpan = deleteSpan;
        this.getSpan = getSpan;
        this.getActiveSpan = getActiveSpan;
        this.getSpanContext = getSpanContext;
        this.setSpan = setSpan;
        this.setSpanContext = setSpanContext;
      }
      TraceAPI2.getInstance = function() {
        if (!this._instance) {
          this._instance = new TraceAPI2();
        }
        return this._instance;
      };
      TraceAPI2.prototype.setGlobalTracerProvider = function(provider) {
        var success = registerGlobal(API_NAME5, this._proxyTracerProvider, DiagAPI.instance());
        if (success) {
          this._proxyTracerProvider.setDelegate(provider);
        }
        return success;
      };
      TraceAPI2.prototype.getTracerProvider = function() {
        return getGlobal(API_NAME5) || this._proxyTracerProvider;
      };
      TraceAPI2.prototype.getTracer = function(name, version) {
        return this.getTracerProvider().getTracer(name, version);
      };
      TraceAPI2.prototype.disable = function() {
        unregisterGlobal(API_NAME5, DiagAPI.instance());
        this._proxyTracerProvider = new ProxyTracerProvider();
      };
      return TraceAPI2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/trace-api.js
var trace;
var init_trace_api = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace-api.js"() {
    init_trace();
    trace = TraceAPI.getInstance();
  }
});

// node_modules/@opentelemetry/api/build/esm/index.js
var init_esm = __esm({
  "node_modules/@opentelemetry/api/build/esm/index.js"() {
    init_utils();
    init_context();
    init_types();
    init_SamplingResult();
    init_span_kind();
    init_status();
    init_trace_flags();
    init_spancontext_utils();
    init_invalid_span_constants();
    init_context_api();
    init_diag_api();
    init_metrics_api();
    init_propagation_api();
    init_trace_api();
  }
});

// node_modules/semver/internal/constants.js
var require_constants = __commonJS({
  "node_modules/semver/internal/constants.js"(exports, module) {
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var RELEASE_TYPES = [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease"
    ];
    module.exports = {
      MAX_LENGTH,
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_SAFE_INTEGER,
      RELEASE_TYPES,
      SEMVER_SPEC_VERSION,
      FLAG_INCLUDE_PRERELEASE: 1,
      FLAG_LOOSE: 2
    };
  }
});

// node_modules/semver/internal/debug.js
var require_debug = __commonJS({
  "node_modules/semver/internal/debug.js"(exports, module) {
    var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module.exports = debug;
  }
});

// node_modules/semver/internal/re.js
var require_re = __commonJS({
  "node_modules/semver/internal/re.js"(exports, module) {
    var {
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_LENGTH
    } = require_constants();
    var debug = require_debug();
    exports = module.exports = {};
    var re2 = exports.re = [];
    var safeRe = exports.safeRe = [];
    var src = exports.src = [];
    var t5 = exports.t = {};
    var R6 = 0;
    var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    var safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    var makeSafeRegex = (value) => {
      for (const [token, max] of safeRegexReplacements) {
        value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
      }
      return value;
    };
    var createToken = (name, value, isGlobal) => {
      const safe = makeSafeRegex(value);
      const index = R6++;
      debug(name, index, value);
      t5[name] = index;
      src[index] = value;
      re2[index] = new RegExp(value, isGlobal ? "g" : void 0);
      safeRe[index] = new RegExp(safe, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
    createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
    createToken("MAINVERSION", `(${src[t5.NUMERICIDENTIFIER]})\\.(${src[t5.NUMERICIDENTIFIER]})\\.(${src[t5.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t5.NUMERICIDENTIFIERLOOSE]})\\.(${src[t5.NUMERICIDENTIFIERLOOSE]})\\.(${src[t5.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t5.NUMERICIDENTIFIER]}|${src[t5.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t5.NUMERICIDENTIFIERLOOSE]}|${src[t5.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASE", `(?:-(${src[t5.PRERELEASEIDENTIFIER]}(?:\\.${src[t5.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t5.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t5.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
    createToken("BUILD", `(?:\\+(${src[t5.BUILDIDENTIFIER]}(?:\\.${src[t5.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t5.MAINVERSION]}${src[t5.PRERELEASE]}?${src[t5.BUILD]}?`);
    createToken("FULL", `^${src[t5.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t5.MAINVERSIONLOOSE]}${src[t5.PRERELEASELOOSE]}?${src[t5.BUILD]}?`);
    createToken("LOOSE", `^${src[t5.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t5.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t5.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t5.XRANGEIDENTIFIER]})(?:\\.(${src[t5.XRANGEIDENTIFIER]})(?:\\.(${src[t5.XRANGEIDENTIFIER]})(?:${src[t5.PRERELEASE]})?${src[t5.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t5.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t5.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t5.XRANGEIDENTIFIERLOOSE]})(?:${src[t5.PRERELEASELOOSE]})?${src[t5.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t5.GTLT]}\\s*${src[t5.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t5.GTLT]}\\s*${src[t5.XRANGEPLAINLOOSE]}$`);
    createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
    createToken("COERCE", `${src[t5.COERCEPLAIN]}(?:$|[^\\d])`);
    createToken("COERCEFULL", src[t5.COERCEPLAIN] + `(?:${src[t5.PRERELEASE]})?(?:${src[t5.BUILD]})?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t5.COERCE], true);
    createToken("COERCERTLFULL", src[t5.COERCEFULL], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t5.LONETILDE]}\\s+`, true);
    exports.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t5.LONETILDE]}${src[t5.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t5.LONETILDE]}${src[t5.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t5.LONECARET]}\\s+`, true);
    exports.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t5.LONECARET]}${src[t5.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t5.LONECARET]}${src[t5.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t5.GTLT]}\\s*(${src[t5.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t5.GTLT]}\\s*(${src[t5.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t5.GTLT]}\\s*(${src[t5.LOOSEPLAIN]}|${src[t5.XRANGEPLAIN]})`, true);
    exports.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t5.XRANGEPLAIN]})\\s+-\\s+(${src[t5.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t5.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t5.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  }
});

// node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS({
  "node_modules/semver/internal/parse-options.js"(exports, module) {
    var looseOption = Object.freeze({ loose: true });
    var emptyOpts = Object.freeze({});
    var parseOptions = (options) => {
      if (!options) {
        return emptyOpts;
      }
      if (typeof options !== "object") {
        return looseOption;
      }
      return options;
    };
    module.exports = parseOptions;
  }
});

// node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS({
  "node_modules/semver/internal/identifiers.js"(exports, module) {
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = (a4, b4) => {
      const anum = numeric.test(a4);
      const bnum = numeric.test(b4);
      if (anum && bnum) {
        a4 = +a4;
        b4 = +b4;
      }
      return a4 === b4 ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a4 < b4 ? -1 : 1;
    };
    var rcompareIdentifiers = (a4, b4) => compareIdentifiers(b4, a4);
    module.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});

// node_modules/semver/classes/semver.js
var require_semver = __commonJS({
  "node_modules/semver/classes/semver.js"(exports, module) {
    var debug = require_debug();
    var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants();
    var { safeRe: re2, t: t5 } = require_re();
    var parseOptions = require_parse_options();
    var { compareIdentifiers } = require_identifiers();
    var SemVer = class {
      constructor(version, options) {
        options = parseOptions(options);
        if (version instanceof SemVer) {
          if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
            return version;
          } else {
            version = version.version;
          }
        } else if (typeof version !== "string") {
          throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`);
        }
        if (version.length > MAX_LENGTH) {
          throw new TypeError(
            `version is longer than ${MAX_LENGTH} characters`
          );
        }
        debug("SemVer", version, options);
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        const m2 = version.trim().match(options.loose ? re2[t5.LOOSE] : re2[t5.FULL]);
        if (!m2) {
          throw new TypeError(`Invalid Version: ${version}`);
        }
        this.raw = version;
        this.major = +m2[1];
        this.minor = +m2[2];
        this.patch = +m2[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m2[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m2[4].split(".").map((id) => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id;
          });
        }
        this.build = m2[5] ? m2[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
      }
      comparePre(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i4 = 0;
        do {
          const a4 = this.prerelease[i4];
          const b4 = other.prerelease[i4];
          debug("prerelease compare", i4, a4, b4);
          if (a4 === void 0 && b4 === void 0) {
            return 0;
          } else if (b4 === void 0) {
            return 1;
          } else if (a4 === void 0) {
            return -1;
          } else if (a4 === b4) {
            continue;
          } else {
            return compareIdentifiers(a4, b4);
          }
        } while (++i4);
      }
      compareBuild(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        let i4 = 0;
        do {
          const a4 = this.build[i4];
          const b4 = other.build[i4];
          debug("prerelease compare", i4, a4, b4);
          if (a4 === void 0 && b4 === void 0) {
            return 0;
          } else if (b4 === void 0) {
            return 1;
          } else if (a4 === void 0) {
            return -1;
          } else if (a4 === b4) {
            continue;
          } else {
            return compareIdentifiers(a4, b4);
          }
        } while (++i4);
      }
      // preminor will bump the version up to the next minor release, and immediately
      // down to pre-release. premajor and prepatch work the same way.
      inc(release, identifier, identifierBase) {
        switch (release) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier, identifierBase);
            this.inc("pre", identifier, identifierBase);
            break;
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier, identifierBase);
            }
            this.inc("pre", identifier, identifierBase);
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          case "pre": {
            const base = Number(identifierBase) ? 1 : 0;
            if (!identifier && identifierBase === false) {
              throw new Error("invalid increment argument: identifier is empty");
            }
            if (this.prerelease.length === 0) {
              this.prerelease = [base];
            } else {
              let i4 = this.prerelease.length;
              while (--i4 >= 0) {
                if (typeof this.prerelease[i4] === "number") {
                  this.prerelease[i4]++;
                  i4 = -2;
                }
              }
              if (i4 === -1) {
                if (identifier === this.prerelease.join(".") && identifierBase === false) {
                  throw new Error("invalid increment argument: identifier already exists");
                }
                this.prerelease.push(base);
              }
            }
            if (identifier) {
              let prerelease = [identifier, base];
              if (identifierBase === false) {
                prerelease = [identifier];
              }
              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = prerelease;
                }
              } else {
                this.prerelease = prerelease;
              }
            }
            break;
          }
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.raw = this.format();
        if (this.build.length) {
          this.raw += `+${this.build.join(".")}`;
        }
        return this;
      }
    };
    module.exports = SemVer;
  }
});

// node_modules/semver/functions/parse.js
var require_parse = __commonJS({
  "node_modules/semver/functions/parse.js"(exports, module) {
    var SemVer = require_semver();
    var parse = (version, options, throwErrors = false) => {
      if (version instanceof SemVer) {
        return version;
      }
      try {
        return new SemVer(version, options);
      } catch (er) {
        if (!throwErrors) {
          return null;
        }
        throw er;
      }
    };
    module.exports = parse;
  }
});

// node_modules/semver/functions/valid.js
var require_valid = __commonJS({
  "node_modules/semver/functions/valid.js"(exports, module) {
    var parse = require_parse();
    var valid = (version, options) => {
      const v4 = parse(version, options);
      return v4 ? v4.version : null;
    };
    module.exports = valid;
  }
});

// node_modules/semver/functions/clean.js
var require_clean = __commonJS({
  "node_modules/semver/functions/clean.js"(exports, module) {
    var parse = require_parse();
    var clean = (version, options) => {
      const s10 = parse(version.trim().replace(/^[=v]+/, ""), options);
      return s10 ? s10.version : null;
    };
    module.exports = clean;
  }
});

// node_modules/semver/functions/inc.js
var require_inc = __commonJS({
  "node_modules/semver/functions/inc.js"(exports, module) {
    var SemVer = require_semver();
    var inc = (version, release, options, identifier, identifierBase) => {
      if (typeof options === "string") {
        identifierBase = identifier;
        identifier = options;
        options = void 0;
      }
      try {
        return new SemVer(
          version instanceof SemVer ? version.version : version,
          options
        ).inc(release, identifier, identifierBase).version;
      } catch (er) {
        return null;
      }
    };
    module.exports = inc;
  }
});

// node_modules/semver/functions/diff.js
var require_diff = __commonJS({
  "node_modules/semver/functions/diff.js"(exports, module) {
    var parse = require_parse();
    var diff = (version1, version2) => {
      const v1 = parse(version1, null, true);
      const v22 = parse(version2, null, true);
      const comparison = v1.compare(v22);
      if (comparison === 0) {
        return null;
      }
      const v1Higher = comparison > 0;
      const highVersion = v1Higher ? v1 : v22;
      const lowVersion = v1Higher ? v22 : v1;
      const highHasPre = !!highVersion.prerelease.length;
      const lowHasPre = !!lowVersion.prerelease.length;
      if (lowHasPre && !highHasPre) {
        if (!lowVersion.patch && !lowVersion.minor) {
          return "major";
        }
        if (highVersion.patch) {
          return "patch";
        }
        if (highVersion.minor) {
          return "minor";
        }
        return "major";
      }
      const prefix = highHasPre ? "pre" : "";
      if (v1.major !== v22.major) {
        return prefix + "major";
      }
      if (v1.minor !== v22.minor) {
        return prefix + "minor";
      }
      if (v1.patch !== v22.patch) {
        return prefix + "patch";
      }
      return "prerelease";
    };
    module.exports = diff;
  }
});

// node_modules/semver/functions/major.js
var require_major = __commonJS({
  "node_modules/semver/functions/major.js"(exports, module) {
    var SemVer = require_semver();
    var major2 = (a4, loose) => new SemVer(a4, loose).major;
    module.exports = major2;
  }
});

// node_modules/semver/functions/minor.js
var require_minor = __commonJS({
  "node_modules/semver/functions/minor.js"(exports, module) {
    var SemVer = require_semver();
    var minor = (a4, loose) => new SemVer(a4, loose).minor;
    module.exports = minor;
  }
});

// node_modules/semver/functions/patch.js
var require_patch = __commonJS({
  "node_modules/semver/functions/patch.js"(exports, module) {
    var SemVer = require_semver();
    var patch = (a4, loose) => new SemVer(a4, loose).patch;
    module.exports = patch;
  }
});

// node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS({
  "node_modules/semver/functions/prerelease.js"(exports, module) {
    var parse = require_parse();
    var prerelease = (version, options) => {
      const parsed = parse(version, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    };
    module.exports = prerelease;
  }
});

// node_modules/semver/functions/compare.js
var require_compare = __commonJS({
  "node_modules/semver/functions/compare.js"(exports, module) {
    var SemVer = require_semver();
    var compare = (a4, b4, loose) => new SemVer(a4, loose).compare(new SemVer(b4, loose));
    module.exports = compare;
  }
});

// node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS({
  "node_modules/semver/functions/rcompare.js"(exports, module) {
    var compare = require_compare();
    var rcompare = (a4, b4, loose) => compare(b4, a4, loose);
    module.exports = rcompare;
  }
});

// node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS({
  "node_modules/semver/functions/compare-loose.js"(exports, module) {
    var compare = require_compare();
    var compareLoose = (a4, b4) => compare(a4, b4, true);
    module.exports = compareLoose;
  }
});

// node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS({
  "node_modules/semver/functions/compare-build.js"(exports, module) {
    var SemVer = require_semver();
    var compareBuild = (a4, b4, loose) => {
      const versionA = new SemVer(a4, loose);
      const versionB = new SemVer(b4, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    };
    module.exports = compareBuild;
  }
});

// node_modules/semver/functions/sort.js
var require_sort = __commonJS({
  "node_modules/semver/functions/sort.js"(exports, module) {
    var compareBuild = require_compare_build();
    var sort = (list, loose) => list.sort((a4, b4) => compareBuild(a4, b4, loose));
    module.exports = sort;
  }
});

// node_modules/semver/functions/rsort.js
var require_rsort = __commonJS({
  "node_modules/semver/functions/rsort.js"(exports, module) {
    var compareBuild = require_compare_build();
    var rsort = (list, loose) => list.sort((a4, b4) => compareBuild(b4, a4, loose));
    module.exports = rsort;
  }
});

// node_modules/semver/functions/gt.js
var require_gt = __commonJS({
  "node_modules/semver/functions/gt.js"(exports, module) {
    var compare = require_compare();
    var gt = (a4, b4, loose) => compare(a4, b4, loose) > 0;
    module.exports = gt;
  }
});

// node_modules/semver/functions/lt.js
var require_lt = __commonJS({
  "node_modules/semver/functions/lt.js"(exports, module) {
    var compare = require_compare();
    var lt = (a4, b4, loose) => compare(a4, b4, loose) < 0;
    module.exports = lt;
  }
});

// node_modules/semver/functions/eq.js
var require_eq = __commonJS({
  "node_modules/semver/functions/eq.js"(exports, module) {
    var compare = require_compare();
    var eq = (a4, b4, loose) => compare(a4, b4, loose) === 0;
    module.exports = eq;
  }
});

// node_modules/semver/functions/neq.js
var require_neq = __commonJS({
  "node_modules/semver/functions/neq.js"(exports, module) {
    var compare = require_compare();
    var neq = (a4, b4, loose) => compare(a4, b4, loose) !== 0;
    module.exports = neq;
  }
});

// node_modules/semver/functions/gte.js
var require_gte = __commonJS({
  "node_modules/semver/functions/gte.js"(exports, module) {
    var compare = require_compare();
    var gte = (a4, b4, loose) => compare(a4, b4, loose) >= 0;
    module.exports = gte;
  }
});

// node_modules/semver/functions/lte.js
var require_lte = __commonJS({
  "node_modules/semver/functions/lte.js"(exports, module) {
    var compare = require_compare();
    var lte = (a4, b4, loose) => compare(a4, b4, loose) <= 0;
    module.exports = lte;
  }
});

// node_modules/semver/functions/cmp.js
var require_cmp = __commonJS({
  "node_modules/semver/functions/cmp.js"(exports, module) {
    var eq = require_eq();
    var neq = require_neq();
    var gt = require_gt();
    var gte = require_gte();
    var lt = require_lt();
    var lte = require_lte();
    var cmp = (a4, op, b4, loose) => {
      switch (op) {
        case "===":
          if (typeof a4 === "object") {
            a4 = a4.version;
          }
          if (typeof b4 === "object") {
            b4 = b4.version;
          }
          return a4 === b4;
        case "!==":
          if (typeof a4 === "object") {
            a4 = a4.version;
          }
          if (typeof b4 === "object") {
            b4 = b4.version;
          }
          return a4 !== b4;
        case "":
        case "=":
        case "==":
          return eq(a4, b4, loose);
        case "!=":
          return neq(a4, b4, loose);
        case ">":
          return gt(a4, b4, loose);
        case ">=":
          return gte(a4, b4, loose);
        case "<":
          return lt(a4, b4, loose);
        case "<=":
          return lte(a4, b4, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    };
    module.exports = cmp;
  }
});

// node_modules/semver/functions/coerce.js
var require_coerce = __commonJS({
  "node_modules/semver/functions/coerce.js"(exports, module) {
    var SemVer = require_semver();
    var parse = require_parse();
    var { safeRe: re2, t: t5 } = require_re();
    var coerce = (version, options) => {
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version === "number") {
        version = String(version);
      }
      if (typeof version !== "string") {
        return null;
      }
      options = options || {};
      let match = null;
      if (!options.rtl) {
        match = version.match(options.includePrerelease ? re2[t5.COERCEFULL] : re2[t5.COERCE]);
      } else {
        const coerceRtlRegex = options.includePrerelease ? re2[t5.COERCERTLFULL] : re2[t5.COERCERTL];
        let next;
        while ((next = coerceRtlRegex.exec(version)) && (!match || match.index + match[0].length !== version.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
        }
        coerceRtlRegex.lastIndex = -1;
      }
      if (match === null) {
        return null;
      }
      const major2 = match[2];
      const minor = match[3] || "0";
      const patch = match[4] || "0";
      const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : "";
      const build = options.includePrerelease && match[6] ? `+${match[6]}` : "";
      return parse(`${major2}.${minor}.${patch}${prerelease}${build}`, options);
    };
    module.exports = coerce;
  }
});

// node_modules/semver/node_modules/yallist/iterator.js
var require_iterator = __commonJS({
  "node_modules/semver/node_modules/yallist/iterator.js"(exports, module) {
    "use strict";
    module.exports = function(Yallist) {
      Yallist.prototype[Symbol.iterator] = function* () {
        for (let walker = this.head; walker; walker = walker.next) {
          yield walker.value;
        }
      };
    };
  }
});

// node_modules/semver/node_modules/yallist/yallist.js
var require_yallist = __commonJS({
  "node_modules/semver/node_modules/yallist/yallist.js"(exports, module) {
    "use strict";
    module.exports = Yallist;
    Yallist.Node = Node2;
    Yallist.create = Yallist;
    function Yallist(list) {
      var self2 = this;
      if (!(self2 instanceof Yallist)) {
        self2 = new Yallist();
      }
      self2.tail = null;
      self2.head = null;
      self2.length = 0;
      if (list && typeof list.forEach === "function") {
        list.forEach(function(item) {
          self2.push(item);
        });
      } else if (arguments.length > 0) {
        for (var i4 = 0, l5 = arguments.length; i4 < l5; i4++) {
          self2.push(arguments[i4]);
        }
      }
      return self2;
    }
    Yallist.prototype.removeNode = function(node) {
      if (node.list !== this) {
        throw new Error("removing node which does not belong to this list");
      }
      var next = node.next;
      var prev = node.prev;
      if (next) {
        next.prev = prev;
      }
      if (prev) {
        prev.next = next;
      }
      if (node === this.head) {
        this.head = next;
      }
      if (node === this.tail) {
        this.tail = prev;
      }
      node.list.length--;
      node.next = null;
      node.prev = null;
      node.list = null;
      return next;
    };
    Yallist.prototype.unshiftNode = function(node) {
      if (node === this.head) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var head = this.head;
      node.list = this;
      node.next = head;
      if (head) {
        head.prev = node;
      }
      this.head = node;
      if (!this.tail) {
        this.tail = node;
      }
      this.length++;
    };
    Yallist.prototype.pushNode = function(node) {
      if (node === this.tail) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var tail = this.tail;
      node.list = this;
      node.prev = tail;
      if (tail) {
        tail.next = node;
      }
      this.tail = node;
      if (!this.head) {
        this.head = node;
      }
      this.length++;
    };
    Yallist.prototype.push = function() {
      for (var i4 = 0, l5 = arguments.length; i4 < l5; i4++) {
        push(this, arguments[i4]);
      }
      return this.length;
    };
    Yallist.prototype.unshift = function() {
      for (var i4 = 0, l5 = arguments.length; i4 < l5; i4++) {
        unshift(this, arguments[i4]);
      }
      return this.length;
    };
    Yallist.prototype.pop = function() {
      if (!this.tail) {
        return void 0;
      }
      var res = this.tail.value;
      this.tail = this.tail.prev;
      if (this.tail) {
        this.tail.next = null;
      } else {
        this.head = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.shift = function() {
      if (!this.head) {
        return void 0;
      }
      var res = this.head.value;
      this.head = this.head.next;
      if (this.head) {
        this.head.prev = null;
      } else {
        this.tail = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.forEach = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.head, i4 = 0; walker !== null; i4++) {
        fn.call(thisp, walker.value, i4, this);
        walker = walker.next;
      }
    };
    Yallist.prototype.forEachReverse = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.tail, i4 = this.length - 1; walker !== null; i4--) {
        fn.call(thisp, walker.value, i4, this);
        walker = walker.prev;
      }
    };
    Yallist.prototype.get = function(n9) {
      for (var i4 = 0, walker = this.head; walker !== null && i4 < n9; i4++) {
        walker = walker.next;
      }
      if (i4 === n9 && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.getReverse = function(n9) {
      for (var i4 = 0, walker = this.tail; walker !== null && i4 < n9; i4++) {
        walker = walker.prev;
      }
      if (i4 === n9 && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.map = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.head; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.next;
      }
      return res;
    };
    Yallist.prototype.mapReverse = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.tail; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.prev;
      }
      return res;
    };
    Yallist.prototype.reduce = function(fn, initial) {
      var acc;
      var walker = this.head;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.head) {
        walker = this.head.next;
        acc = this.head.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i4 = 0; walker !== null; i4++) {
        acc = fn(acc, walker.value, i4);
        walker = walker.next;
      }
      return acc;
    };
    Yallist.prototype.reduceReverse = function(fn, initial) {
      var acc;
      var walker = this.tail;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.tail) {
        walker = this.tail.prev;
        acc = this.tail.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i4 = this.length - 1; walker !== null; i4--) {
        acc = fn(acc, walker.value, i4);
        walker = walker.prev;
      }
      return acc;
    };
    Yallist.prototype.toArray = function() {
      var arr = new Array(this.length);
      for (var i4 = 0, walker = this.head; walker !== null; i4++) {
        arr[i4] = walker.value;
        walker = walker.next;
      }
      return arr;
    };
    Yallist.prototype.toArrayReverse = function() {
      var arr = new Array(this.length);
      for (var i4 = 0, walker = this.tail; walker !== null; i4++) {
        arr[i4] = walker.value;
        walker = walker.prev;
      }
      return arr;
    };
    Yallist.prototype.slice = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i4 = 0, walker = this.head; walker !== null && i4 < from; i4++) {
        walker = walker.next;
      }
      for (; walker !== null && i4 < to; i4++, walker = walker.next) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.sliceReverse = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i4 = this.length, walker = this.tail; walker !== null && i4 > to; i4--) {
        walker = walker.prev;
      }
      for (; walker !== null && i4 > from; i4--, walker = walker.prev) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
      if (start > this.length) {
        start = this.length - 1;
      }
      if (start < 0) {
        start = this.length + start;
      }
      for (var i4 = 0, walker = this.head; walker !== null && i4 < start; i4++) {
        walker = walker.next;
      }
      var ret = [];
      for (var i4 = 0; walker && i4 < deleteCount; i4++) {
        ret.push(walker.value);
        walker = this.removeNode(walker);
      }
      if (walker === null) {
        walker = this.tail;
      }
      if (walker !== this.head && walker !== this.tail) {
        walker = walker.prev;
      }
      for (var i4 = 0; i4 < nodes.length; i4++) {
        walker = insert(this, walker, nodes[i4]);
      }
      return ret;
    };
    Yallist.prototype.reverse = function() {
      var head = this.head;
      var tail = this.tail;
      for (var walker = head; walker !== null; walker = walker.prev) {
        var p9 = walker.prev;
        walker.prev = walker.next;
        walker.next = p9;
      }
      this.head = tail;
      this.tail = head;
      return this;
    };
    function insert(self2, node, value) {
      var inserted = node === self2.head ? new Node2(value, null, node, self2) : new Node2(value, node, node.next, self2);
      if (inserted.next === null) {
        self2.tail = inserted;
      }
      if (inserted.prev === null) {
        self2.head = inserted;
      }
      self2.length++;
      return inserted;
    }
    function push(self2, item) {
      self2.tail = new Node2(item, self2.tail, null, self2);
      if (!self2.head) {
        self2.head = self2.tail;
      }
      self2.length++;
    }
    function unshift(self2, item) {
      self2.head = new Node2(item, null, self2.head, self2);
      if (!self2.tail) {
        self2.tail = self2.head;
      }
      self2.length++;
    }
    function Node2(value, prev, next, list) {
      if (!(this instanceof Node2)) {
        return new Node2(value, prev, next, list);
      }
      this.list = list;
      this.value = value;
      if (prev) {
        prev.next = this;
        this.prev = prev;
      } else {
        this.prev = null;
      }
      if (next) {
        next.prev = this;
        this.next = next;
      } else {
        this.next = null;
      }
    }
    try {
      require_iterator()(Yallist);
    } catch (er) {
    }
  }
});

// node_modules/semver/node_modules/lru-cache/index.js
var require_lru_cache = __commonJS({
  "node_modules/semver/node_modules/lru-cache/index.js"(exports, module) {
    "use strict";
    var Yallist = require_yallist();
    var MAX = Symbol("max");
    var LENGTH = Symbol("length");
    var LENGTH_CALCULATOR = Symbol("lengthCalculator");
    var ALLOW_STALE = Symbol("allowStale");
    var MAX_AGE = Symbol("maxAge");
    var DISPOSE = Symbol("dispose");
    var NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
    var LRU_LIST = Symbol("lruList");
    var CACHE = Symbol("cache");
    var UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
    var naiveLength = () => 1;
    var LRUCache = class {
      constructor(options) {
        if (typeof options === "number")
          options = { max: options };
        if (!options)
          options = {};
        if (options.max && (typeof options.max !== "number" || options.max < 0))
          throw new TypeError("max must be a non-negative number");
        const max = this[MAX] = options.max || Infinity;
        const lc = options.length || naiveLength;
        this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
        this[ALLOW_STALE] = options.stale || false;
        if (options.maxAge && typeof options.maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        this[MAX_AGE] = options.maxAge || 0;
        this[DISPOSE] = options.dispose;
        this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
        this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
        this.reset();
      }
      // resize the cache when the max changes.
      set max(mL) {
        if (typeof mL !== "number" || mL < 0)
          throw new TypeError("max must be a non-negative number");
        this[MAX] = mL || Infinity;
        trim(this);
      }
      get max() {
        return this[MAX];
      }
      set allowStale(allowStale) {
        this[ALLOW_STALE] = !!allowStale;
      }
      get allowStale() {
        return this[ALLOW_STALE];
      }
      set maxAge(mA) {
        if (typeof mA !== "number")
          throw new TypeError("maxAge must be a non-negative number");
        this[MAX_AGE] = mA;
        trim(this);
      }
      get maxAge() {
        return this[MAX_AGE];
      }
      // resize the cache when the lengthCalculator changes.
      set lengthCalculator(lC) {
        if (typeof lC !== "function")
          lC = naiveLength;
        if (lC !== this[LENGTH_CALCULATOR]) {
          this[LENGTH_CALCULATOR] = lC;
          this[LENGTH] = 0;
          this[LRU_LIST].forEach((hit) => {
            hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
            this[LENGTH] += hit.length;
          });
        }
        trim(this);
      }
      get lengthCalculator() {
        return this[LENGTH_CALCULATOR];
      }
      get length() {
        return this[LENGTH];
      }
      get itemCount() {
        return this[LRU_LIST].length;
      }
      rforEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].tail; walker !== null; ) {
          const prev = walker.prev;
          forEachStep(this, fn, walker, thisp);
          walker = prev;
        }
      }
      forEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].head; walker !== null; ) {
          const next = walker.next;
          forEachStep(this, fn, walker, thisp);
          walker = next;
        }
      }
      keys() {
        return this[LRU_LIST].toArray().map((k3) => k3.key);
      }
      values() {
        return this[LRU_LIST].toArray().map((k3) => k3.value);
      }
      reset() {
        if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
          this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
        }
        this[CACHE] = /* @__PURE__ */ new Map();
        this[LRU_LIST] = new Yallist();
        this[LENGTH] = 0;
      }
      dump() {
        return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
          k: hit.key,
          v: hit.value,
          e: hit.now + (hit.maxAge || 0)
        }).toArray().filter((h4) => h4);
      }
      dumpLru() {
        return this[LRU_LIST];
      }
      set(key, value, maxAge) {
        maxAge = maxAge || this[MAX_AGE];
        if (maxAge && typeof maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        const now = maxAge ? Date.now() : 0;
        const len = this[LENGTH_CALCULATOR](value, key);
        if (this[CACHE].has(key)) {
          if (len > this[MAX]) {
            del(this, this[CACHE].get(key));
            return false;
          }
          const node = this[CACHE].get(key);
          const item = node.value;
          if (this[DISPOSE]) {
            if (!this[NO_DISPOSE_ON_SET])
              this[DISPOSE](key, item.value);
          }
          item.now = now;
          item.maxAge = maxAge;
          item.value = value;
          this[LENGTH] += len - item.length;
          item.length = len;
          this.get(key);
          trim(this);
          return true;
        }
        const hit = new Entry(key, value, len, now, maxAge);
        if (hit.length > this[MAX]) {
          if (this[DISPOSE])
            this[DISPOSE](key, value);
          return false;
        }
        this[LENGTH] += hit.length;
        this[LRU_LIST].unshift(hit);
        this[CACHE].set(key, this[LRU_LIST].head);
        trim(this);
        return true;
      }
      has(key) {
        if (!this[CACHE].has(key))
          return false;
        const hit = this[CACHE].get(key).value;
        return !isStale(this, hit);
      }
      get(key) {
        return get(this, key, true);
      }
      peek(key) {
        return get(this, key, false);
      }
      pop() {
        const node = this[LRU_LIST].tail;
        if (!node)
          return null;
        del(this, node);
        return node.value;
      }
      del(key) {
        del(this, this[CACHE].get(key));
      }
      load(arr) {
        this.reset();
        const now = Date.now();
        for (let l5 = arr.length - 1; l5 >= 0; l5--) {
          const hit = arr[l5];
          const expiresAt = hit.e || 0;
          if (expiresAt === 0)
            this.set(hit.k, hit.v);
          else {
            const maxAge = expiresAt - now;
            if (maxAge > 0) {
              this.set(hit.k, hit.v, maxAge);
            }
          }
        }
      }
      prune() {
        this[CACHE].forEach((value, key) => get(this, key, false));
      }
    };
    var get = (self2, key, doUse) => {
      const node = self2[CACHE].get(key);
      if (node) {
        const hit = node.value;
        if (isStale(self2, hit)) {
          del(self2, node);
          if (!self2[ALLOW_STALE])
            return void 0;
        } else {
          if (doUse) {
            if (self2[UPDATE_AGE_ON_GET])
              node.value.now = Date.now();
            self2[LRU_LIST].unshiftNode(node);
          }
        }
        return hit.value;
      }
    };
    var isStale = (self2, hit) => {
      if (!hit || !hit.maxAge && !self2[MAX_AGE])
        return false;
      const diff = Date.now() - hit.now;
      return hit.maxAge ? diff > hit.maxAge : self2[MAX_AGE] && diff > self2[MAX_AGE];
    };
    var trim = (self2) => {
      if (self2[LENGTH] > self2[MAX]) {
        for (let walker = self2[LRU_LIST].tail; self2[LENGTH] > self2[MAX] && walker !== null; ) {
          const prev = walker.prev;
          del(self2, walker);
          walker = prev;
        }
      }
    };
    var del = (self2, node) => {
      if (node) {
        const hit = node.value;
        if (self2[DISPOSE])
          self2[DISPOSE](hit.key, hit.value);
        self2[LENGTH] -= hit.length;
        self2[CACHE].delete(hit.key);
        self2[LRU_LIST].removeNode(node);
      }
    };
    var Entry = class {
      constructor(key, value, length, now, maxAge) {
        this.key = key;
        this.value = value;
        this.length = length;
        this.now = now;
        this.maxAge = maxAge || 0;
      }
    };
    var forEachStep = (self2, fn, node, thisp) => {
      let hit = node.value;
      if (isStale(self2, hit)) {
        del(self2, node);
        if (!self2[ALLOW_STALE])
          hit = void 0;
      }
      if (hit)
        fn.call(thisp, hit.value, hit.key, self2);
    };
    module.exports = LRUCache;
  }
});

// node_modules/semver/classes/range.js
var require_range = __commonJS({
  "node_modules/semver/classes/range.js"(exports, module) {
    var Range = class {
      constructor(range, options) {
        options = parseOptions(options);
        if (range instanceof Range) {
          if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
            return range;
          } else {
            return new Range(range.raw, options);
          }
        }
        if (range instanceof Comparator) {
          this.raw = range.value;
          this.set = [[range]];
          this.format();
          return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        this.raw = range.trim().split(/\s+/).join(" ");
        this.set = this.raw.split("||").map((r7) => this.parseRange(r7.trim())).filter((c5) => c5.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
        }
        if (this.set.length > 1) {
          const first = this.set[0];
          this.set = this.set.filter((c5) => !isNullSet(c5[0]));
          if (this.set.length === 0) {
            this.set = [first];
          } else if (this.set.length > 1) {
            for (const c5 of this.set) {
              if (c5.length === 1 && isAny(c5[0])) {
                this.set = [c5];
                break;
              }
            }
          }
        }
        this.format();
      }
      format() {
        this.range = this.set.map((comps) => comps.join(" ").trim()).join("||").trim();
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range) {
        const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
        const memoKey = memoOpts + ":" + range;
        const cached = cache.get(memoKey);
        if (cached) {
          return cached;
        }
        const loose = this.options.loose;
        const hr = loose ? re2[t5.HYPHENRANGELOOSE] : re2[t5.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug("hyphen replace", range);
        range = range.replace(re2[t5.COMPARATORTRIM], comparatorTrimReplace);
        debug("comparator trim", range);
        range = range.replace(re2[t5.TILDETRIM], tildeTrimReplace);
        debug("tilde trim", range);
        range = range.replace(re2[t5.CARETTRIM], caretTrimReplace);
        debug("caret trim", range);
        let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
        if (loose) {
          rangeList = rangeList.filter((comp) => {
            debug("loose invalid filter", comp, this.options);
            return !!comp.match(re2[t5.COMPARATORLOOSE]);
          });
        }
        debug("range list", rangeList);
        const rangeMap = /* @__PURE__ */ new Map();
        const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
        for (const comp of comparators) {
          if (isNullSet(comp)) {
            return [comp];
          }
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has("")) {
          rangeMap.delete("");
        }
        const result = [...rangeMap.values()];
        cache.set(memoKey, result);
        return result;
      }
      intersects(range, options) {
        if (!(range instanceof Range)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options);
              });
            });
          });
        });
      }
      // if ANY of the sets match ALL of its comparators, then pass
      test(version) {
        if (!version) {
          return false;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer(version, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i4 = 0; i4 < this.set.length; i4++) {
          if (testSet(this.set[i4], version, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module.exports = Range;
    var LRU = require_lru_cache();
    var cache = new LRU({ max: 1e3 });
    var parseOptions = require_parse_options();
    var Comparator = require_comparator();
    var debug = require_debug();
    var SemVer = require_semver();
    var {
      safeRe: re2,
      t: t5,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re();
    var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants();
    var isNullSet = (c5) => c5.value === "<0.0.0-0";
    var isAny = (c5) => c5.value === "";
    var isSatisfiable = (comparators, options) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    };
    var parseComparator = (comp, options) => {
      debug("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug("caret", comp);
      comp = replaceTildes(comp, options);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug("xrange", comp);
      comp = replaceStars(comp, options);
      debug("stars", comp);
      return comp;
    };
    var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
    var replaceTildes = (comp, options) => {
      return comp.trim().split(/\s+/).map((c5) => replaceTilde(c5, options)).join(" ");
    };
    var replaceTilde = (comp, options) => {
      const r7 = options.loose ? re2[t5.TILDELOOSE] : re2[t5.TILDE];
      return comp.replace(r7, (_2, M3, m2, p9, pr) => {
        debug("tilde", comp, _2, M3, m2, p9, pr);
        let ret;
        if (isX(M3)) {
          ret = "";
        } else if (isX(m2)) {
          ret = `>=${M3}.0.0 <${+M3 + 1}.0.0-0`;
        } else if (isX(p9)) {
          ret = `>=${M3}.${m2}.0 <${M3}.${+m2 + 1}.0-0`;
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = `>=${M3}.${m2}.${p9}-${pr} <${M3}.${+m2 + 1}.0-0`;
        } else {
          ret = `>=${M3}.${m2}.${p9} <${M3}.${+m2 + 1}.0-0`;
        }
        debug("tilde return", ret);
        return ret;
      });
    };
    var replaceCarets = (comp, options) => {
      return comp.trim().split(/\s+/).map((c5) => replaceCaret(c5, options)).join(" ");
    };
    var replaceCaret = (comp, options) => {
      debug("caret", comp, options);
      const r7 = options.loose ? re2[t5.CARETLOOSE] : re2[t5.CARET];
      const z3 = options.includePrerelease ? "-0" : "";
      return comp.replace(r7, (_2, M3, m2, p9, pr) => {
        debug("caret", comp, _2, M3, m2, p9, pr);
        let ret;
        if (isX(M3)) {
          ret = "";
        } else if (isX(m2)) {
          ret = `>=${M3}.0.0${z3} <${+M3 + 1}.0.0-0`;
        } else if (isX(p9)) {
          if (M3 === "0") {
            ret = `>=${M3}.${m2}.0${z3} <${M3}.${+m2 + 1}.0-0`;
          } else {
            ret = `>=${M3}.${m2}.0${z3} <${+M3 + 1}.0.0-0`;
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M3 === "0") {
            if (m2 === "0") {
              ret = `>=${M3}.${m2}.${p9}-${pr} <${M3}.${m2}.${+p9 + 1}-0`;
            } else {
              ret = `>=${M3}.${m2}.${p9}-${pr} <${M3}.${+m2 + 1}.0-0`;
            }
          } else {
            ret = `>=${M3}.${m2}.${p9}-${pr} <${+M3 + 1}.0.0-0`;
          }
        } else {
          debug("no pr");
          if (M3 === "0") {
            if (m2 === "0") {
              ret = `>=${M3}.${m2}.${p9}${z3} <${M3}.${m2}.${+p9 + 1}-0`;
            } else {
              ret = `>=${M3}.${m2}.${p9}${z3} <${M3}.${+m2 + 1}.0-0`;
            }
          } else {
            ret = `>=${M3}.${m2}.${p9} <${+M3 + 1}.0.0-0`;
          }
        }
        debug("caret return", ret);
        return ret;
      });
    };
    var replaceXRanges = (comp, options) => {
      debug("replaceXRanges", comp, options);
      return comp.split(/\s+/).map((c5) => replaceXRange(c5, options)).join(" ");
    };
    var replaceXRange = (comp, options) => {
      comp = comp.trim();
      const r7 = options.loose ? re2[t5.XRANGELOOSE] : re2[t5.XRANGE];
      return comp.replace(r7, (ret, gtlt, M3, m2, p9, pr) => {
        debug("xRange", comp, ret, gtlt, M3, m2, p9, pr);
        const xM = isX(M3);
        const xm = xM || isX(m2);
        const xp = xm || isX(p9);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m2 = 0;
          }
          p9 = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M3 = +M3 + 1;
              m2 = 0;
              p9 = 0;
            } else {
              m2 = +m2 + 1;
              p9 = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M3 = +M3 + 1;
            } else {
              m2 = +m2 + 1;
            }
          }
          if (gtlt === "<") {
            pr = "-0";
          }
          ret = `${gtlt + M3}.${m2}.${p9}${pr}`;
        } else if (xm) {
          ret = `>=${M3}.0.0${pr} <${+M3 + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M3}.${m2}.0${pr} <${M3}.${+m2 + 1}.0-0`;
        }
        debug("xRange return", ret);
        return ret;
      });
    };
    var replaceStars = (comp, options) => {
      debug("replaceStars", comp, options);
      return comp.trim().replace(re2[t5.STAR], "");
    };
    var replaceGTE0 = (comp, options) => {
      debug("replaceGTE0", comp, options);
      return comp.trim().replace(re2[options.includePrerelease ? t5.GTE0PRE : t5.GTE0], "");
    };
    var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) => {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from} ${to}`.trim();
    };
    var testSet = (set, version, options) => {
      for (let i4 = 0; i4 < set.length; i4++) {
        if (!set[i4].test(version)) {
          return false;
        }
      }
      if (version.prerelease.length && !options.includePrerelease) {
        for (let i4 = 0; i4 < set.length; i4++) {
          debug(set[i4].semver);
          if (set[i4].semver === Comparator.ANY) {
            continue;
          }
          if (set[i4].semver.prerelease.length > 0) {
            const allowed = set[i4].semver;
            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  }
});

// node_modules/semver/classes/comparator.js
var require_comparator = __commonJS({
  "node_modules/semver/classes/comparator.js"(exports, module) {
    var ANY = Symbol("SemVer ANY");
    var Comparator = class {
      static get ANY() {
        return ANY;
      }
      constructor(comp, options) {
        options = parseOptions(options);
        if (comp instanceof Comparator) {
          if (comp.loose === !!options.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        comp = comp.trim().split(/\s+/).join(" ");
        debug("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug("comp", this);
      }
      parse(comp) {
        const r7 = this.options.loose ? re2[t5.COMPARATORLOOSE] : re2[t5.COMPARATOR];
        const m2 = comp.match(r7);
        if (!m2) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m2[1] !== void 0 ? m2[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m2[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m2[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version) {
        debug("Comparator.test", version, this.options.loose);
        if (this.semver === ANY || version === ANY) {
          return true;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer(version, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp(version, this.operator, this.semver, this.options);
      }
      intersects(comp, options) {
        if (!(comp instanceof Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range(comp.value, options).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range(this.value, options).test(comp.semver);
        }
        options = parseOptions(options);
        if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
          return false;
        }
        if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
          return false;
        }
        if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
          return true;
        }
        if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
          return true;
        }
        if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
          return true;
        }
        if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
          return true;
        }
        if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
          return true;
        }
        return false;
      }
    };
    module.exports = Comparator;
    var parseOptions = require_parse_options();
    var { safeRe: re2, t: t5 } = require_re();
    var cmp = require_cmp();
    var debug = require_debug();
    var SemVer = require_semver();
    var Range = require_range();
  }
});

// node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS({
  "node_modules/semver/functions/satisfies.js"(exports, module) {
    var Range = require_range();
    var satisfies2 = (version, range, options) => {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version);
    };
    module.exports = satisfies2;
  }
});

// node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS({
  "node_modules/semver/ranges/to-comparators.js"(exports, module) {
    var Range = require_range();
    var toComparators = (range, options) => new Range(range, options).set.map((comp) => comp.map((c5) => c5.value).join(" ").trim().split(" "));
    module.exports = toComparators;
  }
});

// node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS({
  "node_modules/semver/ranges/max-satisfying.js"(exports, module) {
    var SemVer = require_semver();
    var Range = require_range();
    var maxSatisfying = (versions, range, options) => {
      let max = null;
      let maxSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v4) => {
        if (rangeObj.test(v4)) {
          if (!max || maxSV.compare(v4) === -1) {
            max = v4;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    };
    module.exports = maxSatisfying;
  }
});

// node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS({
  "node_modules/semver/ranges/min-satisfying.js"(exports, module) {
    var SemVer = require_semver();
    var Range = require_range();
    var minSatisfying = (versions, range, options) => {
      let min = null;
      let minSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v4) => {
        if (rangeObj.test(v4)) {
          if (!min || minSV.compare(v4) === 1) {
            min = v4;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    };
    module.exports = minSatisfying;
  }
});

// node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS({
  "node_modules/semver/ranges/min-version.js"(exports, module) {
    var SemVer = require_semver();
    var Range = require_range();
    var gt = require_gt();
    var minVersion = (range, loose) => {
      range = new Range(range, loose);
      let minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (let i4 = 0; i4 < range.set.length; ++i4) {
        const comparators = range.set[i4];
        let setMin = null;
        comparators.forEach((comparator) => {
          const compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            case "":
            case ">=":
              if (!setMin || gt(compver, setMin)) {
                setMin = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            default:
              throw new Error(`Unexpected operation: ${comparator.operator}`);
          }
        });
        if (setMin && (!minver || gt(minver, setMin))) {
          minver = setMin;
        }
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    };
    module.exports = minVersion;
  }
});

// node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS({
  "node_modules/semver/ranges/valid.js"(exports, module) {
    var Range = require_range();
    var validRange = (range, options) => {
      try {
        return new Range(range, options).range || "*";
      } catch (er) {
        return null;
      }
    };
    module.exports = validRange;
  }
});

// node_modules/semver/ranges/outside.js
var require_outside = __commonJS({
  "node_modules/semver/ranges/outside.js"(exports, module) {
    var SemVer = require_semver();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var Range = require_range();
    var satisfies2 = require_satisfies();
    var gt = require_gt();
    var lt = require_lt();
    var lte = require_lte();
    var gte = require_gte();
    var outside = (version, range, hilo, options) => {
      version = new SemVer(version, options);
      range = new Range(range, options);
      let gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies2(version, range, options)) {
        return false;
      }
      for (let i4 = 0; i4 < range.set.length; ++i4) {
        const comparators = range.set[i4];
        let high = null;
        let low = null;
        comparators.forEach((comparator) => {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
          return false;
        }
      }
      return true;
    };
    module.exports = outside;
  }
});

// node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS({
  "node_modules/semver/ranges/gtr.js"(exports, module) {
    var outside = require_outside();
    var gtr = (version, range, options) => outside(version, range, ">", options);
    module.exports = gtr;
  }
});

// node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS({
  "node_modules/semver/ranges/ltr.js"(exports, module) {
    var outside = require_outside();
    var ltr = (version, range, options) => outside(version, range, "<", options);
    module.exports = ltr;
  }
});

// node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS({
  "node_modules/semver/ranges/intersects.js"(exports, module) {
    var Range = require_range();
    var intersects = (r1, r22, options) => {
      r1 = new Range(r1, options);
      r22 = new Range(r22, options);
      return r1.intersects(r22, options);
    };
    module.exports = intersects;
  }
});

// node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS({
  "node_modules/semver/ranges/simplify.js"(exports, module) {
    var satisfies2 = require_satisfies();
    var compare = require_compare();
    module.exports = (versions, range, options) => {
      const set = [];
      let first = null;
      let prev = null;
      const v4 = versions.sort((a4, b4) => compare(a4, b4, options));
      for (const version of v4) {
        const included = satisfies2(version, range, options);
        if (included) {
          prev = version;
          if (!first) {
            first = version;
          }
        } else {
          if (prev) {
            set.push([first, prev]);
          }
          prev = null;
          first = null;
        }
      }
      if (first) {
        set.push([first, null]);
      }
      const ranges = [];
      for (const [min, max] of set) {
        if (min === max) {
          ranges.push(min);
        } else if (!max && min === v4[0]) {
          ranges.push("*");
        } else if (!max) {
          ranges.push(`>=${min}`);
        } else if (min === v4[0]) {
          ranges.push(`<=${max}`);
        } else {
          ranges.push(`${min} - ${max}`);
        }
      }
      const simplified = ranges.join(" || ");
      const original = typeof range.raw === "string" ? range.raw : String(range);
      return simplified.length < original.length ? simplified : range;
    };
  }
});

// node_modules/semver/ranges/subset.js
var require_subset = __commonJS({
  "node_modules/semver/ranges/subset.js"(exports, module) {
    var Range = require_range();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var satisfies2 = require_satisfies();
    var compare = require_compare();
    var subset = (sub, dom, options = {}) => {
      if (sub === dom) {
        return true;
      }
      sub = new Range(sub, options);
      dom = new Range(dom, options);
      let sawNonNull = false;
      OUTER:
        for (const simpleSub of sub.set) {
          for (const simpleDom of dom.set) {
            const isSub = simpleSubset(simpleSub, simpleDom, options);
            sawNonNull = sawNonNull || isSub !== null;
            if (isSub) {
              continue OUTER;
            }
          }
          if (sawNonNull) {
            return false;
          }
        }
      return true;
    };
    var minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
    var minimumVersion = [new Comparator(">=0.0.0")];
    var simpleSubset = (sub, dom, options) => {
      if (sub === dom) {
        return true;
      }
      if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY) {
          return true;
        } else if (options.includePrerelease) {
          sub = minimumVersionWithPreRelease;
        } else {
          sub = minimumVersion;
        }
      }
      if (dom.length === 1 && dom[0].semver === ANY) {
        if (options.includePrerelease) {
          return true;
        } else {
          dom = minimumVersion;
        }
      }
      const eqSet = /* @__PURE__ */ new Set();
      let gt, lt;
      for (const c5 of sub) {
        if (c5.operator === ">" || c5.operator === ">=") {
          gt = higherGT(gt, c5, options);
        } else if (c5.operator === "<" || c5.operator === "<=") {
          lt = lowerLT(lt, c5, options);
        } else {
          eqSet.add(c5.semver);
        }
      }
      if (eqSet.size > 1) {
        return null;
      }
      let gtltComp;
      if (gt && lt) {
        gtltComp = compare(gt.semver, lt.semver, options);
        if (gtltComp > 0) {
          return null;
        } else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) {
          return null;
        }
      }
      for (const eq of eqSet) {
        if (gt && !satisfies2(eq, String(gt), options)) {
          return null;
        }
        if (lt && !satisfies2(eq, String(lt), options)) {
          return null;
        }
        for (const c5 of dom) {
          if (!satisfies2(eq, String(c5), options)) {
            return false;
          }
        }
        return true;
      }
      let higher, lower;
      let hasDomLT, hasDomGT;
      let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
      let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
      if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
        needDomLTPre = false;
      }
      for (const c5 of dom) {
        hasDomGT = hasDomGT || c5.operator === ">" || c5.operator === ">=";
        hasDomLT = hasDomLT || c5.operator === "<" || c5.operator === "<=";
        if (gt) {
          if (needDomGTPre) {
            if (c5.semver.prerelease && c5.semver.prerelease.length && c5.semver.major === needDomGTPre.major && c5.semver.minor === needDomGTPre.minor && c5.semver.patch === needDomGTPre.patch) {
              needDomGTPre = false;
            }
          }
          if (c5.operator === ">" || c5.operator === ">=") {
            higher = higherGT(gt, c5, options);
            if (higher === c5 && higher !== gt) {
              return false;
            }
          } else if (gt.operator === ">=" && !satisfies2(gt.semver, String(c5), options)) {
            return false;
          }
        }
        if (lt) {
          if (needDomLTPre) {
            if (c5.semver.prerelease && c5.semver.prerelease.length && c5.semver.major === needDomLTPre.major && c5.semver.minor === needDomLTPre.minor && c5.semver.patch === needDomLTPre.patch) {
              needDomLTPre = false;
            }
          }
          if (c5.operator === "<" || c5.operator === "<=") {
            lower = lowerLT(lt, c5, options);
            if (lower === c5 && lower !== lt) {
              return false;
            }
          } else if (lt.operator === "<=" && !satisfies2(lt.semver, String(c5), options)) {
            return false;
          }
        }
        if (!c5.operator && (lt || gt) && gtltComp !== 0) {
          return false;
        }
      }
      if (gt && hasDomLT && !lt && gtltComp !== 0) {
        return false;
      }
      if (lt && hasDomGT && !gt && gtltComp !== 0) {
        return false;
      }
      if (needDomGTPre || needDomLTPre) {
        return false;
      }
      return true;
    };
    var higherGT = (a4, b4, options) => {
      if (!a4) {
        return b4;
      }
      const comp = compare(a4.semver, b4.semver, options);
      return comp > 0 ? a4 : comp < 0 ? b4 : b4.operator === ">" && a4.operator === ">=" ? b4 : a4;
    };
    var lowerLT = (a4, b4, options) => {
      if (!a4) {
        return b4;
      }
      const comp = compare(a4.semver, b4.semver, options);
      return comp < 0 ? a4 : comp > 0 ? b4 : b4.operator === "<" && a4.operator === "<=" ? b4 : a4;
    };
    module.exports = subset;
  }
});

// node_modules/semver/index.js
var require_semver2 = __commonJS({
  "node_modules/semver/index.js"(exports, module) {
    var internalRe = require_re();
    var constants = require_constants();
    var SemVer = require_semver();
    var identifiers = require_identifiers();
    var parse = require_parse();
    var valid = require_valid();
    var clean = require_clean();
    var inc = require_inc();
    var diff = require_diff();
    var major2 = require_major();
    var minor = require_minor();
    var patch = require_patch();
    var prerelease = require_prerelease();
    var compare = require_compare();
    var rcompare = require_rcompare();
    var compareLoose = require_compare_loose();
    var compareBuild = require_compare_build();
    var sort = require_sort();
    var rsort = require_rsort();
    var gt = require_gt();
    var lt = require_lt();
    var eq = require_eq();
    var neq = require_neq();
    var gte = require_gte();
    var lte = require_lte();
    var cmp = require_cmp();
    var coerce = require_coerce();
    var Comparator = require_comparator();
    var Range = require_range();
    var satisfies2 = require_satisfies();
    var toComparators = require_to_comparators();
    var maxSatisfying = require_max_satisfying();
    var minSatisfying = require_min_satisfying();
    var minVersion = require_min_version();
    var validRange = require_valid2();
    var outside = require_outside();
    var gtr = require_gtr();
    var ltr = require_ltr();
    var intersects = require_intersects();
    var simplifyRange = require_simplify();
    var subset = require_subset();
    module.exports = {
      parse,
      valid,
      clean,
      inc,
      diff,
      major: major2,
      minor,
      patch,
      prerelease,
      compare,
      rcompare,
      compareLoose,
      compareBuild,
      sort,
      rsort,
      gt,
      lt,
      eq,
      neq,
      gte,
      lte,
      cmp,
      coerce,
      Comparator,
      Range,
      satisfies: satisfies2,
      toComparators,
      maxSatisfying,
      minSatisfying,
      minVersion,
      validRange,
      outside,
      gtr,
      ltr,
      intersects,
      simplifyRange,
      subset,
      SemVer,
      re: internalRe.re,
      src: internalRe.src,
      tokens: internalRe.t,
      SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
      RELEASE_TYPES: constants.RELEASE_TYPES,
      compareIdentifiers: identifiers.compareIdentifiers,
      rcompareIdentifiers: identifiers.rcompareIdentifiers
    };
  }
});

// node_modules/shimmer/index.js
var require_shimmer = __commonJS({
  "node_modules/shimmer/index.js"(exports, module) {
    "use strict";
    function isFunction3(funktion) {
      return typeof funktion === "function";
    }
    var logger = console.error.bind(console);
    function defineProperty(obj, name, value) {
      var enumerable = !!obj[name] && obj.propertyIsEnumerable(name);
      Object.defineProperty(obj, name, {
        configurable: true,
        enumerable,
        writable: true,
        value
      });
    }
    function shimmer2(options) {
      if (options && options.logger) {
        if (!isFunction3(options.logger))
          logger("new logger isn't a function, not replacing");
        else
          logger = options.logger;
      }
    }
    function wrap3(nodule, name, wrapper) {
      if (!nodule || !nodule[name]) {
        logger("no original function " + name + " to wrap");
        return;
      }
      if (!wrapper) {
        logger("no wrapper function");
        logger(new Error().stack);
        return;
      }
      if (!isFunction3(nodule[name]) || !isFunction3(wrapper)) {
        logger("original object and wrapper must be functions");
        return;
      }
      var original = nodule[name];
      var wrapped = wrapper(original, name);
      defineProperty(wrapped, "__original", original);
      defineProperty(wrapped, "__unwrap", function() {
        if (nodule[name] === wrapped)
          defineProperty(nodule, name, original);
      });
      defineProperty(wrapped, "__wrapped", true);
      defineProperty(nodule, name, wrapped);
      return wrapped;
    }
    function massWrap2(nodules, names, wrapper) {
      if (!nodules) {
        logger("must provide one or more modules to patch");
        logger(new Error().stack);
        return;
      } else if (!Array.isArray(nodules)) {
        nodules = [nodules];
      }
      if (!(names && Array.isArray(names))) {
        logger("must provide one or more functions to wrap on modules");
        return;
      }
      nodules.forEach(function(nodule) {
        names.forEach(function(name) {
          wrap3(nodule, name, wrapper);
        });
      });
    }
    function unwrap3(nodule, name) {
      if (!nodule || !nodule[name]) {
        logger("no function to unwrap.");
        logger(new Error().stack);
        return;
      }
      if (!nodule[name].__unwrap) {
        logger("no original to unwrap to -- has " + name + " already been unwrapped?");
      } else {
        return nodule[name].__unwrap();
      }
    }
    function massUnwrap2(nodules, names) {
      if (!nodules) {
        logger("must provide one or more modules to patch");
        logger(new Error().stack);
        return;
      } else if (!Array.isArray(nodules)) {
        nodules = [nodules];
      }
      if (!(names && Array.isArray(names))) {
        logger("must provide one or more functions to unwrap on modules");
        return;
      }
      nodules.forEach(function(nodule) {
        names.forEach(function(name) {
          unwrap3(nodule, name);
        });
      });
    }
    shimmer2.wrap = wrap3;
    shimmer2.massWrap = massWrap2;
    shimmer2.unwrap = unwrap3;
    shimmer2.massUnwrap = massUnwrap2;
    module.exports = shimmer2;
  }
});

// node_modules/resolve/lib/homedir.js
var require_homedir = __commonJS({
  "node_modules/resolve/lib/homedir.js"(exports, module) {
    "use strict";
    var os = __require("os");
    module.exports = os.homedir || function homedir() {
      var home = process.env.HOME;
      var user = process.env.LOGNAME || process.env.USER || process.env.LNAME || process.env.USERNAME;
      if (process.platform === "win32") {
        return process.env.USERPROFILE || process.env.HOMEDRIVE + process.env.HOMEPATH || home || null;
      }
      if (process.platform === "darwin") {
        return home || (user ? "/Users/" + user : null);
      }
      if (process.platform === "linux") {
        return home || (process.getuid() === 0 ? "/root" : user ? "/home/" + user : null);
      }
      return home || null;
    };
  }
});

// node_modules/resolve/lib/caller.js
var require_caller = __commonJS({
  "node_modules/resolve/lib/caller.js"(exports, module) {
    module.exports = function() {
      var origPrepareStackTrace = Error.prepareStackTrace;
      Error.prepareStackTrace = function(_2, stack2) {
        return stack2;
      };
      var stack = new Error().stack;
      Error.prepareStackTrace = origPrepareStackTrace;
      return stack[2].getFileName();
    };
  }
});

// node_modules/path-parse/index.js
var require_path_parse = __commonJS({
  "node_modules/path-parse/index.js"(exports, module) {
    "use strict";
    var isWindows = process.platform === "win32";
    var splitWindowsRe = /^(((?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?[\\\/]?)(?:[^\\\/]*[\\\/])*)((\.{1,2}|[^\\\/]+?|)(\.[^.\/\\]*|))[\\\/]*$/;
    var win32 = {};
    function win32SplitPath(filename) {
      return splitWindowsRe.exec(filename).slice(1);
    }
    win32.parse = function(pathString) {
      if (typeof pathString !== "string") {
        throw new TypeError(
          "Parameter 'pathString' must be a string, not " + typeof pathString
        );
      }
      var allParts = win32SplitPath(pathString);
      if (!allParts || allParts.length !== 5) {
        throw new TypeError("Invalid path '" + pathString + "'");
      }
      return {
        root: allParts[1],
        dir: allParts[0] === allParts[1] ? allParts[0] : allParts[0].slice(0, -1),
        base: allParts[2],
        ext: allParts[4],
        name: allParts[3]
      };
    };
    var splitPathRe = /^((\/?)(?:[^\/]*\/)*)((\.{1,2}|[^\/]+?|)(\.[^.\/]*|))[\/]*$/;
    var posix = {};
    function posixSplitPath(filename) {
      return splitPathRe.exec(filename).slice(1);
    }
    posix.parse = function(pathString) {
      if (typeof pathString !== "string") {
        throw new TypeError(
          "Parameter 'pathString' must be a string, not " + typeof pathString
        );
      }
      var allParts = posixSplitPath(pathString);
      if (!allParts || allParts.length !== 5) {
        throw new TypeError("Invalid path '" + pathString + "'");
      }
      return {
        root: allParts[1],
        dir: allParts[0].slice(0, -1),
        base: allParts[2],
        ext: allParts[4],
        name: allParts[3]
      };
    };
    if (isWindows)
      module.exports = win32.parse;
    else
      module.exports = posix.parse;
    module.exports.posix = posix.parse;
    module.exports.win32 = win32.parse;
  }
});

// node_modules/resolve/lib/node-modules-paths.js
var require_node_modules_paths = __commonJS({
  "node_modules/resolve/lib/node-modules-paths.js"(exports, module) {
    var path3 = __require("path");
    var parse = path3.parse || require_path_parse();
    var getNodeModulesDirs = function getNodeModulesDirs2(absoluteStart, modules) {
      var prefix = "/";
      if (/^([A-Za-z]:)/.test(absoluteStart)) {
        prefix = "";
      } else if (/^\\\\/.test(absoluteStart)) {
        prefix = "\\\\";
      }
      var paths = [absoluteStart];
      var parsed = parse(absoluteStart);
      while (parsed.dir !== paths[paths.length - 1]) {
        paths.push(parsed.dir);
        parsed = parse(parsed.dir);
      }
      return paths.reduce(function(dirs, aPath) {
        return dirs.concat(modules.map(function(moduleDir) {
          return path3.resolve(prefix, aPath, moduleDir);
        }));
      }, []);
    };
    module.exports = function nodeModulesPaths(start, opts, request3) {
      var modules = opts && opts.moduleDirectory ? [].concat(opts.moduleDirectory) : ["node_modules"];
      if (opts && typeof opts.paths === "function") {
        return opts.paths(
          request3,
          start,
          function() {
            return getNodeModulesDirs(start, modules);
          },
          opts
        );
      }
      var dirs = getNodeModulesDirs(start, modules);
      return opts && opts.paths ? dirs.concat(opts.paths) : dirs;
    };
  }
});

// node_modules/resolve/lib/normalize-options.js
var require_normalize_options = __commonJS({
  "node_modules/resolve/lib/normalize-options.js"(exports, module) {
    module.exports = function(x7, opts) {
      return opts || {};
    };
  }
});

// node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  "node_modules/function-bind/implementation.js"(exports, module) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var toStr = Object.prototype.toString;
    var max = Math.max;
    var funcType = "[object Function]";
    var concatty = function concatty2(a4, b4) {
      var arr = [];
      for (var i4 = 0; i4 < a4.length; i4 += 1) {
        arr[i4] = a4[i4];
      }
      for (var j = 0; j < b4.length; j += 1) {
        arr[j + a4.length] = b4[j];
      }
      return arr;
    };
    var slicy = function slicy2(arrLike, offset) {
      var arr = [];
      for (var i4 = offset || 0, j = 0; i4 < arrLike.length; i4 += 1, j += 1) {
        arr[j] = arrLike[i4];
      }
      return arr;
    };
    var joiny = function(arr, joiner) {
      var str = "";
      for (var i4 = 0; i4 < arr.length; i4 += 1) {
        str += arr[i4];
        if (i4 + 1 < arr.length) {
          str += joiner;
        }
      }
      return str;
    };
    module.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slicy(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            concatty(args, arguments)
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        }
        return target.apply(
          that,
          concatty(args, arguments)
        );
      };
      var boundLength = max(0, target.length - args.length);
      var boundArgs = [];
      for (var i4 = 0; i4 < boundLength; i4++) {
        boundArgs[i4] = "$" + i4;
      }
      bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "node_modules/function-bind/index.js"(exports, module) {
    "use strict";
    var implementation = require_implementation();
    module.exports = Function.prototype.bind || implementation;
  }
});

// node_modules/hasown/index.js
var require_hasown = __commonJS({
  "node_modules/hasown/index.js"(exports, module) {
    "use strict";
    var call = Function.prototype.call;
    var $hasOwn = Object.prototype.hasOwnProperty;
    var bind = require_function_bind();
    module.exports = bind.call(call, $hasOwn);
  }
});

// node_modules/is-core-module/core.json
var require_core = __commonJS({
  "node_modules/is-core-module/core.json"(exports, module) {
    module.exports = {
      assert: true,
      "node:assert": [">= 14.18 && < 15", ">= 16"],
      "assert/strict": ">= 15",
      "node:assert/strict": ">= 16",
      async_hooks: ">= 8",
      "node:async_hooks": [">= 14.18 && < 15", ">= 16"],
      buffer_ieee754: ">= 0.5 && < 0.9.7",
      buffer: true,
      "node:buffer": [">= 14.18 && < 15", ">= 16"],
      child_process: true,
      "node:child_process": [">= 14.18 && < 15", ">= 16"],
      cluster: ">= 0.5",
      "node:cluster": [">= 14.18 && < 15", ">= 16"],
      console: true,
      "node:console": [">= 14.18 && < 15", ">= 16"],
      constants: true,
      "node:constants": [">= 14.18 && < 15", ">= 16"],
      crypto: true,
      "node:crypto": [">= 14.18 && < 15", ">= 16"],
      _debug_agent: ">= 1 && < 8",
      _debugger: "< 8",
      dgram: true,
      "node:dgram": [">= 14.18 && < 15", ">= 16"],
      diagnostics_channel: [">= 14.17 && < 15", ">= 15.1"],
      "node:diagnostics_channel": [">= 14.18 && < 15", ">= 16"],
      dns: true,
      "node:dns": [">= 14.18 && < 15", ">= 16"],
      "dns/promises": ">= 15",
      "node:dns/promises": ">= 16",
      domain: ">= 0.7.12",
      "node:domain": [">= 14.18 && < 15", ">= 16"],
      events: true,
      "node:events": [">= 14.18 && < 15", ">= 16"],
      freelist: "< 6",
      fs: true,
      "node:fs": [">= 14.18 && < 15", ">= 16"],
      "fs/promises": [">= 10 && < 10.1", ">= 14"],
      "node:fs/promises": [">= 14.18 && < 15", ">= 16"],
      _http_agent: ">= 0.11.1",
      "node:_http_agent": [">= 14.18 && < 15", ">= 16"],
      _http_client: ">= 0.11.1",
      "node:_http_client": [">= 14.18 && < 15", ">= 16"],
      _http_common: ">= 0.11.1",
      "node:_http_common": [">= 14.18 && < 15", ">= 16"],
      _http_incoming: ">= 0.11.1",
      "node:_http_incoming": [">= 14.18 && < 15", ">= 16"],
      _http_outgoing: ">= 0.11.1",
      "node:_http_outgoing": [">= 14.18 && < 15", ">= 16"],
      _http_server: ">= 0.11.1",
      "node:_http_server": [">= 14.18 && < 15", ">= 16"],
      http: true,
      "node:http": [">= 14.18 && < 15", ">= 16"],
      http2: ">= 8.8",
      "node:http2": [">= 14.18 && < 15", ">= 16"],
      https: true,
      "node:https": [">= 14.18 && < 15", ">= 16"],
      inspector: ">= 8",
      "node:inspector": [">= 14.18 && < 15", ">= 16"],
      "inspector/promises": [">= 19"],
      "node:inspector/promises": [">= 19"],
      _linklist: "< 8",
      module: true,
      "node:module": [">= 14.18 && < 15", ">= 16"],
      net: true,
      "node:net": [">= 14.18 && < 15", ">= 16"],
      "node-inspect/lib/_inspect": ">= 7.6 && < 12",
      "node-inspect/lib/internal/inspect_client": ">= 7.6 && < 12",
      "node-inspect/lib/internal/inspect_repl": ">= 7.6 && < 12",
      os: true,
      "node:os": [">= 14.18 && < 15", ">= 16"],
      path: true,
      "node:path": [">= 14.18 && < 15", ">= 16"],
      "path/posix": ">= 15.3",
      "node:path/posix": ">= 16",
      "path/win32": ">= 15.3",
      "node:path/win32": ">= 16",
      perf_hooks: ">= 8.5",
      "node:perf_hooks": [">= 14.18 && < 15", ">= 16"],
      process: ">= 1",
      "node:process": [">= 14.18 && < 15", ">= 16"],
      punycode: ">= 0.5",
      "node:punycode": [">= 14.18 && < 15", ">= 16"],
      querystring: true,
      "node:querystring": [">= 14.18 && < 15", ">= 16"],
      readline: true,
      "node:readline": [">= 14.18 && < 15", ">= 16"],
      "readline/promises": ">= 17",
      "node:readline/promises": ">= 17",
      repl: true,
      "node:repl": [">= 14.18 && < 15", ">= 16"],
      "node:sea": [">= 20.12 && < 21", ">= 21.7"],
      smalloc: ">= 0.11.5 && < 3",
      _stream_duplex: ">= 0.9.4",
      "node:_stream_duplex": [">= 14.18 && < 15", ">= 16"],
      _stream_transform: ">= 0.9.4",
      "node:_stream_transform": [">= 14.18 && < 15", ">= 16"],
      _stream_wrap: ">= 1.4.1",
      "node:_stream_wrap": [">= 14.18 && < 15", ">= 16"],
      _stream_passthrough: ">= 0.9.4",
      "node:_stream_passthrough": [">= 14.18 && < 15", ">= 16"],
      _stream_readable: ">= 0.9.4",
      "node:_stream_readable": [">= 14.18 && < 15", ">= 16"],
      _stream_writable: ">= 0.9.4",
      "node:_stream_writable": [">= 14.18 && < 15", ">= 16"],
      stream: true,
      "node:stream": [">= 14.18 && < 15", ">= 16"],
      "stream/consumers": ">= 16.7",
      "node:stream/consumers": ">= 16.7",
      "stream/promises": ">= 15",
      "node:stream/promises": ">= 16",
      "stream/web": ">= 16.5",
      "node:stream/web": ">= 16.5",
      string_decoder: true,
      "node:string_decoder": [">= 14.18 && < 15", ">= 16"],
      sys: [">= 0.4 && < 0.7", ">= 0.8"],
      "node:sys": [">= 14.18 && < 15", ">= 16"],
      "test/reporters": ">= 19.9 && < 20.2",
      "node:test/reporters": [">= 18.17 && < 19", ">= 19.9", ">= 20"],
      "test/mock_loader": ">= 22.3 && < 22.7",
      "node:test/mock_loader": ">= 22.3 && < 22.7",
      "node:test": [">= 16.17 && < 17", ">= 18"],
      timers: true,
      "node:timers": [">= 14.18 && < 15", ">= 16"],
      "timers/promises": ">= 15",
      "node:timers/promises": ">= 16",
      _tls_common: ">= 0.11.13",
      "node:_tls_common": [">= 14.18 && < 15", ">= 16"],
      _tls_legacy: ">= 0.11.3 && < 10",
      _tls_wrap: ">= 0.11.3",
      "node:_tls_wrap": [">= 14.18 && < 15", ">= 16"],
      tls: true,
      "node:tls": [">= 14.18 && < 15", ">= 16"],
      trace_events: ">= 10",
      "node:trace_events": [">= 14.18 && < 15", ">= 16"],
      tty: true,
      "node:tty": [">= 14.18 && < 15", ">= 16"],
      url: true,
      "node:url": [">= 14.18 && < 15", ">= 16"],
      util: true,
      "node:util": [">= 14.18 && < 15", ">= 16"],
      "util/types": ">= 15.3",
      "node:util/types": ">= 16",
      "v8/tools/arguments": ">= 10 && < 12",
      "v8/tools/codemap": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/consarray": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/csvparser": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/logreader": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/profile_view": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/splaytree": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      v8: ">= 1",
      "node:v8": [">= 14.18 && < 15", ">= 16"],
      vm: true,
      "node:vm": [">= 14.18 && < 15", ">= 16"],
      wasi: [">= 13.4 && < 13.5", ">= 18.17 && < 19", ">= 20"],
      "node:wasi": [">= 18.17 && < 19", ">= 20"],
      worker_threads: ">= 11.7",
      "node:worker_threads": [">= 14.18 && < 15", ">= 16"],
      zlib: ">= 0.5",
      "node:zlib": [">= 14.18 && < 15", ">= 16"]
    };
  }
});

// node_modules/is-core-module/index.js
var require_is_core_module = __commonJS({
  "node_modules/is-core-module/index.js"(exports, module) {
    "use strict";
    var hasOwn = require_hasown();
    function specifierIncluded(current, specifier) {
      var nodeParts = current.split(".");
      var parts = specifier.split(" ");
      var op = parts.length > 1 ? parts[0] : "=";
      var versionParts = (parts.length > 1 ? parts[1] : parts[0]).split(".");
      for (var i4 = 0; i4 < 3; ++i4) {
        var cur = parseInt(nodeParts[i4] || 0, 10);
        var ver = parseInt(versionParts[i4] || 0, 10);
        if (cur === ver) {
          continue;
        }
        if (op === "<") {
          return cur < ver;
        }
        if (op === ">=") {
          return cur >= ver;
        }
        return false;
      }
      return op === ">=";
    }
    function matchesRange(current, range) {
      var specifiers = range.split(/ ?&& ?/);
      if (specifiers.length === 0) {
        return false;
      }
      for (var i4 = 0; i4 < specifiers.length; ++i4) {
        if (!specifierIncluded(current, specifiers[i4])) {
          return false;
        }
      }
      return true;
    }
    function versionIncluded(nodeVersion, specifierValue) {
      if (typeof specifierValue === "boolean") {
        return specifierValue;
      }
      var current = typeof nodeVersion === "undefined" ? process.versions && process.versions.node : nodeVersion;
      if (typeof current !== "string") {
        throw new TypeError(typeof nodeVersion === "undefined" ? "Unable to determine current node version" : "If provided, a valid node version is required");
      }
      if (specifierValue && typeof specifierValue === "object") {
        for (var i4 = 0; i4 < specifierValue.length; ++i4) {
          if (matchesRange(current, specifierValue[i4])) {
            return true;
          }
        }
        return false;
      }
      return matchesRange(current, specifierValue);
    }
    var data = require_core();
    module.exports = function isCore(x7, nodeVersion) {
      return hasOwn(data, x7) && versionIncluded(nodeVersion, data[x7]);
    };
  }
});

// node_modules/resolve/lib/async.js
var require_async = __commonJS({
  "node_modules/resolve/lib/async.js"(exports, module) {
    var fs = __require("fs");
    var getHomedir = require_homedir();
    var path3 = __require("path");
    var caller = require_caller();
    var nodeModulesPaths = require_node_modules_paths();
    var normalizeOptions = require_normalize_options();
    var isCore = require_is_core_module();
    var realpathFS = process.platform !== "win32" && fs.realpath && typeof fs.realpath.native === "function" ? fs.realpath.native : fs.realpath;
    var homedir = getHomedir();
    var defaultPaths = function() {
      return [
        path3.join(homedir, ".node_modules"),
        path3.join(homedir, ".node_libraries")
      ];
    };
    var defaultIsFile = function isFile(file, cb) {
      fs.stat(file, function(err, stat) {
        if (!err) {
          return cb(null, stat.isFile() || stat.isFIFO());
        }
        if (err.code === "ENOENT" || err.code === "ENOTDIR")
          return cb(null, false);
        return cb(err);
      });
    };
    var defaultIsDir = function isDirectory(dir, cb) {
      fs.stat(dir, function(err, stat) {
        if (!err) {
          return cb(null, stat.isDirectory());
        }
        if (err.code === "ENOENT" || err.code === "ENOTDIR")
          return cb(null, false);
        return cb(err);
      });
    };
    var defaultRealpath = function realpath(x7, cb) {
      realpathFS(x7, function(realpathErr, realPath) {
        if (realpathErr && realpathErr.code !== "ENOENT")
          cb(realpathErr);
        else
          cb(null, realpathErr ? x7 : realPath);
      });
    };
    var maybeRealpath = function maybeRealpath2(realpath, x7, opts, cb) {
      if (opts && opts.preserveSymlinks === false) {
        realpath(x7, cb);
      } else {
        cb(null, x7);
      }
    };
    var defaultReadPackage = function defaultReadPackage2(readFile, pkgfile, cb) {
      readFile(pkgfile, function(readFileErr, body) {
        if (readFileErr)
          cb(readFileErr);
        else {
          try {
            var pkg = JSON.parse(body);
            cb(null, pkg);
          } catch (jsonErr) {
            cb(null);
          }
        }
      });
    };
    var getPackageCandidates = function getPackageCandidates2(x7, start, opts) {
      var dirs = nodeModulesPaths(start, opts, x7);
      for (var i4 = 0; i4 < dirs.length; i4++) {
        dirs[i4] = path3.join(dirs[i4], x7);
      }
      return dirs;
    };
    module.exports = function resolve(x7, options, callback) {
      var cb = callback;
      var opts = options;
      if (typeof options === "function") {
        cb = opts;
        opts = {};
      }
      if (typeof x7 !== "string") {
        var err = new TypeError("Path must be a string.");
        return process.nextTick(function() {
          cb(err);
        });
      }
      opts = normalizeOptions(x7, opts);
      var isFile = opts.isFile || defaultIsFile;
      var isDirectory = opts.isDirectory || defaultIsDir;
      var readFile = opts.readFile || fs.readFile;
      var realpath = opts.realpath || defaultRealpath;
      var readPackage = opts.readPackage || defaultReadPackage;
      if (opts.readFile && opts.readPackage) {
        var conflictErr = new TypeError("`readFile` and `readPackage` are mutually exclusive.");
        return process.nextTick(function() {
          cb(conflictErr);
        });
      }
      var packageIterator = opts.packageIterator;
      var extensions = opts.extensions || [".js"];
      var includeCoreModules = opts.includeCoreModules !== false;
      var basedir = opts.basedir || path3.dirname(caller());
      var parent = opts.filename || basedir;
      opts.paths = opts.paths || defaultPaths();
      var absoluteStart = path3.resolve(basedir);
      maybeRealpath(
        realpath,
        absoluteStart,
        opts,
        function(err2, realStart) {
          if (err2)
            cb(err2);
          else
            init(realStart);
        }
      );
      var res;
      function init(basedir2) {
        if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(x7)) {
          res = path3.resolve(basedir2, x7);
          if (x7 === "." || x7 === ".." || x7.slice(-1) === "/")
            res += "/";
          if (/\/$/.test(x7) && res === basedir2) {
            loadAsDirectory(res, opts.package, onfile);
          } else
            loadAsFile(res, opts.package, onfile);
        } else if (includeCoreModules && isCore(x7)) {
          return cb(null, x7);
        } else
          loadNodeModules(x7, basedir2, function(err2, n9, pkg) {
            if (err2)
              cb(err2);
            else if (n9) {
              return maybeRealpath(realpath, n9, opts, function(err3, realN) {
                if (err3) {
                  cb(err3);
                } else {
                  cb(null, realN, pkg);
                }
              });
            } else {
              var moduleError = new Error("Cannot find module '" + x7 + "' from '" + parent + "'");
              moduleError.code = "MODULE_NOT_FOUND";
              cb(moduleError);
            }
          });
      }
      function onfile(err2, m2, pkg) {
        if (err2)
          cb(err2);
        else if (m2)
          cb(null, m2, pkg);
        else
          loadAsDirectory(res, function(err3, d5, pkg2) {
            if (err3)
              cb(err3);
            else if (d5) {
              maybeRealpath(realpath, d5, opts, function(err4, realD) {
                if (err4) {
                  cb(err4);
                } else {
                  cb(null, realD, pkg2);
                }
              });
            } else {
              var moduleError = new Error("Cannot find module '" + x7 + "' from '" + parent + "'");
              moduleError.code = "MODULE_NOT_FOUND";
              cb(moduleError);
            }
          });
      }
      function loadAsFile(x8, thePackage, callback2) {
        var loadAsFilePackage = thePackage;
        var cb2 = callback2;
        if (typeof loadAsFilePackage === "function") {
          cb2 = loadAsFilePackage;
          loadAsFilePackage = void 0;
        }
        var exts = [""].concat(extensions);
        load(exts, x8, loadAsFilePackage);
        function load(exts2, x9, loadPackage) {
          if (exts2.length === 0)
            return cb2(null, void 0, loadPackage);
          var file = x9 + exts2[0];
          var pkg = loadPackage;
          if (pkg)
            onpkg(null, pkg);
          else
            loadpkg(path3.dirname(file), onpkg);
          function onpkg(err2, pkg_, dir) {
            pkg = pkg_;
            if (err2)
              return cb2(err2);
            if (dir && pkg && opts.pathFilter) {
              var rfile = path3.relative(dir, file);
              var rel = rfile.slice(0, rfile.length - exts2[0].length);
              var r7 = opts.pathFilter(pkg, x9, rel);
              if (r7)
                return load(
                  [""].concat(extensions.slice()),
                  path3.resolve(dir, r7),
                  pkg
                );
            }
            isFile(file, onex);
          }
          function onex(err2, ex) {
            if (err2)
              return cb2(err2);
            if (ex)
              return cb2(null, file, pkg);
            load(exts2.slice(1), x9, pkg);
          }
        }
      }
      function loadpkg(dir, cb2) {
        if (dir === "" || dir === "/")
          return cb2(null);
        if (process.platform === "win32" && /^\w:[/\\]*$/.test(dir)) {
          return cb2(null);
        }
        if (/[/\\]node_modules[/\\]*$/.test(dir))
          return cb2(null);
        maybeRealpath(realpath, dir, opts, function(unwrapErr, pkgdir) {
          if (unwrapErr)
            return loadpkg(path3.dirname(dir), cb2);
          var pkgfile = path3.join(pkgdir, "package.json");
          isFile(pkgfile, function(err2, ex) {
            if (!ex)
              return loadpkg(path3.dirname(dir), cb2);
            readPackage(readFile, pkgfile, function(err3, pkgParam) {
              if (err3)
                cb2(err3);
              var pkg = pkgParam;
              if (pkg && opts.packageFilter) {
                pkg = opts.packageFilter(pkg, pkgfile);
              }
              cb2(null, pkg, dir);
            });
          });
        });
      }
      function loadAsDirectory(x8, loadAsDirectoryPackage, callback2) {
        var cb2 = callback2;
        var fpkg = loadAsDirectoryPackage;
        if (typeof fpkg === "function") {
          cb2 = fpkg;
          fpkg = opts.package;
        }
        maybeRealpath(realpath, x8, opts, function(unwrapErr, pkgdir) {
          if (unwrapErr)
            return cb2(unwrapErr);
          var pkgfile = path3.join(pkgdir, "package.json");
          isFile(pkgfile, function(err2, ex) {
            if (err2)
              return cb2(err2);
            if (!ex)
              return loadAsFile(path3.join(x8, "index"), fpkg, cb2);
            readPackage(readFile, pkgfile, function(err3, pkgParam) {
              if (err3)
                return cb2(err3);
              var pkg = pkgParam;
              if (pkg && opts.packageFilter) {
                pkg = opts.packageFilter(pkg, pkgfile);
              }
              if (pkg && pkg.main) {
                if (typeof pkg.main !== "string") {
                  var mainError = new TypeError("package \u201C" + pkg.name + "\u201D `main` must be a string");
                  mainError.code = "INVALID_PACKAGE_MAIN";
                  return cb2(mainError);
                }
                if (pkg.main === "." || pkg.main === "./") {
                  pkg.main = "index";
                }
                loadAsFile(path3.resolve(x8, pkg.main), pkg, function(err4, m2, pkg2) {
                  if (err4)
                    return cb2(err4);
                  if (m2)
                    return cb2(null, m2, pkg2);
                  if (!pkg2)
                    return loadAsFile(path3.join(x8, "index"), pkg2, cb2);
                  var dir = path3.resolve(x8, pkg2.main);
                  loadAsDirectory(dir, pkg2, function(err5, n9, pkg3) {
                    if (err5)
                      return cb2(err5);
                    if (n9)
                      return cb2(null, n9, pkg3);
                    loadAsFile(path3.join(x8, "index"), pkg3, cb2);
                  });
                });
                return;
              }
              loadAsFile(path3.join(x8, "/index"), pkg, cb2);
            });
          });
        });
      }
      function processDirs(cb2, dirs) {
        if (dirs.length === 0)
          return cb2(null, void 0);
        var dir = dirs[0];
        isDirectory(path3.dirname(dir), isdir);
        function isdir(err2, isdir2) {
          if (err2)
            return cb2(err2);
          if (!isdir2)
            return processDirs(cb2, dirs.slice(1));
          loadAsFile(dir, opts.package, onfile2);
        }
        function onfile2(err2, m2, pkg) {
          if (err2)
            return cb2(err2);
          if (m2)
            return cb2(null, m2, pkg);
          loadAsDirectory(dir, opts.package, ondir);
        }
        function ondir(err2, n9, pkg) {
          if (err2)
            return cb2(err2);
          if (n9)
            return cb2(null, n9, pkg);
          processDirs(cb2, dirs.slice(1));
        }
      }
      function loadNodeModules(x8, start, cb2) {
        var thunk = function() {
          return getPackageCandidates(x8, start, opts);
        };
        processDirs(
          cb2,
          packageIterator ? packageIterator(x8, start, thunk, opts) : thunk()
        );
      }
    };
  }
});

// node_modules/resolve/lib/core.json
var require_core2 = __commonJS({
  "node_modules/resolve/lib/core.json"(exports, module) {
    module.exports = {
      assert: true,
      "node:assert": [">= 14.18 && < 15", ">= 16"],
      "assert/strict": ">= 15",
      "node:assert/strict": ">= 16",
      async_hooks: ">= 8",
      "node:async_hooks": [">= 14.18 && < 15", ">= 16"],
      buffer_ieee754: ">= 0.5 && < 0.9.7",
      buffer: true,
      "node:buffer": [">= 14.18 && < 15", ">= 16"],
      child_process: true,
      "node:child_process": [">= 14.18 && < 15", ">= 16"],
      cluster: ">= 0.5",
      "node:cluster": [">= 14.18 && < 15", ">= 16"],
      console: true,
      "node:console": [">= 14.18 && < 15", ">= 16"],
      constants: true,
      "node:constants": [">= 14.18 && < 15", ">= 16"],
      crypto: true,
      "node:crypto": [">= 14.18 && < 15", ">= 16"],
      _debug_agent: ">= 1 && < 8",
      _debugger: "< 8",
      dgram: true,
      "node:dgram": [">= 14.18 && < 15", ">= 16"],
      diagnostics_channel: [">= 14.17 && < 15", ">= 15.1"],
      "node:diagnostics_channel": [">= 14.18 && < 15", ">= 16"],
      dns: true,
      "node:dns": [">= 14.18 && < 15", ">= 16"],
      "dns/promises": ">= 15",
      "node:dns/promises": ">= 16",
      domain: ">= 0.7.12",
      "node:domain": [">= 14.18 && < 15", ">= 16"],
      events: true,
      "node:events": [">= 14.18 && < 15", ">= 16"],
      freelist: "< 6",
      fs: true,
      "node:fs": [">= 14.18 && < 15", ">= 16"],
      "fs/promises": [">= 10 && < 10.1", ">= 14"],
      "node:fs/promises": [">= 14.18 && < 15", ">= 16"],
      _http_agent: ">= 0.11.1",
      "node:_http_agent": [">= 14.18 && < 15", ">= 16"],
      _http_client: ">= 0.11.1",
      "node:_http_client": [">= 14.18 && < 15", ">= 16"],
      _http_common: ">= 0.11.1",
      "node:_http_common": [">= 14.18 && < 15", ">= 16"],
      _http_incoming: ">= 0.11.1",
      "node:_http_incoming": [">= 14.18 && < 15", ">= 16"],
      _http_outgoing: ">= 0.11.1",
      "node:_http_outgoing": [">= 14.18 && < 15", ">= 16"],
      _http_server: ">= 0.11.1",
      "node:_http_server": [">= 14.18 && < 15", ">= 16"],
      http: true,
      "node:http": [">= 14.18 && < 15", ">= 16"],
      http2: ">= 8.8",
      "node:http2": [">= 14.18 && < 15", ">= 16"],
      https: true,
      "node:https": [">= 14.18 && < 15", ">= 16"],
      inspector: ">= 8",
      "node:inspector": [">= 14.18 && < 15", ">= 16"],
      "inspector/promises": [">= 19"],
      "node:inspector/promises": [">= 19"],
      _linklist: "< 8",
      module: true,
      "node:module": [">= 14.18 && < 15", ">= 16"],
      net: true,
      "node:net": [">= 14.18 && < 15", ">= 16"],
      "node-inspect/lib/_inspect": ">= 7.6 && < 12",
      "node-inspect/lib/internal/inspect_client": ">= 7.6 && < 12",
      "node-inspect/lib/internal/inspect_repl": ">= 7.6 && < 12",
      os: true,
      "node:os": [">= 14.18 && < 15", ">= 16"],
      path: true,
      "node:path": [">= 14.18 && < 15", ">= 16"],
      "path/posix": ">= 15.3",
      "node:path/posix": ">= 16",
      "path/win32": ">= 15.3",
      "node:path/win32": ">= 16",
      perf_hooks: ">= 8.5",
      "node:perf_hooks": [">= 14.18 && < 15", ">= 16"],
      process: ">= 1",
      "node:process": [">= 14.18 && < 15", ">= 16"],
      punycode: ">= 0.5",
      "node:punycode": [">= 14.18 && < 15", ">= 16"],
      querystring: true,
      "node:querystring": [">= 14.18 && < 15", ">= 16"],
      readline: true,
      "node:readline": [">= 14.18 && < 15", ">= 16"],
      "readline/promises": ">= 17",
      "node:readline/promises": ">= 17",
      repl: true,
      "node:repl": [">= 14.18 && < 15", ">= 16"],
      smalloc: ">= 0.11.5 && < 3",
      _stream_duplex: ">= 0.9.4",
      "node:_stream_duplex": [">= 14.18 && < 15", ">= 16"],
      _stream_transform: ">= 0.9.4",
      "node:_stream_transform": [">= 14.18 && < 15", ">= 16"],
      _stream_wrap: ">= 1.4.1",
      "node:_stream_wrap": [">= 14.18 && < 15", ">= 16"],
      _stream_passthrough: ">= 0.9.4",
      "node:_stream_passthrough": [">= 14.18 && < 15", ">= 16"],
      _stream_readable: ">= 0.9.4",
      "node:_stream_readable": [">= 14.18 && < 15", ">= 16"],
      _stream_writable: ">= 0.9.4",
      "node:_stream_writable": [">= 14.18 && < 15", ">= 16"],
      stream: true,
      "node:stream": [">= 14.18 && < 15", ">= 16"],
      "stream/consumers": ">= 16.7",
      "node:stream/consumers": ">= 16.7",
      "stream/promises": ">= 15",
      "node:stream/promises": ">= 16",
      "stream/web": ">= 16.5",
      "node:stream/web": ">= 16.5",
      string_decoder: true,
      "node:string_decoder": [">= 14.18 && < 15", ">= 16"],
      sys: [">= 0.4 && < 0.7", ">= 0.8"],
      "node:sys": [">= 14.18 && < 15", ">= 16"],
      "test/reporters": ">= 19.9 && < 20.2",
      "node:test/reporters": [">= 18.17 && < 19", ">= 19.9", ">= 20"],
      "node:test": [">= 16.17 && < 17", ">= 18"],
      timers: true,
      "node:timers": [">= 14.18 && < 15", ">= 16"],
      "timers/promises": ">= 15",
      "node:timers/promises": ">= 16",
      _tls_common: ">= 0.11.13",
      "node:_tls_common": [">= 14.18 && < 15", ">= 16"],
      _tls_legacy: ">= 0.11.3 && < 10",
      _tls_wrap: ">= 0.11.3",
      "node:_tls_wrap": [">= 14.18 && < 15", ">= 16"],
      tls: true,
      "node:tls": [">= 14.18 && < 15", ">= 16"],
      trace_events: ">= 10",
      "node:trace_events": [">= 14.18 && < 15", ">= 16"],
      tty: true,
      "node:tty": [">= 14.18 && < 15", ">= 16"],
      url: true,
      "node:url": [">= 14.18 && < 15", ">= 16"],
      util: true,
      "node:util": [">= 14.18 && < 15", ">= 16"],
      "util/types": ">= 15.3",
      "node:util/types": ">= 16",
      "v8/tools/arguments": ">= 10 && < 12",
      "v8/tools/codemap": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/consarray": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/csvparser": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/logreader": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/profile_view": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/splaytree": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      v8: ">= 1",
      "node:v8": [">= 14.18 && < 15", ">= 16"],
      vm: true,
      "node:vm": [">= 14.18 && < 15", ">= 16"],
      wasi: [">= 13.4 && < 13.5", ">= 18.17 && < 19", ">= 20"],
      "node:wasi": [">= 18.17 && < 19", ">= 20"],
      worker_threads: ">= 11.7",
      "node:worker_threads": [">= 14.18 && < 15", ">= 16"],
      zlib: ">= 0.5",
      "node:zlib": [">= 14.18 && < 15", ">= 16"]
    };
  }
});

// node_modules/resolve/lib/core.js
var require_core3 = __commonJS({
  "node_modules/resolve/lib/core.js"(exports, module) {
    "use strict";
    var isCoreModule = require_is_core_module();
    var data = require_core2();
    var core = {};
    for (mod in data) {
      if (Object.prototype.hasOwnProperty.call(data, mod)) {
        core[mod] = isCoreModule(mod);
      }
    }
    var mod;
    module.exports = core;
  }
});

// node_modules/resolve/lib/is-core.js
var require_is_core = __commonJS({
  "node_modules/resolve/lib/is-core.js"(exports, module) {
    var isCoreModule = require_is_core_module();
    module.exports = function isCore(x7) {
      return isCoreModule(x7);
    };
  }
});

// node_modules/resolve/lib/sync.js
var require_sync = __commonJS({
  "node_modules/resolve/lib/sync.js"(exports, module) {
    var isCore = require_is_core_module();
    var fs = __require("fs");
    var path3 = __require("path");
    var getHomedir = require_homedir();
    var caller = require_caller();
    var nodeModulesPaths = require_node_modules_paths();
    var normalizeOptions = require_normalize_options();
    var realpathFS = process.platform !== "win32" && fs.realpathSync && typeof fs.realpathSync.native === "function" ? fs.realpathSync.native : fs.realpathSync;
    var homedir = getHomedir();
    var defaultPaths = function() {
      return [
        path3.join(homedir, ".node_modules"),
        path3.join(homedir, ".node_libraries")
      ];
    };
    var defaultIsFile = function isFile(file) {
      try {
        var stat = fs.statSync(file, { throwIfNoEntry: false });
      } catch (e7) {
        if (e7 && (e7.code === "ENOENT" || e7.code === "ENOTDIR"))
          return false;
        throw e7;
      }
      return !!stat && (stat.isFile() || stat.isFIFO());
    };
    var defaultIsDir = function isDirectory(dir) {
      try {
        var stat = fs.statSync(dir, { throwIfNoEntry: false });
      } catch (e7) {
        if (e7 && (e7.code === "ENOENT" || e7.code === "ENOTDIR"))
          return false;
        throw e7;
      }
      return !!stat && stat.isDirectory();
    };
    var defaultRealpathSync = function realpathSync(x7) {
      try {
        return realpathFS(x7);
      } catch (realpathErr) {
        if (realpathErr.code !== "ENOENT") {
          throw realpathErr;
        }
      }
      return x7;
    };
    var maybeRealpathSync = function maybeRealpathSync2(realpathSync, x7, opts) {
      if (opts && opts.preserveSymlinks === false) {
        return realpathSync(x7);
      }
      return x7;
    };
    var defaultReadPackageSync = function defaultReadPackageSync2(readFileSync2, pkgfile) {
      var body = readFileSync2(pkgfile);
      try {
        var pkg = JSON.parse(body);
        return pkg;
      } catch (jsonErr) {
      }
    };
    var getPackageCandidates = function getPackageCandidates2(x7, start, opts) {
      var dirs = nodeModulesPaths(start, opts, x7);
      for (var i4 = 0; i4 < dirs.length; i4++) {
        dirs[i4] = path3.join(dirs[i4], x7);
      }
      return dirs;
    };
    module.exports = function resolveSync(x7, options) {
      if (typeof x7 !== "string") {
        throw new TypeError("Path must be a string.");
      }
      var opts = normalizeOptions(x7, options);
      var isFile = opts.isFile || defaultIsFile;
      var readFileSync2 = opts.readFileSync || fs.readFileSync;
      var isDirectory = opts.isDirectory || defaultIsDir;
      var realpathSync = opts.realpathSync || defaultRealpathSync;
      var readPackageSync = opts.readPackageSync || defaultReadPackageSync;
      if (opts.readFileSync && opts.readPackageSync) {
        throw new TypeError("`readFileSync` and `readPackageSync` are mutually exclusive.");
      }
      var packageIterator = opts.packageIterator;
      var extensions = opts.extensions || [".js"];
      var includeCoreModules = opts.includeCoreModules !== false;
      var basedir = opts.basedir || path3.dirname(caller());
      var parent = opts.filename || basedir;
      opts.paths = opts.paths || defaultPaths();
      var absoluteStart = maybeRealpathSync(realpathSync, path3.resolve(basedir), opts);
      if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(x7)) {
        var res = path3.resolve(absoluteStart, x7);
        if (x7 === "." || x7 === ".." || x7.slice(-1) === "/")
          res += "/";
        var m2 = loadAsFileSync(res) || loadAsDirectorySync(res);
        if (m2)
          return maybeRealpathSync(realpathSync, m2, opts);
      } else if (includeCoreModules && isCore(x7)) {
        return x7;
      } else {
        var n9 = loadNodeModulesSync(x7, absoluteStart);
        if (n9)
          return maybeRealpathSync(realpathSync, n9, opts);
      }
      var err = new Error("Cannot find module '" + x7 + "' from '" + parent + "'");
      err.code = "MODULE_NOT_FOUND";
      throw err;
      function loadAsFileSync(x8) {
        var pkg = loadpkg(path3.dirname(x8));
        if (pkg && pkg.dir && pkg.pkg && opts.pathFilter) {
          var rfile = path3.relative(pkg.dir, x8);
          var r7 = opts.pathFilter(pkg.pkg, x8, rfile);
          if (r7) {
            x8 = path3.resolve(pkg.dir, r7);
          }
        }
        if (isFile(x8)) {
          return x8;
        }
        for (var i4 = 0; i4 < extensions.length; i4++) {
          var file = x8 + extensions[i4];
          if (isFile(file)) {
            return file;
          }
        }
      }
      function loadpkg(dir) {
        if (dir === "" || dir === "/")
          return;
        if (process.platform === "win32" && /^\w:[/\\]*$/.test(dir)) {
          return;
        }
        if (/[/\\]node_modules[/\\]*$/.test(dir))
          return;
        var pkgfile = path3.join(maybeRealpathSync(realpathSync, dir, opts), "package.json");
        if (!isFile(pkgfile)) {
          return loadpkg(path3.dirname(dir));
        }
        var pkg = readPackageSync(readFileSync2, pkgfile);
        if (pkg && opts.packageFilter) {
          pkg = opts.packageFilter(
            pkg,
            /*pkgfile,*/
            dir
          );
        }
        return { pkg, dir };
      }
      function loadAsDirectorySync(x8) {
        var pkgfile = path3.join(maybeRealpathSync(realpathSync, x8, opts), "/package.json");
        if (isFile(pkgfile)) {
          try {
            var pkg = readPackageSync(readFileSync2, pkgfile);
          } catch (e7) {
          }
          if (pkg && opts.packageFilter) {
            pkg = opts.packageFilter(
              pkg,
              /*pkgfile,*/
              x8
            );
          }
          if (pkg && pkg.main) {
            if (typeof pkg.main !== "string") {
              var mainError = new TypeError("package \u201C" + pkg.name + "\u201D `main` must be a string");
              mainError.code = "INVALID_PACKAGE_MAIN";
              throw mainError;
            }
            if (pkg.main === "." || pkg.main === "./") {
              pkg.main = "index";
            }
            try {
              var m3 = loadAsFileSync(path3.resolve(x8, pkg.main));
              if (m3)
                return m3;
              var n10 = loadAsDirectorySync(path3.resolve(x8, pkg.main));
              if (n10)
                return n10;
            } catch (e7) {
            }
          }
        }
        return loadAsFileSync(path3.join(x8, "/index"));
      }
      function loadNodeModulesSync(x8, start) {
        var thunk = function() {
          return getPackageCandidates(x8, start, opts);
        };
        var dirs = packageIterator ? packageIterator(x8, start, thunk, opts) : thunk();
        for (var i4 = 0; i4 < dirs.length; i4++) {
          var dir = dirs[i4];
          if (isDirectory(path3.dirname(dir))) {
            var m3 = loadAsFileSync(dir);
            if (m3)
              return m3;
            var n10 = loadAsDirectorySync(dir);
            if (n10)
              return n10;
          }
        }
      }
    };
  }
});

// node_modules/resolve/index.js
var require_resolve = __commonJS({
  "node_modules/resolve/index.js"(exports, module) {
    var async = require_async();
    async.core = require_core3();
    async.isCore = require_is_core();
    async.sync = require_sync();
    module.exports = async;
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports, module) {
    var s10 = 1e3;
    var m2 = s10 * 60;
    var h4 = m2 * 60;
    var d5 = h4 * 24;
    var w7 = d5 * 7;
    var y4 = d5 * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n9 = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n9 * y4;
        case "weeks":
        case "week":
        case "w":
          return n9 * w7;
        case "days":
        case "day":
        case "d":
          return n9 * d5;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n9 * h4;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n9 * m2;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n9 * s10;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n9;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d5) {
        return Math.round(ms / d5) + "d";
      }
      if (msAbs >= h4) {
        return Math.round(ms / h4) + "h";
      }
      if (msAbs >= m2) {
        return Math.round(ms / m2) + "m";
      }
      if (msAbs >= s10) {
        return Math.round(ms / s10) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d5) {
        return plural(ms, msAbs, d5, "day");
      }
      if (msAbs >= h4) {
        return plural(ms, msAbs, h4, "hour");
      }
      if (msAbs >= m2) {
        return plural(ms, msAbs, m2, "minute");
      }
      if (msAbs >= s10) {
        return plural(ms, msAbs, s10, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n9, name) {
      var isPlural = msAbs >= n9 * 1.5;
      return Math.round(ms / n9) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports, module) {
    function setup(env2) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env2).forEach((key) => {
        createDebug[key] = env2[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i4 = 0; i4 < namespace.length; i4++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i4);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v4) => {
            enableOverride = v4;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(" ", ",").split(",").filter(Boolean);
        for (const ns of split) {
          if (ns[0] === "-") {
            createDebug.skips.push(ns.slice(1));
          } else {
            createDebug.names.push(ns);
          }
        }
      }
      function matchesTemplate(search, template) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while (searchIndex < search.length) {
          if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
            if (template[templateIndex] === "*") {
              starIndex = templateIndex;
              matchIndex = searchIndex;
              templateIndex++;
            } else {
              searchIndex++;
              templateIndex++;
            }
          } else if (starIndex !== -1) {
            templateIndex = starIndex + 1;
            matchIndex++;
            searchIndex = matchIndex;
          } else {
            return false;
          }
        }
        while (templateIndex < template.length && template[templateIndex] === "*") {
          templateIndex++;
        }
        return templateIndex === template.length;
      }
      function disable() {
        const namespaces = [
          ...createDebug.names,
          ...createDebug.skips.map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        for (const skip of createDebug.skips) {
          if (matchesTemplate(name, skip)) {
            return false;
          }
        }
        for (const ns of createDebug.names) {
          if (matchesTemplate(name, ns)) {
            return true;
          }
        }
        return false;
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports, module) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m2;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m2 = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m2[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c5 = "color: " + this.color;
      args.splice(1, 0, c5, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c5);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r7;
      try {
        r7 = exports.storage.getItem("debug");
      } catch (error) {
      }
      if (!r7 && typeof process !== "undefined" && "env" in process) {
        r7 = process.env.DEBUG;
      }
      return r7;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module.exports = require_common()(exports);
    var { formatters } = module.exports;
    formatters.j = function(v4) {
      try {
        return JSON.stringify(v4);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "node_modules/has-flag/index.js"(exports, module) {
    "use strict";
    module.exports = (flag, argv) => {
      argv = argv || process.argv;
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const pos = argv.indexOf(prefix + flag);
      const terminatorPos = argv.indexOf("--");
      return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
    };
  }
});

// node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "node_modules/supports-color/index.js"(exports, module) {
    "use strict";
    var os = __require("os");
    var hasFlag = require_has_flag();
    var env2 = process.env;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false")) {
      forceColor = false;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = true;
    }
    if ("FORCE_COLOR" in env2) {
      forceColor = env2.FORCE_COLOR.length === 0 || parseInt(env2.FORCE_COLOR, 10) !== 0;
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(stream) {
      if (forceColor === false) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (stream && !stream.isTTY && forceColor !== true) {
        return 0;
      }
      const min = forceColor ? 1 : 0;
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env2) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((sign) => sign in env2) || env2.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env2) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env2.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env2.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env2) {
        const version = parseInt((env2.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env2.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env2.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env2.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env2) {
        return 1;
      }
      if (env2.TERM === "dumb") {
        return min;
      }
      return min;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream);
      return translateLevel(level);
    }
    module.exports = {
      supportsColor: getSupportLevel,
      stdout: getSupportLevel(process.stdout),
      stderr: getSupportLevel(process.stderr)
    };
  }
});

// node_modules/debug/src/node.js
var require_node = __commonJS({
  "node_modules/debug/src/node.js"(exports, module) {
    var tty = __require("tty");
    var util = __require("util");
    exports.init = init;
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.destroy = util.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_2, k3) => {
        return k3.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c5 = this.color;
        const colorCode = "\x1B[3" + (c5 < 8 ? c5 : "8;5;" + c5);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug) {
      debug.inspectOpts = {};
      const keys = Object.keys(exports.inspectOpts);
      for (let i4 = 0; i4 < keys.length; i4++) {
        debug.inspectOpts[keys[i4]] = exports.inspectOpts[keys[i4]];
      }
    }
    module.exports = require_common()(exports);
    var { formatters } = module.exports;
    formatters.o = function(v4) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v4, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v4) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v4, this.inspectOpts);
    };
  }
});

// node_modules/debug/src/index.js
var require_src = __commonJS({
  "node_modules/debug/src/index.js"(exports, module) {
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module.exports = require_browser();
    } else {
      module.exports = require_node();
    }
  }
});

// node_modules/module-details-from-path/index.js
var require_module_details_from_path = __commonJS({
  "node_modules/module-details-from-path/index.js"(exports, module) {
    "use strict";
    var path3 = __require("path");
    module.exports = function(file) {
      var segments = file.split(path3.sep);
      var index = segments.lastIndexOf("node_modules");
      if (index === -1)
        return;
      if (!segments[index + 1])
        return;
      var scoped = segments[index + 1][0] === "@";
      var name = scoped ? segments[index + 1] + "/" + segments[index + 2] : segments[index + 1];
      var offset = scoped ? 3 : 2;
      return {
        name,
        basedir: segments.slice(0, index + offset).join(path3.sep),
        path: segments.slice(index + offset).join(path3.sep)
      };
    };
  }
});

// node_modules/require-in-the-middle/package.json
var require_package = __commonJS({
  "node_modules/require-in-the-middle/package.json"(exports, module) {
    module.exports = {
      name: "require-in-the-middle",
      version: "7.4.0",
      description: "Module to hook into the Node.js require function",
      main: "index.js",
      types: "types/index.d.ts",
      dependencies: {
        debug: "^4.3.5",
        "module-details-from-path": "^1.0.3",
        resolve: "^1.22.8"
      },
      devDependencies: {
        "@babel/core": "^7.9.0",
        "@babel/preset-env": "^7.9.5",
        "@babel/preset-typescript": "^7.9.0",
        "@babel/register": "^7.9.0",
        "ipp-printer": "^1.0.0",
        patterns: "^1.0.3",
        roundround: "^0.2.0",
        semver: "^6.3.0",
        standard: "^14.3.1",
        tape: "^4.11.0"
      },
      scripts: {
        test: "npm run test:lint && npm run test:tape && npm run test:babel",
        "test:lint": "standard",
        "test:tape": "tape test/*.js",
        "test:babel": "node test/babel/babel-register.js"
      },
      repository: {
        type: "git",
        url: "git+https://github.com/elastic/require-in-the-middle.git"
      },
      keywords: [
        "require",
        "hook",
        "shim",
        "shimmer",
        "shimming",
        "patch",
        "monkey",
        "monkeypatch",
        "module",
        "load"
      ],
      files: [
        "types"
      ],
      author: "Thomas Watson Steen <w@tson.dk> (https://twitter.com/wa7son)",
      license: "MIT",
      bugs: {
        url: "https://github.com/elastic/require-in-the-middle/issues"
      },
      homepage: "https://github.com/elastic/require-in-the-middle#readme",
      engines: {
        node: ">=8.6.0"
      }
    };
  }
});

// node_modules/require-in-the-middle/index.js
var require_require_in_the_middle = __commonJS({
  "node_modules/require-in-the-middle/index.js"(exports, module) {
    "use strict";
    var path3 = __require("path");
    var Module = __require("module");
    var resolve = require_resolve();
    var debug = require_src()("require-in-the-middle");
    var moduleDetailsFromPath = require_module_details_from_path();
    module.exports = Hook2;
    module.exports.Hook = Hook2;
    var isCore;
    if (Module.isBuiltin) {
      isCore = Module.isBuiltin;
    } else {
      const [major2, minor] = process.versions.node.split(".").map(Number);
      if (major2 === 8 && minor < 8) {
        isCore = (moduleName) => {
          if (moduleName === "http2") {
            return true;
          }
          return !!resolve.core[moduleName];
        };
      } else {
        isCore = (moduleName) => {
          return !!resolve.core[moduleName];
        };
      }
    }
    var normalize3 = /([/\\]index)?(\.js)?$/;
    var ExportsCache = class {
      constructor() {
        this._localCache = /* @__PURE__ */ new Map();
        this._kRitmExports = Symbol("RitmExports");
      }
      has(filename, isBuiltin) {
        if (this._localCache.has(filename)) {
          return true;
        } else if (!isBuiltin) {
          const mod = __require.cache[filename];
          return !!(mod && this._kRitmExports in mod);
        } else {
          return false;
        }
      }
      get(filename, isBuiltin) {
        const cachedExports = this._localCache.get(filename);
        if (cachedExports !== void 0) {
          return cachedExports;
        } else if (!isBuiltin) {
          const mod = __require.cache[filename];
          return mod && mod[this._kRitmExports];
        }
      }
      set(filename, exports2, isBuiltin) {
        if (isBuiltin) {
          this._localCache.set(filename, exports2);
        } else if (filename in __require.cache) {
          __require.cache[filename][this._kRitmExports] = exports2;
        } else {
          debug('non-core module is unexpectedly not in require.cache: "%s"', filename);
          this._localCache.set(filename, exports2);
        }
      }
    };
    function Hook2(modules, options, onrequire) {
      if (this instanceof Hook2 === false)
        return new Hook2(modules, options, onrequire);
      if (typeof modules === "function") {
        onrequire = modules;
        modules = null;
        options = null;
      } else if (typeof options === "function") {
        onrequire = options;
        options = null;
      }
      if (typeof Module._resolveFilename !== "function") {
        console.error("Error: Expected Module._resolveFilename to be a function (was: %s) - aborting!", typeof Module._resolveFilename);
        console.error("Please report this error as an issue related to Node.js %s at %s", process.version, require_package().bugs.url);
        return;
      }
      this._cache = new ExportsCache();
      this._unhooked = false;
      this._origRequire = Module.prototype.require;
      const self2 = this;
      const patching = /* @__PURE__ */ new Set();
      const internals = options ? options.internals === true : false;
      const hasWhitelist = Array.isArray(modules);
      debug("registering require hook");
      this._require = Module.prototype.require = function(id) {
        if (self2._unhooked === true) {
          debug("ignoring require call - module is soft-unhooked");
          return self2._origRequire.apply(this, arguments);
        }
        return patchedRequire.call(this, arguments, false);
      };
      if (typeof process.getBuiltinModule === "function") {
        this._origGetBuiltinModule = process.getBuiltinModule;
        this._getBuiltinModule = process.getBuiltinModule = function(id) {
          if (self2._unhooked === true) {
            debug("ignoring process.getBuiltinModule call - module is soft-unhooked");
            return self2._origGetBuiltinModule.apply(this, arguments);
          }
          return patchedRequire.call(this, arguments, true);
        };
      }
      function patchedRequire(args, coreOnly) {
        const id = args[0];
        const core = isCore(id);
        let filename;
        if (core) {
          filename = id;
          if (id.startsWith("node:")) {
            const idWithoutPrefix = id.slice(5);
            if (isCore(idWithoutPrefix)) {
              filename = idWithoutPrefix;
            }
          }
        } else if (coreOnly) {
          debug("call to process.getBuiltinModule with unknown built-in id");
          return self2._origGetBuiltinModule.apply(this, args);
        } else {
          try {
            filename = Module._resolveFilename(id, this);
          } catch (resolveErr) {
            debug('Module._resolveFilename("%s") threw %j, calling original Module.require', id, resolveErr.message);
            return self2._origRequire.apply(this, args);
          }
        }
        let moduleName, basedir;
        debug("processing %s module require('%s'): %s", core === true ? "core" : "non-core", id, filename);
        if (self2._cache.has(filename, core) === true) {
          debug("returning already patched cached module: %s", filename);
          return self2._cache.get(filename, core);
        }
        const isPatching = patching.has(filename);
        if (isPatching === false) {
          patching.add(filename);
        }
        const exports2 = coreOnly ? self2._origGetBuiltinModule.apply(this, args) : self2._origRequire.apply(this, args);
        if (isPatching === true) {
          debug("module is in the process of being patched already - ignoring: %s", filename);
          return exports2;
        }
        patching.delete(filename);
        if (core === true) {
          if (hasWhitelist === true && modules.includes(filename) === false) {
            debug("ignoring core module not on whitelist: %s", filename);
            return exports2;
          }
          moduleName = filename;
        } else if (hasWhitelist === true && modules.includes(filename)) {
          const parsedPath = path3.parse(filename);
          moduleName = parsedPath.name;
          basedir = parsedPath.dir;
        } else {
          const stat = moduleDetailsFromPath(filename);
          if (stat === void 0) {
            debug("could not parse filename: %s", filename);
            return exports2;
          }
          moduleName = stat.name;
          basedir = stat.basedir;
          const fullModuleName = resolveModuleName(stat);
          debug("resolved filename to module: %s (id: %s, resolved: %s, basedir: %s)", moduleName, id, fullModuleName, basedir);
          let matchFound = false;
          if (hasWhitelist) {
            if (!id.startsWith(".") && modules.includes(id)) {
              moduleName = id;
              matchFound = true;
            }
            if (!modules.includes(moduleName) && !modules.includes(fullModuleName)) {
              return exports2;
            }
            if (modules.includes(fullModuleName) && fullModuleName !== moduleName) {
              moduleName = fullModuleName;
              matchFound = true;
            }
          }
          if (!matchFound) {
            let res;
            try {
              res = resolve.sync(moduleName, { basedir });
            } catch (e7) {
              debug("could not resolve module: %s", moduleName);
              self2._cache.set(filename, exports2, core);
              return exports2;
            }
            if (res !== filename) {
              if (internals === true) {
                moduleName = moduleName + path3.sep + path3.relative(basedir, filename);
                debug("preparing to process require of internal file: %s", moduleName);
              } else {
                debug("ignoring require of non-main module file: %s", res);
                self2._cache.set(filename, exports2, core);
                return exports2;
              }
            }
          }
        }
        self2._cache.set(filename, exports2, core);
        debug("calling require hook: %s", moduleName);
        const patchedExports = onrequire(exports2, moduleName, basedir);
        self2._cache.set(filename, patchedExports, core);
        debug("returning module: %s", moduleName);
        return patchedExports;
      }
    }
    Hook2.prototype.unhook = function() {
      this._unhooked = true;
      if (this._require === Module.prototype.require) {
        Module.prototype.require = this._origRequire;
        debug("require unhook successful");
      } else {
        debug("require unhook unsuccessful");
      }
      if (process.getBuiltinModule !== void 0) {
        if (this._getBuiltinModule === process.getBuiltinModule) {
          process.getBuiltinModule = this._origGetBuiltinModule;
          debug("process.getBuiltinModule unhook successful");
        } else {
          debug("process.getBuiltinModule unhook unsuccessful");
        }
      }
    };
    function resolveModuleName(stat) {
      const normalizedPath = path3.sep !== "/" ? stat.path.split(path3.sep).join("/") : stat.path;
      return path3.posix.join(stat.name, normalizedPath).replace(normalize3, "");
    }
  }
});

// node_modules/import-in-the-middle/lib/register.js
var require_register = __commonJS({
  "node_modules/import-in-the-middle/lib/register.js"(exports) {
    var importHooks = [];
    var setters = /* @__PURE__ */ new WeakMap();
    var getters = /* @__PURE__ */ new WeakMap();
    var specifiers = /* @__PURE__ */ new Map();
    var toHook = [];
    var proxyHandler = {
      set(target, name, value) {
        return setters.get(target)[name](value);
      },
      get(target, name) {
        if (name === Symbol.toStringTag) {
          return "Module";
        }
        const getter = getters.get(target)[name];
        if (typeof getter === "function") {
          return getter();
        }
      },
      defineProperty(target, property, descriptor) {
        if (!("value" in descriptor)) {
          throw new Error("Getters/setters are not supported for exports property descriptors.");
        }
        return setters.get(target)[property](descriptor.value);
      }
    };
    function register(name, namespace, set, get, specifier) {
      specifiers.set(name, specifier);
      setters.set(namespace, set);
      getters.set(namespace, get);
      const proxy = new Proxy(namespace, proxyHandler);
      importHooks.forEach((hook) => hook(name, proxy));
      toHook.push([name, proxy]);
    }
    exports.register = register;
    exports.importHooks = importHooks;
    exports.specifiers = specifiers;
    exports.toHook = toHook;
  }
});

// node_modules/import-in-the-middle/index.js
var require_import_in_the_middle = __commonJS({
  "node_modules/import-in-the-middle/index.js"(exports, module) {
    var path3 = __require("path");
    var parse = require_module_details_from_path();
    var { fileURLToPath } = __require("url");
    var { MessageChannel } = __require("worker_threads");
    var {
      importHooks,
      specifiers,
      toHook
    } = require_register();
    function addHook(hook) {
      importHooks.push(hook);
      toHook.forEach(([name, namespace]) => hook(name, namespace));
    }
    function removeHook(hook) {
      const index = importHooks.indexOf(hook);
      if (index > -1) {
        importHooks.splice(index, 1);
      }
    }
    function callHookFn(hookFn, namespace, name, baseDir) {
      const newDefault = hookFn(namespace, name, baseDir);
      if (newDefault && newDefault !== namespace) {
        namespace.default = newDefault;
      }
    }
    var sendModulesToLoader;
    function createAddHookMessageChannel() {
      const { port1, port2 } = new MessageChannel();
      let pendingAckCount = 0;
      let resolveFn;
      sendModulesToLoader = (modules) => {
        pendingAckCount++;
        port1.postMessage(modules);
      };
      port1.on("message", () => {
        pendingAckCount--;
        if (resolveFn && pendingAckCount <= 0) {
          resolveFn();
        }
      }).unref();
      function waitForAllMessagesAcknowledged() {
        const timer = setInterval(() => {
        }, 1e3);
        const promise = new Promise((resolve) => {
          resolveFn = resolve;
        }).then(() => {
          clearInterval(timer);
        });
        if (pendingAckCount === 0) {
          resolveFn();
        }
        return promise;
      }
      const addHookMessagePort = port2;
      const registerOptions = { data: { addHookMessagePort, include: [] }, transferList: [addHookMessagePort] };
      return { registerOptions, addHookMessagePort, waitForAllMessagesAcknowledged };
    }
    function Hook2(modules, options, hookFn) {
      if (this instanceof Hook2 === false)
        return new Hook2(modules, options, hookFn);
      if (typeof modules === "function") {
        hookFn = modules;
        modules = null;
        options = null;
      } else if (typeof options === "function") {
        hookFn = options;
        options = null;
      }
      const internals = options ? options.internals === true : false;
      if (sendModulesToLoader && Array.isArray(modules)) {
        sendModulesToLoader(modules);
      }
      this._iitmHook = (name, namespace) => {
        const filename = name;
        const isBuiltin = name.startsWith("node:");
        let baseDir;
        if (isBuiltin) {
          name = name.replace(/^node:/, "");
        } else {
          if (name.startsWith("file://")) {
            try {
              name = fileURLToPath(name);
            } catch (e7) {
            }
          }
          const details = parse(name);
          if (details) {
            name = details.name;
            baseDir = details.basedir;
          }
        }
        if (modules) {
          for (const moduleName of modules) {
            if (moduleName === name) {
              if (baseDir) {
                if (internals) {
                  name = name + path3.sep + path3.relative(baseDir, fileURLToPath(filename));
                } else {
                  if (!baseDir.endsWith(specifiers.get(filename)))
                    continue;
                }
              }
              callHookFn(hookFn, namespace, name, baseDir);
            }
          }
        } else {
          callHookFn(hookFn, namespace, name, baseDir);
        }
      };
      addHook(this._iitmHook);
    }
    Hook2.prototype.unhook = function() {
      removeHook(this._iitmHook);
    };
    module.exports = Hook2;
    module.exports.Hook = Hook2;
    module.exports.addHook = addHook;
    module.exports.removeHook = removeHook;
    module.exports.createAddHookMessageChannel = createAddHookMessageChannel;
  }
});

// node_modules/@opentelemetry/otlp-exporter-base/build/esm/is-export-retryable.js
function isExportRetryable(statusCode) {
  var retryCodes = [429, 502, 503, 504];
  return retryCodes.includes(statusCode);
}
function parseRetryAfterToMills(retryAfter) {
  if (retryAfter == null) {
    return void 0;
  }
  var seconds = Number.parseInt(retryAfter, 10);
  if (Number.isInteger(seconds)) {
    return seconds > 0 ? seconds * 1e3 : -1;
  }
  var delay = new Date(retryAfter).getTime() - Date.now();
  if (delay >= 0) {
    return delay;
  }
  return 0;
}
var init_is_export_retryable = __esm({
  "node_modules/@opentelemetry/otlp-exporter-base/build/esm/is-export-retryable.js"() {
  }
});

// node_modules/@opentelemetry/otlp-exporter-base/build/esm/types.js
var __extends6, OTLPExporterError;
var init_types2 = __esm({
  "node_modules/@opentelemetry/otlp-exporter-base/build/esm/types.js"() {
    __extends6 = function() {
      var extendStatics = function(d5, b4) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d6, b5) {
          d6.__proto__ = b5;
        } || function(d6, b5) {
          for (var p9 in b5)
            if (Object.prototype.hasOwnProperty.call(b5, p9))
              d6[p9] = b5[p9];
        };
        return extendStatics(d5, b4);
      };
      return function(d5, b4) {
        if (typeof b4 !== "function" && b4 !== null)
          throw new TypeError("Class extends value " + String(b4) + " is not a constructor or null");
        extendStatics(d5, b4);
        function __() {
          this.constructor = d5;
        }
        d5.prototype = b4 === null ? Object.create(b4) : (__.prototype = b4.prototype, new __());
      };
    }();
    OTLPExporterError = /** @class */
    function(_super) {
      __extends6(OTLPExporterError2, _super);
      function OTLPExporterError2(message, code, data) {
        var _this = _super.call(this, message) || this;
        _this.name = "OTLPExporterError";
        _this.data = data;
        _this.code = code;
        return _this;
      }
      return OTLPExporterError2;
    }(Error);
  }
});

// node_modules/@opentelemetry/otlp-exporter-base/build/esm/platform/node/http-transport-utils.js
var http_transport_utils_exports = {};
__export(http_transport_utils_exports, {
  createHttpAgent: () => createHttpAgent,
  sendWithHttp: () => sendWithHttp
});
import * as http from "http";
import * as https from "https";
import * as zlib from "zlib";
import { Readable } from "stream";
function sendWithHttp(params, agent, data, onDone, timeoutMillis) {
  var parsedUrl = new URL(params.url);
  var nodeVersion = Number(process.versions.node.split(".")[0]);
  var options = {
    hostname: parsedUrl.hostname,
    port: parsedUrl.port,
    path: parsedUrl.pathname,
    method: "POST",
    headers: __assign4({}, params.headers),
    agent
  };
  var request3 = parsedUrl.protocol === "http:" ? http.request : https.request;
  var req = request3(options, function(res) {
    var responseData = [];
    res.on("data", function(chunk) {
      return responseData.push(chunk);
    });
    res.on("end", function() {
      if (res.statusCode && res.statusCode < 299) {
        onDone({
          status: "success",
          data: Buffer.concat(responseData)
        });
      } else if (res.statusCode && isExportRetryable(res.statusCode)) {
        onDone({
          status: "retryable",
          retryInMillis: parseRetryAfterToMills(res.headers["retry-after"])
        });
      } else {
        var error = new OTLPExporterError(res.statusMessage, res.statusCode);
        onDone({
          status: "failure",
          error
        });
      }
    });
  });
  req.setTimeout(timeoutMillis, function() {
    req.destroy();
    onDone({
      status: "failure",
      error: new Error("Request Timeout")
    });
  });
  req.on("error", function(error) {
    onDone({
      status: "failure",
      error
    });
  });
  var reportTimeoutErrorEvent = nodeVersion >= 14 ? "close" : "abort";
  req.on(reportTimeoutErrorEvent, function() {
    onDone({
      status: "failure",
      error: new Error("Request timed out")
    });
  });
  compressAndSend(req, params.compression, data, function(error) {
    onDone({
      status: "failure",
      error
    });
  });
}
function compressAndSend(req, compression, data, onError) {
  var dataStream = readableFromUint8Array(data);
  if (compression === "gzip") {
    req.setHeader("Content-Encoding", "gzip");
    dataStream = dataStream.on("error", onError).pipe(zlib.createGzip()).on("error", onError);
  }
  dataStream.pipe(req);
}
function readableFromUint8Array(buff) {
  var readable = new Readable();
  readable.push(buff);
  readable.push(null);
  return readable;
}
function createHttpAgent(rawUrl, agentOptions) {
  var parsedUrl = new URL(rawUrl);
  var Agent3 = parsedUrl.protocol === "http:" ? http.Agent : https.Agent;
  return new Agent3(agentOptions);
}
var __assign4;
var init_http_transport_utils = __esm({
  "node_modules/@opentelemetry/otlp-exporter-base/build/esm/platform/node/http-transport-utils.js"() {
    init_is_export_retryable();
    init_types2();
    __assign4 = function() {
      __assign4 = Object.assign || function(t5) {
        for (var s10, i4 = 1, n9 = arguments.length; i4 < n9; i4++) {
          s10 = arguments[i4];
          for (var p9 in s10)
            if (Object.prototype.hasOwnProperty.call(s10, p9))
              t5[p9] = s10[p9];
        }
        return t5;
      };
      return __assign4.apply(this, arguments);
    };
  }
});

// node_modules/@redocly/realm/dist/client/App.js
import * as e6 from "react";
import { useEffect as l4 } from "react";
import { Outlet as u7, useLocation as f6, useNavigate as E8 } from "react-router-dom";
import { Helmet as d4 } from "react-helmet";

// node_modules/@markdoc/markdoc/dist/react.js
var Tag2 = class {
  constructor(name = "div", attributes = {}, children = []) {
    this.$$mdtype = "Tag";
    this.name = name;
    this.attributes = attributes;
    this.children = children;
  }
};
Tag2.isTag = (tag) => {
  return !!(tag?.$$mdtype === "Tag");
};
function tagName(name, components2) {
  return typeof name !== "string" ? name : name[0] !== name[0].toUpperCase() ? name : components2 instanceof Function ? components2(name) : components2[name];
}
function dynamic(node, React, { components: components2 = {} } = {}) {
  function deepRender(value) {
    if (value == null || typeof value !== "object")
      return value;
    if (Array.isArray(value))
      return value.map((item) => deepRender(item));
    if (value.$$mdtype === "Tag")
      return render(value);
    if (typeof value !== "object")
      return value;
    const output = {};
    for (const [k3, v4] of Object.entries(value))
      output[k3] = deepRender(v4);
    return output;
  }
  function render(node2) {
    if (Array.isArray(node2))
      return React.createElement(React.Fragment, null, ...node2.map(render));
    if (node2 === null || typeof node2 !== "object" || !Tag2.isTag(node2))
      return node2;
    const {
      name,
      attributes: { class: className, ...attrs } = {},
      children = []
    } = node2;
    if (className)
      attrs.className = className;
    return React.createElement(tagName(name, components2), Object.keys(attrs).length == 0 ? null : deepRender(attrs), ...children.map(render));
  }
  return render(node);
}

// node_modules/@redocly/realm/dist/client/App.js
init_RootLayout();
init_PageLayout();
init_default();

// node_modules/@redocly/realm/dist/client/app/Sidebar/Sidebar.js
init_styled_components_esm();
init_Menu();
init_SidebarActions();
init_Sidebar();
init_VersionPicker();
init_Button();
init_ArrowLeftIcon();
import e2, { useEffect as S2, useState as u } from "react";

// node_modules/@redocly/realm/dist/client/app/Sidebar/RequestAccessButton.js
init_styled_components_esm();
init_Button();
init_Admonition();
import r3, { useEffect as I3, useState as a } from "react";
import { useLocation as C } from "react-router-dom";
var O = (e7) => {
  const {
    apiId: s10,
    status: t5,
    setStatus: o4
  } = e7, u8 = m(), {
    userData: n9
  } = s3("userData") || {}, h4 = C(), i4 = I2(), [l5, p9] = a(), [E9, g6] = a(), [m2, A4] = a(true);
  I3(() => {
    n9?.isAuthenticated && fetch(`/api/api-keys/api-products/${s10}/access`).then((d5) => d5.json().then((c5) => {
      d5.ok ? (o4(c5.status), g6(c5.appId)) : p9(c5.message);
    }).catch(() => p9("Something went wrong")).finally(() => A4(false)));
  }, [n9?.isAuthenticated, s10, o4]);
  const P6 = () => {
    !n9?.isAuthenticated && i4 ? window.location.href = `${i4}${i4.includes("?") ? "&" : "?"}redirectTo=${h4.pathname}` : t5 === "ACCEPTED" ? u8.push("/apps/" + E9 || "") : t5 === "NONE" && u8.push("/apps/?createApp&apiId=" + s10), s.send("request_api_access_button_clicked", {
      action: "click"
    });
  }, D2 = (t5 === "PENDING" || m2 || l5 != null) && n9?.isAuthenticated;
  return r3.createElement(r3.Fragment, null, r3.createElement(Button, {
    disabled: D2,
    onClick: P6,
    fullWidth: true,
    size: "small"
  }, x4(t5, m2, l5, !!n9?.isAuthenticated)));
};
var x4 = (e7, s10, t5, o4) => {
  if (!o4)
    return "Request access";
  if (s10)
    return "Loading...";
  if (t5)
    return "Failed to check access";
  switch (e7) {
    case "NONE":
      return "Request access";
    case "ACCEPTED":
      return "Credentials";
    case "PENDING":
      return "Pending access...";
  }
  return null;
};
var U = (e7) => e7 === "ACCEPTED" ? r3.createElement(f3, {
  type: "success",
  name: "You have access to this API"
}) : e7 === "PENDING" ? r3.createElement(f3, {
  type: "info",
  name: "You have requested access to this API"
}) : null;
var f3 = styled_components_esm_default(Admonition).withConfig({
  displayName: "RequestAccessButton__f",
  componentId: "sc-i9zdry-0"
})(["margin-top:0px;margin-bottom:var(--spacing-sm);"]);

// node_modules/@redocly/realm/dist/client/app/Sidebar/Sidebar.js
function Y({
  layoutControls: r7
}) {
  const {
    versions: s10 = []
  } = S() || {}, f7 = s10.find((t5) => t5?.active), {
    translate: a4
  } = c(), {
    currentItems: b4,
    backLink: n9,
    pushDrilldownState: h4,
    popDrilldownState: k3
  } = N(f7), [m2, v4] = u(), {
    collapsedSidebar: i4
  } = r7, c5 = n3("openAPIDocsStore")?.definition.info?.["x-metadata"]?.apiId, g6 = m(), [l5, o4] = u(void 0);
  return S2(() => {
    const t5 = setTimeout(() => o4(void 0), 350);
    return () => clearTimeout(t5);
  }, [l5]), e2.createElement(e2.Fragment, null, e2.createElement(Sidebar, {
    collapsed: i4,
    menuItemsAnimation: l5,
    versions: e2.createElement(VersionPicker, {
      versions: s10,
      onChange: (t5) => {
        s.send("version_picker_selection_change", {
          action: "change"
        });
        const d5 = location.hash ? t5?.link + location.hash : t5?.link;
        d5 && g6.push(d5);
      }
    }),
    menu: e2.createElement(Menu, {
      items: b4,
      onDrilldownOpen: (t5) => {
        o4("slideInRight"), h4(t5);
      }
    }),
    footer: e2.createElement("div", {
      style: {
        width: "100%"
      }
    }, !i4 && U(m2), e2.createElement(SidebarActions, {
      ...r7,
      requestAccessButton: c5 ? e2.createElement(O, {
        apiId: c5,
        status: m2,
        setStatus: v4
      }) : null
    })),
    header: n9 && e2.createElement(q, {
      icon: e2.createElement(ArrowLeftIcon, null),
      iconPosition: "left",
      variant: "ghost",
      size: "medium",
      "data-component-name": "Sidebar/BackButton",
      to: n9.slug,
      onClick: () => {
        o4("slideInLeft"), k3(), s.send(n9.event, {
          action: "click"
        });
      }
    }, i4 ? "" : n9.label ? e2.createElement("div", {
      "data-translation-key": "sidebar.menu.backToLabel"
    }, a4("sidebar.menu.backToLabel", {
      value: a4(n9.labelTranslationKey, n9.label)
    })) : e2.createElement("div", {
      "data-translation-key": "sidebar.menu.backLabel"
    }, a4("sidebar.menu.backLabel")))
  }));
}
var q = styled_components_esm_default(Button).withConfig({
  displayName: "Sidebar__q",
  componentId: "sc-vhzy19-0"
})(["padding:var(--menu-item-padding-vertical) 0;height:calc(var(--line-height-base) + var(--menu-item-padding-vertical) * 2);justify-content:flex-start;width:100%;"]);

// node_modules/@redocly/realm/dist/client/app/Sidebar/useActions.js
init_lib_esm();
import a2 from "react";
function d() {
  const { definition: n9, options: t5 = {} } = n3("openAPIDocsStore") || {}, s10 = n9 && t5, [e7, i4] = a2.useState(t5.layout || LayoutVariant.THREE_PANEL), [u8, c5] = a2.useState(false);
  function r7() {
    i4(e7 === LayoutVariant.STACKED ? LayoutVariant.THREE_PANEL : LayoutVariant.STACKED);
  }
  function l5() {
    c5((p9) => !p9);
  }
  return { onChangeViewClick: r7, onChangeCollapseSidebarClick: l5, showChangeLayoutButton: t5.showChangeLayoutButton || true, layout: e7, collapsedSidebar: u8, isOpenapiDocs: s10 };
}

// node_modules/@redocly/realm/dist/client/app/hooks/useScrollTracker.js
import { useCallback as n5, useEffect as s5 } from "react";

// node_modules/@redocly/realm/dist/client/app/utils/getBlocksHeight.js
function f4(t5) {
  const n9 = ["margin-top", "margin-bottom", "border-top", "border-bottom", "padding-top", "padding-bottom", "height"], e7 = window.getComputedStyle(t5);
  return n9.reduce((r7, c5) => {
    const i4 = parseInt(e7.getPropertyValue(c5), 10);
    return r7 + i4;
  }, 0);
}
var s4 = (t5) => !!t5 && (t5 instanceof HTMLHeadingElement || /^H[1-6]$/.test(t5.tagName));
function l() {
  const t5 = [], n9 = Array.from(document.querySelectorAll("article > *") ?? []);
  let e7 = 0, o4 = false;
  return n9.forEach((r7, c5) => {
    s4(r7) && (!o4 && e7 && (t5.push(e7), e7 = 0), o4 = true, e7 !== 0 && t5.push(e7), e7 = 0);
    const i4 = c5 === 0 ? r7.offsetTop : 0;
    e7 += f4(r7) + i4;
  }), e7 !== 0 && t5.push(e7), t5;
}
function a3(t5) {
  if (t5 === 0)
    return 0;
  const e7 = Array.from(document.querySelectorAll("article > *")).filter((o4) => s4(o4));
  if (t5 < e7.length) {
    const o4 = document.querySelector("nav")?.offsetHeight ?? 0;
    return e7[t5].offsetTop - o4;
  }
  return 0;
}
var g2 = () => {
  const t5 = document.querySelector("article")?.offsetTop ?? 0, n9 = document.querySelector("nav")?.offsetHeight ?? 0;
  return t5 - n9;
};

// node_modules/@redocly/realm/dist/client/app/utils/syncScrollWithEditor.js
function b2(o4, e7 = 0) {
  if (typeof o4 > "u") {
    window.scrollTo({ top: 0, behavior: "smooth" });
    return;
  }
  const t5 = l()[e7], c5 = a3(e7), r7 = Math.round(c5 + t5 * (Math.round(o4) / 100));
  window.scrollTo({ top: r7, behavior: "smooth" });
}
var g3 = (o4) => {
  const e7 = g2();
  if (o4 < e7)
    return { percentScrolled: 0, sequenceNumber: -1 };
  const n9 = l(), t5 = u2(o4, n9.length), c5 = n9[t5], r7 = a3(t5), l5 = t5 === 0 ? e7 : r7, f7 = t5 === 0 ? c5 - e7 : c5;
  return { percentScrolled: Math.round((o4 - l5) / f7 * 100), sequenceNumber: t5 };
};
function u2(o4, e7) {
  let n9 = 0;
  for (let t5 = 0; t5 < e7; t5++) {
    const c5 = a3(t5), r7 = a3(t5 + 1);
    if (o4 >= c5 && o4 < r7) {
      n9 = t5;
      break;
    }
  }
  return n9;
}

// node_modules/@redocly/realm/dist/client/providers/post-message/use-post-message.js
import { useContext as t3 } from "react";

// node_modules/@redocly/realm/dist/client/providers/post-message/PostMessageProvider.js
import n4, { createContext as R3, useEffect as v } from "react";
import { useLocation as M, useNavigate as S3 } from "react-router-dom";

// node_modules/@redocly/realm/dist/client/providers/post-message/PostMessageConnection.js
var e3 = class {
  source;
  origin;
  constructor(s10, o4) {
    this.source = s10, this.origin = o4;
  }
  send(s10) {
    this.source.postMessage(s10, this.origin);
  }
};

// node_modules/@redocly/realm/dist/client/providers/post-message/PostMessageProvider.js
var T = R3({ sendMessage: () => {
} });
function V({ children: c5, enabled: o4 }) {
  const k3 = S3(), l5 = M(), i4 = n4.useRef(null), u8 = n4.useCallback((e7) => {
    i4.current?.send(e7);
  }, []), m2 = n4.useCallback((e7) => {
    console.info("[PM] connection initialized."), i4.current = new e3(e7.source, e7.origin), u8({ type: "initialized" });
  }, [u8]), h4 = n4.useCallback(async (e7) => {
    const { path: r7 = "/", line: t5 = 1, url: w7 } = e7;
    let a4 = w7;
    if (!w7)
      try {
        const d5 = await fetch(P2(t.RESOLVE_ROUTE_BY_PATH), { method: "POST", body: JSON.stringify(r7 + (t5 ? `:${t5}` : "")) }), { route: b4 } = await d5.json();
        a4 = b4?.slug ?? b4?.url ?? void 0;
      } catch (d5) {
        console.error(d5);
      }
    if (!a4)
      return;
    a4 = a4 === "/" ? "/" : n2(a4);
    const [y4, P6] = a4.split("#");
    P(y4) === P(l5.pathname) && (P6 ?? "") === l5.hash.substring(1) || (console.info("[PM] Update route to: ", a4), await p2(k3, a4, "pm"));
  }, [l5]), f7 = n4.useCallback(async (e7) => {
    const { action: r7 } = e7;
    switch (r7) {
      case "back":
        window.history.back();
        break;
      case "forward":
        window.history.forward();
        break;
      case "reload":
        window.location.reload();
        break;
    }
  }, []), p9 = n4.useCallback((e7) => {
    window.scrollTo({ top: e7.position.absolute, behavior: "instant" });
  }, []);
  return v(() => {
    if (!o4)
      return;
    const e7 = async (r7) => {
      if (!z(r7.origin))
        return;
      const t5 = r7.data;
      switch (t5.type) {
        case "initialize":
          m2(r7);
          break;
        case "route-update":
          if (!i4.current)
            return;
          h4(t5);
          break;
        case "location-update":
          if (!i4.current)
            return;
          f7(t5);
          break;
        case "scroll-update":
          if (!i4.current)
            return;
          p9(t5);
          break;
        case "editor-scroll-update":
          if (!i4.current)
            return;
          b2(t5.percentScrolled, t5.sequenceNumber);
          break;
      }
    };
    return window.addEventListener("message", e7), () => {
      window.removeEventListener("message", e7);
    };
  }, [o4, m2, h4, f7, p9]), n4.createElement(T.Provider, { value: { sendMessage: u8 } }, c5);
}
function z(c5) {
  const o4 = new URL(c5);
  return i(o4.hostname, "localhost") || i(o4.hostname, "127.0.0.1") || i(o4.hostname, "blueharvest.cloud") || i(o4.hostname, "bhstage.cloud") || i(o4.hostname, "cloud.redocly.com") || i(o4.hostname, "cloud.eu.redocly.com") || i(o4.hostname, "cba.au.redocly.com");
}

// node_modules/@redocly/realm/dist/client/providers/post-message/use-post-message.js
function r4() {
  return t3(T);
}

// node_modules/@redocly/realm/dist/client/app/hooks/useScrollTracker.js
var p5 = () => {
  const { sendMessage: e7 } = r4(), o4 = n5(() => {
    if (!window.document.querySelector(":hover"))
      return;
    const { percentScrolled: r7, sequenceNumber: t5 } = g3(window.scrollY);
    e7({ type: "editor-scroll-updated", percentScrolled: r7, sequenceNumber: t5 }), e7({ type: "scroll-updated", position: { absolute: window.scrollY, relative: Math.round(window.scrollY / (window.document.body.clientHeight - window.innerHeight) * 100) } });
  }, [e7]);
  s5(() => {
    if (w())
      return window.addEventListener("scroll", o4, { passive: true }), () => {
        window.removeEventListener("scroll", o4);
      };
  }, [o4]);
};

// node_modules/@redocly/realm/dist/client/app/ErrorBubble/index.js
init_styled_components_esm();
init_WarningFilledIcon();
init_Button();
import r5 from "react";

// node_modules/@redocly/realm/dist/client/app/ErrorBubble/DetailedErrors.js
init_styled_components_esm();
var import_ansi_to_react = __toESM(require_lib2(), 1);
init_src();
init_Button();
init_hooks();
import e4, { useRef as s6 } from "react";
var u3 = import_ansi_to_react.default?.default || import_ansi_to_react.default;
var A = ({
  onHide: a4,
  problems: l5
}) => {
  const t5 = s6(null);
  return useOutsideClick(t5, a4), e4.createElement(e4.Fragment, null, e4.createElement(h, null), e4.createElement(y, {
    ref: t5
  }, e4.createElement(x5, null, e4.createElement(k, {
    onClick: () => a4()
  }, "Close")), e4.createElement(w5, null, e4.createElement(E5, null, l5.map((o4, n9) => {
    const d5 = o4.message.split(`
`)[0];
    return e4.createElement(p6, {
      key: n9
    }, e4.createElement(R4, null, e4.createElement("span", null, e4.createElement(v2, null, n9 + 1, "."), " ", e4.createElement(i2, null, d5)), e4.createElement(Tag, {
      color: "purple",
      className: "tag"
    }, o4.type || "ERROR")), o4.sourceFileRelativePath && e4.createElement(b3, null, "at", " ", [o4.sourceFileRelativePath || "", o4.sourceFileLocation?.line || ""].join(":")), e4.createElement(C2, {
      message: [o4.message.slice(d5.length + 1).trim(), o4.codeframe].join(`
`)
    }));
  })))));
};
var b3 = styled_components_esm_default.div.withConfig({
  displayName: "DetailedErrors__b",
  componentId: "sc-1nq7neo-0"
})(["word-break:break-all;"]);
var v2 = styled_components_esm_default.span.withConfig({
  displayName: "DetailedErrors__v",
  componentId: "sc-1nq7neo-1"
})(["font-weight:bold;display:inline-block;width:16px;"]);
var p6 = styled_components_esm_default.div.withConfig({
  displayName: "DetailedErrors__p",
  componentId: "sc-1nq7neo-2"
})(["display:flex;flex-direction:column;gap:var(--spacing-sm);padding:var(--spacing-md);border-radius:var(--border-radius-md);background:var(--detailed-error-message-bg-color);position:relative;"]);
var h = styled_components_esm_default.div.withConfig({
  displayName: "DetailedErrors__h",
  componentId: "sc-1nq7neo-3"
})(["position:fixed;top:0;left:0;width:100vw;height:100vh;background:var(--detailed-error-overlay-bg-color);opacity:var(--detailed-error-overlay-opacity);z-index:var(--detailed-error-overlay-z-index);"]);
var y = styled_components_esm_default.div.withConfig({
  displayName: "DetailedErrors__y",
  componentId: "sc-1nq7neo-4"
})(["position:fixed;width:var(--detailed-error-modal-width);max-width:1000px;height:var(--detailed-error-modal-height);top:var(--detailed-error-modal-top);left:50%;transform:translateX(-50%);border-radius:var(--detailed-error-modal-border-radius);background:var(--detailed-error-modal-bg-color);color:var(--detailed-error-modal-color);box-shadow:var(--detailed-error-modal-box-shadow);z-index:var(--detailed-error-modal-z-index);font-family:var(--detailed-error-modal-font-family);overflow:hidden;padding:var(--detailed-error-modal-padding);"]);
var w5 = styled_components_esm_default.div.withConfig({
  displayName: "DetailedErrors__w",
  componentId: "sc-1nq7neo-5"
})(["position:relative;overflow:auto;display:flex;flex-direction:column;height:var(--detailed-error-content-height);"]);
var x5 = styled_components_esm_default.div.withConfig({
  displayName: "DetailedErrors__x",
  componentId: "sc-1nq7neo-6"
})(["text-align:var(--detailed-error-modal-wapper-text-align);"]);
var k = styled_components_esm_default.button.withConfig({
  displayName: "DetailedErrors__k",
  componentId: "sc-1nq7neo-7"
})(["border:none;background:none;color:var(--detailed-error-close-button-color);text-transform:var(--detailed-error-close-button-text-transform);cursor:pointer;"]);
var E5 = styled_components_esm_default.div.withConfig({
  displayName: "DetailedErrors__E",
  componentId: "sc-1nq7neo-8"
})(["margin:var(--detailed-error-message-margin);display:flex;flex-direction:column;border-radius:var(--detailed-error-message-border-radius);color:var(--detailed-error-message-color);width:var(--detailed-error-message-width);font-size:var(--detailed-error-message-font-size);font-family:var(--detailed-error-message-font-family);overflow-x:auto;gap:var(--spacing-sm);"]);
function C2({
  message: a4
}) {
  const [l5, t5] = e4.useState(false), o4 = a4.split(`
`), n9 = l5 ? a4 : o4.slice(0, 10).join(`
`);
  return e4.createElement(e4.Fragment, null, e4.createElement(i2, {
    useClasses: true
  }, n9), o4.length > 10 ? e4.createElement(Button, {
    variant: "link",
    onClick: () => t5(!l5)
  }, l5 ? "Show less" : "Show more") : null);
}
var i2 = styled_components_esm_default(u3).withConfig({
  displayName: "DetailedErrors__i",
  componentId: "sc-1nq7neo-9"
})(["display:block;white-space:pre;overflow:auto;.ansi-black-fg{color:#000;}.ansi-bright-black-fg{color:#888;}.ansi-red-fg{color:#ff5554;}.ansi-green-fg{color:#19cb00;}.ansi-yellow-fg{color:#cecb00;}.ansi-blue-fg{color:#4f67ff;}.ansi-magenta-fg{color:#cb1ed1;}.ansi-cyan-fg{color:#0dcdcd;}.ansi-white-fg{color:#e5e5e5;}.ansi-bright-white-fg{color:#fff;}.ansi-bright-red-fg{color:#3e0605;}.ansi-bright-green-fg{color:#23fd00;}.ansi-bright-yellow-fg{color:#fffd00;}.ansi-bright-blue-fg{color:#0026ff;}.ansi-bright-magenta-fg{color:#fd28ff;}.ansi-bright-cyan-fg{color:#14ffff;}.ansi-black-bg{background-color:#000;}.ansi-red-bg{background-color:#cc0403;}.ansi-green-bg{background-color:#19cb00;}.ansi-yellow-bg{background-color:#cecb00;}.ansi-blue-bg{background-color:#001cd1;}.ansi-magenta-bg{background-color:#cb1ed1;}.ansi-cyan-bg{background-color:#0dcdcd;}.ansi-white-bg{background-color:#e5e5e5;}"]);
var R4 = styled_components_esm_default.div.withConfig({
  displayName: "DetailedErrors__R",
  componentId: "sc-1nq7neo-10"
})(["font-size:1.2em;display:flex;flex-direction:row;justify-content:space-between;align-items:center;", "{font-family:var(--font-family-base);display:inline;}"], i2);

// node_modules/@redocly/realm/dist/client/runtime/useSocketMessages.js
import { useEffect as s8 } from "react";

// node_modules/@redocly/realm/dist/client/runtime/ws-client.js
var d2 = /* @__PURE__ */ new Map();
var s7 = /* @__PURE__ */ new Map();
function h2(e7, t5) {
  const n9 = s7.get(e7) ?? /* @__PURE__ */ new Set();
  s7.set(e7, n9), n9.add(t5);
  const l5 = g4(e7);
  return l5 && t5(l5), () => {
    n9.delete(t5), n9.size === 0 && s7.delete(e7);
  };
}
function g4(e7) {
  return d2.get(e7);
}

// node_modules/@redocly/realm/dist/client/runtime/useSocketMessages.js
function c3(e7, o4) {
  s8(() => h2(e7, o4), [e7, o4]);
}

// node_modules/@redocly/realm/dist/client/app/ErrorBubble/index.js
var E6 = "errors-updated";
var k2 = 99;
var N2 = () => {
  const [e7, s10] = r5.useState([]), [i4, a4] = r5.useState(false);
  c3(E6, (n9) => s10(n9.errors));
  const o4 = r5.useMemo(() => {
    const n9 = e7.filter((t5) => t5.type === "BROKEN_LINK"), p9 = e7.filter((t5) => t5.type === "MARKDOC"), g6 = e7.filter((t5) => t5.type !== "BROKEN_LINK" && t5.type !== "MARKDOC");
    return {
      brokenLinks: n9,
      markdocErrors: p9,
      otherErrors: g6
    };
  }, [e7]);
  if (!e7.length)
    return null;
  const c5 = o4.markdocErrors.length ? r5.createElement("span", null, "(", o4.markdocErrors.length, " markdoc)") : null, b4 = o4.brokenLinks.length ? r5.createElement("span", null, "(", o4.brokenLinks.length, " broken links) ") : null, u8 = o4.otherErrors.length ? r5.createElement("span", null, "(", o4.otherErrors.length, " other) ") : null;
  if (i4)
    return r5.createElement(A, {
      onHide: () => a4(false),
      problems: e7
    });
  const d5 = e7.length > k2 ? r5.createElement(WarningFilledIcon, {
    color: "currentColor"
  }) : r5.createElement(y2, null, r5.createElement("span", null, e7.length));
  return r5.createElement(w6, null, r5.createElement(Button, {
    tone: "danger",
    variant: "primary",
    size: "large",
    "aria-label": "Show detailed error message",
    icon: d5,
    onClick: () => a4(true)
  }, r5.createElement(x6, null, "Problems:", c5, b4, u8)));
};
var y2 = styled_components_esm_default.div.withConfig({
  displayName: "ErrorBubble__y",
  componentId: "sc-q7mbm9-0"
})(["display:flex;align-items:center;justify-content:center;width:26px;height:26px;border-radius:50%;background-color:currentcolor;font-size:16px;font-weight:bold;> span{color:var(--button-bg-color-danger);}"]);
var x6 = styled_components_esm_default.div.withConfig({
  displayName: "ErrorBubble__x",
  componentId: "sc-q7mbm9-1"
})(["display:flex;gap:var(--error-bubble-gap);white-space:nowrap;padding:0;font-size:var(--error-card-font-size);color:var(--text-color-primary);"]);
var w6 = styled_components_esm_default.div.withConfig({
  displayName: "ErrorBubble__w",
  componentId: "sc-q7mbm9-2"
})(["display:flex;flex-direction:row;align-items:center;position:fixed;top:calc(var(--navbar-height) + 20px);right:0;transition:transform 0.2s ease-in-out,opacity 0.2s ease-in-out;transform:translateX(calc(100% - (24px + var(--spacing-sm) + var(--button-gap))));width:fit-content;&:hover{transform:translateX(0);opacity:1;}text-overflow:var(--error-bubble-text-overflow);font-family:var(--error-bubble-font-family);z-index:var(--error-bubble-z-index);&& button{--button-icon-size:24px;--button-font-size:var(--error-bubble-font-size);--button-icon-left-padding:var(--error-bubble-padding);--button-bg-color-primary-danger:var(--error-bubble-bg-color);--button-bg-color-primary-danger-hover:var(--error-bubble-bg-color-hover);--button-bg-color-primary-danger-pressed:var(--error-bubble-bg-colorpressed);--button-content-color-danger:var(--error-bubble-content-color);--button-content-color-danger-hover:var(--error-bubble-content-color-hover);--button-content-color-danger-pressed:var(--error-bubble-content-color-pressed);border-top-right-radius:0;border-bottom-right-radius:0;}"]);

// node_modules/@redocly/realm/dist/client/styling/default-styles.js
init_styles();

// node_modules/@redocly/realm/dist/client/providers/theme/ThemeDataProvider.js
init_src();
import o2 from "react";

// node_modules/@redocly/realm/dist/client/app/search/useSearch.js
init_hooks();
import { useCallback as _, useEffect as P4, useState as R5, useRef as L2 } from "react";

// node_modules/@redocly/realm/dist/client/app/search/useFacets.js
import { useCallback as y3, useEffect as u4, useState as n6 } from "react";
function h3(e7) {
  const [o4, c5] = n6([]), [s10, a4] = n6(null), [t5, r7] = n6(null), [p9, i4] = n6(false), { currentLocale: f7 } = E4();
  u4(() => {
    i4(true), m2();
  }, [t5]);
  const m2 = y3(async () => {
    if (e7 && t5 === null) {
      i4(false);
      return;
    }
    let l5 = { locale: f7, field: e7 };
    t5 && (l5 = { ...l5, ...t5 });
    const F2 = await (await fetch(P2(t.SEARCH_FACETS), { method: "POST", headers: { "content-type": "application/json" }, body: JSON.stringify(l5) })).json();
    e7 ? a4(F2) : c5(F2), i4(false);
  }, [f7, t5, e7]);
  return { initialFacets: o4, searchFacets: s10, isFacetsLoading: p9, setSearchFacetQuery: r7 };
}
function E7(e7) {
  const [o4, c5] = n6(null), { searchFacets: s10, setSearchFacetQuery: a4 } = h3(e7);
  return u4(() => {
    const t5 = s10 ? s10.find((r7) => r7.field === e7) ?? null : null;
    c5(t5);
  }, [s10, e7]), { searchFacet: o4, setSearchFacet: c5, setSearchFacetQuery: a4 };
}
var L = (e7) => {
  const [o4, c5] = n6([]), { initialFacets: s10 } = h3();
  return u4(() => {
    if (e7 && Object.keys(e7).length) {
      const a4 = [];
      for (const t5 of s10)
        a4.push({ ...t5, values: e7[t5.field]?.map((r7) => ({ ...r7, isCounterVisible: true })) || [] });
      c5(a4);
    } else
      c5(s10);
  }, [s10, e7]), { facets: o4 };
};

// node_modules/@redocly/realm/dist/client/app/search/useSearch.js
var J = 300;
var M2 = "redocly_product";
var Q = "redocly_version";
var U2 = (t5, r7, e7, i4, c5, a4, s10, f7) => {
  const { currentLocale: d5 } = E4(), { addSearchHistoryItem: p9 } = useRecentSearches(), l5 = L2("");
  P4(() => {
    f7 || (c5(true), E9(t5, r7, d5, s10), l5.current = t5);
  }, [t5, r7, a4?.version, a4?.folderId, s10, f7]);
  const E9 = _(x(async (o4, m2, u8, h4) => {
    if (!o4.trim().length && !m2.length) {
      e7({}), i4({}), c5(false);
      return;
    }
    const S4 = { method: "POST", headers: { "content-type": "application/json" }, body: JSON.stringify({ query: o4, filter: H(m2, h4, a4), locale: u8 }) };
    p9(o4);
    try {
      const n9 = await fetch(P2(t.SEARCH), S4);
      if (l5.current === o4) {
        const I4 = await n9.json();
        i4(I4.facets), e7(I4.documents);
      }
      c5(false);
    } catch (n9) {
      e7({}), console.log(n9);
    }
  }, J), [a4?.version, a4?.folderId, s10]);
  return {};
};
var B = (t5, r7, e7, i4, c5, a4, s10, f7) => {
  const { currentLocale: d5 } = E4();
  P4(() => {
    p9(e7, t5, r7, d5, i4, c5, f7);
  }, [i4, f7]);
  const p9 = _(async (l5, E9, o4, m2, u8, h4, S4) => {
    if (u8) {
      const { groupKey: n9 } = u8;
      s10(true);
      const y4 = { method: "POST", headers: { "content-type": "application/json" }, body: JSON.stringify({ query: E9, filter: (() => {
        const F2 = h4.find((C3) => C3.isTop);
        return F2 && !o4.find((D2) => D2.field === F2?.field) ? [...o4, { field: F2.field, values: [n9], isTop: true }] : H(o4, S4);
      })(), loadMore: u8, locale: m2 }) }, T3 = await (await fetch(P2(t.SEARCH), y4)).json(), v4 = l5[n9] || [], w7 = T3.documents[n9], A4 = { ...l5, [n9]: [...v4, ...w7] };
      a4(A4), s10(false);
    }
  }, []);
  return {};
};
function ee(t5, r7) {
  const { advancedSearch: e7, askAi: i4 } = s2(), [c5, a4] = R5(""), [s10, f7] = R5([]), [d5, p9] = R5({}), [l5, E9] = R5({}), [o4, m2] = R5(), [u8, h4] = R5(false), { facets: S4 } = L(l5), { versions: n9 = [] } = S() || {}, I4 = n9.find((y4) => y4?.active);
  return U2(c5, s10, p9, E9, h4, I4, t5, r7), B(c5, s10, d5, o4, S4, p9, h4, t5), { query: c5, setQuery: a4, filter: s10, setFilter: f7, items: d5, isSearchLoading: u8, facets: S4, setLoadMore: m2, advancedSearch: e7, askAi: i4 };
}
function H(t5, r7, e7) {
  return [...t5, ...r7 ? [{ field: M2, values: [r7] }] : [], ...e7 ? [{ field: Q, values: [...e7.default ? ["default"] : [e7.folderId, e7.version]] }] : []];
}

// node_modules/@redocly/realm/dist/client/app/search/useAiSearch.js
import { useState as s9 } from "react";
function T2(l5) {
  const [d5, c5] = s9(), [m2, a4] = s9([]), [h4, p9] = s9(""), [g6, t5] = s9(false), { currentLocale: R6 } = E4(), S4 = g();
  return { askQuestion: async (r7) => {
    r7 && (c5(""), a4([]), t5(true), p9(r7), fetch(P2(t.ASK_AI), { method: "POST", body: JSON.stringify({ text: r7, locale: R6, product: S4?.name, filter: l5?.filter }) }).then((x7) => {
      let i4 = "";
      const u8 = x7.body;
      if (!u8)
        return;
      const w7 = u8.getReader(), f7 = () => {
        w7.read().then(({ value: o4, done: k3 }) => {
          if (k3) {
            t5(false);
            return;
          }
          const y4 = new TextDecoder().decode(o4), P6 = /data: (.*)/g;
          let n9;
          for (; (n9 = P6.exec(y4)) !== null; ) {
            if (!n9[1])
              continue;
            const e7 = JSON.parse(n9[1]);
            e7.answer ? (i4 += e7.answer, c5(i4)) : e7.sources && a4(e7.sources.slice(0, 5));
          }
          f7();
        }).catch((o4) => {
          console.error(o4), t5(false);
        });
      };
      f7();
    }));
  }, isGeneratingResponse: g6, response: d5, resources: m2, question: h4 };
}

// node_modules/@redocly/realm/dist/client/providers/theme/ThemeDataProvider.js
var A2 = { useBreadcrumbs: P3, useCatalog: te, useCurrentProduct: g, useGlobalData: s2, useSearch: ee, useAiSearch: T2, useFacetQuery: E7, useI18n: e, useI18nConfig: E4, useL10n: e, useL10nConfig: E4, usePageData: F, usePageSharedData: n3, usePageVersions: S, usePreloadHistory: m, useProducts: f2, useUserMenu: p3, useSidebarItems: N, useSidebarSiblingsData: w3, useSubmitFeedback: w4, useTelemetry: t2, useTranslate: c, useUserTeams: r2, usePageProps: R2, useMarkdownText: p4, useCodeHighlight: Sr };
var B2 = { LinkComponent: I };
function z2({ children: a4 }) {
  const { props: e7 } = F() || {}, r7 = s2() || {}, u8 = o2.useMemo(() => p(r7, e7?.frontmatter || {}), [r7, e7?.frontmatter]), n9 = { hooks: A2, components: B2, config: u8 };
  return o2.createElement(ThemeDataContext.Provider, { value: n9 }, a4);
}

// node_modules/@redocly/realm/dist/client/ErrorBoundary.js
import * as n7 from "react";

// node_modules/ulid/dist/index.esm.js
function createError(message) {
  var err = new Error(message);
  err.source = "ulid";
  return err;
}
var ENCODING = "0123456789ABCDEFGHJKMNPQRSTVWXYZ";
var ENCODING_LEN = ENCODING.length;
var TIME_MAX = Math.pow(2, 48) - 1;
var TIME_LEN = 10;
var RANDOM_LEN = 16;
function randomChar(prng) {
  var rand = Math.floor(prng() * ENCODING_LEN);
  if (rand === ENCODING_LEN) {
    rand = ENCODING_LEN - 1;
  }
  return ENCODING.charAt(rand);
}
function encodeTime(now, len) {
  if (isNaN(now)) {
    throw new Error(now + " must be a number");
  }
  if (now > TIME_MAX) {
    throw createError("cannot encode time greater than " + TIME_MAX);
  }
  if (now < 0) {
    throw createError("time must be positive");
  }
  if (Number.isInteger(now) === false) {
    throw createError("time must be an integer");
  }
  var mod = void 0;
  var str = "";
  for (; len > 0; len--) {
    mod = now % ENCODING_LEN;
    str = ENCODING.charAt(mod) + str;
    now = (now - mod) / ENCODING_LEN;
  }
  return str;
}
function encodeRandom(len, prng) {
  var str = "";
  for (; len > 0; len--) {
    str = randomChar(prng) + str;
  }
  return str;
}
function detectPrng() {
  var allowInsecure = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
  var root = arguments[1];
  if (!root) {
    root = typeof window !== "undefined" ? window : null;
  }
  var browserCrypto = root && (root.crypto || root.msCrypto);
  if (browserCrypto) {
    return function() {
      var buffer = new Uint8Array(1);
      browserCrypto.getRandomValues(buffer);
      return buffer[0] / 255;
    };
  } else {
    try {
      var nodeCrypto = __require("crypto");
      return function() {
        return nodeCrypto.randomBytes(1).readUInt8() / 255;
      };
    } catch (e7) {
    }
  }
  if (allowInsecure) {
    try {
      console.error("secure crypto unusable, falling back to insecure Math.random()!");
    } catch (e7) {
    }
    return function() {
      return Math.random();
    };
  }
  throw createError("secure crypto unusable, insecure Math.random not allowed");
}
function factory(currPrng) {
  if (!currPrng) {
    currPrng = detectPrng();
  }
  return function ulid2(seedTime) {
    if (isNaN(seedTime)) {
      seedTime = Date.now();
    }
    return encodeTime(seedTime, TIME_LEN) + encodeRandom(RANDOM_LEN, currPrng);
  };
}
var ulid = factory();

// node_modules/@redocly/realm/dist/client/app/telemetry/otel/telemetry.js
init_esm();

// node_modules/@opentelemetry/core/build/esm/baggage/propagation/W3CBaggagePropagator.js
init_esm();

// node_modules/@opentelemetry/core/build/esm/trace/suppress-tracing.js
init_esm();
var SUPPRESS_TRACING_KEY = createContextKey("OpenTelemetry SDK Context Key SUPPRESS_TRACING");
function suppressTracing(context2) {
  return context2.setValue(SUPPRESS_TRACING_KEY, true);
}
function isTracingSuppressed(context2) {
  return context2.getValue(SUPPRESS_TRACING_KEY) === true;
}

// node_modules/@opentelemetry/core/build/esm/baggage/constants.js
var BAGGAGE_KEY_PAIR_SEPARATOR = "=";
var BAGGAGE_PROPERTIES_SEPARATOR = ";";
var BAGGAGE_ITEMS_SEPARATOR = ",";
var BAGGAGE_HEADER = "baggage";
var BAGGAGE_MAX_NAME_VALUE_PAIRS = 180;
var BAGGAGE_MAX_PER_NAME_VALUE_PAIRS = 4096;
var BAGGAGE_MAX_TOTAL_LENGTH = 8192;

// node_modules/@opentelemetry/core/build/esm/baggage/utils.js
init_esm();
var __read6 = function(o4, n9) {
  var m2 = typeof Symbol === "function" && o4[Symbol.iterator];
  if (!m2)
    return o4;
  var i4 = m2.call(o4), r7, ar = [], e7;
  try {
    while ((n9 === void 0 || n9-- > 0) && !(r7 = i4.next()).done)
      ar.push(r7.value);
  } catch (error) {
    e7 = { error };
  } finally {
    try {
      if (r7 && !r7.done && (m2 = i4["return"]))
        m2.call(i4);
    } finally {
      if (e7)
        throw e7.error;
    }
  }
  return ar;
};
function serializeKeyPairs(keyPairs) {
  return keyPairs.reduce(function(hValue, current) {
    var value = "" + hValue + (hValue !== "" ? BAGGAGE_ITEMS_SEPARATOR : "") + current;
    return value.length > BAGGAGE_MAX_TOTAL_LENGTH ? hValue : value;
  }, "");
}
function getKeyPairs(baggage) {
  return baggage.getAllEntries().map(function(_a3) {
    var _b = __read6(_a3, 2), key = _b[0], value = _b[1];
    var entry = encodeURIComponent(key) + "=" + encodeURIComponent(value.value);
    if (value.metadata !== void 0) {
      entry += BAGGAGE_PROPERTIES_SEPARATOR + value.metadata.toString();
    }
    return entry;
  });
}
function parsePairKeyValue(entry) {
  var valueProps = entry.split(BAGGAGE_PROPERTIES_SEPARATOR);
  if (valueProps.length <= 0)
    return;
  var keyPairPart = valueProps.shift();
  if (!keyPairPart)
    return;
  var separatorIndex = keyPairPart.indexOf(BAGGAGE_KEY_PAIR_SEPARATOR);
  if (separatorIndex <= 0)
    return;
  var key = decodeURIComponent(keyPairPart.substring(0, separatorIndex).trim());
  var value = decodeURIComponent(keyPairPart.substring(separatorIndex + 1).trim());
  var metadata;
  if (valueProps.length > 0) {
    metadata = baggageEntryMetadataFromString(valueProps.join(BAGGAGE_PROPERTIES_SEPARATOR));
  }
  return { key, value, metadata };
}

// node_modules/@opentelemetry/core/build/esm/baggage/propagation/W3CBaggagePropagator.js
var W3CBaggagePropagator = (
  /** @class */
  function() {
    function W3CBaggagePropagator2() {
    }
    W3CBaggagePropagator2.prototype.inject = function(context2, carrier, setter) {
      var baggage = propagation.getBaggage(context2);
      if (!baggage || isTracingSuppressed(context2))
        return;
      var keyPairs = getKeyPairs(baggage).filter(function(pair) {
        return pair.length <= BAGGAGE_MAX_PER_NAME_VALUE_PAIRS;
      }).slice(0, BAGGAGE_MAX_NAME_VALUE_PAIRS);
      var headerValue = serializeKeyPairs(keyPairs);
      if (headerValue.length > 0) {
        setter.set(carrier, BAGGAGE_HEADER, headerValue);
      }
    };
    W3CBaggagePropagator2.prototype.extract = function(context2, carrier, getter) {
      var headerValue = getter.get(carrier, BAGGAGE_HEADER);
      var baggageString = Array.isArray(headerValue) ? headerValue.join(BAGGAGE_ITEMS_SEPARATOR) : headerValue;
      if (!baggageString)
        return context2;
      var baggage = {};
      if (baggageString.length === 0) {
        return context2;
      }
      var pairs = baggageString.split(BAGGAGE_ITEMS_SEPARATOR);
      pairs.forEach(function(entry) {
        var keyPair = parsePairKeyValue(entry);
        if (keyPair) {
          var baggageEntry = { value: keyPair.value };
          if (keyPair.metadata) {
            baggageEntry.metadata = keyPair.metadata;
          }
          baggage[keyPair.key] = baggageEntry;
        }
      });
      if (Object.entries(baggage).length === 0) {
        return context2;
      }
      return propagation.setBaggage(context2, propagation.createBaggage(baggage));
    };
    W3CBaggagePropagator2.prototype.fields = function() {
      return [BAGGAGE_HEADER];
    };
    return W3CBaggagePropagator2;
  }()
);

// node_modules/@opentelemetry/core/build/esm/common/attributes.js
init_esm();
var __values2 = function(o4) {
  var s10 = typeof Symbol === "function" && Symbol.iterator, m2 = s10 && o4[s10], i4 = 0;
  if (m2)
    return m2.call(o4);
  if (o4 && typeof o4.length === "number")
    return {
      next: function() {
        if (o4 && i4 >= o4.length)
          o4 = void 0;
        return { value: o4 && o4[i4++], done: !o4 };
      }
    };
  throw new TypeError(s10 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read7 = function(o4, n9) {
  var m2 = typeof Symbol === "function" && o4[Symbol.iterator];
  if (!m2)
    return o4;
  var i4 = m2.call(o4), r7, ar = [], e7;
  try {
    while ((n9 === void 0 || n9-- > 0) && !(r7 = i4.next()).done)
      ar.push(r7.value);
  } catch (error) {
    e7 = { error };
  } finally {
    try {
      if (r7 && !r7.done && (m2 = i4["return"]))
        m2.call(i4);
    } finally {
      if (e7)
        throw e7.error;
    }
  }
  return ar;
};
function sanitizeAttributes(attributes) {
  var e_1, _a3;
  var out = {};
  if (typeof attributes !== "object" || attributes == null) {
    return out;
  }
  try {
    for (var _b = __values2(Object.entries(attributes)), _c = _b.next(); !_c.done; _c = _b.next()) {
      var _d = __read7(_c.value, 2), key = _d[0], val = _d[1];
      if (!isAttributeKey(key)) {
        diag2.warn("Invalid attribute key: " + key);
        continue;
      }
      if (!isAttributeValue(val)) {
        diag2.warn("Invalid attribute value set for key: " + key);
        continue;
      }
      if (Array.isArray(val)) {
        out[key] = val.slice();
      } else {
        out[key] = val;
      }
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (_c && !_c.done && (_a3 = _b.return))
        _a3.call(_b);
    } finally {
      if (e_1)
        throw e_1.error;
    }
  }
  return out;
}
function isAttributeKey(key) {
  return typeof key === "string" && key.length > 0;
}
function isAttributeValue(val) {
  if (val == null) {
    return true;
  }
  if (Array.isArray(val)) {
    return isHomogeneousAttributeValueArray(val);
  }
  return isValidPrimitiveAttributeValue(val);
}
function isHomogeneousAttributeValueArray(arr) {
  var e_2, _a3;
  var type;
  try {
    for (var arr_1 = __values2(arr), arr_1_1 = arr_1.next(); !arr_1_1.done; arr_1_1 = arr_1.next()) {
      var element = arr_1_1.value;
      if (element == null)
        continue;
      if (!type) {
        if (isValidPrimitiveAttributeValue(element)) {
          type = typeof element;
          continue;
        }
        return false;
      }
      if (typeof element === type) {
        continue;
      }
      return false;
    }
  } catch (e_2_1) {
    e_2 = { error: e_2_1 };
  } finally {
    try {
      if (arr_1_1 && !arr_1_1.done && (_a3 = arr_1.return))
        _a3.call(arr_1);
    } finally {
      if (e_2)
        throw e_2.error;
    }
  }
  return true;
}
function isValidPrimitiveAttributeValue(val) {
  switch (typeof val) {
    case "number":
    case "boolean":
    case "string":
      return true;
  }
  return false;
}

// node_modules/@opentelemetry/core/build/esm/common/logging-error-handler.js
init_esm();
function loggingErrorHandler() {
  return function(ex) {
    diag2.error(stringifyException(ex));
  };
}
function stringifyException(ex) {
  if (typeof ex === "string") {
    return ex;
  } else {
    return JSON.stringify(flattenException(ex));
  }
}
function flattenException(ex) {
  var result = {};
  var current = ex;
  while (current !== null) {
    Object.getOwnPropertyNames(current).forEach(function(propertyName) {
      if (result[propertyName])
        return;
      var value = current[propertyName];
      if (value) {
        result[propertyName] = String(value);
      }
    });
    current = Object.getPrototypeOf(current);
  }
  return result;
}

// node_modules/@opentelemetry/core/build/esm/common/global-error-handler.js
var delegateHandler = loggingErrorHandler();
function globalErrorHandler(ex) {
  try {
    delegateHandler(ex);
  } catch (_a3) {
  }
}

// node_modules/@opentelemetry/core/build/esm/utils/environment.js
init_esm();

// node_modules/@opentelemetry/core/build/esm/utils/sampling.js
var TracesSamplerValues;
(function(TracesSamplerValues4) {
  TracesSamplerValues4["AlwaysOff"] = "always_off";
  TracesSamplerValues4["AlwaysOn"] = "always_on";
  TracesSamplerValues4["ParentBasedAlwaysOff"] = "parentbased_always_off";
  TracesSamplerValues4["ParentBasedAlwaysOn"] = "parentbased_always_on";
  TracesSamplerValues4["ParentBasedTraceIdRatio"] = "parentbased_traceidratio";
  TracesSamplerValues4["TraceIdRatio"] = "traceidratio";
})(TracesSamplerValues || (TracesSamplerValues = {}));

// node_modules/@opentelemetry/core/build/esm/utils/environment.js
var DEFAULT_LIST_SEPARATOR = ",";
var ENVIRONMENT_BOOLEAN_KEYS = ["OTEL_SDK_DISABLED"];
function isEnvVarABoolean(key) {
  return ENVIRONMENT_BOOLEAN_KEYS.indexOf(key) > -1;
}
var ENVIRONMENT_NUMBERS_KEYS = [
  "OTEL_BSP_EXPORT_TIMEOUT",
  "OTEL_BSP_MAX_EXPORT_BATCH_SIZE",
  "OTEL_BSP_MAX_QUEUE_SIZE",
  "OTEL_BSP_SCHEDULE_DELAY",
  "OTEL_BLRP_EXPORT_TIMEOUT",
  "OTEL_BLRP_MAX_EXPORT_BATCH_SIZE",
  "OTEL_BLRP_MAX_QUEUE_SIZE",
  "OTEL_BLRP_SCHEDULE_DELAY",
  "OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT",
  "OTEL_ATTRIBUTE_COUNT_LIMIT",
  "OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT",
  "OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT",
  "OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT",
  "OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT",
  "OTEL_SPAN_EVENT_COUNT_LIMIT",
  "OTEL_SPAN_LINK_COUNT_LIMIT",
  "OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT",
  "OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT",
  "OTEL_EXPORTER_OTLP_TIMEOUT",
  "OTEL_EXPORTER_OTLP_TRACES_TIMEOUT",
  "OTEL_EXPORTER_OTLP_METRICS_TIMEOUT",
  "OTEL_EXPORTER_OTLP_LOGS_TIMEOUT",
  "OTEL_EXPORTER_JAEGER_AGENT_PORT"
];
function isEnvVarANumber(key) {
  return ENVIRONMENT_NUMBERS_KEYS.indexOf(key) > -1;
}
var ENVIRONMENT_LISTS_KEYS = [
  "OTEL_NO_PATCH_MODULES",
  "OTEL_PROPAGATORS",
  "OTEL_SEMCONV_STABILITY_OPT_IN"
];
function isEnvVarAList(key) {
  return ENVIRONMENT_LISTS_KEYS.indexOf(key) > -1;
}
var DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT = Infinity;
var DEFAULT_ATTRIBUTE_COUNT_LIMIT = 128;
var DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT = 128;
var DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT = 128;
var DEFAULT_ENVIRONMENT = {
  OTEL_SDK_DISABLED: false,
  CONTAINER_NAME: "",
  ECS_CONTAINER_METADATA_URI_V4: "",
  ECS_CONTAINER_METADATA_URI: "",
  HOSTNAME: "",
  KUBERNETES_SERVICE_HOST: "",
  NAMESPACE: "",
  OTEL_BSP_EXPORT_TIMEOUT: 3e4,
  OTEL_BSP_MAX_EXPORT_BATCH_SIZE: 512,
  OTEL_BSP_MAX_QUEUE_SIZE: 2048,
  OTEL_BSP_SCHEDULE_DELAY: 5e3,
  OTEL_BLRP_EXPORT_TIMEOUT: 3e4,
  OTEL_BLRP_MAX_EXPORT_BATCH_SIZE: 512,
  OTEL_BLRP_MAX_QUEUE_SIZE: 2048,
  OTEL_BLRP_SCHEDULE_DELAY: 5e3,
  OTEL_EXPORTER_JAEGER_AGENT_HOST: "",
  OTEL_EXPORTER_JAEGER_AGENT_PORT: 6832,
  OTEL_EXPORTER_JAEGER_ENDPOINT: "",
  OTEL_EXPORTER_JAEGER_PASSWORD: "",
  OTEL_EXPORTER_JAEGER_USER: "",
  OTEL_EXPORTER_OTLP_ENDPOINT: "",
  OTEL_EXPORTER_OTLP_TRACES_ENDPOINT: "",
  OTEL_EXPORTER_OTLP_METRICS_ENDPOINT: "",
  OTEL_EXPORTER_OTLP_LOGS_ENDPOINT: "",
  OTEL_EXPORTER_OTLP_HEADERS: "",
  OTEL_EXPORTER_OTLP_TRACES_HEADERS: "",
  OTEL_EXPORTER_OTLP_METRICS_HEADERS: "",
  OTEL_EXPORTER_OTLP_LOGS_HEADERS: "",
  OTEL_EXPORTER_OTLP_TIMEOUT: 1e4,
  OTEL_EXPORTER_OTLP_TRACES_TIMEOUT: 1e4,
  OTEL_EXPORTER_OTLP_METRICS_TIMEOUT: 1e4,
  OTEL_EXPORTER_OTLP_LOGS_TIMEOUT: 1e4,
  OTEL_EXPORTER_ZIPKIN_ENDPOINT: "http://localhost:9411/api/v2/spans",
  OTEL_LOG_LEVEL: DiagLogLevel.INFO,
  OTEL_NO_PATCH_MODULES: [],
  OTEL_PROPAGATORS: ["tracecontext", "baggage"],
  OTEL_RESOURCE_ATTRIBUTES: "",
  OTEL_SERVICE_NAME: "",
  OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT: DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
  OTEL_ATTRIBUTE_COUNT_LIMIT: DEFAULT_ATTRIBUTE_COUNT_LIMIT,
  OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT: DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
  OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT: DEFAULT_ATTRIBUTE_COUNT_LIMIT,
  OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT: DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
  OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT: DEFAULT_ATTRIBUTE_COUNT_LIMIT,
  OTEL_SPAN_EVENT_COUNT_LIMIT: 128,
  OTEL_SPAN_LINK_COUNT_LIMIT: 128,
  OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT: DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT,
  OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT: DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT,
  OTEL_TRACES_EXPORTER: "",
  OTEL_TRACES_SAMPLER: TracesSamplerValues.ParentBasedAlwaysOn,
  OTEL_TRACES_SAMPLER_ARG: "",
  OTEL_LOGS_EXPORTER: "",
  OTEL_EXPORTER_OTLP_INSECURE: "",
  OTEL_EXPORTER_OTLP_TRACES_INSECURE: "",
  OTEL_EXPORTER_OTLP_METRICS_INSECURE: "",
  OTEL_EXPORTER_OTLP_LOGS_INSECURE: "",
  OTEL_EXPORTER_OTLP_CERTIFICATE: "",
  OTEL_EXPORTER_OTLP_TRACES_CERTIFICATE: "",
  OTEL_EXPORTER_OTLP_METRICS_CERTIFICATE: "",
  OTEL_EXPORTER_OTLP_LOGS_CERTIFICATE: "",
  OTEL_EXPORTER_OTLP_COMPRESSION: "",
  OTEL_EXPORTER_OTLP_TRACES_COMPRESSION: "",
  OTEL_EXPORTER_OTLP_METRICS_COMPRESSION: "",
  OTEL_EXPORTER_OTLP_LOGS_COMPRESSION: "",
  OTEL_EXPORTER_OTLP_CLIENT_KEY: "",
  OTEL_EXPORTER_OTLP_TRACES_CLIENT_KEY: "",
  OTEL_EXPORTER_OTLP_METRICS_CLIENT_KEY: "",
  OTEL_EXPORTER_OTLP_LOGS_CLIENT_KEY: "",
  OTEL_EXPORTER_OTLP_CLIENT_CERTIFICATE: "",
  OTEL_EXPORTER_OTLP_TRACES_CLIENT_CERTIFICATE: "",
  OTEL_EXPORTER_OTLP_METRICS_CLIENT_CERTIFICATE: "",
  OTEL_EXPORTER_OTLP_LOGS_CLIENT_CERTIFICATE: "",
  OTEL_EXPORTER_OTLP_PROTOCOL: "http/protobuf",
  OTEL_EXPORTER_OTLP_TRACES_PROTOCOL: "http/protobuf",
  OTEL_EXPORTER_OTLP_METRICS_PROTOCOL: "http/protobuf",
  OTEL_EXPORTER_OTLP_LOGS_PROTOCOL: "http/protobuf",
  OTEL_EXPORTER_OTLP_METRICS_TEMPORALITY_PREFERENCE: "cumulative",
  OTEL_SEMCONV_STABILITY_OPT_IN: []
};
function parseBoolean(key, environment, values) {
  if (typeof values[key] === "undefined") {
    return;
  }
  var value = String(values[key]);
  environment[key] = value.toLowerCase() === "true";
}
function parseNumber(name, environment, values, min, max) {
  if (min === void 0) {
    min = -Infinity;
  }
  if (max === void 0) {
    max = Infinity;
  }
  if (typeof values[name] !== "undefined") {
    var value = Number(values[name]);
    if (!isNaN(value)) {
      if (value < min) {
        environment[name] = min;
      } else if (value > max) {
        environment[name] = max;
      } else {
        environment[name] = value;
      }
    }
  }
}
function parseStringList(name, output, input, separator) {
  if (separator === void 0) {
    separator = DEFAULT_LIST_SEPARATOR;
  }
  var givenValue = input[name];
  if (typeof givenValue === "string") {
    output[name] = givenValue.split(separator).map(function(v4) {
      return v4.trim();
    });
  }
}
var logLevelMap = {
  ALL: DiagLogLevel.ALL,
  VERBOSE: DiagLogLevel.VERBOSE,
  DEBUG: DiagLogLevel.DEBUG,
  INFO: DiagLogLevel.INFO,
  WARN: DiagLogLevel.WARN,
  ERROR: DiagLogLevel.ERROR,
  NONE: DiagLogLevel.NONE
};
function setLogLevelFromEnv(key, environment, values) {
  var value = values[key];
  if (typeof value === "string") {
    var theLevel = logLevelMap[value.toUpperCase()];
    if (theLevel != null) {
      environment[key] = theLevel;
    }
  }
}
function parseEnvironment(values) {
  var environment = {};
  for (var env2 in DEFAULT_ENVIRONMENT) {
    var key = env2;
    switch (key) {
      case "OTEL_LOG_LEVEL":
        setLogLevelFromEnv(key, environment, values);
        break;
      default:
        if (isEnvVarABoolean(key)) {
          parseBoolean(key, environment, values);
        } else if (isEnvVarANumber(key)) {
          parseNumber(key, environment, values);
        } else if (isEnvVarAList(key)) {
          parseStringList(key, environment, values);
        } else {
          var value = values[key];
          if (typeof value !== "undefined" && value !== null) {
            environment[key] = String(value);
          }
        }
    }
  }
  return environment;
}

// node_modules/@opentelemetry/core/build/esm/platform/node/environment.js
function getEnv() {
  var processEnv = parseEnvironment(process.env);
  return Object.assign({}, DEFAULT_ENVIRONMENT, processEnv);
}
function getEnvWithoutDefaults() {
  return parseEnvironment(process.env);
}

// node_modules/@opentelemetry/core/build/esm/platform/node/performance.js
import { performance as performance2 } from "perf_hooks";
var otperformance = performance2;

// node_modules/@opentelemetry/core/build/esm/version.js
var VERSION2 = "1.29.0";

// node_modules/@opentelemetry/semantic-conventions/build/esm/trace/SemanticAttributes.js
var TMP_EXCEPTION_TYPE = "exception.type";
var TMP_EXCEPTION_MESSAGE = "exception.message";
var TMP_EXCEPTION_STACKTRACE = "exception.stacktrace";
var TMP_HTTP_URL = "http.url";
var TMP_HTTP_USER_AGENT = "http.user_agent";
var TMP_HTTP_RESPONSE_CONTENT_LENGTH = "http.response_content_length";
var TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED = "http.response_content_length_uncompressed";
var SEMATTRS_EXCEPTION_TYPE = TMP_EXCEPTION_TYPE;
var SEMATTRS_EXCEPTION_MESSAGE = TMP_EXCEPTION_MESSAGE;
var SEMATTRS_EXCEPTION_STACKTRACE = TMP_EXCEPTION_STACKTRACE;
var SEMATTRS_HTTP_URL = TMP_HTTP_URL;
var SEMATTRS_HTTP_USER_AGENT = TMP_HTTP_USER_AGENT;
var SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH = TMP_HTTP_RESPONSE_CONTENT_LENGTH;
var SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED = TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED;

// node_modules/@opentelemetry/semantic-conventions/build/esm/resource/SemanticResourceAttributes.js
var TMP_PROCESS_RUNTIME_NAME = "process.runtime.name";
var TMP_SERVICE_NAME = "service.name";
var TMP_TELEMETRY_SDK_NAME = "telemetry.sdk.name";
var TMP_TELEMETRY_SDK_LANGUAGE = "telemetry.sdk.language";
var TMP_TELEMETRY_SDK_VERSION = "telemetry.sdk.version";
var SEMRESATTRS_PROCESS_RUNTIME_NAME = TMP_PROCESS_RUNTIME_NAME;
var SEMRESATTRS_SERVICE_NAME = TMP_SERVICE_NAME;
var SEMRESATTRS_TELEMETRY_SDK_NAME = TMP_TELEMETRY_SDK_NAME;
var SEMRESATTRS_TELEMETRY_SDK_LANGUAGE = TMP_TELEMETRY_SDK_LANGUAGE;
var SEMRESATTRS_TELEMETRY_SDK_VERSION = TMP_TELEMETRY_SDK_VERSION;
var TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS = "nodejs";
var TELEMETRYSDKLANGUAGEVALUES_NODEJS = TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS;

// node_modules/@opentelemetry/semantic-conventions/build/esm/stable_attributes.js
var ATTR_SERVICE_NAME = "service.name";
var ATTR_SERVICE_VERSION = "service.version";

// node_modules/@opentelemetry/core/build/esm/platform/node/sdk-info.js
var _a;
var SDK_INFO = (_a = {}, _a[SEMRESATTRS_TELEMETRY_SDK_NAME] = "opentelemetry", _a[SEMRESATTRS_PROCESS_RUNTIME_NAME] = "node", _a[SEMRESATTRS_TELEMETRY_SDK_LANGUAGE] = TELEMETRYSDKLANGUAGEVALUES_NODEJS, _a[SEMRESATTRS_TELEMETRY_SDK_VERSION] = VERSION2, _a);

// node_modules/@opentelemetry/core/build/esm/platform/node/timer-util.js
function unrefTimer(timer) {
  timer.unref();
}

// node_modules/@opentelemetry/core/build/esm/common/time.js
var NANOSECOND_DIGITS = 9;
var NANOSECOND_DIGITS_IN_MILLIS = 6;
var MILLISECONDS_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS_IN_MILLIS);
var SECOND_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS);
function millisToHrTime(epochMillis) {
  var epochSeconds = epochMillis / 1e3;
  var seconds = Math.trunc(epochSeconds);
  var nanos = Math.round(epochMillis % 1e3 * MILLISECONDS_TO_NANOSECONDS);
  return [seconds, nanos];
}
function getTimeOrigin() {
  var timeOrigin = otperformance.timeOrigin;
  if (typeof timeOrigin !== "number") {
    var perf = otperformance;
    timeOrigin = perf.timing && perf.timing.fetchStart;
  }
  return timeOrigin;
}
function hrTime(performanceNow) {
  var timeOrigin = millisToHrTime(getTimeOrigin());
  var now = millisToHrTime(typeof performanceNow === "number" ? performanceNow : otperformance.now());
  return addHrTimes(timeOrigin, now);
}
function hrTimeDuration(startTime, endTime) {
  var seconds = endTime[0] - startTime[0];
  var nanos = endTime[1] - startTime[1];
  if (nanos < 0) {
    seconds -= 1;
    nanos += SECOND_TO_NANOSECONDS;
  }
  return [seconds, nanos];
}
function isTimeInputHrTime(value) {
  return Array.isArray(value) && value.length === 2 && typeof value[0] === "number" && typeof value[1] === "number";
}
function isTimeInput(value) {
  return isTimeInputHrTime(value) || typeof value === "number" || value instanceof Date;
}
function addHrTimes(time1, time2) {
  var out = [time1[0] + time2[0], time1[1] + time2[1]];
  if (out[1] >= SECOND_TO_NANOSECONDS) {
    out[1] -= SECOND_TO_NANOSECONDS;
    out[0] += 1;
  }
  return out;
}

// node_modules/@opentelemetry/core/build/esm/ExportResult.js
var ExportResultCode;
(function(ExportResultCode3) {
  ExportResultCode3[ExportResultCode3["SUCCESS"] = 0] = "SUCCESS";
  ExportResultCode3[ExportResultCode3["FAILED"] = 1] = "FAILED";
})(ExportResultCode || (ExportResultCode = {}));

// node_modules/@opentelemetry/core/build/esm/propagation/composite.js
init_esm();
var __values3 = function(o4) {
  var s10 = typeof Symbol === "function" && Symbol.iterator, m2 = s10 && o4[s10], i4 = 0;
  if (m2)
    return m2.call(o4);
  if (o4 && typeof o4.length === "number")
    return {
      next: function() {
        if (o4 && i4 >= o4.length)
          o4 = void 0;
        return { value: o4 && o4[i4++], done: !o4 };
      }
    };
  throw new TypeError(s10 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var CompositePropagator = (
  /** @class */
  function() {
    function CompositePropagator2(config) {
      if (config === void 0) {
        config = {};
      }
      var _a3;
      this._propagators = (_a3 = config.propagators) !== null && _a3 !== void 0 ? _a3 : [];
      this._fields = Array.from(new Set(this._propagators.map(function(p9) {
        return typeof p9.fields === "function" ? p9.fields() : [];
      }).reduce(function(x7, y4) {
        return x7.concat(y4);
      }, [])));
    }
    CompositePropagator2.prototype.inject = function(context2, carrier, setter) {
      var e_1, _a3;
      try {
        for (var _b = __values3(this._propagators), _c = _b.next(); !_c.done; _c = _b.next()) {
          var propagator = _c.value;
          try {
            propagator.inject(context2, carrier, setter);
          } catch (err) {
            diag2.warn("Failed to inject with " + propagator.constructor.name + ". Err: " + err.message);
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a3 = _b.return))
            _a3.call(_b);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
    };
    CompositePropagator2.prototype.extract = function(context2, carrier, getter) {
      return this._propagators.reduce(function(ctx, propagator) {
        try {
          return propagator.extract(ctx, carrier, getter);
        } catch (err) {
          diag2.warn("Failed to extract with " + propagator.constructor.name + ". Err: " + err.message);
        }
        return ctx;
      }, context2);
    };
    CompositePropagator2.prototype.fields = function() {
      return this._fields.slice();
    };
    return CompositePropagator2;
  }()
);

// node_modules/@opentelemetry/core/build/esm/trace/W3CTraceContextPropagator.js
init_esm();

// node_modules/@opentelemetry/core/build/esm/internal/validators.js
var VALID_KEY_CHAR_RANGE = "[_0-9a-z-*/]";
var VALID_KEY = "[a-z]" + VALID_KEY_CHAR_RANGE + "{0,255}";
var VALID_VENDOR_KEY = "[a-z0-9]" + VALID_KEY_CHAR_RANGE + "{0,240}@[a-z]" + VALID_KEY_CHAR_RANGE + "{0,13}";
var VALID_KEY_REGEX = new RegExp("^(?:" + VALID_KEY + "|" + VALID_VENDOR_KEY + ")$");
var VALID_VALUE_BASE_REGEX = /^[ -~]{0,255}[!-~]$/;
var INVALID_VALUE_COMMA_EQUAL_REGEX = /,|=/;
function validateKey(key) {
  return VALID_KEY_REGEX.test(key);
}
function validateValue(value) {
  return VALID_VALUE_BASE_REGEX.test(value) && !INVALID_VALUE_COMMA_EQUAL_REGEX.test(value);
}

// node_modules/@opentelemetry/core/build/esm/trace/TraceState.js
var MAX_TRACE_STATE_ITEMS = 32;
var MAX_TRACE_STATE_LEN = 512;
var LIST_MEMBERS_SEPARATOR = ",";
var LIST_MEMBER_KEY_VALUE_SPLITTER = "=";
var TraceState = (
  /** @class */
  function() {
    function TraceState2(rawTraceState) {
      this._internalState = /* @__PURE__ */ new Map();
      if (rawTraceState)
        this._parse(rawTraceState);
    }
    TraceState2.prototype.set = function(key, value) {
      var traceState = this._clone();
      if (traceState._internalState.has(key)) {
        traceState._internalState.delete(key);
      }
      traceState._internalState.set(key, value);
      return traceState;
    };
    TraceState2.prototype.unset = function(key) {
      var traceState = this._clone();
      traceState._internalState.delete(key);
      return traceState;
    };
    TraceState2.prototype.get = function(key) {
      return this._internalState.get(key);
    };
    TraceState2.prototype.serialize = function() {
      var _this = this;
      return this._keys().reduce(function(agg, key) {
        agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER + _this.get(key));
        return agg;
      }, []).join(LIST_MEMBERS_SEPARATOR);
    };
    TraceState2.prototype._parse = function(rawTraceState) {
      if (rawTraceState.length > MAX_TRACE_STATE_LEN)
        return;
      this._internalState = rawTraceState.split(LIST_MEMBERS_SEPARATOR).reverse().reduce(function(agg, part) {
        var listMember = part.trim();
        var i4 = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER);
        if (i4 !== -1) {
          var key = listMember.slice(0, i4);
          var value = listMember.slice(i4 + 1, part.length);
          if (validateKey(key) && validateValue(value)) {
            agg.set(key, value);
          } else {
          }
        }
        return agg;
      }, /* @__PURE__ */ new Map());
      if (this._internalState.size > MAX_TRACE_STATE_ITEMS) {
        this._internalState = new Map(Array.from(this._internalState.entries()).reverse().slice(0, MAX_TRACE_STATE_ITEMS));
      }
    };
    TraceState2.prototype._keys = function() {
      return Array.from(this._internalState.keys()).reverse();
    };
    TraceState2.prototype._clone = function() {
      var traceState = new TraceState2();
      traceState._internalState = new Map(this._internalState);
      return traceState;
    };
    return TraceState2;
  }()
);

// node_modules/@opentelemetry/core/build/esm/trace/W3CTraceContextPropagator.js
var TRACE_PARENT_HEADER = "traceparent";
var TRACE_STATE_HEADER = "tracestate";
var VERSION3 = "00";
var VERSION_PART = "(?!ff)[\\da-f]{2}";
var TRACE_ID_PART = "(?![0]{32})[\\da-f]{32}";
var PARENT_ID_PART = "(?![0]{16})[\\da-f]{16}";
var FLAGS_PART = "[\\da-f]{2}";
var TRACE_PARENT_REGEX = new RegExp("^\\s?(" + VERSION_PART + ")-(" + TRACE_ID_PART + ")-(" + PARENT_ID_PART + ")-(" + FLAGS_PART + ")(-.*)?\\s?$");
function parseTraceParent(traceParent) {
  var match = TRACE_PARENT_REGEX.exec(traceParent);
  if (!match)
    return null;
  if (match[1] === "00" && match[5])
    return null;
  return {
    traceId: match[2],
    spanId: match[3],
    traceFlags: parseInt(match[4], 16)
  };
}
var W3CTraceContextPropagator = (
  /** @class */
  function() {
    function W3CTraceContextPropagator2() {
    }
    W3CTraceContextPropagator2.prototype.inject = function(context2, carrier, setter) {
      var spanContext = trace.getSpanContext(context2);
      if (!spanContext || isTracingSuppressed(context2) || !isSpanContextValid(spanContext))
        return;
      var traceParent = VERSION3 + "-" + spanContext.traceId + "-" + spanContext.spanId + "-0" + Number(spanContext.traceFlags || TraceFlags.NONE).toString(16);
      setter.set(carrier, TRACE_PARENT_HEADER, traceParent);
      if (spanContext.traceState) {
        setter.set(carrier, TRACE_STATE_HEADER, spanContext.traceState.serialize());
      }
    };
    W3CTraceContextPropagator2.prototype.extract = function(context2, carrier, getter) {
      var traceParentHeader = getter.get(carrier, TRACE_PARENT_HEADER);
      if (!traceParentHeader)
        return context2;
      var traceParent = Array.isArray(traceParentHeader) ? traceParentHeader[0] : traceParentHeader;
      if (typeof traceParent !== "string")
        return context2;
      var spanContext = parseTraceParent(traceParent);
      if (!spanContext)
        return context2;
      spanContext.isRemote = true;
      var traceStateHeader = getter.get(carrier, TRACE_STATE_HEADER);
      if (traceStateHeader) {
        var state = Array.isArray(traceStateHeader) ? traceStateHeader.join(",") : traceStateHeader;
        spanContext.traceState = new TraceState(typeof state === "string" ? state : void 0);
      }
      return trace.setSpanContext(context2, spanContext);
    };
    W3CTraceContextPropagator2.prototype.fields = function() {
      return [TRACE_PARENT_HEADER, TRACE_STATE_HEADER];
    };
    return W3CTraceContextPropagator2;
  }()
);

// node_modules/@opentelemetry/core/build/esm/utils/lodash.merge.js
var objectTag = "[object Object]";
var nullTag = "[object Null]";
var undefinedTag = "[object Undefined]";
var funcProto = Function.prototype;
var funcToString = funcProto.toString;
var objectCtorString = funcToString.call(Object);
var getPrototype = overArg(Object.getPrototypeOf, Object);
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
var symToStringTag = Symbol ? Symbol.toStringTag : void 0;
var nativeObjectToString = objectProto.toString;
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) !== objectTag) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) === objectCtorString;
}
function isObjectLike(value) {
  return value != null && typeof value == "object";
}
function baseGetTag(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
  var unmasked = false;
  try {
    value[symToStringTag] = void 0;
    unmasked = true;
  } catch (e7) {
  }
  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}
function objectToString(value) {
  return nativeObjectToString.call(value);
}

// node_modules/@opentelemetry/core/build/esm/utils/merge.js
var MAX_LEVEL = 20;
function merge() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var result = args.shift();
  var objects = /* @__PURE__ */ new WeakMap();
  while (args.length > 0) {
    result = mergeTwoObjects(result, args.shift(), 0, objects);
  }
  return result;
}
function takeValue(value) {
  if (isArray(value)) {
    return value.slice();
  }
  return value;
}
function mergeTwoObjects(one, two, level, objects) {
  if (level === void 0) {
    level = 0;
  }
  var result;
  if (level > MAX_LEVEL) {
    return void 0;
  }
  level++;
  if (isPrimitive(one) || isPrimitive(two) || isFunction(two)) {
    result = takeValue(two);
  } else if (isArray(one)) {
    result = one.slice();
    if (isArray(two)) {
      for (var i4 = 0, j = two.length; i4 < j; i4++) {
        result.push(takeValue(two[i4]));
      }
    } else if (isObject(two)) {
      var keys = Object.keys(two);
      for (var i4 = 0, j = keys.length; i4 < j; i4++) {
        var key = keys[i4];
        result[key] = takeValue(two[key]);
      }
    }
  } else if (isObject(one)) {
    if (isObject(two)) {
      if (!shouldMerge(one, two)) {
        return two;
      }
      result = Object.assign({}, one);
      var keys = Object.keys(two);
      for (var i4 = 0, j = keys.length; i4 < j; i4++) {
        var key = keys[i4];
        var twoValue = two[key];
        if (isPrimitive(twoValue)) {
          if (typeof twoValue === "undefined") {
            delete result[key];
          } else {
            result[key] = twoValue;
          }
        } else {
          var obj1 = result[key];
          var obj2 = twoValue;
          if (wasObjectReferenced(one, key, objects) || wasObjectReferenced(two, key, objects)) {
            delete result[key];
          } else {
            if (isObject(obj1) && isObject(obj2)) {
              var arr1 = objects.get(obj1) || [];
              var arr2 = objects.get(obj2) || [];
              arr1.push({ obj: one, key });
              arr2.push({ obj: two, key });
              objects.set(obj1, arr1);
              objects.set(obj2, arr2);
            }
            result[key] = mergeTwoObjects(result[key], twoValue, level, objects);
          }
        }
      }
    } else {
      result = two;
    }
  }
  return result;
}
function wasObjectReferenced(obj, key, objects) {
  var arr = objects.get(obj[key]) || [];
  for (var i4 = 0, j = arr.length; i4 < j; i4++) {
    var info = arr[i4];
    if (info.key === key && info.obj === obj) {
      return true;
    }
  }
  return false;
}
function isArray(value) {
  return Array.isArray(value);
}
function isFunction(value) {
  return typeof value === "function";
}
function isObject(value) {
  return !isPrimitive(value) && !isArray(value) && !isFunction(value) && typeof value === "object";
}
function isPrimitive(value) {
  return typeof value === "string" || typeof value === "number" || typeof value === "boolean" || typeof value === "undefined" || value instanceof Date || value instanceof RegExp || value === null;
}
function shouldMerge(one, two) {
  if (!isPlainObject(one) || !isPlainObject(two)) {
    return false;
  }
  return true;
}

// node_modules/@opentelemetry/core/build/esm/utils/promise.js
var Deferred = (
  /** @class */
  function() {
    function Deferred3() {
      var _this = this;
      this._promise = new Promise(function(resolve, reject) {
        _this._resolve = resolve;
        _this._reject = reject;
      });
    }
    Object.defineProperty(Deferred3.prototype, "promise", {
      get: function() {
        return this._promise;
      },
      enumerable: false,
      configurable: true
    });
    Deferred3.prototype.resolve = function(val) {
      this._resolve(val);
    };
    Deferred3.prototype.reject = function(err) {
      this._reject(err);
    };
    return Deferred3;
  }()
);

// node_modules/@opentelemetry/core/build/esm/utils/callback.js
var __read8 = function(o4, n9) {
  var m2 = typeof Symbol === "function" && o4[Symbol.iterator];
  if (!m2)
    return o4;
  var i4 = m2.call(o4), r7, ar = [], e7;
  try {
    while ((n9 === void 0 || n9-- > 0) && !(r7 = i4.next()).done)
      ar.push(r7.value);
  } catch (error) {
    e7 = { error };
  } finally {
    try {
      if (r7 && !r7.done && (m2 = i4["return"]))
        m2.call(i4);
    } finally {
      if (e7)
        throw e7.error;
    }
  }
  return ar;
};
var __spreadArray5 = function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i4 = 0, l5 = from.length, ar; i4 < l5; i4++) {
      if (ar || !(i4 in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i4);
        ar[i4] = from[i4];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var BindOnceFuture = (
  /** @class */
  function() {
    function BindOnceFuture3(_callback, _that) {
      this._callback = _callback;
      this._that = _that;
      this._isCalled = false;
      this._deferred = new Deferred();
    }
    Object.defineProperty(BindOnceFuture3.prototype, "isCalled", {
      get: function() {
        return this._isCalled;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BindOnceFuture3.prototype, "promise", {
      get: function() {
        return this._deferred.promise;
      },
      enumerable: false,
      configurable: true
    });
    BindOnceFuture3.prototype.call = function() {
      var _a3;
      var _this = this;
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      if (!this._isCalled) {
        this._isCalled = true;
        try {
          Promise.resolve((_a3 = this._callback).call.apply(_a3, __spreadArray5([this._that], __read8(args), false))).then(function(val) {
            return _this._deferred.resolve(val);
          }, function(err) {
            return _this._deferred.reject(err);
          });
        } catch (err) {
          this._deferred.reject(err);
        }
      }
      return this._deferred.promise;
    };
    return BindOnceFuture3;
  }()
);

// node_modules/@opentelemetry/resources/build/esm/Resource.js
init_esm();

// node_modules/@opentelemetry/resources/build/esm/platform/node/default-service-name.js
function defaultServiceName() {
  return "unknown_service:" + process.argv0;
}

// node_modules/@opentelemetry/resources/build/esm/Resource.js
var __assign = function() {
  __assign = Object.assign || function(t5) {
    for (var s10, i4 = 1, n9 = arguments.length; i4 < n9; i4++) {
      s10 = arguments[i4];
      for (var p9 in s10)
        if (Object.prototype.hasOwnProperty.call(s10, p9))
          t5[p9] = s10[p9];
    }
    return t5;
  };
  return __assign.apply(this, arguments);
};
var __awaiter = function(thisArg, _arguments, P6, generator) {
  function adopt(value) {
    return value instanceof P6 ? value : new P6(function(resolve) {
      resolve(value);
    });
  }
  return new (P6 || (P6 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e7) {
        reject(e7);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e7) {
        reject(e7);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator = function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t5[0] & 1)
      throw t5[1];
    return t5[1];
  }, trys: [], ops: [] }, f7, y4, t5, g6;
  return g6 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g6[Symbol.iterator] = function() {
    return this;
  }), g6;
  function verb(n9) {
    return function(v4) {
      return step([n9, v4]);
    };
  }
  function step(op) {
    if (f7)
      throw new TypeError("Generator is already executing.");
    while (_2)
      try {
        if (f7 = 1, y4 && (t5 = op[0] & 2 ? y4["return"] : op[0] ? y4["throw"] || ((t5 = y4["return"]) && t5.call(y4), 0) : y4.next) && !(t5 = t5.call(y4, op[1])).done)
          return t5;
        if (y4 = 0, t5)
          op = [op[0] & 2, t5.value];
        switch (op[0]) {
          case 0:
          case 1:
            t5 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y4 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t5 = _2.trys, t5 = t5.length > 0 && t5[t5.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t5 || op[1] > t5[0] && op[1] < t5[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t5[1]) {
              _2.label = t5[1];
              t5 = op;
              break;
            }
            if (t5 && _2.label < t5[2]) {
              _2.label = t5[2];
              _2.ops.push(op);
              break;
            }
            if (t5[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e7) {
        op = [6, e7];
        y4 = 0;
      } finally {
        f7 = t5 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var __read9 = function(o4, n9) {
  var m2 = typeof Symbol === "function" && o4[Symbol.iterator];
  if (!m2)
    return o4;
  var i4 = m2.call(o4), r7, ar = [], e7;
  try {
    while ((n9 === void 0 || n9-- > 0) && !(r7 = i4.next()).done)
      ar.push(r7.value);
  } catch (error) {
    e7 = { error };
  } finally {
    try {
      if (r7 && !r7.done && (m2 = i4["return"]))
        m2.call(i4);
    } finally {
      if (e7)
        throw e7.error;
    }
  }
  return ar;
};
var Resource = (
  /** @class */
  function() {
    function Resource2(attributes, asyncAttributesPromise) {
      var _this = this;
      var _a3;
      this._attributes = attributes;
      this.asyncAttributesPending = asyncAttributesPromise != null;
      this._syncAttributes = (_a3 = this._attributes) !== null && _a3 !== void 0 ? _a3 : {};
      this._asyncAttributesPromise = asyncAttributesPromise === null || asyncAttributesPromise === void 0 ? void 0 : asyncAttributesPromise.then(function(asyncAttributes) {
        _this._attributes = Object.assign({}, _this._attributes, asyncAttributes);
        _this.asyncAttributesPending = false;
        return asyncAttributes;
      }, function(err) {
        diag2.debug("a resource's async attributes promise rejected: %s", err);
        _this.asyncAttributesPending = false;
        return {};
      });
    }
    Resource2.empty = function() {
      return Resource2.EMPTY;
    };
    Resource2.default = function() {
      var _a3;
      return new Resource2((_a3 = {}, _a3[SEMRESATTRS_SERVICE_NAME] = defaultServiceName(), _a3[SEMRESATTRS_TELEMETRY_SDK_LANGUAGE] = SDK_INFO[SEMRESATTRS_TELEMETRY_SDK_LANGUAGE], _a3[SEMRESATTRS_TELEMETRY_SDK_NAME] = SDK_INFO[SEMRESATTRS_TELEMETRY_SDK_NAME], _a3[SEMRESATTRS_TELEMETRY_SDK_VERSION] = SDK_INFO[SEMRESATTRS_TELEMETRY_SDK_VERSION], _a3));
    };
    Object.defineProperty(Resource2.prototype, "attributes", {
      get: function() {
        var _a3;
        if (this.asyncAttributesPending) {
          diag2.error("Accessing resource attributes before async attributes settled");
        }
        return (_a3 = this._attributes) !== null && _a3 !== void 0 ? _a3 : {};
      },
      enumerable: false,
      configurable: true
    });
    Resource2.prototype.waitForAsyncAttributes = function() {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a3) {
          switch (_a3.label) {
            case 0:
              if (!this.asyncAttributesPending)
                return [3, 2];
              return [4, this._asyncAttributesPromise];
            case 1:
              _a3.sent();
              _a3.label = 2;
            case 2:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    Resource2.prototype.merge = function(other) {
      var _this = this;
      var _a3;
      if (!other)
        return this;
      var mergedSyncAttributes = __assign(__assign({}, this._syncAttributes), (_a3 = other._syncAttributes) !== null && _a3 !== void 0 ? _a3 : other.attributes);
      if (!this._asyncAttributesPromise && !other._asyncAttributesPromise) {
        return new Resource2(mergedSyncAttributes);
      }
      var mergedAttributesPromise = Promise.all([
        this._asyncAttributesPromise,
        other._asyncAttributesPromise
      ]).then(function(_a4) {
        var _b;
        var _c = __read9(_a4, 2), thisAsyncAttributes = _c[0], otherAsyncAttributes = _c[1];
        return __assign(__assign(__assign(__assign({}, _this._syncAttributes), thisAsyncAttributes), (_b = other._syncAttributes) !== null && _b !== void 0 ? _b : other.attributes), otherAsyncAttributes);
      });
      return new Resource2(mergedSyncAttributes, mergedAttributesPromise);
    };
    Resource2.EMPTY = new Resource2({});
    return Resource2;
  }()
);

// node_modules/@opentelemetry/sdk-trace-web/node_modules/@opentelemetry/sdk-trace-base/build/esm/Tracer.js
init_esm();

// node_modules/@opentelemetry/sdk-trace-web/node_modules/@opentelemetry/sdk-trace-base/build/esm/Span.js
init_esm();

// node_modules/@opentelemetry/sdk-trace-web/node_modules/@opentelemetry/sdk-trace-base/build/esm/enums.js
var ExceptionEventName = "exception";

// node_modules/@opentelemetry/sdk-trace-web/node_modules/@opentelemetry/sdk-trace-base/build/esm/Span.js
var __assign2 = function() {
  __assign2 = Object.assign || function(t5) {
    for (var s10, i4 = 1, n9 = arguments.length; i4 < n9; i4++) {
      s10 = arguments[i4];
      for (var p9 in s10)
        if (Object.prototype.hasOwnProperty.call(s10, p9))
          t5[p9] = s10[p9];
    }
    return t5;
  };
  return __assign2.apply(this, arguments);
};
var __values4 = function(o4) {
  var s10 = typeof Symbol === "function" && Symbol.iterator, m2 = s10 && o4[s10], i4 = 0;
  if (m2)
    return m2.call(o4);
  if (o4 && typeof o4.length === "number")
    return {
      next: function() {
        if (o4 && i4 >= o4.length)
          o4 = void 0;
        return { value: o4 && o4[i4++], done: !o4 };
      }
    };
  throw new TypeError(s10 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read10 = function(o4, n9) {
  var m2 = typeof Symbol === "function" && o4[Symbol.iterator];
  if (!m2)
    return o4;
  var i4 = m2.call(o4), r7, ar = [], e7;
  try {
    while ((n9 === void 0 || n9-- > 0) && !(r7 = i4.next()).done)
      ar.push(r7.value);
  } catch (error) {
    e7 = { error };
  } finally {
    try {
      if (r7 && !r7.done && (m2 = i4["return"]))
        m2.call(i4);
    } finally {
      if (e7)
        throw e7.error;
    }
  }
  return ar;
};
var __spreadArray6 = function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i4 = 0, l5 = from.length, ar; i4 < l5; i4++) {
      if (ar || !(i4 in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i4);
        ar[i4] = from[i4];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var Span = (
  /** @class */
  function() {
    function Span2(parentTracer, context2, spanName, spanContext, kind, parentSpanId, links, startTime, _deprecatedClock, attributes) {
      if (links === void 0) {
        links = [];
      }
      this.attributes = {};
      this.links = [];
      this.events = [];
      this._droppedAttributesCount = 0;
      this._droppedEventsCount = 0;
      this._droppedLinksCount = 0;
      this.status = {
        code: SpanStatusCode.UNSET
      };
      this.endTime = [0, 0];
      this._ended = false;
      this._duration = [-1, -1];
      this.name = spanName;
      this._spanContext = spanContext;
      this.parentSpanId = parentSpanId;
      this.kind = kind;
      this.links = links;
      var now = Date.now();
      this._performanceStartTime = otperformance.now();
      this._performanceOffset = now - (this._performanceStartTime + getTimeOrigin());
      this._startTimeProvided = startTime != null;
      this.startTime = this._getTime(startTime !== null && startTime !== void 0 ? startTime : now);
      this.resource = parentTracer.resource;
      this.instrumentationLibrary = parentTracer.instrumentationLibrary;
      this._spanLimits = parentTracer.getSpanLimits();
      this._attributeValueLengthLimit = this._spanLimits.attributeValueLengthLimit || 0;
      if (attributes != null) {
        this.setAttributes(attributes);
      }
      this._spanProcessor = parentTracer.getActiveSpanProcessor();
      this._spanProcessor.onStart(this, context2);
    }
    Span2.prototype.spanContext = function() {
      return this._spanContext;
    };
    Span2.prototype.setAttribute = function(key, value) {
      if (value == null || this._isSpanEnded())
        return this;
      if (key.length === 0) {
        diag2.warn("Invalid attribute key: " + key);
        return this;
      }
      if (!isAttributeValue(value)) {
        diag2.warn("Invalid attribute value set for key: " + key);
        return this;
      }
      if (Object.keys(this.attributes).length >= this._spanLimits.attributeCountLimit && !Object.prototype.hasOwnProperty.call(this.attributes, key)) {
        this._droppedAttributesCount++;
        return this;
      }
      this.attributes[key] = this._truncateToSize(value);
      return this;
    };
    Span2.prototype.setAttributes = function(attributes) {
      var e_1, _a3;
      try {
        for (var _b = __values4(Object.entries(attributes)), _c = _b.next(); !_c.done; _c = _b.next()) {
          var _d = __read10(_c.value, 2), k3 = _d[0], v4 = _d[1];
          this.setAttribute(k3, v4);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a3 = _b.return))
            _a3.call(_b);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return this;
    };
    Span2.prototype.addEvent = function(name, attributesOrStartTime, timeStamp) {
      if (this._isSpanEnded())
        return this;
      if (this._spanLimits.eventCountLimit === 0) {
        diag2.warn("No events allowed.");
        this._droppedEventsCount++;
        return this;
      }
      if (this.events.length >= this._spanLimits.eventCountLimit) {
        if (this._droppedEventsCount === 0) {
          diag2.debug("Dropping extra events.");
        }
        this.events.shift();
        this._droppedEventsCount++;
      }
      if (isTimeInput(attributesOrStartTime)) {
        if (!isTimeInput(timeStamp)) {
          timeStamp = attributesOrStartTime;
        }
        attributesOrStartTime = void 0;
      }
      var attributes = sanitizeAttributes(attributesOrStartTime);
      this.events.push({
        name,
        attributes,
        time: this._getTime(timeStamp),
        droppedAttributesCount: 0
      });
      return this;
    };
    Span2.prototype.addLink = function(link) {
      this.links.push(link);
      return this;
    };
    Span2.prototype.addLinks = function(links) {
      var _a3;
      (_a3 = this.links).push.apply(_a3, __spreadArray6([], __read10(links), false));
      return this;
    };
    Span2.prototype.setStatus = function(status) {
      if (this._isSpanEnded())
        return this;
      this.status = __assign2({}, status);
      if (this.status.message != null && typeof status.message !== "string") {
        diag2.warn("Dropping invalid status.message of type '" + typeof status.message + "', expected 'string'");
        delete this.status.message;
      }
      return this;
    };
    Span2.prototype.updateName = function(name) {
      if (this._isSpanEnded())
        return this;
      this.name = name;
      return this;
    };
    Span2.prototype.end = function(endTime) {
      if (this._isSpanEnded()) {
        diag2.error(this.name + " " + this._spanContext.traceId + "-" + this._spanContext.spanId + " - You can only call end() on a span once.");
        return;
      }
      this._ended = true;
      this.endTime = this._getTime(endTime);
      this._duration = hrTimeDuration(this.startTime, this.endTime);
      if (this._duration[0] < 0) {
        diag2.warn("Inconsistent start and end time, startTime > endTime. Setting span duration to 0ms.", this.startTime, this.endTime);
        this.endTime = this.startTime.slice();
        this._duration = [0, 0];
      }
      if (this._droppedEventsCount > 0) {
        diag2.warn("Dropped " + this._droppedEventsCount + " events because eventCountLimit reached");
      }
      this._spanProcessor.onEnd(this);
    };
    Span2.prototype._getTime = function(inp) {
      if (typeof inp === "number" && inp <= otperformance.now()) {
        return hrTime(inp + this._performanceOffset);
      }
      if (typeof inp === "number") {
        return millisToHrTime(inp);
      }
      if (inp instanceof Date) {
        return millisToHrTime(inp.getTime());
      }
      if (isTimeInputHrTime(inp)) {
        return inp;
      }
      if (this._startTimeProvided) {
        return millisToHrTime(Date.now());
      }
      var msDuration = otperformance.now() - this._performanceStartTime;
      return addHrTimes(this.startTime, millisToHrTime(msDuration));
    };
    Span2.prototype.isRecording = function() {
      return this._ended === false;
    };
    Span2.prototype.recordException = function(exception, time) {
      var attributes = {};
      if (typeof exception === "string") {
        attributes[SEMATTRS_EXCEPTION_MESSAGE] = exception;
      } else if (exception) {
        if (exception.code) {
          attributes[SEMATTRS_EXCEPTION_TYPE] = exception.code.toString();
        } else if (exception.name) {
          attributes[SEMATTRS_EXCEPTION_TYPE] = exception.name;
        }
        if (exception.message) {
          attributes[SEMATTRS_EXCEPTION_MESSAGE] = exception.message;
        }
        if (exception.stack) {
          attributes[SEMATTRS_EXCEPTION_STACKTRACE] = exception.stack;
        }
      }
      if (attributes[SEMATTRS_EXCEPTION_TYPE] || attributes[SEMATTRS_EXCEPTION_MESSAGE]) {
        this.addEvent(ExceptionEventName, attributes, time);
      } else {
        diag2.warn("Failed to record an exception " + exception);
      }
    };
    Object.defineProperty(Span2.prototype, "duration", {
      get: function() {
        return this._duration;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Span2.prototype, "ended", {
      get: function() {
        return this._ended;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Span2.prototype, "droppedAttributesCount", {
      get: function() {
        return this._droppedAttributesCount;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Span2.prototype, "droppedEventsCount", {
      get: function() {
        return this._droppedEventsCount;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Span2.prototype, "droppedLinksCount", {
      get: function() {
        return this._droppedLinksCount;
      },
      enumerable: false,
      configurable: true
    });
    Span2.prototype._isSpanEnded = function() {
      if (this._ended) {
        diag2.warn("Can not execute the operation on ended Span {traceId: " + this._spanContext.traceId + ", spanId: " + this._spanContext.spanId + "}");
      }
      return this._ended;
    };
    Span2.prototype._truncateToLimitUtil = function(value, limit) {
      if (value.length <= limit) {
        return value;
      }
      return value.substring(0, limit);
    };
    Span2.prototype._truncateToSize = function(value) {
      var _this = this;
      var limit = this._attributeValueLengthLimit;
      if (limit <= 0) {
        diag2.warn("Attribute value limit must be positive, got " + limit);
        return value;
      }
      if (typeof value === "string") {
        return this._truncateToLimitUtil(value, limit);
      }
      if (Array.isArray(value)) {
        return value.map(function(val) {
          return typeof val === "string" ? _this._truncateToLimitUtil(val, limit) : val;
        });
      }
      return value;
    };
    return Span2;
  }()
);

// node_modules/@opentelemetry/sdk-trace-web/node_modules/@opentelemetry/sdk-trace-base/build/esm/config.js
init_esm();

// node_modules/@opentelemetry/sdk-trace-web/node_modules/@opentelemetry/sdk-trace-base/build/esm/Sampler.js
var SamplingDecision2;
(function(SamplingDecision3) {
  SamplingDecision3[SamplingDecision3["NOT_RECORD"] = 0] = "NOT_RECORD";
  SamplingDecision3[SamplingDecision3["RECORD"] = 1] = "RECORD";
  SamplingDecision3[SamplingDecision3["RECORD_AND_SAMPLED"] = 2] = "RECORD_AND_SAMPLED";
})(SamplingDecision2 || (SamplingDecision2 = {}));

// node_modules/@opentelemetry/sdk-trace-web/node_modules/@opentelemetry/sdk-trace-base/build/esm/sampler/AlwaysOffSampler.js
var AlwaysOffSampler = (
  /** @class */
  function() {
    function AlwaysOffSampler2() {
    }
    AlwaysOffSampler2.prototype.shouldSample = function() {
      return {
        decision: SamplingDecision2.NOT_RECORD
      };
    };
    AlwaysOffSampler2.prototype.toString = function() {
      return "AlwaysOffSampler";
    };
    return AlwaysOffSampler2;
  }()
);

// node_modules/@opentelemetry/sdk-trace-web/node_modules/@opentelemetry/sdk-trace-base/build/esm/sampler/AlwaysOnSampler.js
var AlwaysOnSampler = (
  /** @class */
  function() {
    function AlwaysOnSampler2() {
    }
    AlwaysOnSampler2.prototype.shouldSample = function() {
      return {
        decision: SamplingDecision2.RECORD_AND_SAMPLED
      };
    };
    AlwaysOnSampler2.prototype.toString = function() {
      return "AlwaysOnSampler";
    };
    return AlwaysOnSampler2;
  }()
);

// node_modules/@opentelemetry/sdk-trace-web/node_modules/@opentelemetry/sdk-trace-base/build/esm/sampler/ParentBasedSampler.js
init_esm();
var ParentBasedSampler = (
  /** @class */
  function() {
    function ParentBasedSampler2(config) {
      var _a3, _b, _c, _d;
      this._root = config.root;
      if (!this._root) {
        globalErrorHandler(new Error("ParentBasedSampler must have a root sampler configured"));
        this._root = new AlwaysOnSampler();
      }
      this._remoteParentSampled = (_a3 = config.remoteParentSampled) !== null && _a3 !== void 0 ? _a3 : new AlwaysOnSampler();
      this._remoteParentNotSampled = (_b = config.remoteParentNotSampled) !== null && _b !== void 0 ? _b : new AlwaysOffSampler();
      this._localParentSampled = (_c = config.localParentSampled) !== null && _c !== void 0 ? _c : new AlwaysOnSampler();
      this._localParentNotSampled = (_d = config.localParentNotSampled) !== null && _d !== void 0 ? _d : new AlwaysOffSampler();
    }
    ParentBasedSampler2.prototype.shouldSample = function(context2, traceId, spanName, spanKind, attributes, links) {
      var parentContext = trace.getSpanContext(context2);
      if (!parentContext || !isSpanContextValid(parentContext)) {
        return this._root.shouldSample(context2, traceId, spanName, spanKind, attributes, links);
      }
      if (parentContext.isRemote) {
        if (parentContext.traceFlags & TraceFlags.SAMPLED) {
          return this._remoteParentSampled.shouldSample(context2, traceId, spanName, spanKind, attributes, links);
        }
        return this._remoteParentNotSampled.shouldSample(context2, traceId, spanName, spanKind, attributes, links);
      }
      if (parentContext.traceFlags & TraceFlags.SAMPLED) {
        return this._localParentSampled.shouldSample(context2, traceId, spanName, spanKind, attributes, links);
      }
      return this._localParentNotSampled.shouldSample(context2, traceId, spanName, spanKind, attributes, links);
    };
    ParentBasedSampler2.prototype.toString = function() {
      return "ParentBased{root=" + this._root.toString() + ", remoteParentSampled=" + this._remoteParentSampled.toString() + ", remoteParentNotSampled=" + this._remoteParentNotSampled.toString() + ", localParentSampled=" + this._localParentSampled.toString() + ", localParentNotSampled=" + this._localParentNotSampled.toString() + "}";
    };
    return ParentBasedSampler2;
  }()
);

// node_modules/@opentelemetry/sdk-trace-web/node_modules/@opentelemetry/sdk-trace-base/build/esm/sampler/TraceIdRatioBasedSampler.js
init_esm();
var TraceIdRatioBasedSampler = (
  /** @class */
  function() {
    function TraceIdRatioBasedSampler2(_ratio) {
      if (_ratio === void 0) {
        _ratio = 0;
      }
      this._ratio = _ratio;
      this._ratio = this._normalize(_ratio);
      this._upperBound = Math.floor(this._ratio * 4294967295);
    }
    TraceIdRatioBasedSampler2.prototype.shouldSample = function(context2, traceId) {
      return {
        decision: isValidTraceId(traceId) && this._accumulate(traceId) < this._upperBound ? SamplingDecision2.RECORD_AND_SAMPLED : SamplingDecision2.NOT_RECORD
      };
    };
    TraceIdRatioBasedSampler2.prototype.toString = function() {
      return "TraceIdRatioBased{" + this._ratio + "}";
    };
    TraceIdRatioBasedSampler2.prototype._normalize = function(ratio) {
      if (typeof ratio !== "number" || isNaN(ratio))
        return 0;
      return ratio >= 1 ? 1 : ratio <= 0 ? 0 : ratio;
    };
    TraceIdRatioBasedSampler2.prototype._accumulate = function(traceId) {
      var accumulation = 0;
      for (var i4 = 0; i4 < traceId.length / 8; i4++) {
        var pos = i4 * 8;
        var part = parseInt(traceId.slice(pos, pos + 8), 16);
        accumulation = (accumulation ^ part) >>> 0;
      }
      return accumulation;
    };
    return TraceIdRatioBasedSampler2;
  }()
);

// node_modules/@opentelemetry/sdk-trace-web/node_modules/@opentelemetry/sdk-trace-base/build/esm/config.js
var env = getEnv();
var FALLBACK_OTEL_TRACES_SAMPLER = TracesSamplerValues.AlwaysOn;
var DEFAULT_RATIO = 1;
function loadDefaultConfig() {
  var _env = getEnv();
  return {
    sampler: buildSamplerFromEnv(env),
    forceFlushTimeoutMillis: 3e4,
    generalLimits: {
      attributeValueLengthLimit: _env.OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT,
      attributeCountLimit: _env.OTEL_ATTRIBUTE_COUNT_LIMIT
    },
    spanLimits: {
      attributeValueLengthLimit: _env.OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT,
      attributeCountLimit: _env.OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT,
      linkCountLimit: _env.OTEL_SPAN_LINK_COUNT_LIMIT,
      eventCountLimit: _env.OTEL_SPAN_EVENT_COUNT_LIMIT,
      attributePerEventCountLimit: _env.OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT,
      attributePerLinkCountLimit: _env.OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT
    },
    mergeResourceWithDefaults: true
  };
}
function buildSamplerFromEnv(environment) {
  if (environment === void 0) {
    environment = getEnv();
  }
  switch (environment.OTEL_TRACES_SAMPLER) {
    case TracesSamplerValues.AlwaysOn:
      return new AlwaysOnSampler();
    case TracesSamplerValues.AlwaysOff:
      return new AlwaysOffSampler();
    case TracesSamplerValues.ParentBasedAlwaysOn:
      return new ParentBasedSampler({
        root: new AlwaysOnSampler()
      });
    case TracesSamplerValues.ParentBasedAlwaysOff:
      return new ParentBasedSampler({
        root: new AlwaysOffSampler()
      });
    case TracesSamplerValues.TraceIdRatio:
      return new TraceIdRatioBasedSampler(getSamplerProbabilityFromEnv(environment));
    case TracesSamplerValues.ParentBasedTraceIdRatio:
      return new ParentBasedSampler({
        root: new TraceIdRatioBasedSampler(getSamplerProbabilityFromEnv(environment))
      });
    default:
      diag2.error('OTEL_TRACES_SAMPLER value "' + environment.OTEL_TRACES_SAMPLER + " invalid, defaulting to " + FALLBACK_OTEL_TRACES_SAMPLER + '".');
      return new AlwaysOnSampler();
  }
}
function getSamplerProbabilityFromEnv(environment) {
  if (environment.OTEL_TRACES_SAMPLER_ARG === void 0 || environment.OTEL_TRACES_SAMPLER_ARG === "") {
    diag2.error("OTEL_TRACES_SAMPLER_ARG is blank, defaulting to " + DEFAULT_RATIO + ".");
    return DEFAULT_RATIO;
  }
  var probability = Number(environment.OTEL_TRACES_SAMPLER_ARG);
  if (isNaN(probability)) {
    diag2.error("OTEL_TRACES_SAMPLER_ARG=" + environment.OTEL_TRACES_SAMPLER_ARG + " was given, but it is invalid, defaulting to " + DEFAULT_RATIO + ".");
    return DEFAULT_RATIO;
  }
  if (probability < 0 || probability > 1) {
    diag2.error("OTEL_TRACES_SAMPLER_ARG=" + environment.OTEL_TRACES_SAMPLER_ARG + " was given, but it is out of range ([0..1]), defaulting to " + DEFAULT_RATIO + ".");
    return DEFAULT_RATIO;
  }
  return probability;
}

// node_modules/@opentelemetry/sdk-trace-web/node_modules/@opentelemetry/sdk-trace-base/build/esm/utility.js
function mergeConfig(userConfig) {
  var perInstanceDefaults = {
    sampler: buildSamplerFromEnv()
  };
  var DEFAULT_CONFIG = loadDefaultConfig();
  var target = Object.assign({}, DEFAULT_CONFIG, perInstanceDefaults, userConfig);
  target.generalLimits = Object.assign({}, DEFAULT_CONFIG.generalLimits, userConfig.generalLimits || {});
  target.spanLimits = Object.assign({}, DEFAULT_CONFIG.spanLimits, userConfig.spanLimits || {});
  return target;
}
function reconfigureLimits(userConfig) {
  var _a3, _b, _c, _d, _e2, _f, _g, _h, _j, _k, _l, _m;
  var spanLimits = Object.assign({}, userConfig.spanLimits);
  var parsedEnvConfig = getEnvWithoutDefaults();
  spanLimits.attributeCountLimit = (_f = (_e2 = (_d = (_b = (_a3 = userConfig.spanLimits) === null || _a3 === void 0 ? void 0 : _a3.attributeCountLimit) !== null && _b !== void 0 ? _b : (_c = userConfig.generalLimits) === null || _c === void 0 ? void 0 : _c.attributeCountLimit) !== null && _d !== void 0 ? _d : parsedEnvConfig.OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT) !== null && _e2 !== void 0 ? _e2 : parsedEnvConfig.OTEL_ATTRIBUTE_COUNT_LIMIT) !== null && _f !== void 0 ? _f : DEFAULT_ATTRIBUTE_COUNT_LIMIT;
  spanLimits.attributeValueLengthLimit = (_m = (_l = (_k = (_h = (_g = userConfig.spanLimits) === null || _g === void 0 ? void 0 : _g.attributeValueLengthLimit) !== null && _h !== void 0 ? _h : (_j = userConfig.generalLimits) === null || _j === void 0 ? void 0 : _j.attributeValueLengthLimit) !== null && _k !== void 0 ? _k : parsedEnvConfig.OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT) !== null && _l !== void 0 ? _l : parsedEnvConfig.OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT) !== null && _m !== void 0 ? _m : DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT;
  return Object.assign({}, userConfig, { spanLimits });
}

// node_modules/@opentelemetry/sdk-trace-web/node_modules/@opentelemetry/sdk-trace-base/build/esm/export/BatchSpanProcessorBase.js
init_esm();
var BatchSpanProcessorBase = (
  /** @class */
  function() {
    function BatchSpanProcessorBase2(_exporter, config) {
      this._exporter = _exporter;
      this._isExporting = false;
      this._finishedSpans = [];
      this._droppedSpansCount = 0;
      var env2 = getEnv();
      this._maxExportBatchSize = typeof (config === null || config === void 0 ? void 0 : config.maxExportBatchSize) === "number" ? config.maxExportBatchSize : env2.OTEL_BSP_MAX_EXPORT_BATCH_SIZE;
      this._maxQueueSize = typeof (config === null || config === void 0 ? void 0 : config.maxQueueSize) === "number" ? config.maxQueueSize : env2.OTEL_BSP_MAX_QUEUE_SIZE;
      this._scheduledDelayMillis = typeof (config === null || config === void 0 ? void 0 : config.scheduledDelayMillis) === "number" ? config.scheduledDelayMillis : env2.OTEL_BSP_SCHEDULE_DELAY;
      this._exportTimeoutMillis = typeof (config === null || config === void 0 ? void 0 : config.exportTimeoutMillis) === "number" ? config.exportTimeoutMillis : env2.OTEL_BSP_EXPORT_TIMEOUT;
      this._shutdownOnce = new BindOnceFuture(this._shutdown, this);
      if (this._maxExportBatchSize > this._maxQueueSize) {
        diag2.warn("BatchSpanProcessor: maxExportBatchSize must be smaller or equal to maxQueueSize, setting maxExportBatchSize to match maxQueueSize");
        this._maxExportBatchSize = this._maxQueueSize;
      }
    }
    BatchSpanProcessorBase2.prototype.forceFlush = function() {
      if (this._shutdownOnce.isCalled) {
        return this._shutdownOnce.promise;
      }
      return this._flushAll();
    };
    BatchSpanProcessorBase2.prototype.onStart = function(_span, _parentContext) {
    };
    BatchSpanProcessorBase2.prototype.onEnd = function(span) {
      if (this._shutdownOnce.isCalled) {
        return;
      }
      if ((span.spanContext().traceFlags & TraceFlags.SAMPLED) === 0) {
        return;
      }
      this._addToBuffer(span);
    };
    BatchSpanProcessorBase2.prototype.shutdown = function() {
      return this._shutdownOnce.call();
    };
    BatchSpanProcessorBase2.prototype._shutdown = function() {
      var _this = this;
      return Promise.resolve().then(function() {
        return _this.onShutdown();
      }).then(function() {
        return _this._flushAll();
      }).then(function() {
        return _this._exporter.shutdown();
      });
    };
    BatchSpanProcessorBase2.prototype._addToBuffer = function(span) {
      if (this._finishedSpans.length >= this._maxQueueSize) {
        if (this._droppedSpansCount === 0) {
          diag2.debug("maxQueueSize reached, dropping spans");
        }
        this._droppedSpansCount++;
        return;
      }
      if (this._droppedSpansCount > 0) {
        diag2.warn("Dropped " + this._droppedSpansCount + " spans because maxQueueSize reached");
        this._droppedSpansCount = 0;
      }
      this._finishedSpans.push(span);
      this._maybeStartTimer();
    };
    BatchSpanProcessorBase2.prototype._flushAll = function() {
      var _this = this;
      return new Promise(function(resolve, reject) {
        var promises = [];
        var count = Math.ceil(_this._finishedSpans.length / _this._maxExportBatchSize);
        for (var i4 = 0, j = count; i4 < j; i4++) {
          promises.push(_this._flushOneBatch());
        }
        Promise.all(promises).then(function() {
          resolve();
        }).catch(reject);
      });
    };
    BatchSpanProcessorBase2.prototype._flushOneBatch = function() {
      var _this = this;
      this._clearTimer();
      if (this._finishedSpans.length === 0) {
        return Promise.resolve();
      }
      return new Promise(function(resolve, reject) {
        var timer = setTimeout(function() {
          reject(new Error("Timeout"));
        }, _this._exportTimeoutMillis);
        context.with(suppressTracing(context.active()), function() {
          var spans;
          if (_this._finishedSpans.length <= _this._maxExportBatchSize) {
            spans = _this._finishedSpans;
            _this._finishedSpans = [];
          } else {
            spans = _this._finishedSpans.splice(0, _this._maxExportBatchSize);
          }
          var doExport = function() {
            return _this._exporter.export(spans, function(result) {
              var _a3;
              clearTimeout(timer);
              if (result.code === ExportResultCode.SUCCESS) {
                resolve();
              } else {
                reject((_a3 = result.error) !== null && _a3 !== void 0 ? _a3 : new Error("BatchSpanProcessor: span export failed"));
              }
            });
          };
          var pendingResources = null;
          for (var i4 = 0, len = spans.length; i4 < len; i4++) {
            var span = spans[i4];
            if (span.resource.asyncAttributesPending && span.resource.waitForAsyncAttributes) {
              pendingResources !== null && pendingResources !== void 0 ? pendingResources : pendingResources = [];
              pendingResources.push(span.resource.waitForAsyncAttributes());
            }
          }
          if (pendingResources === null) {
            doExport();
          } else {
            Promise.all(pendingResources).then(doExport, function(err) {
              globalErrorHandler(err);
              reject(err);
            });
          }
        });
      });
    };
    BatchSpanProcessorBase2.prototype._maybeStartTimer = function() {
      var _this = this;
      if (this._isExporting)
        return;
      var flush = function() {
        _this._isExporting = true;
        _this._flushOneBatch().finally(function() {
          _this._isExporting = false;
          if (_this._finishedSpans.length > 0) {
            _this._clearTimer();
            _this._maybeStartTimer();
          }
        }).catch(function(e7) {
          _this._isExporting = false;
          globalErrorHandler(e7);
        });
      };
      if (this._finishedSpans.length >= this._maxExportBatchSize) {
        return flush();
      }
      if (this._timer !== void 0)
        return;
      this._timer = setTimeout(function() {
        return flush();
      }, this._scheduledDelayMillis);
      unrefTimer(this._timer);
    };
    BatchSpanProcessorBase2.prototype._clearTimer = function() {
      if (this._timer !== void 0) {
        clearTimeout(this._timer);
        this._timer = void 0;
      }
    };
    return BatchSpanProcessorBase2;
  }()
);

// node_modules/@opentelemetry/sdk-trace-web/node_modules/@opentelemetry/sdk-trace-base/build/esm/platform/node/export/BatchSpanProcessor.js
var __extends2 = function() {
  var extendStatics = function(d5, b4) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d6, b5) {
      d6.__proto__ = b5;
    } || function(d6, b5) {
      for (var p9 in b5)
        if (Object.prototype.hasOwnProperty.call(b5, p9))
          d6[p9] = b5[p9];
    };
    return extendStatics(d5, b4);
  };
  return function(d5, b4) {
    if (typeof b4 !== "function" && b4 !== null)
      throw new TypeError("Class extends value " + String(b4) + " is not a constructor or null");
    extendStatics(d5, b4);
    function __() {
      this.constructor = d5;
    }
    d5.prototype = b4 === null ? Object.create(b4) : (__.prototype = b4.prototype, new __());
  };
}();
var BatchSpanProcessor = (
  /** @class */
  function(_super) {
    __extends2(BatchSpanProcessor2, _super);
    function BatchSpanProcessor2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    BatchSpanProcessor2.prototype.onShutdown = function() {
    };
    return BatchSpanProcessor2;
  }(BatchSpanProcessorBase)
);

// node_modules/@opentelemetry/sdk-trace-web/node_modules/@opentelemetry/sdk-trace-base/build/esm/platform/node/RandomIdGenerator.js
var SPAN_ID_BYTES = 8;
var TRACE_ID_BYTES = 16;
var RandomIdGenerator2 = (
  /** @class */
  function() {
    function RandomIdGenerator7() {
      this.generateTraceId = getIdGenerator(TRACE_ID_BYTES);
      this.generateSpanId = getIdGenerator(SPAN_ID_BYTES);
    }
    return RandomIdGenerator7;
  }()
);
var SHARED_BUFFER = Buffer.allocUnsafe(TRACE_ID_BYTES);
function getIdGenerator(bytes) {
  return function generateId() {
    for (var i4 = 0; i4 < bytes / 4; i4++) {
      SHARED_BUFFER.writeUInt32BE(Math.random() * Math.pow(2, 32) >>> 0, i4 * 4);
    }
    for (var i4 = 0; i4 < bytes; i4++) {
      if (SHARED_BUFFER[i4] > 0) {
        break;
      } else if (i4 === bytes - 1) {
        SHARED_BUFFER[bytes - 1] = 1;
      }
    }
    return SHARED_BUFFER.toString("hex", 0, bytes);
  };
}

// node_modules/@opentelemetry/sdk-trace-web/node_modules/@opentelemetry/sdk-trace-base/build/esm/Tracer.js
var Tracer = (
  /** @class */
  function() {
    function Tracer2(instrumentationLibrary, config, _tracerProvider) {
      this._tracerProvider = _tracerProvider;
      var localConfig = mergeConfig(config);
      this._sampler = localConfig.sampler;
      this._generalLimits = localConfig.generalLimits;
      this._spanLimits = localConfig.spanLimits;
      this._idGenerator = config.idGenerator || new RandomIdGenerator2();
      this.resource = _tracerProvider.resource;
      this.instrumentationLibrary = instrumentationLibrary;
    }
    Tracer2.prototype.startSpan = function(name, options, context2) {
      var _a3, _b, _c;
      if (options === void 0) {
        options = {};
      }
      if (context2 === void 0) {
        context2 = context.active();
      }
      if (options.root) {
        context2 = trace.deleteSpan(context2);
      }
      var parentSpan = trace.getSpan(context2);
      if (isTracingSuppressed(context2)) {
        diag2.debug("Instrumentation suppressed, returning Noop Span");
        var nonRecordingSpan = trace.wrapSpanContext(INVALID_SPAN_CONTEXT);
        return nonRecordingSpan;
      }
      var parentSpanContext = parentSpan === null || parentSpan === void 0 ? void 0 : parentSpan.spanContext();
      var spanId = this._idGenerator.generateSpanId();
      var traceId;
      var traceState;
      var parentSpanId;
      if (!parentSpanContext || !trace.isSpanContextValid(parentSpanContext)) {
        traceId = this._idGenerator.generateTraceId();
      } else {
        traceId = parentSpanContext.traceId;
        traceState = parentSpanContext.traceState;
        parentSpanId = parentSpanContext.spanId;
      }
      var spanKind = (_a3 = options.kind) !== null && _a3 !== void 0 ? _a3 : SpanKind.INTERNAL;
      var links = ((_b = options.links) !== null && _b !== void 0 ? _b : []).map(function(link) {
        return {
          context: link.context,
          attributes: sanitizeAttributes(link.attributes)
        };
      });
      var attributes = sanitizeAttributes(options.attributes);
      var samplingResult = this._sampler.shouldSample(context2, traceId, name, spanKind, attributes, links);
      traceState = (_c = samplingResult.traceState) !== null && _c !== void 0 ? _c : traceState;
      var traceFlags = samplingResult.decision === SamplingDecision.RECORD_AND_SAMPLED ? TraceFlags.SAMPLED : TraceFlags.NONE;
      var spanContext = { traceId, spanId, traceFlags, traceState };
      if (samplingResult.decision === SamplingDecision.NOT_RECORD) {
        diag2.debug("Recording is off, propagating context in a non-recording span");
        var nonRecordingSpan = trace.wrapSpanContext(spanContext);
        return nonRecordingSpan;
      }
      var initAttributes = sanitizeAttributes(Object.assign(attributes, samplingResult.attributes));
      var span = new Span(this, context2, name, spanContext, spanKind, parentSpanId, links, options.startTime, void 0, initAttributes);
      return span;
    };
    Tracer2.prototype.startActiveSpan = function(name, arg2, arg3, arg4) {
      var opts;
      var ctx;
      var fn;
      if (arguments.length < 2) {
        return;
      } else if (arguments.length === 2) {
        fn = arg2;
      } else if (arguments.length === 3) {
        opts = arg2;
        fn = arg3;
      } else {
        opts = arg2;
        ctx = arg3;
        fn = arg4;
      }
      var parentContext = ctx !== null && ctx !== void 0 ? ctx : context.active();
      var span = this.startSpan(name, opts, parentContext);
      var contextWithSpanSet = trace.setSpan(parentContext, span);
      return context.with(contextWithSpanSet, fn, void 0, span);
    };
    Tracer2.prototype.getGeneralLimits = function() {
      return this._generalLimits;
    };
    Tracer2.prototype.getSpanLimits = function() {
      return this._spanLimits;
    };
    Tracer2.prototype.getActiveSpanProcessor = function() {
      return this._tracerProvider.getActiveSpanProcessor();
    };
    return Tracer2;
  }()
);

// node_modules/@opentelemetry/sdk-trace-web/node_modules/@opentelemetry/sdk-trace-base/build/esm/BasicTracerProvider.js
init_esm();

// node_modules/@opentelemetry/sdk-trace-web/node_modules/@opentelemetry/sdk-trace-base/build/esm/MultiSpanProcessor.js
var __values5 = function(o4) {
  var s10 = typeof Symbol === "function" && Symbol.iterator, m2 = s10 && o4[s10], i4 = 0;
  if (m2)
    return m2.call(o4);
  if (o4 && typeof o4.length === "number")
    return {
      next: function() {
        if (o4 && i4 >= o4.length)
          o4 = void 0;
        return { value: o4 && o4[i4++], done: !o4 };
      }
    };
  throw new TypeError(s10 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var MultiSpanProcessor = (
  /** @class */
  function() {
    function MultiSpanProcessor2(_spanProcessors) {
      this._spanProcessors = _spanProcessors;
    }
    MultiSpanProcessor2.prototype.forceFlush = function() {
      var e_1, _a3;
      var promises = [];
      try {
        for (var _b = __values5(this._spanProcessors), _c = _b.next(); !_c.done; _c = _b.next()) {
          var spanProcessor = _c.value;
          promises.push(spanProcessor.forceFlush());
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a3 = _b.return))
            _a3.call(_b);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return new Promise(function(resolve) {
        Promise.all(promises).then(function() {
          resolve();
        }).catch(function(error) {
          globalErrorHandler(error || new Error("MultiSpanProcessor: forceFlush failed"));
          resolve();
        });
      });
    };
    MultiSpanProcessor2.prototype.onStart = function(span, context2) {
      var e_2, _a3;
      try {
        for (var _b = __values5(this._spanProcessors), _c = _b.next(); !_c.done; _c = _b.next()) {
          var spanProcessor = _c.value;
          spanProcessor.onStart(span, context2);
        }
      } catch (e_2_1) {
        e_2 = { error: e_2_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a3 = _b.return))
            _a3.call(_b);
        } finally {
          if (e_2)
            throw e_2.error;
        }
      }
    };
    MultiSpanProcessor2.prototype.onEnd = function(span) {
      var e_3, _a3;
      try {
        for (var _b = __values5(this._spanProcessors), _c = _b.next(); !_c.done; _c = _b.next()) {
          var spanProcessor = _c.value;
          spanProcessor.onEnd(span);
        }
      } catch (e_3_1) {
        e_3 = { error: e_3_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a3 = _b.return))
            _a3.call(_b);
        } finally {
          if (e_3)
            throw e_3.error;
        }
      }
    };
    MultiSpanProcessor2.prototype.shutdown = function() {
      var e_4, _a3;
      var promises = [];
      try {
        for (var _b = __values5(this._spanProcessors), _c = _b.next(); !_c.done; _c = _b.next()) {
          var spanProcessor = _c.value;
          promises.push(spanProcessor.shutdown());
        }
      } catch (e_4_1) {
        e_4 = { error: e_4_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a3 = _b.return))
            _a3.call(_b);
        } finally {
          if (e_4)
            throw e_4.error;
        }
      }
      return new Promise(function(resolve, reject) {
        Promise.all(promises).then(function() {
          resolve();
        }, reject);
      });
    };
    return MultiSpanProcessor2;
  }()
);

// node_modules/@opentelemetry/sdk-trace-web/node_modules/@opentelemetry/sdk-trace-base/build/esm/export/NoopSpanProcessor.js
var NoopSpanProcessor = (
  /** @class */
  function() {
    function NoopSpanProcessor2() {
    }
    NoopSpanProcessor2.prototype.onStart = function(_span, _context) {
    };
    NoopSpanProcessor2.prototype.onEnd = function(_span) {
    };
    NoopSpanProcessor2.prototype.shutdown = function() {
      return Promise.resolve();
    };
    NoopSpanProcessor2.prototype.forceFlush = function() {
      return Promise.resolve();
    };
    return NoopSpanProcessor2;
  }()
);

// node_modules/@opentelemetry/sdk-trace-web/node_modules/@opentelemetry/sdk-trace-base/build/esm/BasicTracerProvider.js
var __read11 = function(o4, n9) {
  var m2 = typeof Symbol === "function" && o4[Symbol.iterator];
  if (!m2)
    return o4;
  var i4 = m2.call(o4), r7, ar = [], e7;
  try {
    while ((n9 === void 0 || n9-- > 0) && !(r7 = i4.next()).done)
      ar.push(r7.value);
  } catch (error) {
    e7 = { error };
  } finally {
    try {
      if (r7 && !r7.done && (m2 = i4["return"]))
        m2.call(i4);
    } finally {
      if (e7)
        throw e7.error;
    }
  }
  return ar;
};
var __spreadArray7 = function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i4 = 0, l5 = from.length, ar; i4 < l5; i4++) {
      if (ar || !(i4 in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i4);
        ar[i4] = from[i4];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var ForceFlushState;
(function(ForceFlushState2) {
  ForceFlushState2[ForceFlushState2["resolved"] = 0] = "resolved";
  ForceFlushState2[ForceFlushState2["timeout"] = 1] = "timeout";
  ForceFlushState2[ForceFlushState2["error"] = 2] = "error";
  ForceFlushState2[ForceFlushState2["unresolved"] = 3] = "unresolved";
})(ForceFlushState || (ForceFlushState = {}));
var BasicTracerProvider = (
  /** @class */
  function() {
    function BasicTracerProvider2(config) {
      if (config === void 0) {
        config = {};
      }
      var _a3, _b;
      this._registeredSpanProcessors = [];
      this._tracers = /* @__PURE__ */ new Map();
      var mergedConfig = merge({}, loadDefaultConfig(), reconfigureLimits(config));
      this.resource = (_a3 = mergedConfig.resource) !== null && _a3 !== void 0 ? _a3 : Resource.empty();
      if (mergedConfig.mergeResourceWithDefaults) {
        this.resource = Resource.default().merge(this.resource);
      }
      this._config = Object.assign({}, mergedConfig, {
        resource: this.resource
      });
      if ((_b = config.spanProcessors) === null || _b === void 0 ? void 0 : _b.length) {
        this._registeredSpanProcessors = __spreadArray7([], __read11(config.spanProcessors), false);
        this.activeSpanProcessor = new MultiSpanProcessor(this._registeredSpanProcessors);
      } else {
        var defaultExporter = this._buildExporterFromEnv();
        if (defaultExporter !== void 0) {
          var batchProcessor = new BatchSpanProcessor(defaultExporter);
          this.activeSpanProcessor = batchProcessor;
        } else {
          this.activeSpanProcessor = new NoopSpanProcessor();
        }
      }
    }
    BasicTracerProvider2.prototype.getTracer = function(name, version, options) {
      var key = name + "@" + (version || "") + ":" + ((options === null || options === void 0 ? void 0 : options.schemaUrl) || "");
      if (!this._tracers.has(key)) {
        this._tracers.set(key, new Tracer({ name, version, schemaUrl: options === null || options === void 0 ? void 0 : options.schemaUrl }, this._config, this));
      }
      return this._tracers.get(key);
    };
    BasicTracerProvider2.prototype.addSpanProcessor = function(spanProcessor) {
      if (this._registeredSpanProcessors.length === 0) {
        this.activeSpanProcessor.shutdown().catch(function(err) {
          return diag2.error("Error while trying to shutdown current span processor", err);
        });
      }
      this._registeredSpanProcessors.push(spanProcessor);
      this.activeSpanProcessor = new MultiSpanProcessor(this._registeredSpanProcessors);
    };
    BasicTracerProvider2.prototype.getActiveSpanProcessor = function() {
      return this.activeSpanProcessor;
    };
    BasicTracerProvider2.prototype.register = function(config) {
      if (config === void 0) {
        config = {};
      }
      trace.setGlobalTracerProvider(this);
      if (config.propagator === void 0) {
        config.propagator = this._buildPropagatorFromEnv();
      }
      if (config.contextManager) {
        context.setGlobalContextManager(config.contextManager);
      }
      if (config.propagator) {
        propagation.setGlobalPropagator(config.propagator);
      }
    };
    BasicTracerProvider2.prototype.forceFlush = function() {
      var timeout = this._config.forceFlushTimeoutMillis;
      var promises = this._registeredSpanProcessors.map(function(spanProcessor) {
        return new Promise(function(resolve) {
          var state;
          var timeoutInterval = setTimeout(function() {
            resolve(new Error("Span processor did not completed within timeout period of " + timeout + " ms"));
            state = ForceFlushState.timeout;
          }, timeout);
          spanProcessor.forceFlush().then(function() {
            clearTimeout(timeoutInterval);
            if (state !== ForceFlushState.timeout) {
              state = ForceFlushState.resolved;
              resolve(state);
            }
          }).catch(function(error) {
            clearTimeout(timeoutInterval);
            state = ForceFlushState.error;
            resolve(error);
          });
        });
      });
      return new Promise(function(resolve, reject) {
        Promise.all(promises).then(function(results) {
          var errors = results.filter(function(result) {
            return result !== ForceFlushState.resolved;
          });
          if (errors.length > 0) {
            reject(errors);
          } else {
            resolve();
          }
        }).catch(function(error) {
          return reject([error]);
        });
      });
    };
    BasicTracerProvider2.prototype.shutdown = function() {
      return this.activeSpanProcessor.shutdown();
    };
    BasicTracerProvider2.prototype._getPropagator = function(name) {
      var _a3;
      return (_a3 = this.constructor._registeredPropagators.get(name)) === null || _a3 === void 0 ? void 0 : _a3();
    };
    BasicTracerProvider2.prototype._getSpanExporter = function(name) {
      var _a3;
      return (_a3 = this.constructor._registeredExporters.get(name)) === null || _a3 === void 0 ? void 0 : _a3();
    };
    BasicTracerProvider2.prototype._buildPropagatorFromEnv = function() {
      var _this = this;
      var uniquePropagatorNames = Array.from(new Set(getEnv().OTEL_PROPAGATORS));
      var propagators = uniquePropagatorNames.map(function(name) {
        var propagator = _this._getPropagator(name);
        if (!propagator) {
          diag2.warn('Propagator "' + name + '" requested through environment variable is unavailable.');
        }
        return propagator;
      });
      var validPropagators = propagators.reduce(function(list, item) {
        if (item) {
          list.push(item);
        }
        return list;
      }, []);
      if (validPropagators.length === 0) {
        return;
      } else if (uniquePropagatorNames.length === 1) {
        return validPropagators[0];
      } else {
        return new CompositePropagator({
          propagators: validPropagators
        });
      }
    };
    BasicTracerProvider2.prototype._buildExporterFromEnv = function() {
      var exporterName = getEnv().OTEL_TRACES_EXPORTER;
      if (exporterName === "none" || exporterName === "")
        return;
      var exporter = this._getSpanExporter(exporterName);
      if (!exporter) {
        diag2.error('Exporter "' + exporterName + '" requested through environment variable is unavailable.');
      }
      return exporter;
    };
    BasicTracerProvider2._registeredPropagators = /* @__PURE__ */ new Map([
      ["tracecontext", function() {
        return new W3CTraceContextPropagator();
      }],
      ["baggage", function() {
        return new W3CBaggagePropagator();
      }]
    ]);
    BasicTracerProvider2._registeredExporters = /* @__PURE__ */ new Map();
    return BasicTracerProvider2;
  }()
);

// node_modules/@opentelemetry/sdk-trace-web/build/esm/StackContextManager.js
init_esm();
var __read12 = function(o4, n9) {
  var m2 = typeof Symbol === "function" && o4[Symbol.iterator];
  if (!m2)
    return o4;
  var i4 = m2.call(o4), r7, ar = [], e7;
  try {
    while ((n9 === void 0 || n9-- > 0) && !(r7 = i4.next()).done)
      ar.push(r7.value);
  } catch (error) {
    e7 = { error };
  } finally {
    try {
      if (r7 && !r7.done && (m2 = i4["return"]))
        m2.call(i4);
    } finally {
      if (e7)
        throw e7.error;
    }
  }
  return ar;
};
var __spreadArray8 = function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i4 = 0, l5 = from.length, ar; i4 < l5; i4++) {
      if (ar || !(i4 in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i4);
        ar[i4] = from[i4];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var StackContextManager = (
  /** @class */
  function() {
    function StackContextManager2() {
      this._enabled = false;
      this._currentContext = ROOT_CONTEXT;
    }
    StackContextManager2.prototype._bindFunction = function(context2, target) {
      if (context2 === void 0) {
        context2 = ROOT_CONTEXT;
      }
      var manager = this;
      var contextWrapper = function() {
        var _this = this;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return manager.with(context2, function() {
          return target.apply(_this, args);
        });
      };
      Object.defineProperty(contextWrapper, "length", {
        enumerable: false,
        configurable: true,
        writable: false,
        value: target.length
      });
      return contextWrapper;
    };
    StackContextManager2.prototype.active = function() {
      return this._currentContext;
    };
    StackContextManager2.prototype.bind = function(context2, target) {
      if (context2 === void 0) {
        context2 = this.active();
      }
      if (typeof target === "function") {
        return this._bindFunction(context2, target);
      }
      return target;
    };
    StackContextManager2.prototype.disable = function() {
      this._currentContext = ROOT_CONTEXT;
      this._enabled = false;
      return this;
    };
    StackContextManager2.prototype.enable = function() {
      if (this._enabled) {
        return this;
      }
      this._enabled = true;
      this._currentContext = ROOT_CONTEXT;
      return this;
    };
    StackContextManager2.prototype.with = function(context2, fn, thisArg) {
      var args = [];
      for (var _i = 3; _i < arguments.length; _i++) {
        args[_i - 3] = arguments[_i];
      }
      var previousContext = this._currentContext;
      this._currentContext = context2 || ROOT_CONTEXT;
      try {
        return fn.call.apply(fn, __spreadArray8([thisArg], __read12(args), false));
      } finally {
        this._currentContext = previousContext;
      }
    };
    return StackContextManager2;
  }()
);

// node_modules/@opentelemetry/sdk-trace-web/build/esm/WebTracerProvider.js
var __extends3 = function() {
  var extendStatics = function(d5, b4) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d6, b5) {
      d6.__proto__ = b5;
    } || function(d6, b5) {
      for (var p9 in b5)
        if (Object.prototype.hasOwnProperty.call(b5, p9))
          d6[p9] = b5[p9];
    };
    return extendStatics(d5, b4);
  };
  return function(d5, b4) {
    if (typeof b4 !== "function" && b4 !== null)
      throw new TypeError("Class extends value " + String(b4) + " is not a constructor or null");
    extendStatics(d5, b4);
    function __() {
      this.constructor = d5;
    }
    d5.prototype = b4 === null ? Object.create(b4) : (__.prototype = b4.prototype, new __());
  };
}();
var WebTracerProvider = (
  /** @class */
  function(_super) {
    __extends3(WebTracerProvider2, _super);
    function WebTracerProvider2(config) {
      if (config === void 0) {
        config = {};
      }
      var _this = _super.call(this, config) || this;
      if (config.contextManager) {
        throw "contextManager should be defined in register method not in constructor";
      }
      if (config.propagator) {
        throw "propagator should be defined in register method not in constructor";
      }
      return _this;
    }
    WebTracerProvider2.prototype.register = function(config) {
      if (config === void 0) {
        config = {};
      }
      if (config.contextManager === void 0) {
        config.contextManager = new StackContextManager();
      }
      if (config.contextManager) {
        config.contextManager.enable();
      }
      _super.prototype.register.call(this, config);
    };
    return WebTracerProvider2;
  }(BasicTracerProvider)
);

// node_modules/@opentelemetry/sdk-trace-web/build/esm/enums/PerformanceTimingNames.js
var PerformanceTimingNames;
(function(PerformanceTimingNames4) {
  PerformanceTimingNames4["CONNECT_END"] = "connectEnd";
  PerformanceTimingNames4["CONNECT_START"] = "connectStart";
  PerformanceTimingNames4["DECODED_BODY_SIZE"] = "decodedBodySize";
  PerformanceTimingNames4["DOM_COMPLETE"] = "domComplete";
  PerformanceTimingNames4["DOM_CONTENT_LOADED_EVENT_END"] = "domContentLoadedEventEnd";
  PerformanceTimingNames4["DOM_CONTENT_LOADED_EVENT_START"] = "domContentLoadedEventStart";
  PerformanceTimingNames4["DOM_INTERACTIVE"] = "domInteractive";
  PerformanceTimingNames4["DOMAIN_LOOKUP_END"] = "domainLookupEnd";
  PerformanceTimingNames4["DOMAIN_LOOKUP_START"] = "domainLookupStart";
  PerformanceTimingNames4["ENCODED_BODY_SIZE"] = "encodedBodySize";
  PerformanceTimingNames4["FETCH_START"] = "fetchStart";
  PerformanceTimingNames4["LOAD_EVENT_END"] = "loadEventEnd";
  PerformanceTimingNames4["LOAD_EVENT_START"] = "loadEventStart";
  PerformanceTimingNames4["NAVIGATION_START"] = "navigationStart";
  PerformanceTimingNames4["REDIRECT_END"] = "redirectEnd";
  PerformanceTimingNames4["REDIRECT_START"] = "redirectStart";
  PerformanceTimingNames4["REQUEST_START"] = "requestStart";
  PerformanceTimingNames4["RESPONSE_END"] = "responseEnd";
  PerformanceTimingNames4["RESPONSE_START"] = "responseStart";
  PerformanceTimingNames4["SECURE_CONNECTION_START"] = "secureConnectionStart";
  PerformanceTimingNames4["UNLOAD_EVENT_END"] = "unloadEventEnd";
  PerformanceTimingNames4["UNLOAD_EVENT_START"] = "unloadEventStart";
})(PerformanceTimingNames || (PerformanceTimingNames = {}));

// node_modules/@opentelemetry/sdk-trace-web/build/esm/utils.js
function hasKey(obj, key) {
  return key in obj;
}
function addSpanNetworkEvent(span, performanceName, entries, refPerfName) {
  var perfTime = void 0;
  var refTime = void 0;
  if (hasKey(entries, performanceName) && typeof entries[performanceName] === "number") {
    perfTime = entries[performanceName];
  }
  var refName = refPerfName || PerformanceTimingNames.FETCH_START;
  if (hasKey(entries, refName) && typeof entries[refName] === "number") {
    refTime = entries[refName];
  }
  if (perfTime !== void 0 && refTime !== void 0 && perfTime >= refTime) {
    span.addEvent(performanceName, perfTime);
    return span;
  }
  return void 0;
}
function addSpanNetworkEvents(span, resource) {
  addSpanNetworkEvent(span, PerformanceTimingNames.FETCH_START, resource);
  addSpanNetworkEvent(span, PerformanceTimingNames.DOMAIN_LOOKUP_START, resource);
  addSpanNetworkEvent(span, PerformanceTimingNames.DOMAIN_LOOKUP_END, resource);
  addSpanNetworkEvent(span, PerformanceTimingNames.CONNECT_START, resource);
  if (hasKey(resource, "name") && resource["name"].startsWith("https:")) {
    addSpanNetworkEvent(span, PerformanceTimingNames.SECURE_CONNECTION_START, resource);
  }
  addSpanNetworkEvent(span, PerformanceTimingNames.CONNECT_END, resource);
  addSpanNetworkEvent(span, PerformanceTimingNames.REQUEST_START, resource);
  addSpanNetworkEvent(span, PerformanceTimingNames.RESPONSE_START, resource);
  addSpanNetworkEvent(span, PerformanceTimingNames.RESPONSE_END, resource);
  var encodedLength = resource[PerformanceTimingNames.ENCODED_BODY_SIZE];
  if (encodedLength !== void 0) {
    span.setAttribute(SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH, encodedLength);
  }
  var decodedLength = resource[PerformanceTimingNames.DECODED_BODY_SIZE];
  if (decodedLength !== void 0 && encodedLength !== decodedLength) {
    span.setAttribute(SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED, decodedLength);
  }
}

// node_modules/@opentelemetry/context-zone-peer-dep/build/esm/ZoneContextManager.js
init_esm();

// node_modules/@opentelemetry/context-zone-peer-dep/build/esm/util.js
function isListenerObject(obj) {
  if (obj === void 0) {
    obj = {};
  }
  return typeof obj.addEventListener === "function" && typeof obj.removeEventListener === "function";
}

// node_modules/@opentelemetry/context-zone-peer-dep/build/esm/ZoneContextManager.js
var ZONE_CONTEXT_KEY = "OT_ZONE_CONTEXT";
var ZoneContextManager = (
  /** @class */
  function() {
    function ZoneContextManager2() {
      this._enabled = false;
      this._zoneCounter = 0;
    }
    ZoneContextManager2.prototype._activeContextFromZone = function(activeZone) {
      return activeZone && activeZone.get(ZONE_CONTEXT_KEY) || ROOT_CONTEXT;
    };
    ZoneContextManager2.prototype._bindFunction = function(context2, target) {
      var manager = this;
      var contextWrapper = function() {
        var _this = this;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return manager.with(context2, function() {
          return target.apply(_this, args);
        });
      };
      Object.defineProperty(contextWrapper, "length", {
        enumerable: false,
        configurable: true,
        writable: false,
        value: target.length
      });
      return contextWrapper;
    };
    ZoneContextManager2.prototype._bindListener = function(context2, obj) {
      var target = obj;
      if (target.__ot_listeners !== void 0) {
        return obj;
      }
      target.__ot_listeners = {};
      if (typeof target.addEventListener === "function") {
        target.addEventListener = this._patchAddEventListener(target, target.addEventListener, context2);
      }
      if (typeof target.removeEventListener === "function") {
        target.removeEventListener = this._patchRemoveEventListener(target, target.removeEventListener);
      }
      return obj;
    };
    ZoneContextManager2.prototype._createZoneName = function() {
      this._zoneCounter++;
      var random = Math.random();
      return this._zoneCounter + "-" + random;
    };
    ZoneContextManager2.prototype._createZone = function(zoneName, context2) {
      var _a3;
      return Zone.current.fork({
        name: zoneName,
        properties: (_a3 = {}, _a3[ZONE_CONTEXT_KEY] = context2, _a3)
      });
    };
    ZoneContextManager2.prototype._getActiveZone = function() {
      return Zone.current;
    };
    ZoneContextManager2.prototype._patchAddEventListener = function(target, original, context2) {
      var contextManager = this;
      return function(event, listener, opts) {
        if (target.__ot_listeners === void 0) {
          target.__ot_listeners = {};
        }
        var listeners = target.__ot_listeners[event];
        if (listeners === void 0) {
          listeners = /* @__PURE__ */ new WeakMap();
          target.__ot_listeners[event] = listeners;
        }
        var patchedListener = contextManager.bind(context2, listener);
        listeners.set(listener, patchedListener);
        return original.call(this, event, patchedListener, opts);
      };
    };
    ZoneContextManager2.prototype._patchRemoveEventListener = function(target, original) {
      return function(event, listener) {
        if (target.__ot_listeners === void 0 || target.__ot_listeners[event] === void 0) {
          return original.call(this, event, listener);
        }
        var events = target.__ot_listeners[event];
        var patchedListener = events.get(listener);
        events.delete(listener);
        return original.call(this, event, patchedListener || listener);
      };
    };
    ZoneContextManager2.prototype.active = function() {
      if (!this._enabled) {
        return ROOT_CONTEXT;
      }
      var activeZone = this._getActiveZone();
      var active = this._activeContextFromZone(activeZone);
      if (active) {
        return active;
      }
      return ROOT_CONTEXT;
    };
    ZoneContextManager2.prototype.bind = function(context2, target) {
      if (context2 === void 0) {
        context2 = this.active();
      }
      if (typeof target === "function") {
        return this._bindFunction(context2, target);
      } else if (isListenerObject(target)) {
        this._bindListener(context2, target);
      }
      return target;
    };
    ZoneContextManager2.prototype.disable = function() {
      this._enabled = false;
      return this;
    };
    ZoneContextManager2.prototype.enable = function() {
      this._enabled = true;
      return this;
    };
    ZoneContextManager2.prototype.with = function(context2, fn, thisArg) {
      var args = [];
      for (var _i = 3; _i < arguments.length; _i++) {
        args[_i - 3] = arguments[_i];
      }
      var zoneName = this._createZoneName();
      var newZone = this._createZone(zoneName, context2);
      return newZone.run(fn, thisArg, args);
    };
    return ZoneContextManager2;
  }()
);

// node_modules/zone.js/fesm2015/zone.js
var global2 = globalThis;
function __symbol__(name) {
  const symbolPrefix = global2["__Zone_symbol_prefix"] || "__zone_symbol__";
  return symbolPrefix + name;
}
function initZone() {
  const performance5 = global2["performance"];
  function mark(name) {
    performance5 && performance5["mark"] && performance5["mark"](name);
  }
  function performanceMeasure(name, label) {
    performance5 && performance5["measure"] && performance5["measure"](name, label);
  }
  mark("Zone");
  class ZoneImpl {
    static {
      this.__symbol__ = __symbol__;
    }
    static assertZonePatched() {
      if (global2["Promise"] !== patches["ZoneAwarePromise"]) {
        throw new Error("Zone.js has detected that ZoneAwarePromise `(window|global).Promise` has been overwritten.\nMost likely cause is that a Promise polyfill has been loaded after Zone.js (Polyfilling Promise api is not necessary when zone.js is loaded. If you must load one, do so before loading zone.js.)");
      }
    }
    static get root() {
      let zone = ZoneImpl.current;
      while (zone.parent) {
        zone = zone.parent;
      }
      return zone;
    }
    static get current() {
      return _currentZoneFrame.zone;
    }
    static get currentTask() {
      return _currentTask;
    }
    // tslint:disable-next-line:require-internal-with-underscore
    static __load_patch(name, fn, ignoreDuplicate = false) {
      if (patches.hasOwnProperty(name)) {
        const checkDuplicate = global2[__symbol__("forceDuplicateZoneCheck")] === true;
        if (!ignoreDuplicate && checkDuplicate) {
          throw Error("Already loaded patch: " + name);
        }
      } else if (!global2["__Zone_disable_" + name]) {
        const perfName = "Zone:" + name;
        mark(perfName);
        patches[name] = fn(global2, ZoneImpl, _api);
        performanceMeasure(perfName, perfName);
      }
    }
    get parent() {
      return this._parent;
    }
    get name() {
      return this._name;
    }
    constructor(parent, zoneSpec) {
      this._parent = parent;
      this._name = zoneSpec ? zoneSpec.name || "unnamed" : "<root>";
      this._properties = zoneSpec && zoneSpec.properties || {};
      this._zoneDelegate = new _ZoneDelegate(this, this._parent && this._parent._zoneDelegate, zoneSpec);
    }
    get(key) {
      const zone = this.getZoneWith(key);
      if (zone)
        return zone._properties[key];
    }
    getZoneWith(key) {
      let current = this;
      while (current) {
        if (current._properties.hasOwnProperty(key)) {
          return current;
        }
        current = current._parent;
      }
      return null;
    }
    fork(zoneSpec) {
      if (!zoneSpec)
        throw new Error("ZoneSpec required!");
      return this._zoneDelegate.fork(this, zoneSpec);
    }
    wrap(callback, source) {
      if (typeof callback !== "function") {
        throw new Error("Expecting function got: " + callback);
      }
      const _callback = this._zoneDelegate.intercept(this, callback, source);
      const zone = this;
      return function() {
        return zone.runGuarded(_callback, this, arguments, source);
      };
    }
    run(callback, applyThis, applyArgs, source) {
      _currentZoneFrame = { parent: _currentZoneFrame, zone: this };
      try {
        return this._zoneDelegate.invoke(this, callback, applyThis, applyArgs, source);
      } finally {
        _currentZoneFrame = _currentZoneFrame.parent;
      }
    }
    runGuarded(callback, applyThis = null, applyArgs, source) {
      _currentZoneFrame = { parent: _currentZoneFrame, zone: this };
      try {
        try {
          return this._zoneDelegate.invoke(this, callback, applyThis, applyArgs, source);
        } catch (error) {
          if (this._zoneDelegate.handleError(this, error)) {
            throw error;
          }
        }
      } finally {
        _currentZoneFrame = _currentZoneFrame.parent;
      }
    }
    runTask(task, applyThis, applyArgs) {
      if (task.zone != this) {
        throw new Error("A task can only be run in the zone of creation! (Creation: " + (task.zone || NO_ZONE).name + "; Execution: " + this.name + ")");
      }
      const zoneTask = task;
      const { type, data: { isPeriodic = false, isRefreshable = false } = {} } = task;
      if (task.state === notScheduled && (type === eventTask || type === macroTask)) {
        return;
      }
      const reEntryGuard = task.state != running;
      reEntryGuard && zoneTask._transitionTo(running, scheduled);
      const previousTask = _currentTask;
      _currentTask = zoneTask;
      _currentZoneFrame = { parent: _currentZoneFrame, zone: this };
      try {
        if (type == macroTask && task.data && !isPeriodic && !isRefreshable) {
          task.cancelFn = void 0;
        }
        try {
          return this._zoneDelegate.invokeTask(this, zoneTask, applyThis, applyArgs);
        } catch (error) {
          if (this._zoneDelegate.handleError(this, error)) {
            throw error;
          }
        }
      } finally {
        const state = task.state;
        if (state !== notScheduled && state !== unknown) {
          if (type == eventTask || isPeriodic || isRefreshable && state === scheduling) {
            reEntryGuard && zoneTask._transitionTo(scheduled, running, scheduling);
          } else {
            const zoneDelegates = zoneTask._zoneDelegates;
            this._updateTaskCount(zoneTask, -1);
            reEntryGuard && zoneTask._transitionTo(notScheduled, running, notScheduled);
            if (isRefreshable) {
              zoneTask._zoneDelegates = zoneDelegates;
            }
          }
        }
        _currentZoneFrame = _currentZoneFrame.parent;
        _currentTask = previousTask;
      }
    }
    scheduleTask(task) {
      if (task.zone && task.zone !== this) {
        let newZone = this;
        while (newZone) {
          if (newZone === task.zone) {
            throw Error(`can not reschedule task to ${this.name} which is descendants of the original zone ${task.zone.name}`);
          }
          newZone = newZone.parent;
        }
      }
      task._transitionTo(scheduling, notScheduled);
      const zoneDelegates = [];
      task._zoneDelegates = zoneDelegates;
      task._zone = this;
      try {
        task = this._zoneDelegate.scheduleTask(this, task);
      } catch (err) {
        task._transitionTo(unknown, scheduling, notScheduled);
        this._zoneDelegate.handleError(this, err);
        throw err;
      }
      if (task._zoneDelegates === zoneDelegates) {
        this._updateTaskCount(task, 1);
      }
      if (task.state == scheduling) {
        task._transitionTo(scheduled, scheduling);
      }
      return task;
    }
    scheduleMicroTask(source, callback, data, customSchedule) {
      return this.scheduleTask(new ZoneTask(microTask, source, callback, data, customSchedule, void 0));
    }
    scheduleMacroTask(source, callback, data, customSchedule, customCancel) {
      return this.scheduleTask(new ZoneTask(macroTask, source, callback, data, customSchedule, customCancel));
    }
    scheduleEventTask(source, callback, data, customSchedule, customCancel) {
      return this.scheduleTask(new ZoneTask(eventTask, source, callback, data, customSchedule, customCancel));
    }
    cancelTask(task) {
      if (task.zone != this)
        throw new Error("A task can only be cancelled in the zone of creation! (Creation: " + (task.zone || NO_ZONE).name + "; Execution: " + this.name + ")");
      if (task.state !== scheduled && task.state !== running) {
        return;
      }
      task._transitionTo(canceling, scheduled, running);
      try {
        this._zoneDelegate.cancelTask(this, task);
      } catch (err) {
        task._transitionTo(unknown, canceling);
        this._zoneDelegate.handleError(this, err);
        throw err;
      }
      this._updateTaskCount(task, -1);
      task._transitionTo(notScheduled, canceling);
      task.runCount = -1;
      return task;
    }
    _updateTaskCount(task, count) {
      const zoneDelegates = task._zoneDelegates;
      if (count == -1) {
        task._zoneDelegates = null;
      }
      for (let i4 = 0; i4 < zoneDelegates.length; i4++) {
        zoneDelegates[i4]._updateTaskCount(task.type, count);
      }
    }
  }
  const DELEGATE_ZS = {
    name: "",
    onHasTask: (delegate, _2, target, hasTaskState) => delegate.hasTask(target, hasTaskState),
    onScheduleTask: (delegate, _2, target, task) => delegate.scheduleTask(target, task),
    onInvokeTask: (delegate, _2, target, task, applyThis, applyArgs) => delegate.invokeTask(target, task, applyThis, applyArgs),
    onCancelTask: (delegate, _2, target, task) => delegate.cancelTask(target, task)
  };
  class _ZoneDelegate {
    get zone() {
      return this._zone;
    }
    constructor(zone, parentDelegate, zoneSpec) {
      this._taskCounts = {
        "microTask": 0,
        "macroTask": 0,
        "eventTask": 0
      };
      this._zone = zone;
      this._parentDelegate = parentDelegate;
      this._forkZS = zoneSpec && (zoneSpec && zoneSpec.onFork ? zoneSpec : parentDelegate._forkZS);
      this._forkDlgt = zoneSpec && (zoneSpec.onFork ? parentDelegate : parentDelegate._forkDlgt);
      this._forkCurrZone = zoneSpec && (zoneSpec.onFork ? this._zone : parentDelegate._forkCurrZone);
      this._interceptZS = zoneSpec && (zoneSpec.onIntercept ? zoneSpec : parentDelegate._interceptZS);
      this._interceptDlgt = zoneSpec && (zoneSpec.onIntercept ? parentDelegate : parentDelegate._interceptDlgt);
      this._interceptCurrZone = zoneSpec && (zoneSpec.onIntercept ? this._zone : parentDelegate._interceptCurrZone);
      this._invokeZS = zoneSpec && (zoneSpec.onInvoke ? zoneSpec : parentDelegate._invokeZS);
      this._invokeDlgt = zoneSpec && (zoneSpec.onInvoke ? parentDelegate : parentDelegate._invokeDlgt);
      this._invokeCurrZone = zoneSpec && (zoneSpec.onInvoke ? this._zone : parentDelegate._invokeCurrZone);
      this._handleErrorZS = zoneSpec && (zoneSpec.onHandleError ? zoneSpec : parentDelegate._handleErrorZS);
      this._handleErrorDlgt = zoneSpec && (zoneSpec.onHandleError ? parentDelegate : parentDelegate._handleErrorDlgt);
      this._handleErrorCurrZone = zoneSpec && (zoneSpec.onHandleError ? this._zone : parentDelegate._handleErrorCurrZone);
      this._scheduleTaskZS = zoneSpec && (zoneSpec.onScheduleTask ? zoneSpec : parentDelegate._scheduleTaskZS);
      this._scheduleTaskDlgt = zoneSpec && (zoneSpec.onScheduleTask ? parentDelegate : parentDelegate._scheduleTaskDlgt);
      this._scheduleTaskCurrZone = zoneSpec && (zoneSpec.onScheduleTask ? this._zone : parentDelegate._scheduleTaskCurrZone);
      this._invokeTaskZS = zoneSpec && (zoneSpec.onInvokeTask ? zoneSpec : parentDelegate._invokeTaskZS);
      this._invokeTaskDlgt = zoneSpec && (zoneSpec.onInvokeTask ? parentDelegate : parentDelegate._invokeTaskDlgt);
      this._invokeTaskCurrZone = zoneSpec && (zoneSpec.onInvokeTask ? this._zone : parentDelegate._invokeTaskCurrZone);
      this._cancelTaskZS = zoneSpec && (zoneSpec.onCancelTask ? zoneSpec : parentDelegate._cancelTaskZS);
      this._cancelTaskDlgt = zoneSpec && (zoneSpec.onCancelTask ? parentDelegate : parentDelegate._cancelTaskDlgt);
      this._cancelTaskCurrZone = zoneSpec && (zoneSpec.onCancelTask ? this._zone : parentDelegate._cancelTaskCurrZone);
      this._hasTaskZS = null;
      this._hasTaskDlgt = null;
      this._hasTaskDlgtOwner = null;
      this._hasTaskCurrZone = null;
      const zoneSpecHasTask = zoneSpec && zoneSpec.onHasTask;
      const parentHasTask = parentDelegate && parentDelegate._hasTaskZS;
      if (zoneSpecHasTask || parentHasTask) {
        this._hasTaskZS = zoneSpecHasTask ? zoneSpec : DELEGATE_ZS;
        this._hasTaskDlgt = parentDelegate;
        this._hasTaskDlgtOwner = this;
        this._hasTaskCurrZone = this._zone;
        if (!zoneSpec.onScheduleTask) {
          this._scheduleTaskZS = DELEGATE_ZS;
          this._scheduleTaskDlgt = parentDelegate;
          this._scheduleTaskCurrZone = this._zone;
        }
        if (!zoneSpec.onInvokeTask) {
          this._invokeTaskZS = DELEGATE_ZS;
          this._invokeTaskDlgt = parentDelegate;
          this._invokeTaskCurrZone = this._zone;
        }
        if (!zoneSpec.onCancelTask) {
          this._cancelTaskZS = DELEGATE_ZS;
          this._cancelTaskDlgt = parentDelegate;
          this._cancelTaskCurrZone = this._zone;
        }
      }
    }
    fork(targetZone, zoneSpec) {
      return this._forkZS ? this._forkZS.onFork(this._forkDlgt, this.zone, targetZone, zoneSpec) : new ZoneImpl(targetZone, zoneSpec);
    }
    intercept(targetZone, callback, source) {
      return this._interceptZS ? this._interceptZS.onIntercept(this._interceptDlgt, this._interceptCurrZone, targetZone, callback, source) : callback;
    }
    invoke(targetZone, callback, applyThis, applyArgs, source) {
      return this._invokeZS ? this._invokeZS.onInvoke(this._invokeDlgt, this._invokeCurrZone, targetZone, callback, applyThis, applyArgs, source) : callback.apply(applyThis, applyArgs);
    }
    handleError(targetZone, error) {
      return this._handleErrorZS ? this._handleErrorZS.onHandleError(this._handleErrorDlgt, this._handleErrorCurrZone, targetZone, error) : true;
    }
    scheduleTask(targetZone, task) {
      let returnTask = task;
      if (this._scheduleTaskZS) {
        if (this._hasTaskZS) {
          returnTask._zoneDelegates.push(this._hasTaskDlgtOwner);
        }
        returnTask = this._scheduleTaskZS.onScheduleTask(this._scheduleTaskDlgt, this._scheduleTaskCurrZone, targetZone, task);
        if (!returnTask)
          returnTask = task;
      } else {
        if (task.scheduleFn) {
          task.scheduleFn(task);
        } else if (task.type == microTask) {
          scheduleMicroTask(task);
        } else {
          throw new Error("Task is missing scheduleFn.");
        }
      }
      return returnTask;
    }
    invokeTask(targetZone, task, applyThis, applyArgs) {
      return this._invokeTaskZS ? this._invokeTaskZS.onInvokeTask(this._invokeTaskDlgt, this._invokeTaskCurrZone, targetZone, task, applyThis, applyArgs) : task.callback.apply(applyThis, applyArgs);
    }
    cancelTask(targetZone, task) {
      let value;
      if (this._cancelTaskZS) {
        value = this._cancelTaskZS.onCancelTask(this._cancelTaskDlgt, this._cancelTaskCurrZone, targetZone, task);
      } else {
        if (!task.cancelFn) {
          throw Error("Task is not cancelable");
        }
        value = task.cancelFn(task);
      }
      return value;
    }
    hasTask(targetZone, isEmpty) {
      try {
        this._hasTaskZS && this._hasTaskZS.onHasTask(this._hasTaskDlgt, this._hasTaskCurrZone, targetZone, isEmpty);
      } catch (err) {
        this.handleError(targetZone, err);
      }
    }
    // tslint:disable-next-line:require-internal-with-underscore
    _updateTaskCount(type, count) {
      const counts = this._taskCounts;
      const prev = counts[type];
      const next = counts[type] = prev + count;
      if (next < 0) {
        throw new Error("More tasks executed then were scheduled.");
      }
      if (prev == 0 || next == 0) {
        const isEmpty = {
          microTask: counts["microTask"] > 0,
          macroTask: counts["macroTask"] > 0,
          eventTask: counts["eventTask"] > 0,
          change: type
        };
        this.hasTask(this._zone, isEmpty);
      }
    }
  }
  class ZoneTask {
    constructor(type, source, callback, options, scheduleFn, cancelFn) {
      this._zone = null;
      this.runCount = 0;
      this._zoneDelegates = null;
      this._state = "notScheduled";
      this.type = type;
      this.source = source;
      this.data = options;
      this.scheduleFn = scheduleFn;
      this.cancelFn = cancelFn;
      if (!callback) {
        throw new Error("callback is not defined");
      }
      this.callback = callback;
      const self2 = this;
      if (type === eventTask && options && options.useG) {
        this.invoke = ZoneTask.invokeTask;
      } else {
        this.invoke = function() {
          return ZoneTask.invokeTask.call(global2, self2, this, arguments);
        };
      }
    }
    static invokeTask(task, target, args) {
      if (!task) {
        task = this;
      }
      _numberOfNestedTaskFrames++;
      try {
        task.runCount++;
        return task.zone.runTask(task, target, args);
      } finally {
        if (_numberOfNestedTaskFrames == 1) {
          drainMicroTaskQueue();
        }
        _numberOfNestedTaskFrames--;
      }
    }
    get zone() {
      return this._zone;
    }
    get state() {
      return this._state;
    }
    cancelScheduleRequest() {
      this._transitionTo(notScheduled, scheduling);
    }
    // tslint:disable-next-line:require-internal-with-underscore
    _transitionTo(toState, fromState1, fromState2) {
      if (this._state === fromState1 || this._state === fromState2) {
        this._state = toState;
        if (toState == notScheduled) {
          this._zoneDelegates = null;
        }
      } else {
        throw new Error(`${this.type} '${this.source}': can not transition to '${toState}', expecting state '${fromState1}'${fromState2 ? " or '" + fromState2 + "'" : ""}, was '${this._state}'.`);
      }
    }
    toString() {
      if (this.data && typeof this.data.handleId !== "undefined") {
        return this.data.handleId.toString();
      } else {
        return Object.prototype.toString.call(this);
      }
    }
    // add toJSON method to prevent cyclic error when
    // call JSON.stringify(zoneTask)
    toJSON() {
      return {
        type: this.type,
        state: this.state,
        source: this.source,
        zone: this.zone.name,
        runCount: this.runCount
      };
    }
  }
  const symbolSetTimeout = __symbol__("setTimeout");
  const symbolPromise = __symbol__("Promise");
  const symbolThen = __symbol__("then");
  let _microTaskQueue = [];
  let _isDrainingMicrotaskQueue = false;
  let nativeMicroTaskQueuePromise;
  function nativeScheduleMicroTask(func) {
    if (!nativeMicroTaskQueuePromise) {
      if (global2[symbolPromise]) {
        nativeMicroTaskQueuePromise = global2[symbolPromise].resolve(0);
      }
    }
    if (nativeMicroTaskQueuePromise) {
      let nativeThen = nativeMicroTaskQueuePromise[symbolThen];
      if (!nativeThen) {
        nativeThen = nativeMicroTaskQueuePromise["then"];
      }
      nativeThen.call(nativeMicroTaskQueuePromise, func);
    } else {
      global2[symbolSetTimeout](func, 0);
    }
  }
  function scheduleMicroTask(task) {
    if (_numberOfNestedTaskFrames === 0 && _microTaskQueue.length === 0) {
      nativeScheduleMicroTask(drainMicroTaskQueue);
    }
    task && _microTaskQueue.push(task);
  }
  function drainMicroTaskQueue() {
    if (!_isDrainingMicrotaskQueue) {
      _isDrainingMicrotaskQueue = true;
      while (_microTaskQueue.length) {
        const queue = _microTaskQueue;
        _microTaskQueue = [];
        for (let i4 = 0; i4 < queue.length; i4++) {
          const task = queue[i4];
          try {
            task.zone.runTask(task, null, null);
          } catch (error) {
            _api.onUnhandledError(error);
          }
        }
      }
      _api.microtaskDrainDone();
      _isDrainingMicrotaskQueue = false;
    }
  }
  const NO_ZONE = { name: "NO ZONE" };
  const notScheduled = "notScheduled", scheduling = "scheduling", scheduled = "scheduled", running = "running", canceling = "canceling", unknown = "unknown";
  const microTask = "microTask", macroTask = "macroTask", eventTask = "eventTask";
  const patches = {};
  const _api = {
    symbol: __symbol__,
    currentZoneFrame: () => _currentZoneFrame,
    onUnhandledError: noop,
    microtaskDrainDone: noop,
    scheduleMicroTask,
    showUncaughtError: () => !ZoneImpl[__symbol__("ignoreConsoleErrorUncaughtError")],
    patchEventTarget: () => [],
    patchOnProperties: noop,
    patchMethod: () => noop,
    bindArguments: () => [],
    patchThen: () => noop,
    patchMacroTask: () => noop,
    patchEventPrototype: () => noop,
    isIEOrEdge: () => false,
    getGlobalObjects: () => void 0,
    ObjectDefineProperty: () => noop,
    ObjectGetOwnPropertyDescriptor: () => void 0,
    ObjectCreate: () => void 0,
    ArraySlice: () => [],
    patchClass: () => noop,
    wrapWithCurrentZone: () => noop,
    filterProperties: () => [],
    attachOriginToPatched: () => noop,
    _redefineProperty: () => noop,
    patchCallbacks: () => noop,
    nativeScheduleMicroTask
  };
  let _currentZoneFrame = { parent: null, zone: new ZoneImpl(null, null) };
  let _currentTask = null;
  let _numberOfNestedTaskFrames = 0;
  function noop() {
  }
  performanceMeasure("Zone", "Zone");
  return ZoneImpl;
}
function loadZone() {
  const global3 = globalThis;
  const checkDuplicate = global3[__symbol__("forceDuplicateZoneCheck")] === true;
  if (global3["Zone"] && (checkDuplicate || typeof global3["Zone"].__symbol__ !== "function")) {
    throw new Error("Zone already loaded.");
  }
  global3["Zone"] ??= initZone();
  return global3["Zone"];
}
var ObjectGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var ObjectDefineProperty = Object.defineProperty;
var ObjectGetPrototypeOf = Object.getPrototypeOf;
var ObjectCreate = Object.create;
var ArraySlice = Array.prototype.slice;
var ADD_EVENT_LISTENER_STR = "addEventListener";
var REMOVE_EVENT_LISTENER_STR = "removeEventListener";
var ZONE_SYMBOL_ADD_EVENT_LISTENER = __symbol__(ADD_EVENT_LISTENER_STR);
var ZONE_SYMBOL_REMOVE_EVENT_LISTENER = __symbol__(REMOVE_EVENT_LISTENER_STR);
var TRUE_STR = "true";
var FALSE_STR = "false";
var ZONE_SYMBOL_PREFIX = __symbol__("");
function wrapWithCurrentZone(callback, source) {
  return Zone.current.wrap(callback, source);
}
function scheduleMacroTaskWithCurrentZone(source, callback, data, customSchedule, customCancel) {
  return Zone.current.scheduleMacroTask(source, callback, data, customSchedule, customCancel);
}
var zoneSymbol = __symbol__;
var isWindowExists = typeof window !== "undefined";
var internalWindow = isWindowExists ? window : void 0;
var _global2 = isWindowExists && internalWindow || globalThis;
var REMOVE_ATTRIBUTE = "removeAttribute";
function bindArguments(args, source) {
  for (let i4 = args.length - 1; i4 >= 0; i4--) {
    if (typeof args[i4] === "function") {
      args[i4] = wrapWithCurrentZone(args[i4], source + "_" + i4);
    }
  }
  return args;
}
function patchPrototype(prototype, fnNames) {
  const source = prototype.constructor["name"];
  for (let i4 = 0; i4 < fnNames.length; i4++) {
    const name = fnNames[i4];
    const delegate = prototype[name];
    if (delegate) {
      const prototypeDesc = ObjectGetOwnPropertyDescriptor(prototype, name);
      if (!isPropertyWritable(prototypeDesc)) {
        continue;
      }
      prototype[name] = ((delegate2) => {
        const patched = function() {
          return delegate2.apply(this, bindArguments(arguments, source + "." + name));
        };
        attachOriginToPatched(patched, delegate2);
        return patched;
      })(delegate);
    }
  }
}
function isPropertyWritable(propertyDesc) {
  if (!propertyDesc) {
    return true;
  }
  if (propertyDesc.writable === false) {
    return false;
  }
  return !(typeof propertyDesc.get === "function" && typeof propertyDesc.set === "undefined");
}
var isWebWorker = typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope;
var isNode = !("nw" in _global2) && typeof _global2.process !== "undefined" && _global2.process.toString() === "[object process]";
var isBrowser = !isNode && !isWebWorker && !!(isWindowExists && internalWindow["HTMLElement"]);
var isMix = typeof _global2.process !== "undefined" && _global2.process.toString() === "[object process]" && !isWebWorker && !!(isWindowExists && internalWindow["HTMLElement"]);
var zoneSymbolEventNames$1 = {};
var enableBeforeunloadSymbol = zoneSymbol("enable_beforeunload");
var wrapFn = function(event) {
  event = event || _global2.event;
  if (!event) {
    return;
  }
  let eventNameSymbol = zoneSymbolEventNames$1[event.type];
  if (!eventNameSymbol) {
    eventNameSymbol = zoneSymbolEventNames$1[event.type] = zoneSymbol("ON_PROPERTY" + event.type);
  }
  const target = this || event.target || _global2;
  const listener = target[eventNameSymbol];
  let result;
  if (isBrowser && target === internalWindow && event.type === "error") {
    const errorEvent = event;
    result = listener && listener.call(this, errorEvent.message, errorEvent.filename, errorEvent.lineno, errorEvent.colno, errorEvent.error);
    if (result === true) {
      event.preventDefault();
    }
  } else {
    result = listener && listener.apply(this, arguments);
    if (
      // https://github.com/angular/angular/issues/47579
      // https://www.w3.org/TR/2011/WD-html5-20110525/history.html#beforeunloadevent
      // This is the only specific case we should check for. The spec defines that the
      // `returnValue` attribute represents the message to show the user. When the event
      // is created, this attribute must be set to the empty string.
      event.type === "beforeunload" && // To prevent any breaking changes resulting from this change, given that
      // it was already causing a significant number of failures in G3, we have hidden
      // that behavior behind a global configuration flag. Consumers can enable this
      // flag explicitly if they want the `beforeunload` event to be handled as defined
      // in the specification.
      _global2[enableBeforeunloadSymbol] && // The IDL event definition is `attribute DOMString returnValue`, so we check whether
      // `typeof result` is a string.
      typeof result === "string"
    ) {
      event.returnValue = result;
    } else if (result != void 0 && !result) {
      event.preventDefault();
    }
  }
  return result;
};
function patchProperty(obj, prop, prototype) {
  let desc = ObjectGetOwnPropertyDescriptor(obj, prop);
  if (!desc && prototype) {
    const prototypeDesc = ObjectGetOwnPropertyDescriptor(prototype, prop);
    if (prototypeDesc) {
      desc = { enumerable: true, configurable: true };
    }
  }
  if (!desc || !desc.configurable) {
    return;
  }
  const onPropPatchedSymbol = zoneSymbol("on" + prop + "patched");
  if (obj.hasOwnProperty(onPropPatchedSymbol) && obj[onPropPatchedSymbol]) {
    return;
  }
  delete desc.writable;
  delete desc.value;
  const originalDescGet = desc.get;
  const originalDescSet = desc.set;
  const eventName = prop.slice(2);
  let eventNameSymbol = zoneSymbolEventNames$1[eventName];
  if (!eventNameSymbol) {
    eventNameSymbol = zoneSymbolEventNames$1[eventName] = zoneSymbol("ON_PROPERTY" + eventName);
  }
  desc.set = function(newValue) {
    let target = this;
    if (!target && obj === _global2) {
      target = _global2;
    }
    if (!target) {
      return;
    }
    const previousValue = target[eventNameSymbol];
    if (typeof previousValue === "function") {
      target.removeEventListener(eventName, wrapFn);
    }
    originalDescSet && originalDescSet.call(target, null);
    target[eventNameSymbol] = newValue;
    if (typeof newValue === "function") {
      target.addEventListener(eventName, wrapFn, false);
    }
  };
  desc.get = function() {
    let target = this;
    if (!target && obj === _global2) {
      target = _global2;
    }
    if (!target) {
      return null;
    }
    const listener = target[eventNameSymbol];
    if (listener) {
      return listener;
    } else if (originalDescGet) {
      let value = originalDescGet.call(this);
      if (value) {
        desc.set.call(this, value);
        if (typeof target[REMOVE_ATTRIBUTE] === "function") {
          target.removeAttribute(prop);
        }
        return value;
      }
    }
    return null;
  };
  ObjectDefineProperty(obj, prop, desc);
  obj[onPropPatchedSymbol] = true;
}
function patchOnProperties(obj, properties, prototype) {
  if (properties) {
    for (let i4 = 0; i4 < properties.length; i4++) {
      patchProperty(obj, "on" + properties[i4], prototype);
    }
  } else {
    const onProperties = [];
    for (const prop in obj) {
      if (prop.slice(0, 2) == "on") {
        onProperties.push(prop);
      }
    }
    for (let j = 0; j < onProperties.length; j++) {
      patchProperty(obj, onProperties[j], prototype);
    }
  }
}
var originalInstanceKey = zoneSymbol("originalInstance");
function patchClass(className) {
  const OriginalClass = _global2[className];
  if (!OriginalClass)
    return;
  _global2[zoneSymbol(className)] = OriginalClass;
  _global2[className] = function() {
    const a4 = bindArguments(arguments, className);
    switch (a4.length) {
      case 0:
        this[originalInstanceKey] = new OriginalClass();
        break;
      case 1:
        this[originalInstanceKey] = new OriginalClass(a4[0]);
        break;
      case 2:
        this[originalInstanceKey] = new OriginalClass(a4[0], a4[1]);
        break;
      case 3:
        this[originalInstanceKey] = new OriginalClass(a4[0], a4[1], a4[2]);
        break;
      case 4:
        this[originalInstanceKey] = new OriginalClass(a4[0], a4[1], a4[2], a4[3]);
        break;
      default:
        throw new Error("Arg list too long.");
    }
  };
  attachOriginToPatched(_global2[className], OriginalClass);
  const instance = new OriginalClass(function() {
  });
  let prop;
  for (prop in instance) {
    if (className === "XMLHttpRequest" && prop === "responseBlob")
      continue;
    (function(prop2) {
      if (typeof instance[prop2] === "function") {
        _global2[className].prototype[prop2] = function() {
          return this[originalInstanceKey][prop2].apply(this[originalInstanceKey], arguments);
        };
      } else {
        ObjectDefineProperty(_global2[className].prototype, prop2, {
          set: function(fn) {
            if (typeof fn === "function") {
              this[originalInstanceKey][prop2] = wrapWithCurrentZone(fn, className + "." + prop2);
              attachOriginToPatched(this[originalInstanceKey][prop2], fn);
            } else {
              this[originalInstanceKey][prop2] = fn;
            }
          },
          get: function() {
            return this[originalInstanceKey][prop2];
          }
        });
      }
    })(prop);
  }
  for (prop in OriginalClass) {
    if (prop !== "prototype" && OriginalClass.hasOwnProperty(prop)) {
      _global2[className][prop] = OriginalClass[prop];
    }
  }
}
function patchMethod(target, name, patchFn) {
  let proto = target;
  while (proto && !proto.hasOwnProperty(name)) {
    proto = ObjectGetPrototypeOf(proto);
  }
  if (!proto && target[name]) {
    proto = target;
  }
  const delegateName = zoneSymbol(name);
  let delegate = null;
  if (proto && (!(delegate = proto[delegateName]) || !proto.hasOwnProperty(delegateName))) {
    delegate = proto[delegateName] = proto[name];
    const desc = proto && ObjectGetOwnPropertyDescriptor(proto, name);
    if (isPropertyWritable(desc)) {
      const patchDelegate = patchFn(delegate, delegateName, name);
      proto[name] = function() {
        return patchDelegate(this, arguments);
      };
      attachOriginToPatched(proto[name], delegate);
    }
  }
  return delegate;
}
function patchMacroTask(obj, funcName, metaCreator) {
  let setNative = null;
  function scheduleTask(task) {
    const data = task.data;
    data.args[data.cbIdx] = function() {
      task.invoke.apply(this, arguments);
    };
    setNative.apply(data.target, data.args);
    return task;
  }
  setNative = patchMethod(obj, funcName, (delegate) => function(self2, args) {
    const meta = metaCreator(self2, args);
    if (meta.cbIdx >= 0 && typeof args[meta.cbIdx] === "function") {
      return scheduleMacroTaskWithCurrentZone(meta.name, args[meta.cbIdx], meta, scheduleTask);
    } else {
      return delegate.apply(self2, args);
    }
  });
}
function attachOriginToPatched(patched, original) {
  patched[zoneSymbol("OriginalDelegate")] = original;
}
var isDetectedIEOrEdge = false;
var ieOrEdge = false;
function isIE() {
  try {
    const ua = internalWindow.navigator.userAgent;
    if (ua.indexOf("MSIE ") !== -1 || ua.indexOf("Trident/") !== -1) {
      return true;
    }
  } catch (error) {
  }
  return false;
}
function isIEOrEdge() {
  if (isDetectedIEOrEdge) {
    return ieOrEdge;
  }
  isDetectedIEOrEdge = true;
  try {
    const ua = internalWindow.navigator.userAgent;
    if (ua.indexOf("MSIE ") !== -1 || ua.indexOf("Trident/") !== -1 || ua.indexOf("Edge/") !== -1) {
      ieOrEdge = true;
    }
  } catch (error) {
  }
  return ieOrEdge;
}
function isFunction2(value) {
  return typeof value === "function";
}
function isNumber(value) {
  return typeof value === "number";
}
var passiveSupported = false;
if (typeof window !== "undefined") {
  try {
    const options = Object.defineProperty({}, "passive", {
      get: function() {
        passiveSupported = true;
      }
    });
    window.addEventListener("test", options, options);
    window.removeEventListener("test", options, options);
  } catch (err) {
    passiveSupported = false;
  }
}
var OPTIMIZED_ZONE_EVENT_TASK_DATA = {
  useG: true
};
var zoneSymbolEventNames = {};
var globalSources = {};
var EVENT_NAME_SYMBOL_REGX = new RegExp("^" + ZONE_SYMBOL_PREFIX + "(\\w+)(true|false)$");
var IMMEDIATE_PROPAGATION_SYMBOL = zoneSymbol("propagationStopped");
function prepareEventNames(eventName, eventNameToString) {
  const falseEventName = (eventNameToString ? eventNameToString(eventName) : eventName) + FALSE_STR;
  const trueEventName = (eventNameToString ? eventNameToString(eventName) : eventName) + TRUE_STR;
  const symbol = ZONE_SYMBOL_PREFIX + falseEventName;
  const symbolCapture = ZONE_SYMBOL_PREFIX + trueEventName;
  zoneSymbolEventNames[eventName] = {};
  zoneSymbolEventNames[eventName][FALSE_STR] = symbol;
  zoneSymbolEventNames[eventName][TRUE_STR] = symbolCapture;
}
function patchEventTarget(_global4, api, apis, patchOptions) {
  const ADD_EVENT_LISTENER = patchOptions && patchOptions.add || ADD_EVENT_LISTENER_STR;
  const REMOVE_EVENT_LISTENER = patchOptions && patchOptions.rm || REMOVE_EVENT_LISTENER_STR;
  const LISTENERS_EVENT_LISTENER = patchOptions && patchOptions.listeners || "eventListeners";
  const REMOVE_ALL_LISTENERS_EVENT_LISTENER = patchOptions && patchOptions.rmAll || "removeAllListeners";
  const zoneSymbolAddEventListener = zoneSymbol(ADD_EVENT_LISTENER);
  const ADD_EVENT_LISTENER_SOURCE = "." + ADD_EVENT_LISTENER + ":";
  const PREPEND_EVENT_LISTENER = "prependListener";
  const PREPEND_EVENT_LISTENER_SOURCE = "." + PREPEND_EVENT_LISTENER + ":";
  const invokeTask = function(task, target, event) {
    if (task.isRemoved) {
      return;
    }
    const delegate = task.callback;
    if (typeof delegate === "object" && delegate.handleEvent) {
      task.callback = (event2) => delegate.handleEvent(event2);
      task.originalDelegate = delegate;
    }
    let error;
    try {
      task.invoke(task, target, [event]);
    } catch (err) {
      error = err;
    }
    const options = task.options;
    if (options && typeof options === "object" && options.once) {
      const delegate2 = task.originalDelegate ? task.originalDelegate : task.callback;
      target[REMOVE_EVENT_LISTENER].call(target, event.type, delegate2, options);
    }
    return error;
  };
  function globalCallback(context2, event, isCapture) {
    event = event || _global4.event;
    if (!event) {
      return;
    }
    const target = context2 || event.target || _global4;
    const tasks = target[zoneSymbolEventNames[event.type][isCapture ? TRUE_STR : FALSE_STR]];
    if (tasks) {
      const errors = [];
      if (tasks.length === 1) {
        const err = invokeTask(tasks[0], target, event);
        err && errors.push(err);
      } else {
        const copyTasks = tasks.slice();
        for (let i4 = 0; i4 < copyTasks.length; i4++) {
          if (event && event[IMMEDIATE_PROPAGATION_SYMBOL] === true) {
            break;
          }
          const err = invokeTask(copyTasks[i4], target, event);
          err && errors.push(err);
        }
      }
      if (errors.length === 1) {
        throw errors[0];
      } else {
        for (let i4 = 0; i4 < errors.length; i4++) {
          const err = errors[i4];
          api.nativeScheduleMicroTask(() => {
            throw err;
          });
        }
      }
    }
  }
  const globalZoneAwareCallback = function(event) {
    return globalCallback(this, event, false);
  };
  const globalZoneAwareCaptureCallback = function(event) {
    return globalCallback(this, event, true);
  };
  function patchEventTargetMethods(obj, patchOptions2) {
    if (!obj) {
      return false;
    }
    let useGlobalCallback = true;
    if (patchOptions2 && patchOptions2.useG !== void 0) {
      useGlobalCallback = patchOptions2.useG;
    }
    const validateHandler = patchOptions2 && patchOptions2.vh;
    let checkDuplicate = true;
    if (patchOptions2 && patchOptions2.chkDup !== void 0) {
      checkDuplicate = patchOptions2.chkDup;
    }
    let returnTarget = false;
    if (patchOptions2 && patchOptions2.rt !== void 0) {
      returnTarget = patchOptions2.rt;
    }
    let proto = obj;
    while (proto && !proto.hasOwnProperty(ADD_EVENT_LISTENER)) {
      proto = ObjectGetPrototypeOf(proto);
    }
    if (!proto && obj[ADD_EVENT_LISTENER]) {
      proto = obj;
    }
    if (!proto) {
      return false;
    }
    if (proto[zoneSymbolAddEventListener]) {
      return false;
    }
    const eventNameToString = patchOptions2 && patchOptions2.eventNameToString;
    const taskData = {};
    const nativeAddEventListener = proto[zoneSymbolAddEventListener] = proto[ADD_EVENT_LISTENER];
    const nativeRemoveEventListener = proto[zoneSymbol(REMOVE_EVENT_LISTENER)] = proto[REMOVE_EVENT_LISTENER];
    const nativeListeners = proto[zoneSymbol(LISTENERS_EVENT_LISTENER)] = proto[LISTENERS_EVENT_LISTENER];
    const nativeRemoveAllListeners = proto[zoneSymbol(REMOVE_ALL_LISTENERS_EVENT_LISTENER)] = proto[REMOVE_ALL_LISTENERS_EVENT_LISTENER];
    let nativePrependEventListener;
    if (patchOptions2 && patchOptions2.prepend) {
      nativePrependEventListener = proto[zoneSymbol(patchOptions2.prepend)] = proto[patchOptions2.prepend];
    }
    function buildEventListenerOptions(options, passive) {
      if (!passiveSupported && typeof options === "object" && options) {
        return !!options.capture;
      }
      if (!passiveSupported || !passive) {
        return options;
      }
      if (typeof options === "boolean") {
        return { capture: options, passive: true };
      }
      if (!options) {
        return { passive: true };
      }
      if (typeof options === "object" && options.passive !== false) {
        return { ...options, passive: true };
      }
      return options;
    }
    const customScheduleGlobal = function(task) {
      if (taskData.isExisting) {
        return;
      }
      return nativeAddEventListener.call(taskData.target, taskData.eventName, taskData.capture ? globalZoneAwareCaptureCallback : globalZoneAwareCallback, taskData.options);
    };
    const customCancelGlobal = function(task) {
      if (!task.isRemoved) {
        const symbolEventNames = zoneSymbolEventNames[task.eventName];
        let symbolEventName;
        if (symbolEventNames) {
          symbolEventName = symbolEventNames[task.capture ? TRUE_STR : FALSE_STR];
        }
        const existingTasks = symbolEventName && task.target[symbolEventName];
        if (existingTasks) {
          for (let i4 = 0; i4 < existingTasks.length; i4++) {
            const existingTask = existingTasks[i4];
            if (existingTask === task) {
              existingTasks.splice(i4, 1);
              task.isRemoved = true;
              if (task.removeAbortListener) {
                task.removeAbortListener();
                task.removeAbortListener = null;
              }
              if (existingTasks.length === 0) {
                task.allRemoved = true;
                task.target[symbolEventName] = null;
              }
              break;
            }
          }
        }
      }
      if (!task.allRemoved) {
        return;
      }
      return nativeRemoveEventListener.call(task.target, task.eventName, task.capture ? globalZoneAwareCaptureCallback : globalZoneAwareCallback, task.options);
    };
    const customScheduleNonGlobal = function(task) {
      return nativeAddEventListener.call(taskData.target, taskData.eventName, task.invoke, taskData.options);
    };
    const customSchedulePrepend = function(task) {
      return nativePrependEventListener.call(taskData.target, taskData.eventName, task.invoke, taskData.options);
    };
    const customCancelNonGlobal = function(task) {
      return nativeRemoveEventListener.call(task.target, task.eventName, task.invoke, task.options);
    };
    const customSchedule = useGlobalCallback ? customScheduleGlobal : customScheduleNonGlobal;
    const customCancel = useGlobalCallback ? customCancelGlobal : customCancelNonGlobal;
    const compareTaskCallbackVsDelegate = function(task, delegate) {
      const typeOfDelegate = typeof delegate;
      return typeOfDelegate === "function" && task.callback === delegate || typeOfDelegate === "object" && task.originalDelegate === delegate;
    };
    const compare = patchOptions2 && patchOptions2.diff ? patchOptions2.diff : compareTaskCallbackVsDelegate;
    const unpatchedEvents = Zone[zoneSymbol("UNPATCHED_EVENTS")];
    const passiveEvents = _global4[zoneSymbol("PASSIVE_EVENTS")];
    function copyEventListenerOptions(options) {
      if (typeof options === "object" && options !== null) {
        const newOptions = { ...options };
        if (options.signal) {
          newOptions.signal = options.signal;
        }
        return newOptions;
      }
      return options;
    }
    const makeAddListener = function(nativeListener, addSource, customScheduleFn, customCancelFn, returnTarget2 = false, prepend = false) {
      return function() {
        const target = this || _global4;
        let eventName = arguments[0];
        if (patchOptions2 && patchOptions2.transferEventName) {
          eventName = patchOptions2.transferEventName(eventName);
        }
        let delegate = arguments[1];
        if (!delegate) {
          return nativeListener.apply(this, arguments);
        }
        if (isNode && eventName === "uncaughtException") {
          return nativeListener.apply(this, arguments);
        }
        let isHandleEvent = false;
        if (typeof delegate !== "function") {
          if (!delegate.handleEvent) {
            return nativeListener.apply(this, arguments);
          }
          isHandleEvent = true;
        }
        if (validateHandler && !validateHandler(nativeListener, delegate, target, arguments)) {
          return;
        }
        const passive = passiveSupported && !!passiveEvents && passiveEvents.indexOf(eventName) !== -1;
        const options = copyEventListenerOptions(buildEventListenerOptions(arguments[2], passive));
        const signal = options?.signal;
        if (signal?.aborted) {
          return;
        }
        if (unpatchedEvents) {
          for (let i4 = 0; i4 < unpatchedEvents.length; i4++) {
            if (eventName === unpatchedEvents[i4]) {
              if (passive) {
                return nativeListener.call(target, eventName, delegate, options);
              } else {
                return nativeListener.apply(this, arguments);
              }
            }
          }
        }
        const capture = !options ? false : typeof options === "boolean" ? true : options.capture;
        const once = options && typeof options === "object" ? options.once : false;
        const zone = Zone.current;
        let symbolEventNames = zoneSymbolEventNames[eventName];
        if (!symbolEventNames) {
          prepareEventNames(eventName, eventNameToString);
          symbolEventNames = zoneSymbolEventNames[eventName];
        }
        const symbolEventName = symbolEventNames[capture ? TRUE_STR : FALSE_STR];
        let existingTasks = target[symbolEventName];
        let isExisting = false;
        if (existingTasks) {
          isExisting = true;
          if (checkDuplicate) {
            for (let i4 = 0; i4 < existingTasks.length; i4++) {
              if (compare(existingTasks[i4], delegate)) {
                return;
              }
            }
          }
        } else {
          existingTasks = target[symbolEventName] = [];
        }
        let source;
        const constructorName = target.constructor["name"];
        const targetSource = globalSources[constructorName];
        if (targetSource) {
          source = targetSource[eventName];
        }
        if (!source) {
          source = constructorName + addSource + (eventNameToString ? eventNameToString(eventName) : eventName);
        }
        taskData.options = options;
        if (once) {
          taskData.options.once = false;
        }
        taskData.target = target;
        taskData.capture = capture;
        taskData.eventName = eventName;
        taskData.isExisting = isExisting;
        const data = useGlobalCallback ? OPTIMIZED_ZONE_EVENT_TASK_DATA : void 0;
        if (data) {
          data.taskData = taskData;
        }
        if (signal) {
          taskData.options.signal = void 0;
        }
        const task = zone.scheduleEventTask(source, delegate, data, customScheduleFn, customCancelFn);
        if (signal) {
          taskData.options.signal = signal;
          const onAbort = () => task.zone.cancelTask(task);
          nativeListener.call(signal, "abort", onAbort, { once: true });
          task.removeAbortListener = () => signal.removeEventListener("abort", onAbort);
        }
        taskData.target = null;
        if (data) {
          data.taskData = null;
        }
        if (once) {
          taskData.options.once = true;
        }
        if (!(!passiveSupported && typeof task.options === "boolean")) {
          task.options = options;
        }
        task.target = target;
        task.capture = capture;
        task.eventName = eventName;
        if (isHandleEvent) {
          task.originalDelegate = delegate;
        }
        if (!prepend) {
          existingTasks.push(task);
        } else {
          existingTasks.unshift(task);
        }
        if (returnTarget2) {
          return target;
        }
      };
    };
    proto[ADD_EVENT_LISTENER] = makeAddListener(nativeAddEventListener, ADD_EVENT_LISTENER_SOURCE, customSchedule, customCancel, returnTarget);
    if (nativePrependEventListener) {
      proto[PREPEND_EVENT_LISTENER] = makeAddListener(nativePrependEventListener, PREPEND_EVENT_LISTENER_SOURCE, customSchedulePrepend, customCancel, returnTarget, true);
    }
    proto[REMOVE_EVENT_LISTENER] = function() {
      const target = this || _global4;
      let eventName = arguments[0];
      if (patchOptions2 && patchOptions2.transferEventName) {
        eventName = patchOptions2.transferEventName(eventName);
      }
      const options = arguments[2];
      const capture = !options ? false : typeof options === "boolean" ? true : options.capture;
      const delegate = arguments[1];
      if (!delegate) {
        return nativeRemoveEventListener.apply(this, arguments);
      }
      if (validateHandler && !validateHandler(nativeRemoveEventListener, delegate, target, arguments)) {
        return;
      }
      const symbolEventNames = zoneSymbolEventNames[eventName];
      let symbolEventName;
      if (symbolEventNames) {
        symbolEventName = symbolEventNames[capture ? TRUE_STR : FALSE_STR];
      }
      const existingTasks = symbolEventName && target[symbolEventName];
      if (existingTasks) {
        for (let i4 = 0; i4 < existingTasks.length; i4++) {
          const existingTask = existingTasks[i4];
          if (compare(existingTask, delegate)) {
            existingTasks.splice(i4, 1);
            existingTask.isRemoved = true;
            if (existingTasks.length === 0) {
              existingTask.allRemoved = true;
              target[symbolEventName] = null;
              if (!capture && typeof eventName === "string") {
                const onPropertySymbol = ZONE_SYMBOL_PREFIX + "ON_PROPERTY" + eventName;
                target[onPropertySymbol] = null;
              }
            }
            existingTask.zone.cancelTask(existingTask);
            if (returnTarget) {
              return target;
            }
            return;
          }
        }
      }
      return nativeRemoveEventListener.apply(this, arguments);
    };
    proto[LISTENERS_EVENT_LISTENER] = function() {
      const target = this || _global4;
      let eventName = arguments[0];
      if (patchOptions2 && patchOptions2.transferEventName) {
        eventName = patchOptions2.transferEventName(eventName);
      }
      const listeners = [];
      const tasks = findEventTasks(target, eventNameToString ? eventNameToString(eventName) : eventName);
      for (let i4 = 0; i4 < tasks.length; i4++) {
        const task = tasks[i4];
        let delegate = task.originalDelegate ? task.originalDelegate : task.callback;
        listeners.push(delegate);
      }
      return listeners;
    };
    proto[REMOVE_ALL_LISTENERS_EVENT_LISTENER] = function() {
      const target = this || _global4;
      let eventName = arguments[0];
      if (!eventName) {
        const keys = Object.keys(target);
        for (let i4 = 0; i4 < keys.length; i4++) {
          const prop = keys[i4];
          const match = EVENT_NAME_SYMBOL_REGX.exec(prop);
          let evtName = match && match[1];
          if (evtName && evtName !== "removeListener") {
            this[REMOVE_ALL_LISTENERS_EVENT_LISTENER].call(this, evtName);
          }
        }
        this[REMOVE_ALL_LISTENERS_EVENT_LISTENER].call(this, "removeListener");
      } else {
        if (patchOptions2 && patchOptions2.transferEventName) {
          eventName = patchOptions2.transferEventName(eventName);
        }
        const symbolEventNames = zoneSymbolEventNames[eventName];
        if (symbolEventNames) {
          const symbolEventName = symbolEventNames[FALSE_STR];
          const symbolCaptureEventName = symbolEventNames[TRUE_STR];
          const tasks = target[symbolEventName];
          const captureTasks = target[symbolCaptureEventName];
          if (tasks) {
            const removeTasks = tasks.slice();
            for (let i4 = 0; i4 < removeTasks.length; i4++) {
              const task = removeTasks[i4];
              let delegate = task.originalDelegate ? task.originalDelegate : task.callback;
              this[REMOVE_EVENT_LISTENER].call(this, eventName, delegate, task.options);
            }
          }
          if (captureTasks) {
            const removeTasks = captureTasks.slice();
            for (let i4 = 0; i4 < removeTasks.length; i4++) {
              const task = removeTasks[i4];
              let delegate = task.originalDelegate ? task.originalDelegate : task.callback;
              this[REMOVE_EVENT_LISTENER].call(this, eventName, delegate, task.options);
            }
          }
        }
      }
      if (returnTarget) {
        return this;
      }
    };
    attachOriginToPatched(proto[ADD_EVENT_LISTENER], nativeAddEventListener);
    attachOriginToPatched(proto[REMOVE_EVENT_LISTENER], nativeRemoveEventListener);
    if (nativeRemoveAllListeners) {
      attachOriginToPatched(proto[REMOVE_ALL_LISTENERS_EVENT_LISTENER], nativeRemoveAllListeners);
    }
    if (nativeListeners) {
      attachOriginToPatched(proto[LISTENERS_EVENT_LISTENER], nativeListeners);
    }
    return true;
  }
  let results = [];
  for (let i4 = 0; i4 < apis.length; i4++) {
    results[i4] = patchEventTargetMethods(apis[i4], patchOptions);
  }
  return results;
}
function findEventTasks(target, eventName) {
  if (!eventName) {
    const foundTasks = [];
    for (let prop in target) {
      const match = EVENT_NAME_SYMBOL_REGX.exec(prop);
      let evtName = match && match[1];
      if (evtName && (!eventName || evtName === eventName)) {
        const tasks = target[prop];
        if (tasks) {
          for (let i4 = 0; i4 < tasks.length; i4++) {
            foundTasks.push(tasks[i4]);
          }
        }
      }
    }
    return foundTasks;
  }
  let symbolEventName = zoneSymbolEventNames[eventName];
  if (!symbolEventName) {
    prepareEventNames(eventName);
    symbolEventName = zoneSymbolEventNames[eventName];
  }
  const captureFalseTasks = target[symbolEventName[FALSE_STR]];
  const captureTrueTasks = target[symbolEventName[TRUE_STR]];
  if (!captureFalseTasks) {
    return captureTrueTasks ? captureTrueTasks.slice() : [];
  } else {
    return captureTrueTasks ? captureFalseTasks.concat(captureTrueTasks) : captureFalseTasks.slice();
  }
}
function patchEventPrototype(global3, api) {
  const Event = global3["Event"];
  if (Event && Event.prototype) {
    api.patchMethod(Event.prototype, "stopImmediatePropagation", (delegate) => function(self2, args) {
      self2[IMMEDIATE_PROPAGATION_SYMBOL] = true;
      delegate && delegate.apply(self2, args);
    });
  }
}
function patchQueueMicrotask(global3, api) {
  api.patchMethod(global3, "queueMicrotask", (delegate) => {
    return function(self2, args) {
      Zone.current.scheduleMicroTask("queueMicrotask", args[0]);
    };
  });
}
var taskSymbol = zoneSymbol("zoneTask");
function patchTimer(window2, setName, cancelName, nameSuffix) {
  let setNative = null;
  let clearNative = null;
  setName += nameSuffix;
  cancelName += nameSuffix;
  const tasksByHandleId = {};
  function scheduleTask(task) {
    const data = task.data;
    data.args[0] = function() {
      return task.invoke.apply(this, arguments);
    };
    const handleOrId = setNative.apply(window2, data.args);
    if (isNumber(handleOrId)) {
      data.handleId = handleOrId;
    } else {
      data.handle = handleOrId;
      data.isRefreshable = isFunction2(handleOrId.refresh);
    }
    return task;
  }
  function clearTask(task) {
    const { handle, handleId } = task.data;
    return clearNative.call(window2, handle ?? handleId);
  }
  setNative = patchMethod(window2, setName, (delegate) => function(self2, args) {
    if (isFunction2(args[0])) {
      const options = {
        isRefreshable: false,
        isPeriodic: nameSuffix === "Interval",
        delay: nameSuffix === "Timeout" || nameSuffix === "Interval" ? args[1] || 0 : void 0,
        args
      };
      const callback = args[0];
      args[0] = function timer() {
        try {
          return callback.apply(this, arguments);
        } finally {
          const { handle: handle2, handleId: handleId2, isPeriodic: isPeriodic2, isRefreshable: isRefreshable2 } = options;
          if (!isPeriodic2 && !isRefreshable2) {
            if (handleId2) {
              delete tasksByHandleId[handleId2];
            } else if (handle2) {
              handle2[taskSymbol] = null;
            }
          }
        }
      };
      const task = scheduleMacroTaskWithCurrentZone(setName, args[0], options, scheduleTask, clearTask);
      if (!task) {
        return task;
      }
      const { handleId, handle, isRefreshable, isPeriodic } = task.data;
      if (handleId) {
        tasksByHandleId[handleId] = task;
      } else if (handle) {
        handle[taskSymbol] = task;
        if (isRefreshable && !isPeriodic) {
          const originalRefresh = handle.refresh;
          handle.refresh = function() {
            const { zone, state } = task;
            if (state === "notScheduled") {
              task._state = "scheduled";
              zone._updateTaskCount(task, 1);
            } else if (state === "running") {
              task._state = "scheduling";
            }
            return originalRefresh.call(this);
          };
        }
      }
      return handle ?? handleId ?? task;
    } else {
      return delegate.apply(window2, args);
    }
  });
  clearNative = patchMethod(window2, cancelName, (delegate) => function(self2, args) {
    const id = args[0];
    let task;
    if (isNumber(id)) {
      task = tasksByHandleId[id];
      delete tasksByHandleId[id];
    } else {
      task = id?.[taskSymbol];
      if (task) {
        id[taskSymbol] = null;
      } else {
        task = id;
      }
    }
    if (task?.type) {
      if (task.cancelFn) {
        task.zone.cancelTask(task);
      }
    } else {
      delegate.apply(window2, args);
    }
  });
}
function patchCustomElements(_global4, api) {
  const { isBrowser: isBrowser2, isMix: isMix2 } = api.getGlobalObjects();
  if (!isBrowser2 && !isMix2 || !_global4["customElements"] || !("customElements" in _global4)) {
    return;
  }
  const callbacks = [
    "connectedCallback",
    "disconnectedCallback",
    "adoptedCallback",
    "attributeChangedCallback",
    "formAssociatedCallback",
    "formDisabledCallback",
    "formResetCallback",
    "formStateRestoreCallback"
  ];
  api.patchCallbacks(api, _global4.customElements, "customElements", "define", callbacks);
}
function eventTargetPatch(_global4, api) {
  if (Zone[api.symbol("patchEventTarget")]) {
    return;
  }
  const { eventNames, zoneSymbolEventNames: zoneSymbolEventNames2, TRUE_STR: TRUE_STR2, FALSE_STR: FALSE_STR2, ZONE_SYMBOL_PREFIX: ZONE_SYMBOL_PREFIX2 } = api.getGlobalObjects();
  for (let i4 = 0; i4 < eventNames.length; i4++) {
    const eventName = eventNames[i4];
    const falseEventName = eventName + FALSE_STR2;
    const trueEventName = eventName + TRUE_STR2;
    const symbol = ZONE_SYMBOL_PREFIX2 + falseEventName;
    const symbolCapture = ZONE_SYMBOL_PREFIX2 + trueEventName;
    zoneSymbolEventNames2[eventName] = {};
    zoneSymbolEventNames2[eventName][FALSE_STR2] = symbol;
    zoneSymbolEventNames2[eventName][TRUE_STR2] = symbolCapture;
  }
  const EVENT_TARGET = _global4["EventTarget"];
  if (!EVENT_TARGET || !EVENT_TARGET.prototype) {
    return;
  }
  api.patchEventTarget(_global4, api, [EVENT_TARGET && EVENT_TARGET.prototype]);
  return true;
}
function patchEvent(global3, api) {
  api.patchEventPrototype(global3, api);
}
function filterProperties(target, onProperties, ignoreProperties) {
  if (!ignoreProperties || ignoreProperties.length === 0) {
    return onProperties;
  }
  const tip = ignoreProperties.filter((ip) => ip.target === target);
  if (!tip || tip.length === 0) {
    return onProperties;
  }
  const targetIgnoreProperties = tip[0].ignoreProperties;
  return onProperties.filter((op) => targetIgnoreProperties.indexOf(op) === -1);
}
function patchFilteredProperties(target, onProperties, ignoreProperties, prototype) {
  if (!target) {
    return;
  }
  const filteredProperties = filterProperties(target, onProperties, ignoreProperties);
  patchOnProperties(target, filteredProperties, prototype);
}
function getOnEventNames(target) {
  return Object.getOwnPropertyNames(target).filter((name) => name.startsWith("on") && name.length > 2).map((name) => name.substring(2));
}
function propertyDescriptorPatch(api, _global4) {
  if (isNode && !isMix) {
    return;
  }
  if (Zone[api.symbol("patchEvents")]) {
    return;
  }
  const ignoreProperties = _global4["__Zone_ignore_on_properties"];
  let patchTargets = [];
  if (isBrowser) {
    const internalWindow2 = window;
    patchTargets = patchTargets.concat([
      "Document",
      "SVGElement",
      "Element",
      "HTMLElement",
      "HTMLBodyElement",
      "HTMLMediaElement",
      "HTMLFrameSetElement",
      "HTMLFrameElement",
      "HTMLIFrameElement",
      "HTMLMarqueeElement",
      "Worker"
    ]);
    const ignoreErrorProperties = isIE() ? [{ target: internalWindow2, ignoreProperties: ["error"] }] : [];
    patchFilteredProperties(internalWindow2, getOnEventNames(internalWindow2), ignoreProperties ? ignoreProperties.concat(ignoreErrorProperties) : ignoreProperties, ObjectGetPrototypeOf(internalWindow2));
  }
  patchTargets = patchTargets.concat([
    "XMLHttpRequest",
    "XMLHttpRequestEventTarget",
    "IDBIndex",
    "IDBRequest",
    "IDBOpenDBRequest",
    "IDBDatabase",
    "IDBTransaction",
    "IDBCursor",
    "WebSocket"
  ]);
  for (let i4 = 0; i4 < patchTargets.length; i4++) {
    const target = _global4[patchTargets[i4]];
    target && target.prototype && patchFilteredProperties(target.prototype, getOnEventNames(target.prototype), ignoreProperties);
  }
}
function patchBrowser(Zone2) {
  Zone2.__load_patch("legacy", (global3) => {
    const legacyPatch = global3[Zone2.__symbol__("legacyPatch")];
    if (legacyPatch) {
      legacyPatch();
    }
  });
  Zone2.__load_patch("timers", (global3) => {
    const set = "set";
    const clear = "clear";
    patchTimer(global3, set, clear, "Timeout");
    patchTimer(global3, set, clear, "Interval");
    patchTimer(global3, set, clear, "Immediate");
  });
  Zone2.__load_patch("requestAnimationFrame", (global3) => {
    patchTimer(global3, "request", "cancel", "AnimationFrame");
    patchTimer(global3, "mozRequest", "mozCancel", "AnimationFrame");
    patchTimer(global3, "webkitRequest", "webkitCancel", "AnimationFrame");
  });
  Zone2.__load_patch("blocking", (global3, Zone3) => {
    const blockingMethods = ["alert", "prompt", "confirm"];
    for (let i4 = 0; i4 < blockingMethods.length; i4++) {
      const name = blockingMethods[i4];
      patchMethod(global3, name, (delegate, symbol, name2) => {
        return function(s10, args) {
          return Zone3.current.run(delegate, global3, args, name2);
        };
      });
    }
  });
  Zone2.__load_patch("EventTarget", (global3, Zone3, api) => {
    patchEvent(global3, api);
    eventTargetPatch(global3, api);
    const XMLHttpRequestEventTarget = global3["XMLHttpRequestEventTarget"];
    if (XMLHttpRequestEventTarget && XMLHttpRequestEventTarget.prototype) {
      api.patchEventTarget(global3, api, [XMLHttpRequestEventTarget.prototype]);
    }
  });
  Zone2.__load_patch("MutationObserver", (global3, Zone3, api) => {
    patchClass("MutationObserver");
    patchClass("WebKitMutationObserver");
  });
  Zone2.__load_patch("IntersectionObserver", (global3, Zone3, api) => {
    patchClass("IntersectionObserver");
  });
  Zone2.__load_patch("FileReader", (global3, Zone3, api) => {
    patchClass("FileReader");
  });
  Zone2.__load_patch("on_property", (global3, Zone3, api) => {
    propertyDescriptorPatch(api, global3);
  });
  Zone2.__load_patch("customElements", (global3, Zone3, api) => {
    patchCustomElements(global3, api);
  });
  Zone2.__load_patch("XHR", (global3, Zone3) => {
    patchXHR(global3);
    const XHR_TASK = zoneSymbol("xhrTask");
    const XHR_SYNC = zoneSymbol("xhrSync");
    const XHR_LISTENER = zoneSymbol("xhrListener");
    const XHR_SCHEDULED = zoneSymbol("xhrScheduled");
    const XHR_URL = zoneSymbol("xhrURL");
    const XHR_ERROR_BEFORE_SCHEDULED = zoneSymbol("xhrErrorBeforeScheduled");
    function patchXHR(window2) {
      const XMLHttpRequest2 = window2["XMLHttpRequest"];
      if (!XMLHttpRequest2) {
        return;
      }
      const XMLHttpRequestPrototype = XMLHttpRequest2.prototype;
      function findPendingTask(target) {
        return target[XHR_TASK];
      }
      let oriAddListener = XMLHttpRequestPrototype[ZONE_SYMBOL_ADD_EVENT_LISTENER];
      let oriRemoveListener = XMLHttpRequestPrototype[ZONE_SYMBOL_REMOVE_EVENT_LISTENER];
      if (!oriAddListener) {
        const XMLHttpRequestEventTarget = window2["XMLHttpRequestEventTarget"];
        if (XMLHttpRequestEventTarget) {
          const XMLHttpRequestEventTargetPrototype = XMLHttpRequestEventTarget.prototype;
          oriAddListener = XMLHttpRequestEventTargetPrototype[ZONE_SYMBOL_ADD_EVENT_LISTENER];
          oriRemoveListener = XMLHttpRequestEventTargetPrototype[ZONE_SYMBOL_REMOVE_EVENT_LISTENER];
        }
      }
      const READY_STATE_CHANGE = "readystatechange";
      const SCHEDULED = "scheduled";
      function scheduleTask(task) {
        const data = task.data;
        const target = data.target;
        target[XHR_SCHEDULED] = false;
        target[XHR_ERROR_BEFORE_SCHEDULED] = false;
        const listener = target[XHR_LISTENER];
        if (!oriAddListener) {
          oriAddListener = target[ZONE_SYMBOL_ADD_EVENT_LISTENER];
          oriRemoveListener = target[ZONE_SYMBOL_REMOVE_EVENT_LISTENER];
        }
        if (listener) {
          oriRemoveListener.call(target, READY_STATE_CHANGE, listener);
        }
        const newListener = target[XHR_LISTENER] = () => {
          if (target.readyState === target.DONE) {
            if (!data.aborted && target[XHR_SCHEDULED] && task.state === SCHEDULED) {
              const loadTasks = target[Zone3.__symbol__("loadfalse")];
              if (target.status !== 0 && loadTasks && loadTasks.length > 0) {
                const oriInvoke = task.invoke;
                task.invoke = function() {
                  const loadTasks2 = target[Zone3.__symbol__("loadfalse")];
                  for (let i4 = 0; i4 < loadTasks2.length; i4++) {
                    if (loadTasks2[i4] === task) {
                      loadTasks2.splice(i4, 1);
                    }
                  }
                  if (!data.aborted && task.state === SCHEDULED) {
                    oriInvoke.call(task);
                  }
                };
                loadTasks.push(task);
              } else {
                task.invoke();
              }
            } else if (!data.aborted && target[XHR_SCHEDULED] === false) {
              target[XHR_ERROR_BEFORE_SCHEDULED] = true;
            }
          }
        };
        oriAddListener.call(target, READY_STATE_CHANGE, newListener);
        const storedTask = target[XHR_TASK];
        if (!storedTask) {
          target[XHR_TASK] = task;
        }
        sendNative.apply(target, data.args);
        target[XHR_SCHEDULED] = true;
        return task;
      }
      function placeholderCallback() {
      }
      function clearTask(task) {
        const data = task.data;
        data.aborted = true;
        return abortNative.apply(data.target, data.args);
      }
      const openNative = patchMethod(XMLHttpRequestPrototype, "open", () => function(self2, args) {
        self2[XHR_SYNC] = args[2] == false;
        self2[XHR_URL] = args[1];
        return openNative.apply(self2, args);
      });
      const XMLHTTPREQUEST_SOURCE = "XMLHttpRequest.send";
      const fetchTaskAborting = zoneSymbol("fetchTaskAborting");
      const fetchTaskScheduling = zoneSymbol("fetchTaskScheduling");
      const sendNative = patchMethod(XMLHttpRequestPrototype, "send", () => function(self2, args) {
        if (Zone3.current[fetchTaskScheduling] === true) {
          return sendNative.apply(self2, args);
        }
        if (self2[XHR_SYNC]) {
          return sendNative.apply(self2, args);
        } else {
          const options = {
            target: self2,
            url: self2[XHR_URL],
            isPeriodic: false,
            args,
            aborted: false
          };
          const task = scheduleMacroTaskWithCurrentZone(XMLHTTPREQUEST_SOURCE, placeholderCallback, options, scheduleTask, clearTask);
          if (self2 && self2[XHR_ERROR_BEFORE_SCHEDULED] === true && !options.aborted && task.state === SCHEDULED) {
            task.invoke();
          }
        }
      });
      const abortNative = patchMethod(XMLHttpRequestPrototype, "abort", () => function(self2, args) {
        const task = findPendingTask(self2);
        if (task && typeof task.type == "string") {
          if (task.cancelFn == null || task.data && task.data.aborted) {
            return;
          }
          task.zone.cancelTask(task);
        } else if (Zone3.current[fetchTaskAborting] === true) {
          return abortNative.apply(self2, args);
        }
      });
    }
  });
  Zone2.__load_patch("geolocation", (global3) => {
    if (global3["navigator"] && global3["navigator"].geolocation) {
      patchPrototype(global3["navigator"].geolocation, ["getCurrentPosition", "watchPosition"]);
    }
  });
  Zone2.__load_patch("PromiseRejectionEvent", (global3, Zone3) => {
    function findPromiseRejectionHandler(evtName) {
      return function(e7) {
        const eventTasks = findEventTasks(global3, evtName);
        eventTasks.forEach((eventTask) => {
          const PromiseRejectionEvent = global3["PromiseRejectionEvent"];
          if (PromiseRejectionEvent) {
            const evt = new PromiseRejectionEvent(evtName, {
              promise: e7.promise,
              reason: e7.rejection
            });
            eventTask.invoke(evt);
          }
        });
      };
    }
    if (global3["PromiseRejectionEvent"]) {
      Zone3[zoneSymbol("unhandledPromiseRejectionHandler")] = findPromiseRejectionHandler("unhandledrejection");
      Zone3[zoneSymbol("rejectionHandledHandler")] = findPromiseRejectionHandler("rejectionhandled");
    }
  });
  Zone2.__load_patch("queueMicrotask", (global3, Zone3, api) => {
    patchQueueMicrotask(global3, api);
  });
}
function patchPromise(Zone2) {
  Zone2.__load_patch("ZoneAwarePromise", (global3, Zone3, api) => {
    const ObjectGetOwnPropertyDescriptor2 = Object.getOwnPropertyDescriptor;
    const ObjectDefineProperty2 = Object.defineProperty;
    function readableObjectToString(obj) {
      if (obj && obj.toString === Object.prototype.toString) {
        const className = obj.constructor && obj.constructor.name;
        return (className ? className : "") + ": " + JSON.stringify(obj);
      }
      return obj ? obj.toString() : Object.prototype.toString.call(obj);
    }
    const __symbol__2 = api.symbol;
    const _uncaughtPromiseErrors = [];
    const isDisableWrappingUncaughtPromiseRejection = global3[__symbol__2("DISABLE_WRAPPING_UNCAUGHT_PROMISE_REJECTION")] !== false;
    const symbolPromise = __symbol__2("Promise");
    const symbolThen = __symbol__2("then");
    const creationTrace = "__creationTrace__";
    api.onUnhandledError = (e7) => {
      if (api.showUncaughtError()) {
        const rejection = e7 && e7.rejection;
        if (rejection) {
          console.error("Unhandled Promise rejection:", rejection instanceof Error ? rejection.message : rejection, "; Zone:", e7.zone.name, "; Task:", e7.task && e7.task.source, "; Value:", rejection, rejection instanceof Error ? rejection.stack : void 0);
        } else {
          console.error(e7);
        }
      }
    };
    api.microtaskDrainDone = () => {
      while (_uncaughtPromiseErrors.length) {
        const uncaughtPromiseError = _uncaughtPromiseErrors.shift();
        try {
          uncaughtPromiseError.zone.runGuarded(() => {
            if (uncaughtPromiseError.throwOriginal) {
              throw uncaughtPromiseError.rejection;
            }
            throw uncaughtPromiseError;
          });
        } catch (error) {
          handleUnhandledRejection(error);
        }
      }
    };
    const UNHANDLED_PROMISE_REJECTION_HANDLER_SYMBOL = __symbol__2("unhandledPromiseRejectionHandler");
    function handleUnhandledRejection(e7) {
      api.onUnhandledError(e7);
      try {
        const handler = Zone3[UNHANDLED_PROMISE_REJECTION_HANDLER_SYMBOL];
        if (typeof handler === "function") {
          handler.call(this, e7);
        }
      } catch (err) {
      }
    }
    function isThenable(value) {
      return value && value.then;
    }
    function forwardResolution(value) {
      return value;
    }
    function forwardRejection(rejection) {
      return ZoneAwarePromise.reject(rejection);
    }
    const symbolState = __symbol__2("state");
    const symbolValue = __symbol__2("value");
    const symbolFinally = __symbol__2("finally");
    const symbolParentPromiseValue = __symbol__2("parentPromiseValue");
    const symbolParentPromiseState = __symbol__2("parentPromiseState");
    const source = "Promise.then";
    const UNRESOLVED = null;
    const RESOLVED = true;
    const REJECTED = false;
    const REJECTED_NO_CATCH = 0;
    function makeResolver(promise, state) {
      return (v4) => {
        try {
          resolvePromise(promise, state, v4);
        } catch (err) {
          resolvePromise(promise, false, err);
        }
      };
    }
    const once = function() {
      let wasCalled = false;
      return function wrapper(wrappedFunction) {
        return function() {
          if (wasCalled) {
            return;
          }
          wasCalled = true;
          wrappedFunction.apply(null, arguments);
        };
      };
    };
    const TYPE_ERROR = "Promise resolved with itself";
    const CURRENT_TASK_TRACE_SYMBOL = __symbol__2("currentTaskTrace");
    function resolvePromise(promise, state, value) {
      const onceWrapper = once();
      if (promise === value) {
        throw new TypeError(TYPE_ERROR);
      }
      if (promise[symbolState] === UNRESOLVED) {
        let then = null;
        try {
          if (typeof value === "object" || typeof value === "function") {
            then = value && value.then;
          }
        } catch (err) {
          onceWrapper(() => {
            resolvePromise(promise, false, err);
          })();
          return promise;
        }
        if (state !== REJECTED && value instanceof ZoneAwarePromise && value.hasOwnProperty(symbolState) && value.hasOwnProperty(symbolValue) && value[symbolState] !== UNRESOLVED) {
          clearRejectedNoCatch(value);
          resolvePromise(promise, value[symbolState], value[symbolValue]);
        } else if (state !== REJECTED && typeof then === "function") {
          try {
            then.call(value, onceWrapper(makeResolver(promise, state)), onceWrapper(makeResolver(promise, false)));
          } catch (err) {
            onceWrapper(() => {
              resolvePromise(promise, false, err);
            })();
          }
        } else {
          promise[symbolState] = state;
          const queue = promise[symbolValue];
          promise[symbolValue] = value;
          if (promise[symbolFinally] === symbolFinally) {
            if (state === RESOLVED) {
              promise[symbolState] = promise[symbolParentPromiseState];
              promise[symbolValue] = promise[symbolParentPromiseValue];
            }
          }
          if (state === REJECTED && value instanceof Error) {
            const trace2 = Zone3.currentTask && Zone3.currentTask.data && Zone3.currentTask.data[creationTrace];
            if (trace2) {
              ObjectDefineProperty2(value, CURRENT_TASK_TRACE_SYMBOL, {
                configurable: true,
                enumerable: false,
                writable: true,
                value: trace2
              });
            }
          }
          for (let i4 = 0; i4 < queue.length; ) {
            scheduleResolveOrReject(promise, queue[i4++], queue[i4++], queue[i4++], queue[i4++]);
          }
          if (queue.length == 0 && state == REJECTED) {
            promise[symbolState] = REJECTED_NO_CATCH;
            let uncaughtPromiseError = value;
            try {
              throw new Error("Uncaught (in promise): " + readableObjectToString(value) + (value && value.stack ? "\n" + value.stack : ""));
            } catch (err) {
              uncaughtPromiseError = err;
            }
            if (isDisableWrappingUncaughtPromiseRejection) {
              uncaughtPromiseError.throwOriginal = true;
            }
            uncaughtPromiseError.rejection = value;
            uncaughtPromiseError.promise = promise;
            uncaughtPromiseError.zone = Zone3.current;
            uncaughtPromiseError.task = Zone3.currentTask;
            _uncaughtPromiseErrors.push(uncaughtPromiseError);
            api.scheduleMicroTask();
          }
        }
      }
      return promise;
    }
    const REJECTION_HANDLED_HANDLER = __symbol__2("rejectionHandledHandler");
    function clearRejectedNoCatch(promise) {
      if (promise[symbolState] === REJECTED_NO_CATCH) {
        try {
          const handler = Zone3[REJECTION_HANDLED_HANDLER];
          if (handler && typeof handler === "function") {
            handler.call(this, { rejection: promise[symbolValue], promise });
          }
        } catch (err) {
        }
        promise[symbolState] = REJECTED;
        for (let i4 = 0; i4 < _uncaughtPromiseErrors.length; i4++) {
          if (promise === _uncaughtPromiseErrors[i4].promise) {
            _uncaughtPromiseErrors.splice(i4, 1);
          }
        }
      }
    }
    function scheduleResolveOrReject(promise, zone, chainPromise, onFulfilled, onRejected) {
      clearRejectedNoCatch(promise);
      const promiseState = promise[symbolState];
      const delegate = promiseState ? typeof onFulfilled === "function" ? onFulfilled : forwardResolution : typeof onRejected === "function" ? onRejected : forwardRejection;
      zone.scheduleMicroTask(source, () => {
        try {
          const parentPromiseValue = promise[symbolValue];
          const isFinallyPromise = !!chainPromise && symbolFinally === chainPromise[symbolFinally];
          if (isFinallyPromise) {
            chainPromise[symbolParentPromiseValue] = parentPromiseValue;
            chainPromise[symbolParentPromiseState] = promiseState;
          }
          const value = zone.run(delegate, void 0, isFinallyPromise && delegate !== forwardRejection && delegate !== forwardResolution ? [] : [parentPromiseValue]);
          resolvePromise(chainPromise, true, value);
        } catch (error) {
          resolvePromise(chainPromise, false, error);
        }
      }, chainPromise);
    }
    const ZONE_AWARE_PROMISE_TO_STRING = "function ZoneAwarePromise() { [native code] }";
    const noop = function() {
    };
    const AggregateError = global3.AggregateError;
    class ZoneAwarePromise {
      static toString() {
        return ZONE_AWARE_PROMISE_TO_STRING;
      }
      static resolve(value) {
        if (value instanceof ZoneAwarePromise) {
          return value;
        }
        return resolvePromise(new this(null), RESOLVED, value);
      }
      static reject(error) {
        return resolvePromise(new this(null), REJECTED, error);
      }
      static withResolvers() {
        const result = {};
        result.promise = new ZoneAwarePromise((res, rej) => {
          result.resolve = res;
          result.reject = rej;
        });
        return result;
      }
      static any(values) {
        if (!values || typeof values[Symbol.iterator] !== "function") {
          return Promise.reject(new AggregateError([], "All promises were rejected"));
        }
        const promises = [];
        let count = 0;
        try {
          for (let v4 of values) {
            count++;
            promises.push(ZoneAwarePromise.resolve(v4));
          }
        } catch (err) {
          return Promise.reject(new AggregateError([], "All promises were rejected"));
        }
        if (count === 0) {
          return Promise.reject(new AggregateError([], "All promises were rejected"));
        }
        let finished = false;
        const errors = [];
        return new ZoneAwarePromise((resolve, reject) => {
          for (let i4 = 0; i4 < promises.length; i4++) {
            promises[i4].then((v4) => {
              if (finished) {
                return;
              }
              finished = true;
              resolve(v4);
            }, (err) => {
              errors.push(err);
              count--;
              if (count === 0) {
                finished = true;
                reject(new AggregateError(errors, "All promises were rejected"));
              }
            });
          }
        });
      }
      static race(values) {
        let resolve;
        let reject;
        let promise = new this((res, rej) => {
          resolve = res;
          reject = rej;
        });
        function onResolve(value) {
          resolve(value);
        }
        function onReject(error) {
          reject(error);
        }
        for (let value of values) {
          if (!isThenable(value)) {
            value = this.resolve(value);
          }
          value.then(onResolve, onReject);
        }
        return promise;
      }
      static all(values) {
        return ZoneAwarePromise.allWithCallback(values);
      }
      static allSettled(values) {
        const P6 = this && this.prototype instanceof ZoneAwarePromise ? this : ZoneAwarePromise;
        return P6.allWithCallback(values, {
          thenCallback: (value) => ({ status: "fulfilled", value }),
          errorCallback: (err) => ({ status: "rejected", reason: err })
        });
      }
      static allWithCallback(values, callback) {
        let resolve;
        let reject;
        let promise = new this((res, rej) => {
          resolve = res;
          reject = rej;
        });
        let unresolvedCount = 2;
        let valueIndex = 0;
        const resolvedValues = [];
        for (let value of values) {
          if (!isThenable(value)) {
            value = this.resolve(value);
          }
          const curValueIndex = valueIndex;
          try {
            value.then((value2) => {
              resolvedValues[curValueIndex] = callback ? callback.thenCallback(value2) : value2;
              unresolvedCount--;
              if (unresolvedCount === 0) {
                resolve(resolvedValues);
              }
            }, (err) => {
              if (!callback) {
                reject(err);
              } else {
                resolvedValues[curValueIndex] = callback.errorCallback(err);
                unresolvedCount--;
                if (unresolvedCount === 0) {
                  resolve(resolvedValues);
                }
              }
            });
          } catch (thenErr) {
            reject(thenErr);
          }
          unresolvedCount++;
          valueIndex++;
        }
        unresolvedCount -= 2;
        if (unresolvedCount === 0) {
          resolve(resolvedValues);
        }
        return promise;
      }
      constructor(executor) {
        const promise = this;
        if (!(promise instanceof ZoneAwarePromise)) {
          throw new Error("Must be an instanceof Promise.");
        }
        promise[symbolState] = UNRESOLVED;
        promise[symbolValue] = [];
        try {
          const onceWrapper = once();
          executor && executor(onceWrapper(makeResolver(promise, RESOLVED)), onceWrapper(makeResolver(promise, REJECTED)));
        } catch (error) {
          resolvePromise(promise, false, error);
        }
      }
      get [Symbol.toStringTag]() {
        return "Promise";
      }
      get [Symbol.species]() {
        return ZoneAwarePromise;
      }
      then(onFulfilled, onRejected) {
        let C3 = this.constructor?.[Symbol.species];
        if (!C3 || typeof C3 !== "function") {
          C3 = this.constructor || ZoneAwarePromise;
        }
        const chainPromise = new C3(noop);
        const zone = Zone3.current;
        if (this[symbolState] == UNRESOLVED) {
          this[symbolValue].push(zone, chainPromise, onFulfilled, onRejected);
        } else {
          scheduleResolveOrReject(this, zone, chainPromise, onFulfilled, onRejected);
        }
        return chainPromise;
      }
      catch(onRejected) {
        return this.then(null, onRejected);
      }
      finally(onFinally) {
        let C3 = this.constructor?.[Symbol.species];
        if (!C3 || typeof C3 !== "function") {
          C3 = ZoneAwarePromise;
        }
        const chainPromise = new C3(noop);
        chainPromise[symbolFinally] = symbolFinally;
        const zone = Zone3.current;
        if (this[symbolState] == UNRESOLVED) {
          this[symbolValue].push(zone, chainPromise, onFinally, onFinally);
        } else {
          scheduleResolveOrReject(this, zone, chainPromise, onFinally, onFinally);
        }
        return chainPromise;
      }
    }
    ZoneAwarePromise["resolve"] = ZoneAwarePromise.resolve;
    ZoneAwarePromise["reject"] = ZoneAwarePromise.reject;
    ZoneAwarePromise["race"] = ZoneAwarePromise.race;
    ZoneAwarePromise["all"] = ZoneAwarePromise.all;
    const NativePromise = global3[symbolPromise] = global3["Promise"];
    global3["Promise"] = ZoneAwarePromise;
    const symbolThenPatched = __symbol__2("thenPatched");
    function patchThen(Ctor) {
      const proto = Ctor.prototype;
      const prop = ObjectGetOwnPropertyDescriptor2(proto, "then");
      if (prop && (prop.writable === false || !prop.configurable)) {
        return;
      }
      const originalThen = proto.then;
      proto[symbolThen] = originalThen;
      Ctor.prototype.then = function(onResolve, onReject) {
        const wrapped = new ZoneAwarePromise((resolve, reject) => {
          originalThen.call(this, resolve, reject);
        });
        return wrapped.then(onResolve, onReject);
      };
      Ctor[symbolThenPatched] = true;
    }
    api.patchThen = patchThen;
    function zoneify(fn) {
      return function(self2, args) {
        let resultPromise = fn.apply(self2, args);
        if (resultPromise instanceof ZoneAwarePromise) {
          return resultPromise;
        }
        let ctor = resultPromise.constructor;
        if (!ctor[symbolThenPatched]) {
          patchThen(ctor);
        }
        return resultPromise;
      };
    }
    if (NativePromise) {
      patchThen(NativePromise);
      patchMethod(global3, "fetch", (delegate) => zoneify(delegate));
    }
    Promise[Zone3.__symbol__("uncaughtPromiseErrors")] = _uncaughtPromiseErrors;
    return ZoneAwarePromise;
  });
}
function patchToString(Zone2) {
  Zone2.__load_patch("toString", (global3) => {
    const originalFunctionToString = Function.prototype.toString;
    const ORIGINAL_DELEGATE_SYMBOL = zoneSymbol("OriginalDelegate");
    const PROMISE_SYMBOL = zoneSymbol("Promise");
    const ERROR_SYMBOL = zoneSymbol("Error");
    const newFunctionToString = function toString() {
      if (typeof this === "function") {
        const originalDelegate = this[ORIGINAL_DELEGATE_SYMBOL];
        if (originalDelegate) {
          if (typeof originalDelegate === "function") {
            return originalFunctionToString.call(originalDelegate);
          } else {
            return Object.prototype.toString.call(originalDelegate);
          }
        }
        if (this === Promise) {
          const nativePromise = global3[PROMISE_SYMBOL];
          if (nativePromise) {
            return originalFunctionToString.call(nativePromise);
          }
        }
        if (this === Error) {
          const nativeError = global3[ERROR_SYMBOL];
          if (nativeError) {
            return originalFunctionToString.call(nativeError);
          }
        }
      }
      return originalFunctionToString.call(this);
    };
    newFunctionToString[ORIGINAL_DELEGATE_SYMBOL] = originalFunctionToString;
    Function.prototype.toString = newFunctionToString;
    const originalObjectToString = Object.prototype.toString;
    const PROMISE_OBJECT_TO_STRING = "[object Promise]";
    Object.prototype.toString = function() {
      if (typeof Promise === "function" && this instanceof Promise) {
        return PROMISE_OBJECT_TO_STRING;
      }
      return originalObjectToString.call(this);
    };
  });
}
function patchCallbacks(api, target, targetName, method, callbacks) {
  const symbol = Zone.__symbol__(method);
  if (target[symbol]) {
    return;
  }
  const nativeDelegate = target[symbol] = target[method];
  target[method] = function(name, opts, options) {
    if (opts && opts.prototype) {
      callbacks.forEach(function(callback) {
        const source = `${targetName}.${method}::` + callback;
        const prototype = opts.prototype;
        try {
          if (prototype.hasOwnProperty(callback)) {
            const descriptor = api.ObjectGetOwnPropertyDescriptor(prototype, callback);
            if (descriptor && descriptor.value) {
              descriptor.value = api.wrapWithCurrentZone(descriptor.value, source);
              api._redefineProperty(opts.prototype, callback, descriptor);
            } else if (prototype[callback]) {
              prototype[callback] = api.wrapWithCurrentZone(prototype[callback], source);
            }
          } else if (prototype[callback]) {
            prototype[callback] = api.wrapWithCurrentZone(prototype[callback], source);
          }
        } catch {
        }
      });
    }
    return nativeDelegate.call(target, name, opts, options);
  };
  api.attachOriginToPatched(target[method], nativeDelegate);
}
function patchUtil(Zone2) {
  Zone2.__load_patch("util", (global3, Zone3, api) => {
    const eventNames = getOnEventNames(global3);
    api.patchOnProperties = patchOnProperties;
    api.patchMethod = patchMethod;
    api.bindArguments = bindArguments;
    api.patchMacroTask = patchMacroTask;
    const SYMBOL_BLACK_LISTED_EVENTS = Zone3.__symbol__("BLACK_LISTED_EVENTS");
    const SYMBOL_UNPATCHED_EVENTS = Zone3.__symbol__("UNPATCHED_EVENTS");
    if (global3[SYMBOL_UNPATCHED_EVENTS]) {
      global3[SYMBOL_BLACK_LISTED_EVENTS] = global3[SYMBOL_UNPATCHED_EVENTS];
    }
    if (global3[SYMBOL_BLACK_LISTED_EVENTS]) {
      Zone3[SYMBOL_BLACK_LISTED_EVENTS] = Zone3[SYMBOL_UNPATCHED_EVENTS] = global3[SYMBOL_BLACK_LISTED_EVENTS];
    }
    api.patchEventPrototype = patchEventPrototype;
    api.patchEventTarget = patchEventTarget;
    api.isIEOrEdge = isIEOrEdge;
    api.ObjectDefineProperty = ObjectDefineProperty;
    api.ObjectGetOwnPropertyDescriptor = ObjectGetOwnPropertyDescriptor;
    api.ObjectCreate = ObjectCreate;
    api.ArraySlice = ArraySlice;
    api.patchClass = patchClass;
    api.wrapWithCurrentZone = wrapWithCurrentZone;
    api.filterProperties = filterProperties;
    api.attachOriginToPatched = attachOriginToPatched;
    api._redefineProperty = Object.defineProperty;
    api.patchCallbacks = patchCallbacks;
    api.getGlobalObjects = () => ({
      globalSources,
      zoneSymbolEventNames,
      eventNames,
      isBrowser,
      isMix,
      isNode,
      TRUE_STR,
      FALSE_STR,
      ZONE_SYMBOL_PREFIX,
      ADD_EVENT_LISTENER_STR,
      REMOVE_EVENT_LISTENER_STR
    });
  });
}
function patchCommon(Zone2) {
  patchPromise(Zone2);
  patchToString(Zone2);
  patchUtil(Zone2);
}
var Zone$1 = loadZone();
patchCommon(Zone$1);
patchBrowser(Zone$1);

// node_modules/@opentelemetry/instrumentation/build/esm/autoLoader.js
init_esm();

// node_modules/@opentelemetry/api-logs/build/esm/NoopLogger.js
var NoopLogger = (
  /** @class */
  function() {
    function NoopLogger2() {
    }
    NoopLogger2.prototype.emit = function(_logRecord) {
    };
    return NoopLogger2;
  }()
);
var NOOP_LOGGER = new NoopLogger();

// node_modules/@opentelemetry/api-logs/build/esm/NoopLoggerProvider.js
var NoopLoggerProvider = (
  /** @class */
  function() {
    function NoopLoggerProvider2() {
    }
    NoopLoggerProvider2.prototype.getLogger = function(_name, _version, _options) {
      return new NoopLogger();
    };
    return NoopLoggerProvider2;
  }()
);
var NOOP_LOGGER_PROVIDER = new NoopLoggerProvider();

// node_modules/@opentelemetry/api-logs/build/esm/platform/node/globalThis.js
var _globalThis3 = typeof globalThis === "object" ? globalThis : global;

// node_modules/@opentelemetry/api-logs/build/esm/internal/global-utils.js
var GLOBAL_LOGS_API_KEY = Symbol.for("io.opentelemetry.js.api.logs");
var _global3 = _globalThis3;
function makeGetter(requiredVersion, instance, fallback) {
  return function(version) {
    return version === requiredVersion ? instance : fallback;
  };
}
var API_BACKWARDS_COMPATIBILITY_VERSION = 1;

// node_modules/@opentelemetry/api-logs/build/esm/api/logs.js
var LogsAPI = (
  /** @class */
  function() {
    function LogsAPI2() {
    }
    LogsAPI2.getInstance = function() {
      if (!this._instance) {
        this._instance = new LogsAPI2();
      }
      return this._instance;
    };
    LogsAPI2.prototype.setGlobalLoggerProvider = function(provider) {
      if (_global3[GLOBAL_LOGS_API_KEY]) {
        return this.getLoggerProvider();
      }
      _global3[GLOBAL_LOGS_API_KEY] = makeGetter(API_BACKWARDS_COMPATIBILITY_VERSION, provider, NOOP_LOGGER_PROVIDER);
      return provider;
    };
    LogsAPI2.prototype.getLoggerProvider = function() {
      var _a3, _b;
      return (_b = (_a3 = _global3[GLOBAL_LOGS_API_KEY]) === null || _a3 === void 0 ? void 0 : _a3.call(_global3, API_BACKWARDS_COMPATIBILITY_VERSION)) !== null && _b !== void 0 ? _b : NOOP_LOGGER_PROVIDER;
    };
    LogsAPI2.prototype.getLogger = function(name, version, options) {
      return this.getLoggerProvider().getLogger(name, version, options);
    };
    LogsAPI2.prototype.disable = function() {
      delete _global3[GLOBAL_LOGS_API_KEY];
    };
    return LogsAPI2;
  }()
);

// node_modules/@opentelemetry/api-logs/build/esm/index.js
var logs = LogsAPI.getInstance();

// node_modules/@opentelemetry/instrumentation/build/esm/autoLoaderUtils.js
function enableInstrumentations(instrumentations, tracerProvider, meterProvider, loggerProvider) {
  for (var i4 = 0, j = instrumentations.length; i4 < j; i4++) {
    var instrumentation = instrumentations[i4];
    if (tracerProvider) {
      instrumentation.setTracerProvider(tracerProvider);
    }
    if (meterProvider) {
      instrumentation.setMeterProvider(meterProvider);
    }
    if (loggerProvider && instrumentation.setLoggerProvider) {
      instrumentation.setLoggerProvider(loggerProvider);
    }
    if (!instrumentation.getConfig().enabled) {
      instrumentation.enable();
    }
  }
}
function disableInstrumentations(instrumentations) {
  instrumentations.forEach(function(instrumentation) {
    return instrumentation.disable();
  });
}

// node_modules/@opentelemetry/instrumentation/build/esm/autoLoader.js
function registerInstrumentations(options) {
  var _a3, _b;
  var tracerProvider = options.tracerProvider || trace.getTracerProvider();
  var meterProvider = options.meterProvider || metrics.getMeterProvider();
  var loggerProvider = options.loggerProvider || logs.getLoggerProvider();
  var instrumentations = (_b = (_a3 = options.instrumentations) === null || _a3 === void 0 ? void 0 : _a3.flat()) !== null && _b !== void 0 ? _b : [];
  enableInstrumentations(instrumentations, tracerProvider, meterProvider, loggerProvider);
  return function() {
    disableInstrumentations(instrumentations);
  };
}

// node_modules/@opentelemetry/instrumentation/build/esm/platform/node/instrumentation.js
var import_semver2 = __toESM(require_semver2());
var import_shimmer = __toESM(require_shimmer());
import * as path2 from "path";
import { types as utilTypes } from "util";

// node_modules/@opentelemetry/instrumentation/build/esm/instrumentation.js
init_esm();
var shimmer = __toESM(require_shimmer());
var __assign3 = function() {
  __assign3 = Object.assign || function(t5) {
    for (var s10, i4 = 1, n9 = arguments.length; i4 < n9; i4++) {
      s10 = arguments[i4];
      for (var p9 in s10)
        if (Object.prototype.hasOwnProperty.call(s10, p9))
          t5[p9] = s10[p9];
    }
    return t5;
  };
  return __assign3.apply(this, arguments);
};
var InstrumentationAbstract = (
  /** @class */
  function() {
    function InstrumentationAbstract2(instrumentationName, instrumentationVersion, config) {
      this.instrumentationName = instrumentationName;
      this.instrumentationVersion = instrumentationVersion;
      this._config = {};
      this._wrap = shimmer.wrap;
      this._unwrap = shimmer.unwrap;
      this._massWrap = shimmer.massWrap;
      this._massUnwrap = shimmer.massUnwrap;
      this.setConfig(config);
      this._diag = diag2.createComponentLogger({
        namespace: instrumentationName
      });
      this._tracer = trace.getTracer(instrumentationName, instrumentationVersion);
      this._meter = metrics.getMeter(instrumentationName, instrumentationVersion);
      this._logger = logs.getLogger(instrumentationName, instrumentationVersion);
      this._updateMetricInstruments();
    }
    Object.defineProperty(InstrumentationAbstract2.prototype, "meter", {
      /* Returns meter */
      get: function() {
        return this._meter;
      },
      enumerable: false,
      configurable: true
    });
    InstrumentationAbstract2.prototype.setMeterProvider = function(meterProvider) {
      this._meter = meterProvider.getMeter(this.instrumentationName, this.instrumentationVersion);
      this._updateMetricInstruments();
    };
    Object.defineProperty(InstrumentationAbstract2.prototype, "logger", {
      /* Returns logger */
      get: function() {
        return this._logger;
      },
      enumerable: false,
      configurable: true
    });
    InstrumentationAbstract2.prototype.setLoggerProvider = function(loggerProvider) {
      this._logger = loggerProvider.getLogger(this.instrumentationName, this.instrumentationVersion);
    };
    InstrumentationAbstract2.prototype.getModuleDefinitions = function() {
      var _a3;
      var initResult = (_a3 = this.init()) !== null && _a3 !== void 0 ? _a3 : [];
      if (!Array.isArray(initResult)) {
        return [initResult];
      }
      return initResult;
    };
    InstrumentationAbstract2.prototype._updateMetricInstruments = function() {
      return;
    };
    InstrumentationAbstract2.prototype.getConfig = function() {
      return this._config;
    };
    InstrumentationAbstract2.prototype.setConfig = function(config) {
      this._config = __assign3({ enabled: true }, config);
    };
    InstrumentationAbstract2.prototype.setTracerProvider = function(tracerProvider) {
      this._tracer = tracerProvider.getTracer(this.instrumentationName, this.instrumentationVersion);
    };
    Object.defineProperty(InstrumentationAbstract2.prototype, "tracer", {
      /* Returns tracer */
      get: function() {
        return this._tracer;
      },
      enumerable: false,
      configurable: true
    });
    InstrumentationAbstract2.prototype._runSpanCustomizationHook = function(hookHandler, triggerName, span, info) {
      if (!hookHandler) {
        return;
      }
      try {
        hookHandler(span, info);
      } catch (e7) {
        this._diag.error("Error running span customization hook due to exception in handler", { triggerName }, e7);
      }
    };
    return InstrumentationAbstract2;
  }()
);

// node_modules/@opentelemetry/instrumentation/build/esm/platform/node/RequireInTheMiddleSingleton.js
var import_require_in_the_middle = __toESM(require_require_in_the_middle());
import * as path from "path";

// node_modules/@opentelemetry/instrumentation/build/esm/platform/node/ModuleNameTrie.js
var __values6 = function(o4) {
  var s10 = typeof Symbol === "function" && Symbol.iterator, m2 = s10 && o4[s10], i4 = 0;
  if (m2)
    return m2.call(o4);
  if (o4 && typeof o4.length === "number")
    return {
      next: function() {
        if (o4 && i4 >= o4.length)
          o4 = void 0;
        return { value: o4 && o4[i4++], done: !o4 };
      }
    };
  throw new TypeError(s10 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read13 = function(o4, n9) {
  var m2 = typeof Symbol === "function" && o4[Symbol.iterator];
  if (!m2)
    return o4;
  var i4 = m2.call(o4), r7, ar = [], e7;
  try {
    while ((n9 === void 0 || n9-- > 0) && !(r7 = i4.next()).done)
      ar.push(r7.value);
  } catch (error) {
    e7 = { error };
  } finally {
    try {
      if (r7 && !r7.done && (m2 = i4["return"]))
        m2.call(i4);
    } finally {
      if (e7)
        throw e7.error;
    }
  }
  return ar;
};
var __spreadArray9 = function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i4 = 0, l5 = from.length, ar; i4 < l5; i4++) {
      if (ar || !(i4 in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i4);
        ar[i4] = from[i4];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var ModuleNameSeparator = "/";
var ModuleNameTrieNode = (
  /** @class */
  function() {
    function ModuleNameTrieNode2() {
      this.hooks = [];
      this.children = /* @__PURE__ */ new Map();
    }
    return ModuleNameTrieNode2;
  }()
);
var ModuleNameTrie = (
  /** @class */
  function() {
    function ModuleNameTrie2() {
      this._trie = new ModuleNameTrieNode();
      this._counter = 0;
    }
    ModuleNameTrie2.prototype.insert = function(hook) {
      var e_1, _a3;
      var trieNode = this._trie;
      try {
        for (var _b = __values6(hook.moduleName.split(ModuleNameSeparator)), _c = _b.next(); !_c.done; _c = _b.next()) {
          var moduleNamePart = _c.value;
          var nextNode = trieNode.children.get(moduleNamePart);
          if (!nextNode) {
            nextNode = new ModuleNameTrieNode();
            trieNode.children.set(moduleNamePart, nextNode);
          }
          trieNode = nextNode;
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a3 = _b.return))
            _a3.call(_b);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      trieNode.hooks.push({ hook, insertedId: this._counter++ });
    };
    ModuleNameTrie2.prototype.search = function(moduleName, _a3) {
      var e_2, _b;
      var _c = _a3 === void 0 ? {} : _a3, maintainInsertionOrder = _c.maintainInsertionOrder, fullOnly = _c.fullOnly;
      var trieNode = this._trie;
      var results = [];
      var foundFull = true;
      try {
        for (var _d = __values6(moduleName.split(ModuleNameSeparator)), _e2 = _d.next(); !_e2.done; _e2 = _d.next()) {
          var moduleNamePart = _e2.value;
          var nextNode = trieNode.children.get(moduleNamePart);
          if (!nextNode) {
            foundFull = false;
            break;
          }
          if (!fullOnly) {
            results.push.apply(results, __spreadArray9([], __read13(nextNode.hooks), false));
          }
          trieNode = nextNode;
        }
      } catch (e_2_1) {
        e_2 = { error: e_2_1 };
      } finally {
        try {
          if (_e2 && !_e2.done && (_b = _d.return))
            _b.call(_d);
        } finally {
          if (e_2)
            throw e_2.error;
        }
      }
      if (fullOnly && foundFull) {
        results.push.apply(results, __spreadArray9([], __read13(trieNode.hooks), false));
      }
      if (results.length === 0) {
        return [];
      }
      if (results.length === 1) {
        return [results[0].hook];
      }
      if (maintainInsertionOrder) {
        results.sort(function(a4, b4) {
          return a4.insertedId - b4.insertedId;
        });
      }
      return results.map(function(_a4) {
        var hook = _a4.hook;
        return hook;
      });
    };
    return ModuleNameTrie2;
  }()
);

// node_modules/@opentelemetry/instrumentation/build/esm/platform/node/RequireInTheMiddleSingleton.js
var __values7 = function(o4) {
  var s10 = typeof Symbol === "function" && Symbol.iterator, m2 = s10 && o4[s10], i4 = 0;
  if (m2)
    return m2.call(o4);
  if (o4 && typeof o4.length === "number")
    return {
      next: function() {
        if (o4 && i4 >= o4.length)
          o4 = void 0;
        return { value: o4 && o4[i4++], done: !o4 };
      }
    };
  throw new TypeError(s10 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var isMocha = [
  "afterEach",
  "after",
  "beforeEach",
  "before",
  "describe",
  "it"
].every(function(fn) {
  return typeof global[fn] === "function";
});
var RequireInTheMiddleSingleton = (
  /** @class */
  function() {
    function RequireInTheMiddleSingleton2() {
      this._moduleNameTrie = new ModuleNameTrie();
      this._initialize();
    }
    RequireInTheMiddleSingleton2.prototype._initialize = function() {
      var _this = this;
      new import_require_in_the_middle.Hook(
        // Intercept all `require` calls; we will filter the matching ones below
        null,
        { internals: true },
        function(exports, name, basedir) {
          var e_1, _a3;
          var normalizedModuleName = normalizePathSeparators(name);
          var matches = _this._moduleNameTrie.search(normalizedModuleName, {
            maintainInsertionOrder: true,
            // For core modules (e.g. `fs`), do not match on sub-paths (e.g. `fs/promises').
            // This matches the behavior of `require-in-the-middle`.
            // `basedir` is always `undefined` for core modules.
            fullOnly: basedir === void 0
          });
          try {
            for (var matches_1 = __values7(matches), matches_1_1 = matches_1.next(); !matches_1_1.done; matches_1_1 = matches_1.next()) {
              var onRequire = matches_1_1.value.onRequire;
              exports = onRequire(exports, name, basedir);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (matches_1_1 && !matches_1_1.done && (_a3 = matches_1.return))
                _a3.call(matches_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
          return exports;
        }
      );
    };
    RequireInTheMiddleSingleton2.prototype.register = function(moduleName, onRequire) {
      var hooked = { moduleName, onRequire };
      this._moduleNameTrie.insert(hooked);
      return hooked;
    };
    RequireInTheMiddleSingleton2.getInstance = function() {
      var _a3;
      if (isMocha)
        return new RequireInTheMiddleSingleton2();
      return this._instance = (_a3 = this._instance) !== null && _a3 !== void 0 ? _a3 : new RequireInTheMiddleSingleton2();
    };
    return RequireInTheMiddleSingleton2;
  }()
);
function normalizePathSeparators(moduleNameOrPath) {
  return path.sep !== ModuleNameSeparator ? moduleNameOrPath.split(path.sep).join(ModuleNameSeparator) : moduleNameOrPath;
}

// node_modules/@opentelemetry/instrumentation/build/esm/platform/node/instrumentation.js
var import_import_in_the_middle = __toESM(require_import_in_the_middle());
init_esm();
var import_require_in_the_middle2 = __toESM(require_require_in_the_middle());
import { readFileSync } from "fs";

// node_modules/@opentelemetry/instrumentation/build/esm/utils.js
function safeExecuteInTheMiddle(execute, onFinish, preventThrowingError) {
  var error;
  var result;
  try {
    result = execute();
  } catch (e7) {
    error = e7;
  } finally {
    onFinish(error, result);
    if (error && !preventThrowingError) {
      throw error;
    }
    return result;
  }
}
function isWrapped(func) {
  return typeof func === "function" && typeof func.__original === "function" && typeof func.__unwrap === "function" && func.__wrapped === true;
}

// node_modules/@opentelemetry/instrumentation/build/esm/platform/node/instrumentation.js
var __extends4 = function() {
  var extendStatics = function(d5, b4) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d6, b5) {
      d6.__proto__ = b5;
    } || function(d6, b5) {
      for (var p9 in b5)
        if (Object.prototype.hasOwnProperty.call(b5, p9))
          d6[p9] = b5[p9];
    };
    return extendStatics(d5, b4);
  };
  return function(d5, b4) {
    if (typeof b4 !== "function" && b4 !== null)
      throw new TypeError("Class extends value " + String(b4) + " is not a constructor or null");
    extendStatics(d5, b4);
    function __() {
      this.constructor = d5;
    }
    d5.prototype = b4 === null ? Object.create(b4) : (__.prototype = b4.prototype, new __());
  };
}();
var __values8 = function(o4) {
  var s10 = typeof Symbol === "function" && Symbol.iterator, m2 = s10 && o4[s10], i4 = 0;
  if (m2)
    return m2.call(o4);
  if (o4 && typeof o4.length === "number")
    return {
      next: function() {
        if (o4 && i4 >= o4.length)
          o4 = void 0;
        return { value: o4 && o4[i4++], done: !o4 };
      }
    };
  throw new TypeError(s10 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var InstrumentationBase = (
  /** @class */
  function(_super) {
    __extends4(InstrumentationBase2, _super);
    function InstrumentationBase2(instrumentationName, instrumentationVersion, config) {
      var _this = _super.call(this, instrumentationName, instrumentationVersion, config) || this;
      _this._hooks = [];
      _this._requireInTheMiddleSingleton = RequireInTheMiddleSingleton.getInstance();
      _this._enabled = false;
      _this._wrap = function(moduleExports, name, wrapper) {
        if (isWrapped(moduleExports[name])) {
          _this._unwrap(moduleExports, name);
        }
        if (!utilTypes.isProxy(moduleExports)) {
          return (0, import_shimmer.wrap)(moduleExports, name, wrapper);
        } else {
          var wrapped = (0, import_shimmer.wrap)(Object.assign({}, moduleExports), name, wrapper);
          Object.defineProperty(moduleExports, name, {
            value: wrapped
          });
          return wrapped;
        }
      };
      _this._unwrap = function(moduleExports, name) {
        if (!utilTypes.isProxy(moduleExports)) {
          return (0, import_shimmer.unwrap)(moduleExports, name);
        } else {
          return Object.defineProperty(moduleExports, name, {
            value: moduleExports[name]
          });
        }
      };
      _this._massWrap = function(moduleExportsArray, names, wrapper) {
        if (!moduleExportsArray) {
          diag2.error("must provide one or more modules to patch");
          return;
        } else if (!Array.isArray(moduleExportsArray)) {
          moduleExportsArray = [moduleExportsArray];
        }
        if (!(names && Array.isArray(names))) {
          diag2.error("must provide one or more functions to wrap on modules");
          return;
        }
        moduleExportsArray.forEach(function(moduleExports) {
          names.forEach(function(name) {
            _this._wrap(moduleExports, name, wrapper);
          });
        });
      };
      _this._massUnwrap = function(moduleExportsArray, names) {
        if (!moduleExportsArray) {
          diag2.error("must provide one or more modules to patch");
          return;
        } else if (!Array.isArray(moduleExportsArray)) {
          moduleExportsArray = [moduleExportsArray];
        }
        if (!(names && Array.isArray(names))) {
          diag2.error("must provide one or more functions to wrap on modules");
          return;
        }
        moduleExportsArray.forEach(function(moduleExports) {
          names.forEach(function(name) {
            _this._unwrap(moduleExports, name);
          });
        });
      };
      var modules = _this.init();
      if (modules && !Array.isArray(modules)) {
        modules = [modules];
      }
      _this._modules = modules || [];
      if (_this._config.enabled) {
        _this.enable();
      }
      return _this;
    }
    InstrumentationBase2.prototype._warnOnPreloadedModules = function() {
      var _this = this;
      this._modules.forEach(function(module) {
        var name = module.name;
        try {
          var resolvedModule = __require.resolve(name);
          if (__require.cache[resolvedModule]) {
            _this._diag.warn("Module " + name + " has been loaded before " + _this.instrumentationName + " so it might not work, please initialize it before requiring " + name);
          }
        } catch (_a3) {
        }
      });
    };
    InstrumentationBase2.prototype._extractPackageVersion = function(baseDir) {
      try {
        var json = readFileSync(path2.join(baseDir, "package.json"), {
          encoding: "utf8"
        });
        var version = JSON.parse(json).version;
        return typeof version === "string" ? version : void 0;
      } catch (error) {
        diag2.warn("Failed extracting version", baseDir);
      }
      return void 0;
    };
    InstrumentationBase2.prototype._onRequire = function(module, exports, name, baseDir) {
      var _this = this;
      var _a3;
      if (!baseDir) {
        if (typeof module.patch === "function") {
          module.moduleExports = exports;
          if (this._enabled) {
            this._diag.debug("Applying instrumentation patch for nodejs core module on require hook", {
              module: module.name
            });
            return module.patch(exports);
          }
        }
        return exports;
      }
      var version = this._extractPackageVersion(baseDir);
      module.moduleVersion = version;
      if (module.name === name) {
        if (isSupported(module.supportedVersions, version, module.includePrerelease)) {
          if (typeof module.patch === "function") {
            module.moduleExports = exports;
            if (this._enabled) {
              this._diag.debug("Applying instrumentation patch for module on require hook", {
                module: module.name,
                version: module.moduleVersion,
                baseDir
              });
              return module.patch(exports, module.moduleVersion);
            }
          }
        }
        return exports;
      }
      var files = (_a3 = module.files) !== null && _a3 !== void 0 ? _a3 : [];
      var normalizedName = path2.normalize(name);
      var supportedFileInstrumentations = files.filter(function(f7) {
        return f7.name === normalizedName;
      }).filter(function(f7) {
        return isSupported(f7.supportedVersions, version, module.includePrerelease);
      });
      return supportedFileInstrumentations.reduce(function(patchedExports, file) {
        file.moduleExports = patchedExports;
        if (_this._enabled) {
          _this._diag.debug("Applying instrumentation patch for nodejs module file on require hook", {
            module: module.name,
            version: module.moduleVersion,
            fileName: file.name,
            baseDir
          });
          return file.patch(patchedExports, module.moduleVersion);
        }
        return patchedExports;
      }, exports);
    };
    InstrumentationBase2.prototype.enable = function() {
      var e_1, _a3, e_2, _b, e_3, _c;
      var _this = this;
      if (this._enabled) {
        return;
      }
      this._enabled = true;
      if (this._hooks.length > 0) {
        try {
          for (var _d = __values8(this._modules), _e2 = _d.next(); !_e2.done; _e2 = _d.next()) {
            var module_1 = _e2.value;
            if (typeof module_1.patch === "function" && module_1.moduleExports) {
              this._diag.debug("Applying instrumentation patch for nodejs module on instrumentation enabled", {
                module: module_1.name,
                version: module_1.moduleVersion
              });
              module_1.patch(module_1.moduleExports, module_1.moduleVersion);
            }
            try {
              for (var _f = (e_2 = void 0, __values8(module_1.files)), _g = _f.next(); !_g.done; _g = _f.next()) {
                var file = _g.value;
                if (file.moduleExports) {
                  this._diag.debug("Applying instrumentation patch for nodejs module file on instrumentation enabled", {
                    module: module_1.name,
                    version: module_1.moduleVersion,
                    fileName: file.name
                  });
                  file.patch(file.moduleExports, module_1.moduleVersion);
                }
              }
            } catch (e_2_1) {
              e_2 = { error: e_2_1 };
            } finally {
              try {
                if (_g && !_g.done && (_b = _f.return))
                  _b.call(_f);
              } finally {
                if (e_2)
                  throw e_2.error;
              }
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_e2 && !_e2.done && (_a3 = _d.return))
              _a3.call(_d);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        return;
      }
      this._warnOnPreloadedModules();
      var _loop_1 = function(module_22) {
        var hookFn = function(exports, name, baseDir) {
          return _this._onRequire(module_22, exports, name, baseDir);
        };
        var onRequire = function(exports, name, baseDir) {
          return _this._onRequire(module_22, exports, name, baseDir);
        };
        var hook = path2.isAbsolute(module_22.name) ? new import_require_in_the_middle2.Hook([module_22.name], { internals: true }, onRequire) : this_1._requireInTheMiddleSingleton.register(module_22.name, onRequire);
        this_1._hooks.push(hook);
        var esmHook = new import_import_in_the_middle.Hook([module_22.name], { internals: false }, hookFn);
        this_1._hooks.push(esmHook);
      };
      var this_1 = this;
      try {
        for (var _h = __values8(this._modules), _j = _h.next(); !_j.done; _j = _h.next()) {
          var module_2 = _j.value;
          _loop_1(module_2);
        }
      } catch (e_3_1) {
        e_3 = { error: e_3_1 };
      } finally {
        try {
          if (_j && !_j.done && (_c = _h.return))
            _c.call(_h);
        } finally {
          if (e_3)
            throw e_3.error;
        }
      }
    };
    InstrumentationBase2.prototype.disable = function() {
      var e_4, _a3, e_5, _b;
      if (!this._enabled) {
        return;
      }
      this._enabled = false;
      try {
        for (var _c = __values8(this._modules), _d = _c.next(); !_d.done; _d = _c.next()) {
          var module_3 = _d.value;
          if (typeof module_3.unpatch === "function" && module_3.moduleExports) {
            this._diag.debug("Removing instrumentation patch for nodejs module on instrumentation disabled", {
              module: module_3.name,
              version: module_3.moduleVersion
            });
            module_3.unpatch(module_3.moduleExports, module_3.moduleVersion);
          }
          try {
            for (var _e2 = (e_5 = void 0, __values8(module_3.files)), _f = _e2.next(); !_f.done; _f = _e2.next()) {
              var file = _f.value;
              if (file.moduleExports) {
                this._diag.debug("Removing instrumentation patch for nodejs module file on instrumentation disabled", {
                  module: module_3.name,
                  version: module_3.moduleVersion,
                  fileName: file.name
                });
                file.unpatch(file.moduleExports, module_3.moduleVersion);
              }
            }
          } catch (e_5_1) {
            e_5 = { error: e_5_1 };
          } finally {
            try {
              if (_f && !_f.done && (_b = _e2.return))
                _b.call(_e2);
            } finally {
              if (e_5)
                throw e_5.error;
            }
          }
        }
      } catch (e_4_1) {
        e_4 = { error: e_4_1 };
      } finally {
        try {
          if (_d && !_d.done && (_a3 = _c.return))
            _a3.call(_c);
        } finally {
          if (e_4)
            throw e_4.error;
        }
      }
    };
    InstrumentationBase2.prototype.isEnabled = function() {
      return this._enabled;
    };
    return InstrumentationBase2;
  }(InstrumentationAbstract)
);
function isSupported(supportedVersions, version, includePrerelease) {
  if (typeof version === "undefined") {
    return supportedVersions.includes("*");
  }
  return supportedVersions.some(function(supportedVersion) {
    return (0, import_semver2.satisfies)(version, supportedVersion, { includePrerelease });
  });
}

// node_modules/@opentelemetry/instrumentation-document-load/build/esm/instrumentation.js
init_esm();

// node_modules/@opentelemetry/instrumentation-document-load/build/esm/enums/AttributeNames.js
var AttributeNames;
(function(AttributeNames4) {
  AttributeNames4["DOCUMENT_LOAD"] = "documentLoad";
  AttributeNames4["DOCUMENT_FETCH"] = "documentFetch";
  AttributeNames4["RESOURCE_FETCH"] = "resourceFetch";
})(AttributeNames || (AttributeNames = {}));

// node_modules/@opentelemetry/instrumentation-document-load/build/esm/version.js
var PACKAGE_VERSION = "0.40.0";
var PACKAGE_NAME = "@opentelemetry/instrumentation-document-load";

// node_modules/@opentelemetry/instrumentation-document-load/build/esm/enums/EventNames.js
var EventNames;
(function(EventNames3) {
  EventNames3["FIRST_PAINT"] = "firstPaint";
  EventNames3["FIRST_CONTENTFUL_PAINT"] = "firstContentfulPaint";
})(EventNames || (EventNames = {}));

// node_modules/@opentelemetry/instrumentation-document-load/build/esm/utils.js
var getPerformanceNavigationEntries = function() {
  var _a3, _b;
  var entries = {};
  var performanceNavigationTiming = (_b = (_a3 = otperformance).getEntriesByType) === null || _b === void 0 ? void 0 : _b.call(_a3, "navigation")[0];
  if (performanceNavigationTiming) {
    var keys = Object.values(PerformanceTimingNames);
    keys.forEach(function(key) {
      if (hasKey(performanceNavigationTiming, key)) {
        var value = performanceNavigationTiming[key];
        if (typeof value === "number") {
          entries[key] = value;
        }
      }
    });
  } else {
    var perf = otperformance;
    var performanceTiming_1 = perf.timing;
    if (performanceTiming_1) {
      var keys = Object.values(PerformanceTimingNames);
      keys.forEach(function(key) {
        if (hasKey(performanceTiming_1, key)) {
          var value = performanceTiming_1[key];
          if (typeof value === "number") {
            entries[key] = value;
          }
        }
      });
    }
  }
  return entries;
};
var performancePaintNames = {
  "first-paint": EventNames.FIRST_PAINT,
  "first-contentful-paint": EventNames.FIRST_CONTENTFUL_PAINT
};
var addSpanPerformancePaintEvents = function(span) {
  var _a3, _b;
  var performancePaintTiming = (_b = (_a3 = otperformance).getEntriesByType) === null || _b === void 0 ? void 0 : _b.call(_a3, "paint");
  if (performancePaintTiming) {
    performancePaintTiming.forEach(function(_a4) {
      var name = _a4.name, startTime = _a4.startTime;
      if (hasKey(performancePaintNames, name)) {
        span.addEvent(performancePaintNames[name], startTime);
      }
    });
  }
};

// node_modules/@opentelemetry/instrumentation-document-load/build/esm/instrumentation.js
var __extends5 = function() {
  var extendStatics = function(d5, b4) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d6, b5) {
      d6.__proto__ = b5;
    } || function(d6, b5) {
      for (var p9 in b5)
        if (Object.prototype.hasOwnProperty.call(b5, p9))
          d6[p9] = b5[p9];
    };
    return extendStatics(d5, b4);
  };
  return function(d5, b4) {
    if (typeof b4 !== "function" && b4 !== null)
      throw new TypeError("Class extends value " + String(b4) + " is not a constructor or null");
    extendStatics(d5, b4);
    function __() {
      this.constructor = d5;
    }
    d5.prototype = b4 === null ? Object.create(b4) : (__.prototype = b4.prototype, new __());
  };
}();
var DocumentLoadInstrumentation = (
  /** @class */
  function(_super) {
    __extends5(DocumentLoadInstrumentation2, _super);
    function DocumentLoadInstrumentation2(config) {
      if (config === void 0) {
        config = {};
      }
      var _this = _super.call(this, PACKAGE_NAME, PACKAGE_VERSION, config) || this;
      _this.component = "document-load";
      _this.version = "1";
      _this.moduleName = _this.component;
      return _this;
    }
    DocumentLoadInstrumentation2.prototype.init = function() {
    };
    DocumentLoadInstrumentation2.prototype._onDocumentLoaded = function() {
      var _this = this;
      window.setTimeout(function() {
        _this._collectPerformance();
      });
    };
    DocumentLoadInstrumentation2.prototype._addResourcesSpans = function(rootSpan) {
      var _this = this;
      var _a3, _b;
      var resources = (_b = (_a3 = otperformance).getEntriesByType) === null || _b === void 0 ? void 0 : _b.call(_a3, "resource");
      if (resources) {
        resources.forEach(function(resource) {
          _this._initResourceSpan(resource, rootSpan);
        });
      }
    };
    DocumentLoadInstrumentation2.prototype._collectPerformance = function() {
      var _this = this;
      var metaElement = Array.from(document.getElementsByTagName("meta")).find(function(e7) {
        return e7.getAttribute("name") === TRACE_PARENT_HEADER;
      });
      var entries = getPerformanceNavigationEntries();
      var traceparent = metaElement && metaElement.content || "";
      context.with(propagation.extract(ROOT_CONTEXT, { traceparent }), function() {
        var _a3;
        var rootSpan = _this._startSpan(AttributeNames.DOCUMENT_LOAD, PerformanceTimingNames.FETCH_START, entries);
        if (!rootSpan) {
          return;
        }
        context.with(trace.setSpan(context.active(), rootSpan), function() {
          var fetchSpan = _this._startSpan(AttributeNames.DOCUMENT_FETCH, PerformanceTimingNames.FETCH_START, entries);
          if (fetchSpan) {
            fetchSpan.setAttribute(SEMATTRS_HTTP_URL, location.href);
            context.with(trace.setSpan(context.active(), fetchSpan), function() {
              var _a4;
              if (!_this.getConfig().ignoreNetworkEvents) {
                addSpanNetworkEvents(fetchSpan, entries);
              }
              _this._addCustomAttributesOnSpan(fetchSpan, (_a4 = _this.getConfig().applyCustomAttributesOnSpan) === null || _a4 === void 0 ? void 0 : _a4.documentFetch);
              _this._endSpan(fetchSpan, PerformanceTimingNames.RESPONSE_END, entries);
            });
          }
        });
        rootSpan.setAttribute(SEMATTRS_HTTP_URL, location.href);
        rootSpan.setAttribute(SEMATTRS_HTTP_USER_AGENT, navigator.userAgent);
        _this._addResourcesSpans(rootSpan);
        if (!_this.getConfig().ignoreNetworkEvents) {
          addSpanNetworkEvent(rootSpan, PerformanceTimingNames.FETCH_START, entries);
          addSpanNetworkEvent(rootSpan, PerformanceTimingNames.UNLOAD_EVENT_START, entries);
          addSpanNetworkEvent(rootSpan, PerformanceTimingNames.UNLOAD_EVENT_END, entries);
          addSpanNetworkEvent(rootSpan, PerformanceTimingNames.DOM_INTERACTIVE, entries);
          addSpanNetworkEvent(rootSpan, PerformanceTimingNames.DOM_CONTENT_LOADED_EVENT_START, entries);
          addSpanNetworkEvent(rootSpan, PerformanceTimingNames.DOM_CONTENT_LOADED_EVENT_END, entries);
          addSpanNetworkEvent(rootSpan, PerformanceTimingNames.DOM_COMPLETE, entries);
          addSpanNetworkEvent(rootSpan, PerformanceTimingNames.LOAD_EVENT_START, entries);
          addSpanNetworkEvent(rootSpan, PerformanceTimingNames.LOAD_EVENT_END, entries);
        }
        if (!_this.getConfig().ignorePerformancePaintEvents) {
          addSpanPerformancePaintEvents(rootSpan);
        }
        _this._addCustomAttributesOnSpan(rootSpan, (_a3 = _this.getConfig().applyCustomAttributesOnSpan) === null || _a3 === void 0 ? void 0 : _a3.documentLoad);
        _this._endSpan(rootSpan, PerformanceTimingNames.LOAD_EVENT_END, entries);
      });
    };
    DocumentLoadInstrumentation2.prototype._endSpan = function(span, performanceName, entries) {
      if (span) {
        if (hasKey(entries, performanceName)) {
          span.end(entries[performanceName]);
        } else {
          span.end();
        }
      }
    };
    DocumentLoadInstrumentation2.prototype._initResourceSpan = function(resource, parentSpan) {
      var _a3;
      var span = this._startSpan(AttributeNames.RESOURCE_FETCH, PerformanceTimingNames.FETCH_START, resource, parentSpan);
      if (span) {
        span.setAttribute(SEMATTRS_HTTP_URL, resource.name);
        if (!this.getConfig().ignoreNetworkEvents) {
          addSpanNetworkEvents(span, resource);
        }
        this._addCustomAttributesOnResourceSpan(span, resource, (_a3 = this.getConfig().applyCustomAttributesOnSpan) === null || _a3 === void 0 ? void 0 : _a3.resourceFetch);
        this._endSpan(span, PerformanceTimingNames.RESPONSE_END, resource);
      }
    };
    DocumentLoadInstrumentation2.prototype._startSpan = function(spanName, performanceName, entries, parentSpan) {
      if (hasKey(entries, performanceName) && typeof entries[performanceName] === "number") {
        var span = this.tracer.startSpan(spanName, {
          startTime: entries[performanceName]
        }, parentSpan ? trace.setSpan(context.active(), parentSpan) : void 0);
        return span;
      }
      return void 0;
    };
    DocumentLoadInstrumentation2.prototype._waitForPageLoad = function() {
      if (window.document.readyState === "complete") {
        this._onDocumentLoaded();
      } else {
        this._onDocumentLoaded = this._onDocumentLoaded.bind(this);
        window.addEventListener("load", this._onDocumentLoaded);
      }
    };
    DocumentLoadInstrumentation2.prototype._addCustomAttributesOnSpan = function(span, applyCustomAttributesOnSpan) {
      var _this = this;
      if (applyCustomAttributesOnSpan) {
        safeExecuteInTheMiddle(function() {
          return applyCustomAttributesOnSpan(span);
        }, function(error) {
          if (!error) {
            return;
          }
          _this._diag.error("addCustomAttributesOnSpan", error);
        }, true);
      }
    };
    DocumentLoadInstrumentation2.prototype._addCustomAttributesOnResourceSpan = function(span, resource, applyCustomAttributesOnSpan) {
      var _this = this;
      if (applyCustomAttributesOnSpan) {
        safeExecuteInTheMiddle(function() {
          return applyCustomAttributesOnSpan(span, resource);
        }, function(error) {
          if (!error) {
            return;
          }
          _this._diag.error("addCustomAttributesOnResourceSpan", error);
        }, true);
      }
    };
    DocumentLoadInstrumentation2.prototype.enable = function() {
      window.removeEventListener("load", this._onDocumentLoaded);
      this._waitForPageLoad();
    };
    DocumentLoadInstrumentation2.prototype.disable = function() {
      window.removeEventListener("load", this._onDocumentLoaded);
    };
    return DocumentLoadInstrumentation2;
  }(InstrumentationBase)
);

// node_modules/@opentelemetry/exporter-trace-otlp-http/node_modules/@opentelemetry/core/build/esm/baggage/constants.js
var BAGGAGE_KEY_PAIR_SEPARATOR2 = "=";
var BAGGAGE_PROPERTIES_SEPARATOR2 = ";";
var BAGGAGE_ITEMS_SEPARATOR2 = ",";
var BAGGAGE_MAX_TOTAL_LENGTH2 = 8192;

// node_modules/@opentelemetry/exporter-trace-otlp-http/node_modules/@opentelemetry/core/build/esm/baggage/utils.js
init_esm();
var __read14 = function(o4, n9) {
  var m2 = typeof Symbol === "function" && o4[Symbol.iterator];
  if (!m2)
    return o4;
  var i4 = m2.call(o4), r7, ar = [], e7;
  try {
    while ((n9 === void 0 || n9-- > 0) && !(r7 = i4.next()).done)
      ar.push(r7.value);
  } catch (error) {
    e7 = { error };
  } finally {
    try {
      if (r7 && !r7.done && (m2 = i4["return"]))
        m2.call(i4);
    } finally {
      if (e7)
        throw e7.error;
    }
  }
  return ar;
};
function serializeKeyPairs2(keyPairs) {
  return keyPairs.reduce(function(hValue, current) {
    var value = "" + hValue + (hValue !== "" ? BAGGAGE_ITEMS_SEPARATOR2 : "") + current;
    return value.length > BAGGAGE_MAX_TOTAL_LENGTH2 ? hValue : value;
  }, "");
}
function getKeyPairs2(baggage) {
  return baggage.getAllEntries().map(function(_a3) {
    var _b = __read14(_a3, 2), key = _b[0], value = _b[1];
    var entry = encodeURIComponent(key) + "=" + encodeURIComponent(value.value);
    if (value.metadata !== void 0) {
      entry += BAGGAGE_PROPERTIES_SEPARATOR2 + value.metadata.toString();
    }
    return entry;
  });
}
function parsePairKeyValue2(entry) {
  var valueProps = entry.split(BAGGAGE_PROPERTIES_SEPARATOR2);
  if (valueProps.length <= 0)
    return;
  var keyPairPart = valueProps.shift();
  if (!keyPairPart)
    return;
  var separatorIndex = keyPairPart.indexOf(BAGGAGE_KEY_PAIR_SEPARATOR2);
  if (separatorIndex <= 0)
    return;
  var key = decodeURIComponent(keyPairPart.substring(0, separatorIndex).trim());
  var value = decodeURIComponent(keyPairPart.substring(separatorIndex + 1).trim());
  var metadata;
  if (valueProps.length > 0) {
    metadata = baggageEntryMetadataFromString(valueProps.join(BAGGAGE_PROPERTIES_SEPARATOR2));
  }
  return { key, value, metadata };
}
function parseKeyPairsIntoRecord(value) {
  if (typeof value !== "string" || value.length === 0)
    return {};
  return value.split(BAGGAGE_ITEMS_SEPARATOR2).map(function(entry) {
    return parsePairKeyValue2(entry);
  }).filter(function(keyPair) {
    return keyPair !== void 0 && keyPair.value.length > 0;
  }).reduce(function(headers, keyPair) {
    headers[keyPair.key] = keyPair.value;
    return headers;
  }, {});
}

// node_modules/@opentelemetry/exporter-trace-otlp-http/node_modules/@opentelemetry/core/build/esm/utils/environment.js
init_esm();

// node_modules/@opentelemetry/exporter-trace-otlp-http/node_modules/@opentelemetry/core/build/esm/utils/sampling.js
var TracesSamplerValues2;
(function(TracesSamplerValues4) {
  TracesSamplerValues4["AlwaysOff"] = "always_off";
  TracesSamplerValues4["AlwaysOn"] = "always_on";
  TracesSamplerValues4["ParentBasedAlwaysOff"] = "parentbased_always_off";
  TracesSamplerValues4["ParentBasedAlwaysOn"] = "parentbased_always_on";
  TracesSamplerValues4["ParentBasedTraceIdRatio"] = "parentbased_traceidratio";
  TracesSamplerValues4["TraceIdRatio"] = "traceidratio";
})(TracesSamplerValues2 || (TracesSamplerValues2 = {}));

// node_modules/@opentelemetry/exporter-trace-otlp-http/node_modules/@opentelemetry/core/build/esm/utils/environment.js
var DEFAULT_LIST_SEPARATOR2 = ",";
var ENVIRONMENT_BOOLEAN_KEYS2 = ["OTEL_SDK_DISABLED"];
function isEnvVarABoolean2(key) {
  return ENVIRONMENT_BOOLEAN_KEYS2.indexOf(key) > -1;
}
var ENVIRONMENT_NUMBERS_KEYS2 = [
  "OTEL_BSP_EXPORT_TIMEOUT",
  "OTEL_BSP_MAX_EXPORT_BATCH_SIZE",
  "OTEL_BSP_MAX_QUEUE_SIZE",
  "OTEL_BSP_SCHEDULE_DELAY",
  "OTEL_BLRP_EXPORT_TIMEOUT",
  "OTEL_BLRP_MAX_EXPORT_BATCH_SIZE",
  "OTEL_BLRP_MAX_QUEUE_SIZE",
  "OTEL_BLRP_SCHEDULE_DELAY",
  "OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT",
  "OTEL_ATTRIBUTE_COUNT_LIMIT",
  "OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT",
  "OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT",
  "OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT",
  "OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT",
  "OTEL_SPAN_EVENT_COUNT_LIMIT",
  "OTEL_SPAN_LINK_COUNT_LIMIT",
  "OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT",
  "OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT",
  "OTEL_EXPORTER_OTLP_TIMEOUT",
  "OTEL_EXPORTER_OTLP_TRACES_TIMEOUT",
  "OTEL_EXPORTER_OTLP_METRICS_TIMEOUT",
  "OTEL_EXPORTER_OTLP_LOGS_TIMEOUT",
  "OTEL_EXPORTER_JAEGER_AGENT_PORT"
];
function isEnvVarANumber2(key) {
  return ENVIRONMENT_NUMBERS_KEYS2.indexOf(key) > -1;
}
var ENVIRONMENT_LISTS_KEYS2 = [
  "OTEL_NO_PATCH_MODULES",
  "OTEL_PROPAGATORS"
];
function isEnvVarAList2(key) {
  return ENVIRONMENT_LISTS_KEYS2.indexOf(key) > -1;
}
var DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT2 = Infinity;
var DEFAULT_ATTRIBUTE_COUNT_LIMIT2 = 128;
var DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT2 = 128;
var DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT2 = 128;
var DEFAULT_ENVIRONMENT2 = {
  OTEL_SDK_DISABLED: false,
  CONTAINER_NAME: "",
  ECS_CONTAINER_METADATA_URI_V4: "",
  ECS_CONTAINER_METADATA_URI: "",
  HOSTNAME: "",
  KUBERNETES_SERVICE_HOST: "",
  NAMESPACE: "",
  OTEL_BSP_EXPORT_TIMEOUT: 3e4,
  OTEL_BSP_MAX_EXPORT_BATCH_SIZE: 512,
  OTEL_BSP_MAX_QUEUE_SIZE: 2048,
  OTEL_BSP_SCHEDULE_DELAY: 5e3,
  OTEL_BLRP_EXPORT_TIMEOUT: 3e4,
  OTEL_BLRP_MAX_EXPORT_BATCH_SIZE: 512,
  OTEL_BLRP_MAX_QUEUE_SIZE: 2048,
  OTEL_BLRP_SCHEDULE_DELAY: 5e3,
  OTEL_EXPORTER_JAEGER_AGENT_HOST: "",
  OTEL_EXPORTER_JAEGER_AGENT_PORT: 6832,
  OTEL_EXPORTER_JAEGER_ENDPOINT: "",
  OTEL_EXPORTER_JAEGER_PASSWORD: "",
  OTEL_EXPORTER_JAEGER_USER: "",
  OTEL_EXPORTER_OTLP_ENDPOINT: "",
  OTEL_EXPORTER_OTLP_TRACES_ENDPOINT: "",
  OTEL_EXPORTER_OTLP_METRICS_ENDPOINT: "",
  OTEL_EXPORTER_OTLP_LOGS_ENDPOINT: "",
  OTEL_EXPORTER_OTLP_HEADERS: "",
  OTEL_EXPORTER_OTLP_TRACES_HEADERS: "",
  OTEL_EXPORTER_OTLP_METRICS_HEADERS: "",
  OTEL_EXPORTER_OTLP_LOGS_HEADERS: "",
  OTEL_EXPORTER_OTLP_TIMEOUT: 1e4,
  OTEL_EXPORTER_OTLP_TRACES_TIMEOUT: 1e4,
  OTEL_EXPORTER_OTLP_METRICS_TIMEOUT: 1e4,
  OTEL_EXPORTER_OTLP_LOGS_TIMEOUT: 1e4,
  OTEL_EXPORTER_ZIPKIN_ENDPOINT: "http://localhost:9411/api/v2/spans",
  OTEL_LOG_LEVEL: DiagLogLevel.INFO,
  OTEL_NO_PATCH_MODULES: [],
  OTEL_PROPAGATORS: ["tracecontext", "baggage"],
  OTEL_RESOURCE_ATTRIBUTES: "",
  OTEL_SERVICE_NAME: "",
  OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT: DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT2,
  OTEL_ATTRIBUTE_COUNT_LIMIT: DEFAULT_ATTRIBUTE_COUNT_LIMIT2,
  OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT: DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT2,
  OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT: DEFAULT_ATTRIBUTE_COUNT_LIMIT2,
  OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT: DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT2,
  OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT: DEFAULT_ATTRIBUTE_COUNT_LIMIT2,
  OTEL_SPAN_EVENT_COUNT_LIMIT: 128,
  OTEL_SPAN_LINK_COUNT_LIMIT: 128,
  OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT: DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT2,
  OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT: DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT2,
  OTEL_TRACES_EXPORTER: "",
  OTEL_TRACES_SAMPLER: TracesSamplerValues2.ParentBasedAlwaysOn,
  OTEL_TRACES_SAMPLER_ARG: "",
  OTEL_LOGS_EXPORTER: "",
  OTEL_EXPORTER_OTLP_INSECURE: "",
  OTEL_EXPORTER_OTLP_TRACES_INSECURE: "",
  OTEL_EXPORTER_OTLP_METRICS_INSECURE: "",
  OTEL_EXPORTER_OTLP_LOGS_INSECURE: "",
  OTEL_EXPORTER_OTLP_CERTIFICATE: "",
  OTEL_EXPORTER_OTLP_TRACES_CERTIFICATE: "",
  OTEL_EXPORTER_OTLP_METRICS_CERTIFICATE: "",
  OTEL_EXPORTER_OTLP_LOGS_CERTIFICATE: "",
  OTEL_EXPORTER_OTLP_COMPRESSION: "",
  OTEL_EXPORTER_OTLP_TRACES_COMPRESSION: "",
  OTEL_EXPORTER_OTLP_METRICS_COMPRESSION: "",
  OTEL_EXPORTER_OTLP_LOGS_COMPRESSION: "",
  OTEL_EXPORTER_OTLP_CLIENT_KEY: "",
  OTEL_EXPORTER_OTLP_TRACES_CLIENT_KEY: "",
  OTEL_EXPORTER_OTLP_METRICS_CLIENT_KEY: "",
  OTEL_EXPORTER_OTLP_LOGS_CLIENT_KEY: "",
  OTEL_EXPORTER_OTLP_CLIENT_CERTIFICATE: "",
  OTEL_EXPORTER_OTLP_TRACES_CLIENT_CERTIFICATE: "",
  OTEL_EXPORTER_OTLP_METRICS_CLIENT_CERTIFICATE: "",
  OTEL_EXPORTER_OTLP_LOGS_CLIENT_CERTIFICATE: "",
  OTEL_EXPORTER_OTLP_PROTOCOL: "http/protobuf",
  OTEL_EXPORTER_OTLP_TRACES_PROTOCOL: "http/protobuf",
  OTEL_EXPORTER_OTLP_METRICS_PROTOCOL: "http/protobuf",
  OTEL_EXPORTER_OTLP_LOGS_PROTOCOL: "http/protobuf",
  OTEL_EXPORTER_OTLP_METRICS_TEMPORALITY_PREFERENCE: "cumulative"
};
function parseBoolean2(key, environment, values) {
  if (typeof values[key] === "undefined") {
    return;
  }
  var value = String(values[key]);
  environment[key] = value.toLowerCase() === "true";
}
function parseNumber2(name, environment, values, min, max) {
  if (min === void 0) {
    min = -Infinity;
  }
  if (max === void 0) {
    max = Infinity;
  }
  if (typeof values[name] !== "undefined") {
    var value = Number(values[name]);
    if (!isNaN(value)) {
      if (value < min) {
        environment[name] = min;
      } else if (value > max) {
        environment[name] = max;
      } else {
        environment[name] = value;
      }
    }
  }
}
function parseStringList2(name, output, input, separator) {
  if (separator === void 0) {
    separator = DEFAULT_LIST_SEPARATOR2;
  }
  var givenValue = input[name];
  if (typeof givenValue === "string") {
    output[name] = givenValue.split(separator).map(function(v4) {
      return v4.trim();
    });
  }
}
var logLevelMap2 = {
  ALL: DiagLogLevel.ALL,
  VERBOSE: DiagLogLevel.VERBOSE,
  DEBUG: DiagLogLevel.DEBUG,
  INFO: DiagLogLevel.INFO,
  WARN: DiagLogLevel.WARN,
  ERROR: DiagLogLevel.ERROR,
  NONE: DiagLogLevel.NONE
};
function setLogLevelFromEnv2(key, environment, values) {
  var value = values[key];
  if (typeof value === "string") {
    var theLevel = logLevelMap2[value.toUpperCase()];
    if (theLevel != null) {
      environment[key] = theLevel;
    }
  }
}
function parseEnvironment2(values) {
  var environment = {};
  for (var env2 in DEFAULT_ENVIRONMENT2) {
    var key = env2;
    switch (key) {
      case "OTEL_LOG_LEVEL":
        setLogLevelFromEnv2(key, environment, values);
        break;
      default:
        if (isEnvVarABoolean2(key)) {
          parseBoolean2(key, environment, values);
        } else if (isEnvVarANumber2(key)) {
          parseNumber2(key, environment, values);
        } else if (isEnvVarAList2(key)) {
          parseStringList2(key, environment, values);
        } else {
          var value = values[key];
          if (typeof value !== "undefined" && value !== null) {
            environment[key] = String(value);
          }
        }
    }
  }
  return environment;
}

// node_modules/@opentelemetry/exporter-trace-otlp-http/node_modules/@opentelemetry/core/build/esm/platform/node/environment.js
function getEnv2() {
  var processEnv = parseEnvironment2(process.env);
  return Object.assign({}, DEFAULT_ENVIRONMENT2, processEnv);
}

// node_modules/@opentelemetry/exporter-trace-otlp-http/node_modules/@opentelemetry/core/build/esm/index.js
var baggageUtils = {
  getKeyPairs: getKeyPairs2,
  serializeKeyPairs: serializeKeyPairs2,
  parseKeyPairsIntoRecord,
  parsePairKeyValue: parsePairKeyValue2
};

// node_modules/@opentelemetry/otlp-exporter-base/build/esm/OTLPExporterBase.js
init_esm();

// node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/esm/baggage/constants.js
var BAGGAGE_KEY_PAIR_SEPARATOR3 = "=";
var BAGGAGE_PROPERTIES_SEPARATOR3 = ";";
var BAGGAGE_ITEMS_SEPARATOR3 = ",";
var BAGGAGE_MAX_TOTAL_LENGTH3 = 8192;

// node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/esm/baggage/utils.js
init_esm();
var __read15 = function(o4, n9) {
  var m2 = typeof Symbol === "function" && o4[Symbol.iterator];
  if (!m2)
    return o4;
  var i4 = m2.call(o4), r7, ar = [], e7;
  try {
    while ((n9 === void 0 || n9-- > 0) && !(r7 = i4.next()).done)
      ar.push(r7.value);
  } catch (error) {
    e7 = { error };
  } finally {
    try {
      if (r7 && !r7.done && (m2 = i4["return"]))
        m2.call(i4);
    } finally {
      if (e7)
        throw e7.error;
    }
  }
  return ar;
};
function serializeKeyPairs3(keyPairs) {
  return keyPairs.reduce(function(hValue, current) {
    var value = "" + hValue + (hValue !== "" ? BAGGAGE_ITEMS_SEPARATOR3 : "") + current;
    return value.length > BAGGAGE_MAX_TOTAL_LENGTH3 ? hValue : value;
  }, "");
}
function getKeyPairs3(baggage) {
  return baggage.getAllEntries().map(function(_a3) {
    var _b = __read15(_a3, 2), key = _b[0], value = _b[1];
    var entry = encodeURIComponent(key) + "=" + encodeURIComponent(value.value);
    if (value.metadata !== void 0) {
      entry += BAGGAGE_PROPERTIES_SEPARATOR3 + value.metadata.toString();
    }
    return entry;
  });
}
function parsePairKeyValue3(entry) {
  var valueProps = entry.split(BAGGAGE_PROPERTIES_SEPARATOR3);
  if (valueProps.length <= 0)
    return;
  var keyPairPart = valueProps.shift();
  if (!keyPairPart)
    return;
  var separatorIndex = keyPairPart.indexOf(BAGGAGE_KEY_PAIR_SEPARATOR3);
  if (separatorIndex <= 0)
    return;
  var key = decodeURIComponent(keyPairPart.substring(0, separatorIndex).trim());
  var value = decodeURIComponent(keyPairPart.substring(separatorIndex + 1).trim());
  var metadata;
  if (valueProps.length > 0) {
    metadata = baggageEntryMetadataFromString(valueProps.join(BAGGAGE_PROPERTIES_SEPARATOR3));
  }
  return { key, value, metadata };
}
function parseKeyPairsIntoRecord2(value) {
  if (typeof value !== "string" || value.length === 0)
    return {};
  return value.split(BAGGAGE_ITEMS_SEPARATOR3).map(function(entry) {
    return parsePairKeyValue3(entry);
  }).filter(function(keyPair) {
    return keyPair !== void 0 && keyPair.value.length > 0;
  }).reduce(function(headers, keyPair) {
    headers[keyPair.key] = keyPair.value;
    return headers;
  }, {});
}

// node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/esm/utils/environment.js
init_esm();

// node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/esm/utils/sampling.js
var TracesSamplerValues3;
(function(TracesSamplerValues4) {
  TracesSamplerValues4["AlwaysOff"] = "always_off";
  TracesSamplerValues4["AlwaysOn"] = "always_on";
  TracesSamplerValues4["ParentBasedAlwaysOff"] = "parentbased_always_off";
  TracesSamplerValues4["ParentBasedAlwaysOn"] = "parentbased_always_on";
  TracesSamplerValues4["ParentBasedTraceIdRatio"] = "parentbased_traceidratio";
  TracesSamplerValues4["TraceIdRatio"] = "traceidratio";
})(TracesSamplerValues3 || (TracesSamplerValues3 = {}));

// node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/esm/utils/environment.js
var DEFAULT_LIST_SEPARATOR3 = ",";
var ENVIRONMENT_BOOLEAN_KEYS3 = ["OTEL_SDK_DISABLED"];
function isEnvVarABoolean3(key) {
  return ENVIRONMENT_BOOLEAN_KEYS3.indexOf(key) > -1;
}
var ENVIRONMENT_NUMBERS_KEYS3 = [
  "OTEL_BSP_EXPORT_TIMEOUT",
  "OTEL_BSP_MAX_EXPORT_BATCH_SIZE",
  "OTEL_BSP_MAX_QUEUE_SIZE",
  "OTEL_BSP_SCHEDULE_DELAY",
  "OTEL_BLRP_EXPORT_TIMEOUT",
  "OTEL_BLRP_MAX_EXPORT_BATCH_SIZE",
  "OTEL_BLRP_MAX_QUEUE_SIZE",
  "OTEL_BLRP_SCHEDULE_DELAY",
  "OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT",
  "OTEL_ATTRIBUTE_COUNT_LIMIT",
  "OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT",
  "OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT",
  "OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT",
  "OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT",
  "OTEL_SPAN_EVENT_COUNT_LIMIT",
  "OTEL_SPAN_LINK_COUNT_LIMIT",
  "OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT",
  "OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT",
  "OTEL_EXPORTER_OTLP_TIMEOUT",
  "OTEL_EXPORTER_OTLP_TRACES_TIMEOUT",
  "OTEL_EXPORTER_OTLP_METRICS_TIMEOUT",
  "OTEL_EXPORTER_OTLP_LOGS_TIMEOUT",
  "OTEL_EXPORTER_JAEGER_AGENT_PORT"
];
function isEnvVarANumber3(key) {
  return ENVIRONMENT_NUMBERS_KEYS3.indexOf(key) > -1;
}
var ENVIRONMENT_LISTS_KEYS3 = [
  "OTEL_NO_PATCH_MODULES",
  "OTEL_PROPAGATORS"
];
function isEnvVarAList3(key) {
  return ENVIRONMENT_LISTS_KEYS3.indexOf(key) > -1;
}
var DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT3 = Infinity;
var DEFAULT_ATTRIBUTE_COUNT_LIMIT3 = 128;
var DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT3 = 128;
var DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT3 = 128;
var DEFAULT_ENVIRONMENT3 = {
  OTEL_SDK_DISABLED: false,
  CONTAINER_NAME: "",
  ECS_CONTAINER_METADATA_URI_V4: "",
  ECS_CONTAINER_METADATA_URI: "",
  HOSTNAME: "",
  KUBERNETES_SERVICE_HOST: "",
  NAMESPACE: "",
  OTEL_BSP_EXPORT_TIMEOUT: 3e4,
  OTEL_BSP_MAX_EXPORT_BATCH_SIZE: 512,
  OTEL_BSP_MAX_QUEUE_SIZE: 2048,
  OTEL_BSP_SCHEDULE_DELAY: 5e3,
  OTEL_BLRP_EXPORT_TIMEOUT: 3e4,
  OTEL_BLRP_MAX_EXPORT_BATCH_SIZE: 512,
  OTEL_BLRP_MAX_QUEUE_SIZE: 2048,
  OTEL_BLRP_SCHEDULE_DELAY: 5e3,
  OTEL_EXPORTER_JAEGER_AGENT_HOST: "",
  OTEL_EXPORTER_JAEGER_AGENT_PORT: 6832,
  OTEL_EXPORTER_JAEGER_ENDPOINT: "",
  OTEL_EXPORTER_JAEGER_PASSWORD: "",
  OTEL_EXPORTER_JAEGER_USER: "",
  OTEL_EXPORTER_OTLP_ENDPOINT: "",
  OTEL_EXPORTER_OTLP_TRACES_ENDPOINT: "",
  OTEL_EXPORTER_OTLP_METRICS_ENDPOINT: "",
  OTEL_EXPORTER_OTLP_LOGS_ENDPOINT: "",
  OTEL_EXPORTER_OTLP_HEADERS: "",
  OTEL_EXPORTER_OTLP_TRACES_HEADERS: "",
  OTEL_EXPORTER_OTLP_METRICS_HEADERS: "",
  OTEL_EXPORTER_OTLP_LOGS_HEADERS: "",
  OTEL_EXPORTER_OTLP_TIMEOUT: 1e4,
  OTEL_EXPORTER_OTLP_TRACES_TIMEOUT: 1e4,
  OTEL_EXPORTER_OTLP_METRICS_TIMEOUT: 1e4,
  OTEL_EXPORTER_OTLP_LOGS_TIMEOUT: 1e4,
  OTEL_EXPORTER_ZIPKIN_ENDPOINT: "http://localhost:9411/api/v2/spans",
  OTEL_LOG_LEVEL: DiagLogLevel.INFO,
  OTEL_NO_PATCH_MODULES: [],
  OTEL_PROPAGATORS: ["tracecontext", "baggage"],
  OTEL_RESOURCE_ATTRIBUTES: "",
  OTEL_SERVICE_NAME: "",
  OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT: DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT3,
  OTEL_ATTRIBUTE_COUNT_LIMIT: DEFAULT_ATTRIBUTE_COUNT_LIMIT3,
  OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT: DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT3,
  OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT: DEFAULT_ATTRIBUTE_COUNT_LIMIT3,
  OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT: DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT3,
  OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT: DEFAULT_ATTRIBUTE_COUNT_LIMIT3,
  OTEL_SPAN_EVENT_COUNT_LIMIT: 128,
  OTEL_SPAN_LINK_COUNT_LIMIT: 128,
  OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT: DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT3,
  OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT: DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT3,
  OTEL_TRACES_EXPORTER: "",
  OTEL_TRACES_SAMPLER: TracesSamplerValues3.ParentBasedAlwaysOn,
  OTEL_TRACES_SAMPLER_ARG: "",
  OTEL_LOGS_EXPORTER: "",
  OTEL_EXPORTER_OTLP_INSECURE: "",
  OTEL_EXPORTER_OTLP_TRACES_INSECURE: "",
  OTEL_EXPORTER_OTLP_METRICS_INSECURE: "",
  OTEL_EXPORTER_OTLP_LOGS_INSECURE: "",
  OTEL_EXPORTER_OTLP_CERTIFICATE: "",
  OTEL_EXPORTER_OTLP_TRACES_CERTIFICATE: "",
  OTEL_EXPORTER_OTLP_METRICS_CERTIFICATE: "",
  OTEL_EXPORTER_OTLP_LOGS_CERTIFICATE: "",
  OTEL_EXPORTER_OTLP_COMPRESSION: "",
  OTEL_EXPORTER_OTLP_TRACES_COMPRESSION: "",
  OTEL_EXPORTER_OTLP_METRICS_COMPRESSION: "",
  OTEL_EXPORTER_OTLP_LOGS_COMPRESSION: "",
  OTEL_EXPORTER_OTLP_CLIENT_KEY: "",
  OTEL_EXPORTER_OTLP_TRACES_CLIENT_KEY: "",
  OTEL_EXPORTER_OTLP_METRICS_CLIENT_KEY: "",
  OTEL_EXPORTER_OTLP_LOGS_CLIENT_KEY: "",
  OTEL_EXPORTER_OTLP_CLIENT_CERTIFICATE: "",
  OTEL_EXPORTER_OTLP_TRACES_CLIENT_CERTIFICATE: "",
  OTEL_EXPORTER_OTLP_METRICS_CLIENT_CERTIFICATE: "",
  OTEL_EXPORTER_OTLP_LOGS_CLIENT_CERTIFICATE: "",
  OTEL_EXPORTER_OTLP_PROTOCOL: "http/protobuf",
  OTEL_EXPORTER_OTLP_TRACES_PROTOCOL: "http/protobuf",
  OTEL_EXPORTER_OTLP_METRICS_PROTOCOL: "http/protobuf",
  OTEL_EXPORTER_OTLP_LOGS_PROTOCOL: "http/protobuf",
  OTEL_EXPORTER_OTLP_METRICS_TEMPORALITY_PREFERENCE: "cumulative"
};
function parseBoolean3(key, environment, values) {
  if (typeof values[key] === "undefined") {
    return;
  }
  var value = String(values[key]);
  environment[key] = value.toLowerCase() === "true";
}
function parseNumber3(name, environment, values, min, max) {
  if (min === void 0) {
    min = -Infinity;
  }
  if (max === void 0) {
    max = Infinity;
  }
  if (typeof values[name] !== "undefined") {
    var value = Number(values[name]);
    if (!isNaN(value)) {
      if (value < min) {
        environment[name] = min;
      } else if (value > max) {
        environment[name] = max;
      } else {
        environment[name] = value;
      }
    }
  }
}
function parseStringList3(name, output, input, separator) {
  if (separator === void 0) {
    separator = DEFAULT_LIST_SEPARATOR3;
  }
  var givenValue = input[name];
  if (typeof givenValue === "string") {
    output[name] = givenValue.split(separator).map(function(v4) {
      return v4.trim();
    });
  }
}
var logLevelMap3 = {
  ALL: DiagLogLevel.ALL,
  VERBOSE: DiagLogLevel.VERBOSE,
  DEBUG: DiagLogLevel.DEBUG,
  INFO: DiagLogLevel.INFO,
  WARN: DiagLogLevel.WARN,
  ERROR: DiagLogLevel.ERROR,
  NONE: DiagLogLevel.NONE
};
function setLogLevelFromEnv3(key, environment, values) {
  var value = values[key];
  if (typeof value === "string") {
    var theLevel = logLevelMap3[value.toUpperCase()];
    if (theLevel != null) {
      environment[key] = theLevel;
    }
  }
}
function parseEnvironment3(values) {
  var environment = {};
  for (var env2 in DEFAULT_ENVIRONMENT3) {
    var key = env2;
    switch (key) {
      case "OTEL_LOG_LEVEL":
        setLogLevelFromEnv3(key, environment, values);
        break;
      default:
        if (isEnvVarABoolean3(key)) {
          parseBoolean3(key, environment, values);
        } else if (isEnvVarANumber3(key)) {
          parseNumber3(key, environment, values);
        } else if (isEnvVarAList3(key)) {
          parseStringList3(key, environment, values);
        } else {
          var value = values[key];
          if (typeof value !== "undefined" && value !== null) {
            environment[key] = String(value);
          }
        }
    }
  }
  return environment;
}

// node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/esm/platform/node/environment.js
function getEnv3() {
  var processEnv = parseEnvironment3(process.env);
  return Object.assign({}, DEFAULT_ENVIRONMENT3, processEnv);
}

// node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/esm/ExportResult.js
var ExportResultCode2;
(function(ExportResultCode3) {
  ExportResultCode3[ExportResultCode3["SUCCESS"] = 0] = "SUCCESS";
  ExportResultCode3[ExportResultCode3["FAILED"] = 1] = "FAILED";
})(ExportResultCode2 || (ExportResultCode2 = {}));

// node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/esm/utils/promise.js
var Deferred2 = (
  /** @class */
  function() {
    function Deferred3() {
      var _this = this;
      this._promise = new Promise(function(resolve, reject) {
        _this._resolve = resolve;
        _this._reject = reject;
      });
    }
    Object.defineProperty(Deferred3.prototype, "promise", {
      get: function() {
        return this._promise;
      },
      enumerable: false,
      configurable: true
    });
    Deferred3.prototype.resolve = function(val) {
      this._resolve(val);
    };
    Deferred3.prototype.reject = function(err) {
      this._reject(err);
    };
    return Deferred3;
  }()
);

// node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/esm/utils/callback.js
var __read16 = function(o4, n9) {
  var m2 = typeof Symbol === "function" && o4[Symbol.iterator];
  if (!m2)
    return o4;
  var i4 = m2.call(o4), r7, ar = [], e7;
  try {
    while ((n9 === void 0 || n9-- > 0) && !(r7 = i4.next()).done)
      ar.push(r7.value);
  } catch (error) {
    e7 = { error };
  } finally {
    try {
      if (r7 && !r7.done && (m2 = i4["return"]))
        m2.call(i4);
    } finally {
      if (e7)
        throw e7.error;
    }
  }
  return ar;
};
var __spreadArray10 = function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i4 = 0, l5 = from.length, ar; i4 < l5; i4++) {
      if (ar || !(i4 in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i4);
        ar[i4] = from[i4];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var BindOnceFuture2 = (
  /** @class */
  function() {
    function BindOnceFuture3(_callback, _that) {
      this._callback = _callback;
      this._that = _that;
      this._isCalled = false;
      this._deferred = new Deferred2();
    }
    Object.defineProperty(BindOnceFuture3.prototype, "isCalled", {
      get: function() {
        return this._isCalled;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BindOnceFuture3.prototype, "promise", {
      get: function() {
        return this._deferred.promise;
      },
      enumerable: false,
      configurable: true
    });
    BindOnceFuture3.prototype.call = function() {
      var _a3;
      var _this = this;
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      if (!this._isCalled) {
        this._isCalled = true;
        try {
          Promise.resolve((_a3 = this._callback).call.apply(_a3, __spreadArray10([this._that], __read16(args), false))).then(function(val) {
            return _this._deferred.resolve(val);
          }, function(err) {
            return _this._deferred.reject(err);
          });
        } catch (err) {
          this._deferred.reject(err);
        }
      }
      return this._deferred.promise;
    };
    return BindOnceFuture3;
  }()
);

// node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/esm/index.js
var baggageUtils2 = {
  getKeyPairs: getKeyPairs3,
  serializeKeyPairs: serializeKeyPairs3,
  parseKeyPairsIntoRecord: parseKeyPairsIntoRecord2,
  parsePairKeyValue: parsePairKeyValue3
};

// node_modules/@opentelemetry/otlp-exporter-base/build/esm/util.js
init_esm();
var __read17 = function(o4, n9) {
  var m2 = typeof Symbol === "function" && o4[Symbol.iterator];
  if (!m2)
    return o4;
  var i4 = m2.call(o4), r7, ar = [], e7;
  try {
    while ((n9 === void 0 || n9-- > 0) && !(r7 = i4.next()).done)
      ar.push(r7.value);
  } catch (error) {
    e7 = { error };
  } finally {
    try {
      if (r7 && !r7.done && (m2 = i4["return"]))
        m2.call(i4);
    } finally {
      if (e7)
        throw e7.error;
    }
  }
  return ar;
};
var DEFAULT_TRACE_TIMEOUT = 1e4;
function parseHeaders(partialHeaders) {
  if (partialHeaders === void 0) {
    partialHeaders = {};
  }
  var headers = {};
  Object.entries(partialHeaders).forEach(function(_a3) {
    var _b = __read17(_a3, 2), key = _b[0], value = _b[1];
    if (typeof value !== "undefined") {
      headers[key] = String(value);
    } else {
      diag2.warn('Header "' + key + '" has invalid value (' + value + ") and will be ignored");
    }
  });
  return headers;
}
function appendResourcePathToUrl(url, path3) {
  if (!url.endsWith("/")) {
    url = url + "/";
  }
  return url + path3;
}
function appendRootPathToUrlIfNeeded(url) {
  try {
    var parsedUrl = new URL(url);
    if (parsedUrl.pathname === "") {
      parsedUrl.pathname = parsedUrl.pathname + "/";
    }
    return parsedUrl.toString();
  } catch (_a3) {
    diag2.warn("Could not parse export URL: '" + url + "'");
    return url;
  }
}
function configureExporterTimeout(timeoutMillis) {
  if (typeof timeoutMillis === "number") {
    if (timeoutMillis <= 0) {
      return invalidTimeout(timeoutMillis, DEFAULT_TRACE_TIMEOUT);
    }
    return timeoutMillis;
  } else {
    return getExporterTimeoutFromEnv();
  }
}
function getExporterTimeoutFromEnv() {
  var _a3;
  var definedTimeout = Number((_a3 = getEnv3().OTEL_EXPORTER_OTLP_TRACES_TIMEOUT) !== null && _a3 !== void 0 ? _a3 : getEnv3().OTEL_EXPORTER_OTLP_TIMEOUT);
  if (definedTimeout <= 0) {
    return invalidTimeout(definedTimeout, DEFAULT_TRACE_TIMEOUT);
  } else {
    return definedTimeout;
  }
}
function invalidTimeout(timeout, defaultTimeout) {
  diag2.warn("Timeout must be greater than 0", timeout);
  return defaultTimeout;
}

// node_modules/@opentelemetry/otlp-exporter-base/build/esm/OTLPExporterBase.js
var OTLPExporterBase = (
  /** @class */
  function() {
    function OTLPExporterBase2(config) {
      if (config === void 0) {
        config = {};
      }
      this._sendingPromises = [];
      this.url = this.getDefaultUrl(config);
      if (typeof config.hostname === "string") {
        this.hostname = config.hostname;
      }
      this.shutdown = this.shutdown.bind(this);
      this._shutdownOnce = new BindOnceFuture2(this._shutdown, this);
      this._concurrencyLimit = typeof config.concurrencyLimit === "number" ? config.concurrencyLimit : 30;
      this.timeoutMillis = configureExporterTimeout(config.timeoutMillis);
      this.onInit(config);
    }
    OTLPExporterBase2.prototype.export = function(items, resultCallback) {
      if (this._shutdownOnce.isCalled) {
        resultCallback({
          code: ExportResultCode2.FAILED,
          error: new Error("Exporter has been shutdown")
        });
        return;
      }
      if (this._sendingPromises.length >= this._concurrencyLimit) {
        resultCallback({
          code: ExportResultCode2.FAILED,
          error: new Error("Concurrent export limit reached")
        });
        return;
      }
      this._export(items).then(function() {
        resultCallback({ code: ExportResultCode2.SUCCESS });
      }).catch(function(error) {
        resultCallback({ code: ExportResultCode2.FAILED, error });
      });
    };
    OTLPExporterBase2.prototype._export = function(items) {
      var _this = this;
      return new Promise(function(resolve, reject) {
        try {
          diag2.debug("items to be sent", items);
          _this.send(items, resolve, reject);
        } catch (e7) {
          reject(e7);
        }
      });
    };
    OTLPExporterBase2.prototype.shutdown = function() {
      return this._shutdownOnce.call();
    };
    OTLPExporterBase2.prototype.forceFlush = function() {
      return Promise.all(this._sendingPromises).then(function() {
      });
    };
    OTLPExporterBase2.prototype._shutdown = function() {
      diag2.debug("shutdown started");
      this.onShutdown();
      return this.forceFlush();
    };
    return OTLPExporterBase2;
  }()
);

// node_modules/@opentelemetry/otlp-exporter-base/build/esm/platform/node/types.js
var CompressionAlgorithm;
(function(CompressionAlgorithm2) {
  CompressionAlgorithm2["NONE"] = "none";
  CompressionAlgorithm2["GZIP"] = "gzip";
})(CompressionAlgorithm || (CompressionAlgorithm = {}));

// node_modules/@opentelemetry/otlp-exporter-base/build/esm/platform/node/util.js
function configureCompression(compression) {
  if (compression) {
    return compression;
  } else {
    var definedCompression = getEnv3().OTEL_EXPORTER_OTLP_TRACES_COMPRESSION || getEnv3().OTEL_EXPORTER_OTLP_COMPRESSION;
    return definedCompression === CompressionAlgorithm.GZIP ? CompressionAlgorithm.GZIP : CompressionAlgorithm.NONE;
  }
}

// node_modules/@opentelemetry/otlp-exporter-base/build/esm/platform/node/OTLPExporterNodeBase.js
init_esm();

// node_modules/@opentelemetry/otlp-exporter-base/build/esm/platform/node/http-exporter-transport.js
var __awaiter2 = function(thisArg, _arguments, P6, generator) {
  function adopt(value) {
    return value instanceof P6 ? value : new P6(function(resolve) {
      resolve(value);
    });
  }
  return new (P6 || (P6 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e7) {
        reject(e7);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e7) {
        reject(e7);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator2 = function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t5[0] & 1)
      throw t5[1];
    return t5[1];
  }, trys: [], ops: [] }, f7, y4, t5, g6;
  return g6 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g6[Symbol.iterator] = function() {
    return this;
  }), g6;
  function verb(n9) {
    return function(v4) {
      return step([n9, v4]);
    };
  }
  function step(op) {
    if (f7)
      throw new TypeError("Generator is already executing.");
    while (_2)
      try {
        if (f7 = 1, y4 && (t5 = op[0] & 2 ? y4["return"] : op[0] ? y4["throw"] || ((t5 = y4["return"]) && t5.call(y4), 0) : y4.next) && !(t5 = t5.call(y4, op[1])).done)
          return t5;
        if (y4 = 0, t5)
          op = [op[0] & 2, t5.value];
        switch (op[0]) {
          case 0:
          case 1:
            t5 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y4 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t5 = _2.trys, t5 = t5.length > 0 && t5[t5.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t5 || op[1] > t5[0] && op[1] < t5[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t5[1]) {
              _2.label = t5[1];
              t5 = op;
              break;
            }
            if (t5 && _2.label < t5[2]) {
              _2.label = t5[2];
              _2.ops.push(op);
              break;
            }
            if (t5[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e7) {
        op = [6, e7];
        y4 = 0;
      } finally {
        f7 = t5 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var HttpExporterTransport = (
  /** @class */
  function() {
    function HttpExporterTransport2(_parameters) {
      this._parameters = _parameters;
      this._send = null;
      this._agent = null;
    }
    HttpExporterTransport2.prototype.send = function(data, timeoutMillis) {
      return __awaiter2(this, void 0, void 0, function() {
        var _a3, sendWithHttp2, createHttpAgent2;
        var _this = this;
        return __generator2(this, function(_b) {
          if (this._send == null) {
            _a3 = (init_http_transport_utils(), __toCommonJS(http_transport_utils_exports)), sendWithHttp2 = _a3.sendWithHttp, createHttpAgent2 = _a3.createHttpAgent;
            this._agent = createHttpAgent2(this._parameters.url, this._parameters.agentOptions);
            this._send = sendWithHttp2;
          }
          return [2, new Promise(function(resolve) {
            var _a4;
            (_a4 = _this._send) === null || _a4 === void 0 ? void 0 : _a4.call(_this, _this._parameters, _this._agent, data, function(result) {
              resolve(result);
            }, timeoutMillis);
          })];
        });
      });
    };
    HttpExporterTransport2.prototype.shutdown = function() {
    };
    return HttpExporterTransport2;
  }()
);
function createHttpExporterTransport(parameters) {
  return new HttpExporterTransport(parameters);
}

// node_modules/@opentelemetry/otlp-exporter-base/build/esm/platform/node/OTLPExporterNodeBase.js
init_types2();

// node_modules/@opentelemetry/otlp-exporter-base/build/esm/retrying-transport.js
var __awaiter3 = function(thisArg, _arguments, P6, generator) {
  function adopt(value) {
    return value instanceof P6 ? value : new P6(function(resolve) {
      resolve(value);
    });
  }
  return new (P6 || (P6 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e7) {
        reject(e7);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e7) {
        reject(e7);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator3 = function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t5[0] & 1)
      throw t5[1];
    return t5[1];
  }, trys: [], ops: [] }, f7, y4, t5, g6;
  return g6 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g6[Symbol.iterator] = function() {
    return this;
  }), g6;
  function verb(n9) {
    return function(v4) {
      return step([n9, v4]);
    };
  }
  function step(op) {
    if (f7)
      throw new TypeError("Generator is already executing.");
    while (_2)
      try {
        if (f7 = 1, y4 && (t5 = op[0] & 2 ? y4["return"] : op[0] ? y4["throw"] || ((t5 = y4["return"]) && t5.call(y4), 0) : y4.next) && !(t5 = t5.call(y4, op[1])).done)
          return t5;
        if (y4 = 0, t5)
          op = [op[0] & 2, t5.value];
        switch (op[0]) {
          case 0:
          case 1:
            t5 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y4 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t5 = _2.trys, t5 = t5.length > 0 && t5[t5.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t5 || op[1] > t5[0] && op[1] < t5[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t5[1]) {
              _2.label = t5[1];
              t5 = op;
              break;
            }
            if (t5 && _2.label < t5[2]) {
              _2.label = t5[2];
              _2.ops.push(op);
              break;
            }
            if (t5[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e7) {
        op = [6, e7];
        y4 = 0;
      } finally {
        f7 = t5 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var MAX_ATTEMPTS = 5;
var INITIAL_BACKOFF = 1e3;
var MAX_BACKOFF = 5e3;
var BACKOFF_MULTIPLIER = 1.5;
var JITTER = 0.2;
function getJitter() {
  return Math.random() * (2 * JITTER) - JITTER;
}
var RetryingTransport = (
  /** @class */
  function() {
    function RetryingTransport2(_transport) {
      this._transport = _transport;
    }
    RetryingTransport2.prototype.retry = function(data, timeoutMillis, inMillis) {
      var _this = this;
      return new Promise(function(resolve, reject) {
        setTimeout(function() {
          _this._transport.send(data, timeoutMillis).then(resolve, reject);
        }, inMillis);
      });
    };
    RetryingTransport2.prototype.send = function(data, timeoutMillis) {
      var _a3;
      return __awaiter3(this, void 0, void 0, function() {
        var deadline, result, attempts, nextBackoff, backoff, retryInMillis, remainingTimeoutMillis;
        return __generator3(this, function(_b) {
          switch (_b.label) {
            case 0:
              deadline = Date.now() + timeoutMillis;
              return [4, this._transport.send(data, timeoutMillis)];
            case 1:
              result = _b.sent();
              attempts = MAX_ATTEMPTS;
              nextBackoff = INITIAL_BACKOFF;
              _b.label = 2;
            case 2:
              if (!(result.status === "retryable" && attempts > 0))
                return [3, 4];
              attempts--;
              backoff = Math.max(Math.min(nextBackoff, MAX_BACKOFF) + getJitter(), 0);
              nextBackoff = nextBackoff * BACKOFF_MULTIPLIER;
              retryInMillis = (_a3 = result.retryInMillis) !== null && _a3 !== void 0 ? _a3 : backoff;
              remainingTimeoutMillis = deadline - Date.now();
              if (retryInMillis > remainingTimeoutMillis) {
                return [2, result];
              }
              return [4, this.retry(data, remainingTimeoutMillis, retryInMillis)];
            case 3:
              result = _b.sent();
              return [3, 2];
            case 4:
              return [2, result];
          }
        });
      });
    };
    RetryingTransport2.prototype.shutdown = function() {
      return this._transport.shutdown();
    };
    return RetryingTransport2;
  }()
);
function createRetryingTransport(options) {
  return new RetryingTransport(options.transport);
}

// node_modules/@opentelemetry/otlp-exporter-base/build/esm/platform/node/OTLPExporterNodeBase.js
var __extends7 = function() {
  var extendStatics = function(d5, b4) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d6, b5) {
      d6.__proto__ = b5;
    } || function(d6, b5) {
      for (var p9 in b5)
        if (Object.prototype.hasOwnProperty.call(b5, p9))
          d6[p9] = b5[p9];
    };
    return extendStatics(d5, b4);
  };
  return function(d5, b4) {
    if (typeof b4 !== "function" && b4 !== null)
      throw new TypeError("Class extends value " + String(b4) + " is not a constructor or null");
    extendStatics(d5, b4);
    function __() {
      this.constructor = d5;
    }
    d5.prototype = b4 === null ? Object.create(b4) : (__.prototype = b4.prototype, new __());
  };
}();
var OTLPExporterNodeBase = (
  /** @class */
  function(_super) {
    __extends7(OTLPExporterNodeBase2, _super);
    function OTLPExporterNodeBase2(config, serializer, signalSpecificHeaders) {
      if (config === void 0) {
        config = {};
      }
      var _a3;
      var _this = _super.call(this, config) || this;
      if (config.metadata) {
        diag2.warn("Metadata cannot be set when using http");
      }
      _this._serializer = serializer;
      if ((config === null || config === void 0 ? void 0 : config.keepAlive) != null) {
        if (config.httpAgentOptions != null) {
          if (config.httpAgentOptions.keepAlive == null) {
            config.httpAgentOptions.keepAlive = config.keepAlive;
          }
        } else {
          config.httpAgentOptions = {
            keepAlive: config.keepAlive
          };
        }
      }
      var nonSignalSpecificHeaders = baggageUtils2.parseKeyPairsIntoRecord(getEnv3().OTEL_EXPORTER_OTLP_HEADERS);
      _this._transport = createRetryingTransport({
        transport: createHttpExporterTransport({
          agentOptions: (_a3 = config.httpAgentOptions) !== null && _a3 !== void 0 ? _a3 : { keepAlive: true },
          compression: configureCompression(config.compression),
          headers: Object.assign({}, nonSignalSpecificHeaders, signalSpecificHeaders),
          url: _this.url
        })
      });
      return _this;
    }
    OTLPExporterNodeBase2.prototype.onInit = function(_config) {
    };
    OTLPExporterNodeBase2.prototype.send = function(objects, onSuccess, onError) {
      var _this = this;
      if (this._shutdownOnce.isCalled) {
        diag2.debug("Shutdown already started. Cannot send objects");
        return;
      }
      var data = this._serializer.serializeRequest(objects);
      if (data == null) {
        onError(new Error("Could not serialize message"));
        return;
      }
      var promise = this._transport.send(data, this.timeoutMillis).then(function(response) {
        if (response.status === "success") {
          onSuccess();
        } else if (response.status === "failure" && response.error) {
          onError(response.error);
        } else if (response.status === "retryable") {
          onError(new OTLPExporterError("Export failed with retryable status"));
        } else {
          onError(new OTLPExporterError("Export failed with unknown error"));
        }
      }, onError);
      this._sendingPromises.push(promise);
      var popPromise = function() {
        var index = _this._sendingPromises.indexOf(promise);
        _this._sendingPromises.splice(index, 1);
      };
      promise.then(popPromise, popPromise);
    };
    OTLPExporterNodeBase2.prototype.onShutdown = function() {
    };
    return OTLPExporterNodeBase2;
  }(OTLPExporterBase)
);

// node_modules/@opentelemetry/exporter-trace-otlp-http/build/esm/version.js
var VERSION4 = "0.53.0";

// node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/esm/common/hex-to-binary.js
function intValue(charCode) {
  if (charCode >= 48 && charCode <= 57) {
    return charCode - 48;
  }
  if (charCode >= 97 && charCode <= 102) {
    return charCode - 87;
  }
  return charCode - 55;
}
function hexToBinary(hexStr) {
  var buf = new Uint8Array(hexStr.length / 2);
  var offset = 0;
  for (var i4 = 0; i4 < hexStr.length; i4 += 2) {
    var hi = intValue(hexStr.charCodeAt(i4));
    var lo = intValue(hexStr.charCodeAt(i4 + 1));
    buf[offset++] = hi << 4 | lo;
  }
  return buf;
}

// node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/esm/common/time.js
var NANOSECOND_DIGITS2 = 9;
var NANOSECOND_DIGITS_IN_MILLIS2 = 6;
var MILLISECONDS_TO_NANOSECONDS2 = Math.pow(10, NANOSECOND_DIGITS_IN_MILLIS2);
var SECOND_TO_NANOSECONDS2 = Math.pow(10, NANOSECOND_DIGITS2);
function hrTimeToNanoseconds2(time) {
  return time[0] * SECOND_TO_NANOSECONDS2 + time[1];
}

// node_modules/@opentelemetry/otlp-transformer/build/esm/common/index.js
function hrTimeToNanos(hrTime5) {
  var NANOSECONDS = BigInt(1e9);
  return BigInt(hrTime5[0]) * NANOSECONDS + BigInt(hrTime5[1]);
}
function toLongBits(value) {
  var low = Number(BigInt.asUintN(32, value));
  var high = Number(BigInt.asUintN(32, value >> BigInt(32)));
  return { low, high };
}
function encodeAsLongBits(hrTime5) {
  var nanos = hrTimeToNanos(hrTime5);
  return toLongBits(nanos);
}
function encodeAsString(hrTime5) {
  var nanos = hrTimeToNanos(hrTime5);
  return nanos.toString();
}
var encodeTimestamp = typeof BigInt !== "undefined" ? encodeAsString : hrTimeToNanoseconds2;
function identity(value) {
  return value;
}
function optionalHexToBinary(str) {
  if (str === void 0)
    return void 0;
  return hexToBinary(str);
}
var DEFAULT_ENCODER = {
  encodeHrTime: encodeAsLongBits,
  encodeSpanContext: hexToBinary,
  encodeOptionalSpanContext: optionalHexToBinary
};
function getOtlpEncoder(options) {
  var _a3, _b;
  if (options === void 0) {
    return DEFAULT_ENCODER;
  }
  var useLongBits = (_a3 = options.useLongBits) !== null && _a3 !== void 0 ? _a3 : true;
  var useHex = (_b = options.useHex) !== null && _b !== void 0 ? _b : false;
  return {
    encodeHrTime: useLongBits ? encodeAsLongBits : encodeTimestamp,
    encodeSpanContext: useHex ? identity : hexToBinary,
    encodeOptionalSpanContext: useHex ? identity : optionalHexToBinary
  };
}

// node_modules/@opentelemetry/otlp-transformer/build/esm/common/internal.js
var __read18 = function(o4, n9) {
  var m2 = typeof Symbol === "function" && o4[Symbol.iterator];
  if (!m2)
    return o4;
  var i4 = m2.call(o4), r7, ar = [], e7;
  try {
    while ((n9 === void 0 || n9-- > 0) && !(r7 = i4.next()).done)
      ar.push(r7.value);
  } catch (error) {
    e7 = { error };
  } finally {
    try {
      if (r7 && !r7.done && (m2 = i4["return"]))
        m2.call(i4);
    } finally {
      if (e7)
        throw e7.error;
    }
  }
  return ar;
};
function createInstrumentationScope(scope) {
  return {
    name: scope.name,
    version: scope.version
  };
}
function toAttributes(attributes) {
  return Object.keys(attributes).map(function(key) {
    return toKeyValue(key, attributes[key]);
  });
}
function toKeyValue(key, value) {
  return {
    key,
    value: toAnyValue(value)
  };
}
function toAnyValue(value) {
  var t5 = typeof value;
  if (t5 === "string")
    return { stringValue: value };
  if (t5 === "number") {
    if (!Number.isInteger(value))
      return { doubleValue: value };
    return { intValue: value };
  }
  if (t5 === "boolean")
    return { boolValue: value };
  if (value instanceof Uint8Array)
    return { bytesValue: value };
  if (Array.isArray(value))
    return { arrayValue: { values: value.map(toAnyValue) } };
  if (t5 === "object" && value != null)
    return {
      kvlistValue: {
        values: Object.entries(value).map(function(_a3) {
          var _b = __read18(_a3, 2), k3 = _b[0], v4 = _b[1];
          return toKeyValue(k3, v4);
        })
      }
    };
  return {};
}

// node_modules/@opentelemetry/otlp-transformer/build/esm/trace/internal.js
function sdkSpanToOtlpSpan(span, encoder) {
  var _a3;
  var ctx = span.spanContext();
  var status = span.status;
  return {
    traceId: encoder.encodeSpanContext(ctx.traceId),
    spanId: encoder.encodeSpanContext(ctx.spanId),
    parentSpanId: encoder.encodeOptionalSpanContext(span.parentSpanId),
    traceState: (_a3 = ctx.traceState) === null || _a3 === void 0 ? void 0 : _a3.serialize(),
    name: span.name,
    // Span kind is offset by 1 because the API does not define a value for unset
    kind: span.kind == null ? 0 : span.kind + 1,
    startTimeUnixNano: encoder.encodeHrTime(span.startTime),
    endTimeUnixNano: encoder.encodeHrTime(span.endTime),
    attributes: toAttributes(span.attributes),
    droppedAttributesCount: span.droppedAttributesCount,
    events: span.events.map(function(event) {
      return toOtlpSpanEvent(event, encoder);
    }),
    droppedEventsCount: span.droppedEventsCount,
    status: {
      // API and proto enums share the same values
      code: status.code,
      message: status.message
    },
    links: span.links.map(function(link) {
      return toOtlpLink(link, encoder);
    }),
    droppedLinksCount: span.droppedLinksCount
  };
}
function toOtlpLink(link, encoder) {
  var _a3;
  return {
    attributes: link.attributes ? toAttributes(link.attributes) : [],
    spanId: encoder.encodeSpanContext(link.context.spanId),
    traceId: encoder.encodeSpanContext(link.context.traceId),
    traceState: (_a3 = link.context.traceState) === null || _a3 === void 0 ? void 0 : _a3.serialize(),
    droppedAttributesCount: link.droppedAttributesCount || 0
  };
}
function toOtlpSpanEvent(timedEvent, encoder) {
  return {
    attributes: timedEvent.attributes ? toAttributes(timedEvent.attributes) : [],
    name: timedEvent.name,
    timeUnixNano: encoder.encodeHrTime(timedEvent.time),
    droppedAttributesCount: timedEvent.droppedAttributesCount || 0
  };
}

// node_modules/@opentelemetry/otlp-transformer/build/esm/resource/internal.js
function createResource(resource) {
  return {
    attributes: toAttributes(resource.attributes),
    droppedAttributesCount: 0
  };
}

// node_modules/@opentelemetry/otlp-transformer/build/esm/trace/index.js
var __values9 = function(o4) {
  var s10 = typeof Symbol === "function" && Symbol.iterator, m2 = s10 && o4[s10], i4 = 0;
  if (m2)
    return m2.call(o4);
  if (o4 && typeof o4.length === "number")
    return {
      next: function() {
        if (o4 && i4 >= o4.length)
          o4 = void 0;
        return { value: o4 && o4[i4++], done: !o4 };
      }
    };
  throw new TypeError(s10 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read19 = function(o4, n9) {
  var m2 = typeof Symbol === "function" && o4[Symbol.iterator];
  if (!m2)
    return o4;
  var i4 = m2.call(o4), r7, ar = [], e7;
  try {
    while ((n9 === void 0 || n9-- > 0) && !(r7 = i4.next()).done)
      ar.push(r7.value);
  } catch (error) {
    e7 = { error };
  } finally {
    try {
      if (r7 && !r7.done && (m2 = i4["return"]))
        m2.call(i4);
    } finally {
      if (e7)
        throw e7.error;
    }
  }
  return ar;
};
function createExportTraceServiceRequest(spans, options) {
  var encoder = getOtlpEncoder(options);
  return {
    resourceSpans: spanRecordsToResourceSpans(spans, encoder)
  };
}
function createResourceMap(readableSpans) {
  var e_1, _a3;
  var resourceMap = /* @__PURE__ */ new Map();
  try {
    for (var readableSpans_1 = __values9(readableSpans), readableSpans_1_1 = readableSpans_1.next(); !readableSpans_1_1.done; readableSpans_1_1 = readableSpans_1.next()) {
      var record = readableSpans_1_1.value;
      var ilmMap = resourceMap.get(record.resource);
      if (!ilmMap) {
        ilmMap = /* @__PURE__ */ new Map();
        resourceMap.set(record.resource, ilmMap);
      }
      var instrumentationLibraryKey = record.instrumentationLibrary.name + "@" + (record.instrumentationLibrary.version || "") + ":" + (record.instrumentationLibrary.schemaUrl || "");
      var records = ilmMap.get(instrumentationLibraryKey);
      if (!records) {
        records = [];
        ilmMap.set(instrumentationLibraryKey, records);
      }
      records.push(record);
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (readableSpans_1_1 && !readableSpans_1_1.done && (_a3 = readableSpans_1.return))
        _a3.call(readableSpans_1);
    } finally {
      if (e_1)
        throw e_1.error;
    }
  }
  return resourceMap;
}
function spanRecordsToResourceSpans(readableSpans, encoder) {
  var resourceMap = createResourceMap(readableSpans);
  var out = [];
  var entryIterator = resourceMap.entries();
  var entry = entryIterator.next();
  while (!entry.done) {
    var _a3 = __read19(entry.value, 2), resource = _a3[0], ilmMap = _a3[1];
    var scopeResourceSpans = [];
    var ilmIterator = ilmMap.values();
    var ilmEntry = ilmIterator.next();
    while (!ilmEntry.done) {
      var scopeSpans = ilmEntry.value;
      if (scopeSpans.length > 0) {
        var spans = scopeSpans.map(function(readableSpan) {
          return sdkSpanToOtlpSpan(readableSpan, encoder);
        });
        scopeResourceSpans.push({
          scope: createInstrumentationScope(scopeSpans[0].instrumentationLibrary),
          spans,
          schemaUrl: scopeSpans[0].instrumentationLibrary.schemaUrl
        });
      }
      ilmEntry = ilmIterator.next();
    }
    var transformedSpans = {
      resource: createResource(resource),
      scopeSpans: scopeResourceSpans,
      schemaUrl: void 0
    };
    out.push(transformedSpans);
    entry = entryIterator.next();
  }
  return out;
}

// node_modules/@opentelemetry/otlp-transformer/build/esm/json/serializers.js
var JsonTraceSerializer = {
  serializeRequest: function(arg) {
    var request3 = createExportTraceServiceRequest(arg, {
      useHex: true,
      useLongBits: false
    });
    var encoder = new TextEncoder();
    return encoder.encode(JSON.stringify(request3));
  },
  deserializeResponse: function(arg) {
    var decoder = new TextDecoder();
    return JSON.parse(decoder.decode(arg));
  }
};

// node_modules/@opentelemetry/exporter-trace-otlp-http/build/esm/platform/node/OTLPTraceExporter.js
var __extends8 = function() {
  var extendStatics = function(d5, b4) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d6, b5) {
      d6.__proto__ = b5;
    } || function(d6, b5) {
      for (var p9 in b5)
        if (Object.prototype.hasOwnProperty.call(b5, p9))
          d6[p9] = b5[p9];
    };
    return extendStatics(d5, b4);
  };
  return function(d5, b4) {
    if (typeof b4 !== "function" && b4 !== null)
      throw new TypeError("Class extends value " + String(b4) + " is not a constructor or null");
    extendStatics(d5, b4);
    function __() {
      this.constructor = d5;
    }
    d5.prototype = b4 === null ? Object.create(b4) : (__.prototype = b4.prototype, new __());
  };
}();
var __assign5 = function() {
  __assign5 = Object.assign || function(t5) {
    for (var s10, i4 = 1, n9 = arguments.length; i4 < n9; i4++) {
      s10 = arguments[i4];
      for (var p9 in s10)
        if (Object.prototype.hasOwnProperty.call(s10, p9))
          t5[p9] = s10[p9];
    }
    return t5;
  };
  return __assign5.apply(this, arguments);
};
var DEFAULT_COLLECTOR_RESOURCE_PATH = "v1/traces";
var DEFAULT_COLLECTOR_URL = "http://localhost:4318/" + DEFAULT_COLLECTOR_RESOURCE_PATH;
var USER_AGENT = {
  "User-Agent": "OTel-OTLP-Exporter-JavaScript/" + VERSION4
};
var OTLPTraceExporter = (
  /** @class */
  function(_super) {
    __extends8(OTLPTraceExporter2, _super);
    function OTLPTraceExporter2(config) {
      if (config === void 0) {
        config = {};
      }
      return _super.call(this, config, JsonTraceSerializer, __assign5(__assign5(__assign5(__assign5({}, baggageUtils.parseKeyPairsIntoRecord(getEnv2().OTEL_EXPORTER_OTLP_TRACES_HEADERS)), parseHeaders(config === null || config === void 0 ? void 0 : config.headers)), USER_AGENT), { "Content-Type": "application/json" })) || this;
    }
    OTLPTraceExporter2.prototype.getDefaultUrl = function(config) {
      if (typeof config.url === "string") {
        return config.url;
      }
      var env2 = getEnv2();
      if (env2.OTEL_EXPORTER_OTLP_TRACES_ENDPOINT.length > 0) {
        return appendRootPathToUrlIfNeeded(env2.OTEL_EXPORTER_OTLP_TRACES_ENDPOINT);
      }
      if (env2.OTEL_EXPORTER_OTLP_ENDPOINT.length > 0) {
        return appendResourcePathToUrl(env2.OTEL_EXPORTER_OTLP_ENDPOINT, DEFAULT_COLLECTOR_RESOURCE_PATH);
      }
      return DEFAULT_COLLECTOR_URL;
    };
    return OTLPTraceExporter2;
  }(OTLPExporterNodeBase)
);

// node_modules/@opentelemetry/instrumentation-fetch/build/esm/fetch.js
init_esm();

// node_modules/@opentelemetry/instrumentation-fetch/node_modules/@opentelemetry/core/build/esm/platform/node/globalThis.js
var _globalThis6 = typeof globalThis === "object" ? globalThis : global;

// node_modules/@opentelemetry/instrumentation-fetch/node_modules/@opentelemetry/core/build/esm/platform/node/performance.js
import { performance as performance3 } from "perf_hooks";
var otperformance4 = performance3;

// node_modules/@opentelemetry/instrumentation-fetch/node_modules/@opentelemetry/semantic-conventions/build/esm/trace/SemanticAttributes.js
var TMP_HTTP_METHOD = "http.method";
var TMP_HTTP_URL2 = "http.url";
var TMP_HTTP_HOST = "http.host";
var TMP_HTTP_SCHEME = "http.scheme";
var TMP_HTTP_STATUS_CODE = "http.status_code";
var TMP_HTTP_USER_AGENT2 = "http.user_agent";
var TMP_HTTP_RESPONSE_CONTENT_LENGTH2 = "http.response_content_length";
var TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED2 = "http.response_content_length_uncompressed";
var SEMATTRS_HTTP_METHOD = TMP_HTTP_METHOD;
var SEMATTRS_HTTP_URL2 = TMP_HTTP_URL2;
var SEMATTRS_HTTP_HOST = TMP_HTTP_HOST;
var SEMATTRS_HTTP_SCHEME = TMP_HTTP_SCHEME;
var SEMATTRS_HTTP_STATUS_CODE = TMP_HTTP_STATUS_CODE;
var SEMATTRS_HTTP_USER_AGENT2 = TMP_HTTP_USER_AGENT2;
var SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH2 = TMP_HTTP_RESPONSE_CONTENT_LENGTH2;
var SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED2 = TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED2;

// node_modules/@opentelemetry/instrumentation-fetch/node_modules/@opentelemetry/core/build/esm/common/time.js
var NANOSECOND_DIGITS3 = 9;
var NANOSECOND_DIGITS_IN_MILLIS3 = 6;
var MILLISECONDS_TO_NANOSECONDS3 = Math.pow(10, NANOSECOND_DIGITS_IN_MILLIS3);
var SECOND_TO_NANOSECONDS3 = Math.pow(10, NANOSECOND_DIGITS3);
function millisToHrTime3(epochMillis) {
  var epochSeconds = epochMillis / 1e3;
  var seconds = Math.trunc(epochSeconds);
  var nanos = Math.round(epochMillis % 1e3 * MILLISECONDS_TO_NANOSECONDS3);
  return [seconds, nanos];
}
function getTimeOrigin3() {
  var timeOrigin = otperformance4.timeOrigin;
  if (typeof timeOrigin !== "number") {
    var perf = otperformance4;
    timeOrigin = perf.timing && perf.timing.fetchStart;
  }
  return timeOrigin;
}
function hrTime3(performanceNow) {
  var timeOrigin = millisToHrTime3(getTimeOrigin3());
  var now = millisToHrTime3(typeof performanceNow === "number" ? performanceNow : otperformance4.now());
  return addHrTimes3(timeOrigin, now);
}
function timeInputToHrTime3(time) {
  if (isTimeInputHrTime3(time)) {
    return time;
  } else if (typeof time === "number") {
    if (time < getTimeOrigin3()) {
      return hrTime3(time);
    } else {
      return millisToHrTime3(time);
    }
  } else if (time instanceof Date) {
    return millisToHrTime3(time.getTime());
  } else {
    throw TypeError("Invalid input type");
  }
}
function hrTimeToNanoseconds3(time) {
  return time[0] * SECOND_TO_NANOSECONDS3 + time[1];
}
function isTimeInputHrTime3(value) {
  return Array.isArray(value) && value.length === 2 && typeof value[0] === "number" && typeof value[1] === "number";
}
function addHrTimes3(time1, time2) {
  var out = [time1[0] + time2[0], time1[1] + time2[1]];
  if (out[1] >= SECOND_TO_NANOSECONDS3) {
    out[1] -= SECOND_TO_NANOSECONDS3;
    out[0] += 1;
  }
  return out;
}

// node_modules/@opentelemetry/instrumentation-fetch/node_modules/@opentelemetry/core/build/esm/utils/url.js
var __values10 = function(o4) {
  var s10 = typeof Symbol === "function" && Symbol.iterator, m2 = s10 && o4[s10], i4 = 0;
  if (m2)
    return m2.call(o4);
  if (o4 && typeof o4.length === "number")
    return {
      next: function() {
        if (o4 && i4 >= o4.length)
          o4 = void 0;
        return { value: o4 && o4[i4++], done: !o4 };
      }
    };
  throw new TypeError(s10 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
function urlMatches(url, urlToMatch) {
  if (typeof urlToMatch === "string") {
    return url === urlToMatch;
  } else {
    return !!url.match(urlToMatch);
  }
}
function isUrlIgnored(url, ignoredUrls) {
  var e_1, _a3;
  if (!ignoredUrls) {
    return false;
  }
  try {
    for (var ignoredUrls_1 = __values10(ignoredUrls), ignoredUrls_1_1 = ignoredUrls_1.next(); !ignoredUrls_1_1.done; ignoredUrls_1_1 = ignoredUrls_1.next()) {
      var ignoreUrl = ignoredUrls_1_1.value;
      if (urlMatches(url, ignoreUrl)) {
        return true;
      }
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (ignoredUrls_1_1 && !ignoredUrls_1_1.done && (_a3 = ignoredUrls_1.return))
        _a3.call(ignoredUrls_1);
    } finally {
      if (e_1)
        throw e_1.error;
    }
  }
  return false;
}

// node_modules/@opentelemetry/instrumentation-fetch/node_modules/@opentelemetry/sdk-trace-web/build/esm/enums/PerformanceTimingNames.js
var PerformanceTimingNames2;
(function(PerformanceTimingNames4) {
  PerformanceTimingNames4["CONNECT_END"] = "connectEnd";
  PerformanceTimingNames4["CONNECT_START"] = "connectStart";
  PerformanceTimingNames4["DECODED_BODY_SIZE"] = "decodedBodySize";
  PerformanceTimingNames4["DOM_COMPLETE"] = "domComplete";
  PerformanceTimingNames4["DOM_CONTENT_LOADED_EVENT_END"] = "domContentLoadedEventEnd";
  PerformanceTimingNames4["DOM_CONTENT_LOADED_EVENT_START"] = "domContentLoadedEventStart";
  PerformanceTimingNames4["DOM_INTERACTIVE"] = "domInteractive";
  PerformanceTimingNames4["DOMAIN_LOOKUP_END"] = "domainLookupEnd";
  PerformanceTimingNames4["DOMAIN_LOOKUP_START"] = "domainLookupStart";
  PerformanceTimingNames4["ENCODED_BODY_SIZE"] = "encodedBodySize";
  PerformanceTimingNames4["FETCH_START"] = "fetchStart";
  PerformanceTimingNames4["LOAD_EVENT_END"] = "loadEventEnd";
  PerformanceTimingNames4["LOAD_EVENT_START"] = "loadEventStart";
  PerformanceTimingNames4["NAVIGATION_START"] = "navigationStart";
  PerformanceTimingNames4["REDIRECT_END"] = "redirectEnd";
  PerformanceTimingNames4["REDIRECT_START"] = "redirectStart";
  PerformanceTimingNames4["REQUEST_START"] = "requestStart";
  PerformanceTimingNames4["RESPONSE_END"] = "responseEnd";
  PerformanceTimingNames4["RESPONSE_START"] = "responseStart";
  PerformanceTimingNames4["SECURE_CONNECTION_START"] = "secureConnectionStart";
  PerformanceTimingNames4["UNLOAD_EVENT_END"] = "unloadEventEnd";
  PerformanceTimingNames4["UNLOAD_EVENT_START"] = "unloadEventStart";
})(PerformanceTimingNames2 || (PerformanceTimingNames2 = {}));

// node_modules/@opentelemetry/instrumentation-fetch/node_modules/@opentelemetry/sdk-trace-web/build/esm/utils.js
var urlNormalizingAnchor;
function getUrlNormalizingAnchor() {
  if (!urlNormalizingAnchor) {
    urlNormalizingAnchor = document.createElement("a");
  }
  return urlNormalizingAnchor;
}
function hasKey2(obj, key) {
  return key in obj;
}
function addSpanNetworkEvent2(span, performanceName, entries, refPerfName) {
  var perfTime = void 0;
  var refTime = void 0;
  if (hasKey2(entries, performanceName) && typeof entries[performanceName] === "number") {
    perfTime = entries[performanceName];
  }
  var refName = refPerfName || PerformanceTimingNames2.FETCH_START;
  if (hasKey2(entries, refName) && typeof entries[refName] === "number") {
    refTime = entries[refName];
  }
  if (perfTime !== void 0 && refTime !== void 0 && perfTime >= refTime) {
    span.addEvent(performanceName, perfTime);
    return span;
  }
  return void 0;
}
function addSpanNetworkEvents2(span, resource) {
  addSpanNetworkEvent2(span, PerformanceTimingNames2.FETCH_START, resource);
  addSpanNetworkEvent2(span, PerformanceTimingNames2.DOMAIN_LOOKUP_START, resource);
  addSpanNetworkEvent2(span, PerformanceTimingNames2.DOMAIN_LOOKUP_END, resource);
  addSpanNetworkEvent2(span, PerformanceTimingNames2.CONNECT_START, resource);
  if (hasKey2(resource, "name") && resource["name"].startsWith("https:")) {
    addSpanNetworkEvent2(span, PerformanceTimingNames2.SECURE_CONNECTION_START, resource);
  }
  addSpanNetworkEvent2(span, PerformanceTimingNames2.CONNECT_END, resource);
  addSpanNetworkEvent2(span, PerformanceTimingNames2.REQUEST_START, resource);
  addSpanNetworkEvent2(span, PerformanceTimingNames2.RESPONSE_START, resource);
  addSpanNetworkEvent2(span, PerformanceTimingNames2.RESPONSE_END, resource);
  var encodedLength = resource[PerformanceTimingNames2.ENCODED_BODY_SIZE];
  if (encodedLength !== void 0) {
    span.setAttribute(SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH2, encodedLength);
  }
  var decodedLength = resource[PerformanceTimingNames2.DECODED_BODY_SIZE];
  if (decodedLength !== void 0 && encodedLength !== decodedLength) {
    span.setAttribute(SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED2, decodedLength);
  }
}
function sortResources2(filteredResources) {
  return filteredResources.slice().sort(function(a4, b4) {
    var valueA = a4[PerformanceTimingNames2.FETCH_START];
    var valueB = b4[PerformanceTimingNames2.FETCH_START];
    if (valueA > valueB) {
      return 1;
    } else if (valueA < valueB) {
      return -1;
    }
    return 0;
  });
}
function getOrigin() {
  return typeof location !== "undefined" ? location.origin : void 0;
}
function getResource2(spanUrl, startTimeHR, endTimeHR, resources, ignoredResources, initiatorType) {
  if (ignoredResources === void 0) {
    ignoredResources = /* @__PURE__ */ new WeakSet();
  }
  var parsedSpanUrl = parseUrl2(spanUrl);
  spanUrl = parsedSpanUrl.toString();
  var filteredResources = filterResourcesForSpan(spanUrl, startTimeHR, endTimeHR, resources, ignoredResources, initiatorType);
  if (filteredResources.length === 0) {
    return {
      mainRequest: void 0
    };
  }
  if (filteredResources.length === 1) {
    return {
      mainRequest: filteredResources[0]
    };
  }
  var sorted = sortResources2(filteredResources);
  if (parsedSpanUrl.origin !== getOrigin() && sorted.length > 1) {
    var corsPreFlightRequest = sorted[0];
    var mainRequest = findMainRequest(sorted, corsPreFlightRequest[PerformanceTimingNames2.RESPONSE_END], endTimeHR);
    var responseEnd = corsPreFlightRequest[PerformanceTimingNames2.RESPONSE_END];
    var fetchStart = mainRequest[PerformanceTimingNames2.FETCH_START];
    if (fetchStart < responseEnd) {
      mainRequest = corsPreFlightRequest;
      corsPreFlightRequest = void 0;
    }
    return {
      corsPreFlightRequest,
      mainRequest
    };
  } else {
    return {
      mainRequest: filteredResources[0]
    };
  }
}
function findMainRequest(resources, corsPreFlightRequestEndTime, spanEndTimeHR) {
  var spanEndTime = hrTimeToNanoseconds3(spanEndTimeHR);
  var minTime = hrTimeToNanoseconds3(timeInputToHrTime3(corsPreFlightRequestEndTime));
  var mainRequest = resources[1];
  var bestGap;
  var length = resources.length;
  for (var i4 = 1; i4 < length; i4++) {
    var resource = resources[i4];
    var resourceStartTime = hrTimeToNanoseconds3(timeInputToHrTime3(resource[PerformanceTimingNames2.FETCH_START]));
    var resourceEndTime = hrTimeToNanoseconds3(timeInputToHrTime3(resource[PerformanceTimingNames2.RESPONSE_END]));
    var currentGap = spanEndTime - resourceEndTime;
    if (resourceStartTime >= minTime && (!bestGap || currentGap < bestGap)) {
      bestGap = currentGap;
      mainRequest = resource;
    }
  }
  return mainRequest;
}
function filterResourcesForSpan(spanUrl, startTimeHR, endTimeHR, resources, ignoredResources, initiatorType) {
  var startTime = hrTimeToNanoseconds3(startTimeHR);
  var endTime = hrTimeToNanoseconds3(endTimeHR);
  var filteredResources = resources.filter(function(resource) {
    var resourceStartTime = hrTimeToNanoseconds3(timeInputToHrTime3(resource[PerformanceTimingNames2.FETCH_START]));
    var resourceEndTime = hrTimeToNanoseconds3(timeInputToHrTime3(resource[PerformanceTimingNames2.RESPONSE_END]));
    return resource.initiatorType.toLowerCase() === (initiatorType || "xmlhttprequest") && resource.name === spanUrl && resourceStartTime >= startTime && resourceEndTime <= endTime;
  });
  if (filteredResources.length > 0) {
    filteredResources = filteredResources.filter(function(resource) {
      return !ignoredResources.has(resource);
    });
  }
  return filteredResources;
}
function parseUrl2(url) {
  if (typeof URL === "function") {
    return new URL(url, typeof document !== "undefined" ? document.baseURI : typeof location !== "undefined" ? location.href : void 0);
  }
  var element = getUrlNormalizingAnchor();
  element.href = url;
  return element;
}
function shouldPropagateTraceHeaders2(spanUrl, propagateTraceHeaderCorsUrls) {
  var propagateTraceHeaderUrls = propagateTraceHeaderCorsUrls || [];
  if (typeof propagateTraceHeaderUrls === "string" || propagateTraceHeaderUrls instanceof RegExp) {
    propagateTraceHeaderUrls = [propagateTraceHeaderUrls];
  }
  var parsedSpanUrl = parseUrl2(spanUrl);
  if (parsedSpanUrl.origin === getOrigin()) {
    return true;
  } else {
    return propagateTraceHeaderUrls.some(function(propagateTraceHeaderUrl) {
      return urlMatches(spanUrl, propagateTraceHeaderUrl);
    });
  }
}

// node_modules/@opentelemetry/instrumentation-fetch/build/esm/enums/AttributeNames.js
var AttributeNames2;
(function(AttributeNames4) {
  AttributeNames4["COMPONENT"] = "component";
  AttributeNames4["HTTP_ERROR_NAME"] = "http.error_name";
  AttributeNames4["HTTP_STATUS_TEXT"] = "http.status_text";
})(AttributeNames2 || (AttributeNames2 = {}));

// node_modules/@opentelemetry/instrumentation-fetch/build/esm/version.js
var VERSION5 = "0.53.0";

// node_modules/@opentelemetry/instrumentation-fetch/build/esm/fetch.js
var __extends9 = function() {
  var extendStatics = function(d5, b4) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d6, b5) {
      d6.__proto__ = b5;
    } || function(d6, b5) {
      for (var p9 in b5)
        if (Object.prototype.hasOwnProperty.call(b5, p9))
          d6[p9] = b5[p9];
    };
    return extendStatics(d5, b4);
  };
  return function(d5, b4) {
    if (typeof b4 !== "function" && b4 !== null)
      throw new TypeError("Class extends value " + String(b4) + " is not a constructor or null");
    extendStatics(d5, b4);
    function __() {
      this.constructor = d5;
    }
    d5.prototype = b4 === null ? Object.create(b4) : (__.prototype = b4.prototype, new __());
  };
}();
var _a2;
var OBSERVER_WAIT_TIME_MS = 300;
var isNode2 = typeof process === "object" && ((_a2 = process.release) === null || _a2 === void 0 ? void 0 : _a2.name) === "node";
var FetchInstrumentation = (
  /** @class */
  function(_super) {
    __extends9(FetchInstrumentation2, _super);
    function FetchInstrumentation2(config) {
      if (config === void 0) {
        config = {};
      }
      var _this = _super.call(this, "@opentelemetry/instrumentation-fetch", VERSION5, config) || this;
      _this.component = "fetch";
      _this.version = VERSION5;
      _this.moduleName = _this.component;
      _this._usedResources = /* @__PURE__ */ new WeakSet();
      _this._tasksCount = 0;
      return _this;
    }
    FetchInstrumentation2.prototype.init = function() {
    };
    FetchInstrumentation2.prototype._addChildSpan = function(span, corsPreFlightRequest) {
      var childSpan = this.tracer.startSpan("CORS Preflight", {
        startTime: corsPreFlightRequest[PerformanceTimingNames2.FETCH_START]
      }, trace.setSpan(context.active(), span));
      if (!this.getConfig().ignoreNetworkEvents) {
        addSpanNetworkEvents2(childSpan, corsPreFlightRequest);
      }
      childSpan.end(corsPreFlightRequest[PerformanceTimingNames2.RESPONSE_END]);
    };
    FetchInstrumentation2.prototype._addFinalSpanAttributes = function(span, response) {
      var parsedUrl = parseUrl2(response.url);
      span.setAttribute(SEMATTRS_HTTP_STATUS_CODE, response.status);
      if (response.statusText != null) {
        span.setAttribute(AttributeNames2.HTTP_STATUS_TEXT, response.statusText);
      }
      span.setAttribute(SEMATTRS_HTTP_HOST, parsedUrl.host);
      span.setAttribute(SEMATTRS_HTTP_SCHEME, parsedUrl.protocol.replace(":", ""));
      if (typeof navigator !== "undefined") {
        span.setAttribute(SEMATTRS_HTTP_USER_AGENT2, navigator.userAgent);
      }
    };
    FetchInstrumentation2.prototype._addHeaders = function(options, spanUrl) {
      if (!shouldPropagateTraceHeaders2(spanUrl, this.getConfig().propagateTraceHeaderCorsUrls)) {
        var headers = {};
        propagation.inject(context.active(), headers);
        if (Object.keys(headers).length > 0) {
          this._diag.debug("headers inject skipped due to CORS policy");
        }
        return;
      }
      if (options instanceof Request) {
        propagation.inject(context.active(), options.headers, {
          set: function(h4, k3, v4) {
            return h4.set(k3, typeof v4 === "string" ? v4 : String(v4));
          }
        });
      } else if (options.headers instanceof Headers) {
        propagation.inject(context.active(), options.headers, {
          set: function(h4, k3, v4) {
            return h4.set(k3, typeof v4 === "string" ? v4 : String(v4));
          }
        });
      } else if (options.headers instanceof Map) {
        propagation.inject(context.active(), options.headers, {
          set: function(h4, k3, v4) {
            return h4.set(k3, typeof v4 === "string" ? v4 : String(v4));
          }
        });
      } else {
        var headers = {};
        propagation.inject(context.active(), headers);
        options.headers = Object.assign({}, headers, options.headers || {});
      }
    };
    FetchInstrumentation2.prototype._clearResources = function() {
      if (this._tasksCount === 0 && this.getConfig().clearTimingResources) {
        performance.clearResourceTimings();
        this._usedResources = /* @__PURE__ */ new WeakSet();
      }
    };
    FetchInstrumentation2.prototype._createSpan = function(url, options) {
      var _a3;
      if (options === void 0) {
        options = {};
      }
      if (isUrlIgnored(url, this.getConfig().ignoreUrls)) {
        this._diag.debug("ignoring span as url matches ignored url");
        return;
      }
      var method = (options.method || "GET").toUpperCase();
      var spanName = "HTTP " + method;
      return this.tracer.startSpan(spanName, {
        kind: SpanKind.CLIENT,
        attributes: (_a3 = {}, _a3[AttributeNames2.COMPONENT] = this.moduleName, _a3[SEMATTRS_HTTP_METHOD] = method, _a3[SEMATTRS_HTTP_URL2] = url, _a3)
      });
    };
    FetchInstrumentation2.prototype._findResourceAndAddNetworkEvents = function(span, resourcesObserver, endTime) {
      var resources = resourcesObserver.entries;
      if (!resources.length) {
        if (!performance.getEntriesByType) {
          return;
        }
        resources = performance.getEntriesByType("resource");
      }
      var resource = getResource2(resourcesObserver.spanUrl, resourcesObserver.startTime, endTime, resources, this._usedResources, "fetch");
      if (resource.mainRequest) {
        var mainRequest = resource.mainRequest;
        this._markResourceAsUsed(mainRequest);
        var corsPreFlightRequest = resource.corsPreFlightRequest;
        if (corsPreFlightRequest) {
          this._addChildSpan(span, corsPreFlightRequest);
          this._markResourceAsUsed(corsPreFlightRequest);
        }
        if (!this.getConfig().ignoreNetworkEvents) {
          addSpanNetworkEvents2(span, mainRequest);
        }
      }
    };
    FetchInstrumentation2.prototype._markResourceAsUsed = function(resource) {
      this._usedResources.add(resource);
    };
    FetchInstrumentation2.prototype._endSpan = function(span, spanData, response) {
      var _this = this;
      var endTime = millisToHrTime3(Date.now());
      var performanceEndTime = hrTime3();
      this._addFinalSpanAttributes(span, response);
      setTimeout(function() {
        var _a3;
        (_a3 = spanData.observer) === null || _a3 === void 0 ? void 0 : _a3.disconnect();
        _this._findResourceAndAddNetworkEvents(span, spanData, performanceEndTime);
        _this._tasksCount--;
        _this._clearResources();
        span.end(endTime);
      }, OBSERVER_WAIT_TIME_MS);
    };
    FetchInstrumentation2.prototype._patchConstructor = function() {
      var _this = this;
      return function(original) {
        var plugin = _this;
        return function patchConstructor() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var self2 = this;
          var url = parseUrl2(args[0] instanceof Request ? args[0].url : String(args[0])).href;
          var options = args[0] instanceof Request ? args[0] : args[1] || {};
          var createdSpan = plugin._createSpan(url, options);
          if (!createdSpan) {
            return original.apply(this, args);
          }
          var spanData = plugin._prepareSpanData(url);
          function endSpanOnError(span, error) {
            plugin._applyAttributesAfterFetch(span, options, error);
            plugin._endSpan(span, spanData, {
              status: error.status || 0,
              statusText: error.message,
              url
            });
          }
          function endSpanOnSuccess(span, response) {
            plugin._applyAttributesAfterFetch(span, options, response);
            if (response.status >= 200 && response.status < 400) {
              plugin._endSpan(span, spanData, response);
            } else {
              plugin._endSpan(span, spanData, {
                status: response.status,
                statusText: response.statusText,
                url
              });
            }
          }
          function onSuccess(span, resolve, response) {
            try {
              var resClone = response.clone();
              var resClone4Hook_1 = response.clone();
              var body = resClone.body;
              if (body) {
                var reader_1 = body.getReader();
                var read_1 = function() {
                  reader_1.read().then(function(_a3) {
                    var done = _a3.done;
                    if (done) {
                      endSpanOnSuccess(span, resClone4Hook_1);
                    } else {
                      read_1();
                    }
                  }, function(error) {
                    endSpanOnError(span, error);
                  });
                };
                read_1();
              } else {
                endSpanOnSuccess(span, response);
              }
            } finally {
              resolve(response);
            }
          }
          function onError(span, reject, error) {
            try {
              endSpanOnError(span, error);
            } finally {
              reject(error);
            }
          }
          return new Promise(function(resolve, reject) {
            return context.with(trace.setSpan(context.active(), createdSpan), function() {
              plugin._addHeaders(options, url);
              plugin._tasksCount++;
              return original.apply(self2, options instanceof Request ? [options] : [url, options]).then(onSuccess.bind(self2, createdSpan, resolve), onError.bind(self2, createdSpan, reject));
            });
          });
        };
      };
    };
    FetchInstrumentation2.prototype._applyAttributesAfterFetch = function(span, request3, result) {
      var _this = this;
      var applyCustomAttributesOnSpan = this.getConfig().applyCustomAttributesOnSpan;
      if (applyCustomAttributesOnSpan) {
        safeExecuteInTheMiddle(function() {
          return applyCustomAttributesOnSpan(span, request3, result);
        }, function(error) {
          if (!error) {
            return;
          }
          _this._diag.error("applyCustomAttributesOnSpan", error);
        }, true);
      }
    };
    FetchInstrumentation2.prototype._prepareSpanData = function(spanUrl) {
      var startTime = hrTime3();
      var entries = [];
      if (typeof PerformanceObserver !== "function") {
        return { entries, startTime, spanUrl };
      }
      var observer = new PerformanceObserver(function(list) {
        var perfObsEntries = list.getEntries();
        perfObsEntries.forEach(function(entry) {
          if (entry.initiatorType === "fetch" && entry.name === spanUrl) {
            entries.push(entry);
          }
        });
      });
      observer.observe({
        entryTypes: ["resource"]
      });
      return { entries, observer, startTime, spanUrl };
    };
    FetchInstrumentation2.prototype.enable = function() {
      if (isNode2) {
        this._diag.warn("this instrumentation is intended for web usage only, it does not instrument Node.js's fetch()");
        return;
      }
      if (isWrapped(fetch)) {
        this._unwrap(_globalThis6, "fetch");
        this._diag.debug("removing previous patch for constructor");
      }
      this._wrap(_globalThis6, "fetch", this._patchConstructor());
    };
    FetchInstrumentation2.prototype.disable = function() {
      if (isNode2) {
        return;
      }
      this._unwrap(_globalThis6, "fetch");
      this._usedResources = /* @__PURE__ */ new WeakSet();
    };
    return FetchInstrumentation2;
  }(InstrumentationBase)
);

// node_modules/@opentelemetry/instrumentation-xml-http-request/build/esm/xhr.js
init_esm();

// node_modules/@opentelemetry/instrumentation-xml-http-request/node_modules/@opentelemetry/core/build/esm/platform/node/performance.js
import { performance as performance4 } from "perf_hooks";
var otperformance5 = performance4;

// node_modules/@opentelemetry/instrumentation-xml-http-request/node_modules/@opentelemetry/semantic-conventions/build/esm/trace/SemanticAttributes.js
var TMP_HTTP_METHOD2 = "http.method";
var TMP_HTTP_URL3 = "http.url";
var TMP_HTTP_HOST2 = "http.host";
var TMP_HTTP_SCHEME2 = "http.scheme";
var TMP_HTTP_STATUS_CODE2 = "http.status_code";
var TMP_HTTP_USER_AGENT3 = "http.user_agent";
var TMP_HTTP_RESPONSE_CONTENT_LENGTH3 = "http.response_content_length";
var TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED3 = "http.response_content_length_uncompressed";
var SEMATTRS_HTTP_METHOD2 = TMP_HTTP_METHOD2;
var SEMATTRS_HTTP_URL3 = TMP_HTTP_URL3;
var SEMATTRS_HTTP_HOST2 = TMP_HTTP_HOST2;
var SEMATTRS_HTTP_SCHEME2 = TMP_HTTP_SCHEME2;
var SEMATTRS_HTTP_STATUS_CODE2 = TMP_HTTP_STATUS_CODE2;
var SEMATTRS_HTTP_USER_AGENT3 = TMP_HTTP_USER_AGENT3;
var SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH3 = TMP_HTTP_RESPONSE_CONTENT_LENGTH3;
var SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED3 = TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED3;

// node_modules/@opentelemetry/instrumentation-xml-http-request/node_modules/@opentelemetry/core/build/esm/common/time.js
var NANOSECOND_DIGITS4 = 9;
var NANOSECOND_DIGITS_IN_MILLIS4 = 6;
var MILLISECONDS_TO_NANOSECONDS4 = Math.pow(10, NANOSECOND_DIGITS_IN_MILLIS4);
var SECOND_TO_NANOSECONDS4 = Math.pow(10, NANOSECOND_DIGITS4);
function millisToHrTime4(epochMillis) {
  var epochSeconds = epochMillis / 1e3;
  var seconds = Math.trunc(epochSeconds);
  var nanos = Math.round(epochMillis % 1e3 * MILLISECONDS_TO_NANOSECONDS4);
  return [seconds, nanos];
}
function getTimeOrigin4() {
  var timeOrigin = otperformance5.timeOrigin;
  if (typeof timeOrigin !== "number") {
    var perf = otperformance5;
    timeOrigin = perf.timing && perf.timing.fetchStart;
  }
  return timeOrigin;
}
function hrTime4(performanceNow) {
  var timeOrigin = millisToHrTime4(getTimeOrigin4());
  var now = millisToHrTime4(typeof performanceNow === "number" ? performanceNow : otperformance5.now());
  return addHrTimes4(timeOrigin, now);
}
function timeInputToHrTime4(time) {
  if (isTimeInputHrTime4(time)) {
    return time;
  } else if (typeof time === "number") {
    if (time < getTimeOrigin4()) {
      return hrTime4(time);
    } else {
      return millisToHrTime4(time);
    }
  } else if (time instanceof Date) {
    return millisToHrTime4(time.getTime());
  } else {
    throw TypeError("Invalid input type");
  }
}
function hrTimeToNanoseconds4(time) {
  return time[0] * SECOND_TO_NANOSECONDS4 + time[1];
}
function isTimeInputHrTime4(value) {
  return Array.isArray(value) && value.length === 2 && typeof value[0] === "number" && typeof value[1] === "number";
}
function addHrTimes4(time1, time2) {
  var out = [time1[0] + time2[0], time1[1] + time2[1]];
  if (out[1] >= SECOND_TO_NANOSECONDS4) {
    out[1] -= SECOND_TO_NANOSECONDS4;
    out[0] += 1;
  }
  return out;
}

// node_modules/@opentelemetry/instrumentation-xml-http-request/node_modules/@opentelemetry/core/build/esm/utils/url.js
var __values11 = function(o4) {
  var s10 = typeof Symbol === "function" && Symbol.iterator, m2 = s10 && o4[s10], i4 = 0;
  if (m2)
    return m2.call(o4);
  if (o4 && typeof o4.length === "number")
    return {
      next: function() {
        if (o4 && i4 >= o4.length)
          o4 = void 0;
        return { value: o4 && o4[i4++], done: !o4 };
      }
    };
  throw new TypeError(s10 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
function urlMatches2(url, urlToMatch) {
  if (typeof urlToMatch === "string") {
    return url === urlToMatch;
  } else {
    return !!url.match(urlToMatch);
  }
}
function isUrlIgnored2(url, ignoredUrls) {
  var e_1, _a3;
  if (!ignoredUrls) {
    return false;
  }
  try {
    for (var ignoredUrls_1 = __values11(ignoredUrls), ignoredUrls_1_1 = ignoredUrls_1.next(); !ignoredUrls_1_1.done; ignoredUrls_1_1 = ignoredUrls_1.next()) {
      var ignoreUrl = ignoredUrls_1_1.value;
      if (urlMatches2(url, ignoreUrl)) {
        return true;
      }
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (ignoredUrls_1_1 && !ignoredUrls_1_1.done && (_a3 = ignoredUrls_1.return))
        _a3.call(ignoredUrls_1);
    } finally {
      if (e_1)
        throw e_1.error;
    }
  }
  return false;
}

// node_modules/@opentelemetry/instrumentation-xml-http-request/node_modules/@opentelemetry/sdk-trace-web/build/esm/enums/PerformanceTimingNames.js
var PerformanceTimingNames3;
(function(PerformanceTimingNames4) {
  PerformanceTimingNames4["CONNECT_END"] = "connectEnd";
  PerformanceTimingNames4["CONNECT_START"] = "connectStart";
  PerformanceTimingNames4["DECODED_BODY_SIZE"] = "decodedBodySize";
  PerformanceTimingNames4["DOM_COMPLETE"] = "domComplete";
  PerformanceTimingNames4["DOM_CONTENT_LOADED_EVENT_END"] = "domContentLoadedEventEnd";
  PerformanceTimingNames4["DOM_CONTENT_LOADED_EVENT_START"] = "domContentLoadedEventStart";
  PerformanceTimingNames4["DOM_INTERACTIVE"] = "domInteractive";
  PerformanceTimingNames4["DOMAIN_LOOKUP_END"] = "domainLookupEnd";
  PerformanceTimingNames4["DOMAIN_LOOKUP_START"] = "domainLookupStart";
  PerformanceTimingNames4["ENCODED_BODY_SIZE"] = "encodedBodySize";
  PerformanceTimingNames4["FETCH_START"] = "fetchStart";
  PerformanceTimingNames4["LOAD_EVENT_END"] = "loadEventEnd";
  PerformanceTimingNames4["LOAD_EVENT_START"] = "loadEventStart";
  PerformanceTimingNames4["NAVIGATION_START"] = "navigationStart";
  PerformanceTimingNames4["REDIRECT_END"] = "redirectEnd";
  PerformanceTimingNames4["REDIRECT_START"] = "redirectStart";
  PerformanceTimingNames4["REQUEST_START"] = "requestStart";
  PerformanceTimingNames4["RESPONSE_END"] = "responseEnd";
  PerformanceTimingNames4["RESPONSE_START"] = "responseStart";
  PerformanceTimingNames4["SECURE_CONNECTION_START"] = "secureConnectionStart";
  PerformanceTimingNames4["UNLOAD_EVENT_END"] = "unloadEventEnd";
  PerformanceTimingNames4["UNLOAD_EVENT_START"] = "unloadEventStart";
})(PerformanceTimingNames3 || (PerformanceTimingNames3 = {}));

// node_modules/@opentelemetry/instrumentation-xml-http-request/node_modules/@opentelemetry/sdk-trace-web/build/esm/utils.js
var urlNormalizingAnchor2;
function getUrlNormalizingAnchor2() {
  if (!urlNormalizingAnchor2) {
    urlNormalizingAnchor2 = document.createElement("a");
  }
  return urlNormalizingAnchor2;
}
function hasKey3(obj, key) {
  return key in obj;
}
function addSpanNetworkEvent3(span, performanceName, entries, refPerfName) {
  var perfTime = void 0;
  var refTime = void 0;
  if (hasKey3(entries, performanceName) && typeof entries[performanceName] === "number") {
    perfTime = entries[performanceName];
  }
  var refName = refPerfName || PerformanceTimingNames3.FETCH_START;
  if (hasKey3(entries, refName) && typeof entries[refName] === "number") {
    refTime = entries[refName];
  }
  if (perfTime !== void 0 && refTime !== void 0 && perfTime >= refTime) {
    span.addEvent(performanceName, perfTime);
    return span;
  }
  return void 0;
}
function addSpanNetworkEvents3(span, resource) {
  addSpanNetworkEvent3(span, PerformanceTimingNames3.FETCH_START, resource);
  addSpanNetworkEvent3(span, PerformanceTimingNames3.DOMAIN_LOOKUP_START, resource);
  addSpanNetworkEvent3(span, PerformanceTimingNames3.DOMAIN_LOOKUP_END, resource);
  addSpanNetworkEvent3(span, PerformanceTimingNames3.CONNECT_START, resource);
  if (hasKey3(resource, "name") && resource["name"].startsWith("https:")) {
    addSpanNetworkEvent3(span, PerformanceTimingNames3.SECURE_CONNECTION_START, resource);
  }
  addSpanNetworkEvent3(span, PerformanceTimingNames3.CONNECT_END, resource);
  addSpanNetworkEvent3(span, PerformanceTimingNames3.REQUEST_START, resource);
  addSpanNetworkEvent3(span, PerformanceTimingNames3.RESPONSE_START, resource);
  addSpanNetworkEvent3(span, PerformanceTimingNames3.RESPONSE_END, resource);
  var encodedLength = resource[PerformanceTimingNames3.ENCODED_BODY_SIZE];
  if (encodedLength !== void 0) {
    span.setAttribute(SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH3, encodedLength);
  }
  var decodedLength = resource[PerformanceTimingNames3.DECODED_BODY_SIZE];
  if (decodedLength !== void 0 && encodedLength !== decodedLength) {
    span.setAttribute(SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED3, decodedLength);
  }
}
function sortResources3(filteredResources) {
  return filteredResources.slice().sort(function(a4, b4) {
    var valueA = a4[PerformanceTimingNames3.FETCH_START];
    var valueB = b4[PerformanceTimingNames3.FETCH_START];
    if (valueA > valueB) {
      return 1;
    } else if (valueA < valueB) {
      return -1;
    }
    return 0;
  });
}
function getOrigin2() {
  return typeof location !== "undefined" ? location.origin : void 0;
}
function getResource3(spanUrl, startTimeHR, endTimeHR, resources, ignoredResources, initiatorType) {
  if (ignoredResources === void 0) {
    ignoredResources = /* @__PURE__ */ new WeakSet();
  }
  var parsedSpanUrl = parseUrl3(spanUrl);
  spanUrl = parsedSpanUrl.toString();
  var filteredResources = filterResourcesForSpan2(spanUrl, startTimeHR, endTimeHR, resources, ignoredResources, initiatorType);
  if (filteredResources.length === 0) {
    return {
      mainRequest: void 0
    };
  }
  if (filteredResources.length === 1) {
    return {
      mainRequest: filteredResources[0]
    };
  }
  var sorted = sortResources3(filteredResources);
  if (parsedSpanUrl.origin !== getOrigin2() && sorted.length > 1) {
    var corsPreFlightRequest = sorted[0];
    var mainRequest = findMainRequest2(sorted, corsPreFlightRequest[PerformanceTimingNames3.RESPONSE_END], endTimeHR);
    var responseEnd = corsPreFlightRequest[PerformanceTimingNames3.RESPONSE_END];
    var fetchStart = mainRequest[PerformanceTimingNames3.FETCH_START];
    if (fetchStart < responseEnd) {
      mainRequest = corsPreFlightRequest;
      corsPreFlightRequest = void 0;
    }
    return {
      corsPreFlightRequest,
      mainRequest
    };
  } else {
    return {
      mainRequest: filteredResources[0]
    };
  }
}
function findMainRequest2(resources, corsPreFlightRequestEndTime, spanEndTimeHR) {
  var spanEndTime = hrTimeToNanoseconds4(spanEndTimeHR);
  var minTime = hrTimeToNanoseconds4(timeInputToHrTime4(corsPreFlightRequestEndTime));
  var mainRequest = resources[1];
  var bestGap;
  var length = resources.length;
  for (var i4 = 1; i4 < length; i4++) {
    var resource = resources[i4];
    var resourceStartTime = hrTimeToNanoseconds4(timeInputToHrTime4(resource[PerformanceTimingNames3.FETCH_START]));
    var resourceEndTime = hrTimeToNanoseconds4(timeInputToHrTime4(resource[PerformanceTimingNames3.RESPONSE_END]));
    var currentGap = spanEndTime - resourceEndTime;
    if (resourceStartTime >= minTime && (!bestGap || currentGap < bestGap)) {
      bestGap = currentGap;
      mainRequest = resource;
    }
  }
  return mainRequest;
}
function filterResourcesForSpan2(spanUrl, startTimeHR, endTimeHR, resources, ignoredResources, initiatorType) {
  var startTime = hrTimeToNanoseconds4(startTimeHR);
  var endTime = hrTimeToNanoseconds4(endTimeHR);
  var filteredResources = resources.filter(function(resource) {
    var resourceStartTime = hrTimeToNanoseconds4(timeInputToHrTime4(resource[PerformanceTimingNames3.FETCH_START]));
    var resourceEndTime = hrTimeToNanoseconds4(timeInputToHrTime4(resource[PerformanceTimingNames3.RESPONSE_END]));
    return resource.initiatorType.toLowerCase() === (initiatorType || "xmlhttprequest") && resource.name === spanUrl && resourceStartTime >= startTime && resourceEndTime <= endTime;
  });
  if (filteredResources.length > 0) {
    filteredResources = filteredResources.filter(function(resource) {
      return !ignoredResources.has(resource);
    });
  }
  return filteredResources;
}
function parseUrl3(url) {
  if (typeof URL === "function") {
    return new URL(url, typeof document !== "undefined" ? document.baseURI : typeof location !== "undefined" ? location.href : void 0);
  }
  var element = getUrlNormalizingAnchor2();
  element.href = url;
  return element;
}
function shouldPropagateTraceHeaders3(spanUrl, propagateTraceHeaderCorsUrls) {
  var propagateTraceHeaderUrls = propagateTraceHeaderCorsUrls || [];
  if (typeof propagateTraceHeaderUrls === "string" || propagateTraceHeaderUrls instanceof RegExp) {
    propagateTraceHeaderUrls = [propagateTraceHeaderUrls];
  }
  var parsedSpanUrl = parseUrl3(spanUrl);
  if (parsedSpanUrl.origin === getOrigin2()) {
    return true;
  } else {
    return propagateTraceHeaderUrls.some(function(propagateTraceHeaderUrl) {
      return urlMatches2(spanUrl, propagateTraceHeaderUrl);
    });
  }
}

// node_modules/@opentelemetry/instrumentation-xml-http-request/build/esm/enums/EventNames.js
var EventNames2;
(function(EventNames3) {
  EventNames3["METHOD_OPEN"] = "open";
  EventNames3["METHOD_SEND"] = "send";
  EventNames3["EVENT_ABORT"] = "abort";
  EventNames3["EVENT_ERROR"] = "error";
  EventNames3["EVENT_LOAD"] = "loaded";
  EventNames3["EVENT_TIMEOUT"] = "timeout";
})(EventNames2 || (EventNames2 = {}));

// node_modules/@opentelemetry/instrumentation-xml-http-request/build/esm/version.js
var VERSION6 = "0.53.0";

// node_modules/@opentelemetry/instrumentation-xml-http-request/build/esm/enums/AttributeNames.js
var AttributeNames3;
(function(AttributeNames4) {
  AttributeNames4["HTTP_STATUS_TEXT"] = "http.status_text";
})(AttributeNames3 || (AttributeNames3 = {}));

// node_modules/@opentelemetry/instrumentation-xml-http-request/build/esm/xhr.js
var __extends10 = function() {
  var extendStatics = function(d5, b4) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d6, b5) {
      d6.__proto__ = b5;
    } || function(d6, b5) {
      for (var p9 in b5)
        if (Object.prototype.hasOwnProperty.call(b5, p9))
          d6[p9] = b5[p9];
    };
    return extendStatics(d5, b4);
  };
  return function(d5, b4) {
    if (typeof b4 !== "function" && b4 !== null)
      throw new TypeError("Class extends value " + String(b4) + " is not a constructor or null");
    extendStatics(d5, b4);
    function __() {
      this.constructor = d5;
    }
    d5.prototype = b4 === null ? Object.create(b4) : (__.prototype = b4.prototype, new __());
  };
}();
var OBSERVER_WAIT_TIME_MS2 = 300;
var XMLHttpRequestInstrumentation = (
  /** @class */
  function(_super) {
    __extends10(XMLHttpRequestInstrumentation2, _super);
    function XMLHttpRequestInstrumentation2(config) {
      if (config === void 0) {
        config = {};
      }
      var _this = _super.call(this, "@opentelemetry/instrumentation-xml-http-request", VERSION6, config) || this;
      _this.component = "xml-http-request";
      _this.version = VERSION6;
      _this.moduleName = _this.component;
      _this._tasksCount = 0;
      _this._xhrMem = /* @__PURE__ */ new WeakMap();
      _this._usedResources = /* @__PURE__ */ new WeakSet();
      return _this;
    }
    XMLHttpRequestInstrumentation2.prototype.init = function() {
    };
    XMLHttpRequestInstrumentation2.prototype._addHeaders = function(xhr, spanUrl) {
      var url = parseUrl3(spanUrl).href;
      if (!shouldPropagateTraceHeaders3(url, this.getConfig().propagateTraceHeaderCorsUrls)) {
        var headers_1 = {};
        propagation.inject(context.active(), headers_1);
        if (Object.keys(headers_1).length > 0) {
          this._diag.debug("headers inject skipped due to CORS policy");
        }
        return;
      }
      var headers = {};
      propagation.inject(context.active(), headers);
      Object.keys(headers).forEach(function(key) {
        xhr.setRequestHeader(key, String(headers[key]));
      });
    };
    XMLHttpRequestInstrumentation2.prototype._addChildSpan = function(span, corsPreFlightRequest) {
      var _this = this;
      context.with(trace.setSpan(context.active(), span), function() {
        var childSpan = _this.tracer.startSpan("CORS Preflight", {
          startTime: corsPreFlightRequest[PerformanceTimingNames3.FETCH_START]
        });
        if (!_this.getConfig().ignoreNetworkEvents) {
          addSpanNetworkEvents3(childSpan, corsPreFlightRequest);
        }
        childSpan.end(corsPreFlightRequest[PerformanceTimingNames3.RESPONSE_END]);
      });
    };
    XMLHttpRequestInstrumentation2.prototype._addFinalSpanAttributes = function(span, xhrMem, spanUrl) {
      if (typeof spanUrl === "string") {
        var parsedUrl = parseUrl3(spanUrl);
        if (xhrMem.status !== void 0) {
          span.setAttribute(SEMATTRS_HTTP_STATUS_CODE2, xhrMem.status);
        }
        if (xhrMem.statusText !== void 0) {
          span.setAttribute(AttributeNames3.HTTP_STATUS_TEXT, xhrMem.statusText);
        }
        span.setAttribute(SEMATTRS_HTTP_HOST2, parsedUrl.host);
        span.setAttribute(SEMATTRS_HTTP_SCHEME2, parsedUrl.protocol.replace(":", ""));
        span.setAttribute(SEMATTRS_HTTP_USER_AGENT3, navigator.userAgent);
      }
    };
    XMLHttpRequestInstrumentation2.prototype._applyAttributesAfterXHR = function(span, xhr) {
      var _this = this;
      var applyCustomAttributesOnSpan = this.getConfig().applyCustomAttributesOnSpan;
      if (typeof applyCustomAttributesOnSpan === "function") {
        safeExecuteInTheMiddle(function() {
          return applyCustomAttributesOnSpan(span, xhr);
        }, function(error) {
          if (!error) {
            return;
          }
          _this._diag.error("applyCustomAttributesOnSpan", error);
        }, true);
      }
    };
    XMLHttpRequestInstrumentation2.prototype._addResourceObserver = function(xhr, spanUrl) {
      var xhrMem = this._xhrMem.get(xhr);
      if (!xhrMem || typeof PerformanceObserver !== "function" || typeof PerformanceResourceTiming !== "function") {
        return;
      }
      xhrMem.createdResources = {
        observer: new PerformanceObserver(function(list) {
          var entries = list.getEntries();
          var parsedUrl = parseUrl3(spanUrl);
          entries.forEach(function(entry) {
            if (entry.initiatorType === "xmlhttprequest" && entry.name === parsedUrl.href) {
              if (xhrMem.createdResources) {
                xhrMem.createdResources.entries.push(entry);
              }
            }
          });
        }),
        entries: []
      };
      xhrMem.createdResources.observer.observe({
        entryTypes: ["resource"]
      });
    };
    XMLHttpRequestInstrumentation2.prototype._clearResources = function() {
      if (this._tasksCount === 0 && this.getConfig().clearTimingResources) {
        otperformance5.clearResourceTimings();
        this._xhrMem = /* @__PURE__ */ new WeakMap();
        this._usedResources = /* @__PURE__ */ new WeakSet();
      }
    };
    XMLHttpRequestInstrumentation2.prototype._findResourceAndAddNetworkEvents = function(xhrMem, span, spanUrl, startTime, endTime) {
      if (!spanUrl || !startTime || !endTime || !xhrMem.createdResources) {
        return;
      }
      var resources = xhrMem.createdResources.entries;
      if (!resources || !resources.length) {
        resources = otperformance5.getEntriesByType("resource");
      }
      var resource = getResource3(parseUrl3(spanUrl).href, startTime, endTime, resources, this._usedResources);
      if (resource.mainRequest) {
        var mainRequest = resource.mainRequest;
        this._markResourceAsUsed(mainRequest);
        var corsPreFlightRequest = resource.corsPreFlightRequest;
        if (corsPreFlightRequest) {
          this._addChildSpan(span, corsPreFlightRequest);
          this._markResourceAsUsed(corsPreFlightRequest);
        }
        if (!this.getConfig().ignoreNetworkEvents) {
          addSpanNetworkEvents3(span, mainRequest);
        }
      }
    };
    XMLHttpRequestInstrumentation2.prototype._cleanPreviousSpanInformation = function(xhr) {
      var xhrMem = this._xhrMem.get(xhr);
      if (xhrMem) {
        var callbackToRemoveEvents = xhrMem.callbackToRemoveEvents;
        if (callbackToRemoveEvents) {
          callbackToRemoveEvents();
        }
        this._xhrMem.delete(xhr);
      }
    };
    XMLHttpRequestInstrumentation2.prototype._createSpan = function(xhr, url, method) {
      var _a3;
      if (isUrlIgnored2(url, this.getConfig().ignoreUrls)) {
        this._diag.debug("ignoring span as url matches ignored url");
        return;
      }
      var spanName = method.toUpperCase();
      var currentSpan = this.tracer.startSpan(spanName, {
        kind: SpanKind.CLIENT,
        attributes: (_a3 = {}, _a3[SEMATTRS_HTTP_METHOD2] = method, _a3[SEMATTRS_HTTP_URL3] = parseUrl3(url).toString(), _a3)
      });
      currentSpan.addEvent(EventNames2.METHOD_OPEN);
      this._cleanPreviousSpanInformation(xhr);
      this._xhrMem.set(xhr, {
        span: currentSpan,
        spanUrl: url
      });
      return currentSpan;
    };
    XMLHttpRequestInstrumentation2.prototype._markResourceAsUsed = function(resource) {
      this._usedResources.add(resource);
    };
    XMLHttpRequestInstrumentation2.prototype._patchOpen = function() {
      var _this = this;
      return function(original) {
        var plugin = _this;
        return function patchOpen() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var method = args[0];
          var url = args[1];
          plugin._createSpan(this, url, method);
          return original.apply(this, args);
        };
      };
    };
    XMLHttpRequestInstrumentation2.prototype._patchSend = function() {
      var plugin = this;
      function endSpanTimeout(eventName, xhrMem, performanceEndTime, endTime) {
        var callbackToRemoveEvents = xhrMem.callbackToRemoveEvents;
        if (typeof callbackToRemoveEvents === "function") {
          callbackToRemoveEvents();
        }
        var span = xhrMem.span, spanUrl = xhrMem.spanUrl, sendStartTime = xhrMem.sendStartTime;
        if (span) {
          plugin._findResourceAndAddNetworkEvents(xhrMem, span, spanUrl, sendStartTime, performanceEndTime);
          span.addEvent(eventName, endTime);
          plugin._addFinalSpanAttributes(span, xhrMem, spanUrl);
          span.end(endTime);
          plugin._tasksCount--;
        }
        plugin._clearResources();
      }
      function endSpan(eventName, xhr) {
        var xhrMem = plugin._xhrMem.get(xhr);
        if (!xhrMem) {
          return;
        }
        xhrMem.status = xhr.status;
        xhrMem.statusText = xhr.statusText;
        plugin._xhrMem.delete(xhr);
        if (xhrMem.span) {
          plugin._applyAttributesAfterXHR(xhrMem.span, xhr);
        }
        var performanceEndTime = hrTime4();
        var endTime = Date.now();
        setTimeout(function() {
          endSpanTimeout(eventName, xhrMem, performanceEndTime, endTime);
        }, OBSERVER_WAIT_TIME_MS2);
      }
      function onError() {
        endSpan(EventNames2.EVENT_ERROR, this);
      }
      function onAbort() {
        endSpan(EventNames2.EVENT_ABORT, this);
      }
      function onTimeout() {
        endSpan(EventNames2.EVENT_TIMEOUT, this);
      }
      function onLoad() {
        if (this.status < 299) {
          endSpan(EventNames2.EVENT_LOAD, this);
        } else {
          endSpan(EventNames2.EVENT_ERROR, this);
        }
      }
      function unregister(xhr) {
        xhr.removeEventListener("abort", onAbort);
        xhr.removeEventListener("error", onError);
        xhr.removeEventListener("load", onLoad);
        xhr.removeEventListener("timeout", onTimeout);
        var xhrMem = plugin._xhrMem.get(xhr);
        if (xhrMem) {
          xhrMem.callbackToRemoveEvents = void 0;
        }
      }
      return function(original) {
        return function patchSend() {
          var _this = this;
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var xhrMem = plugin._xhrMem.get(this);
          if (!xhrMem) {
            return original.apply(this, args);
          }
          var currentSpan = xhrMem.span;
          var spanUrl = xhrMem.spanUrl;
          if (currentSpan && spanUrl) {
            context.with(trace.setSpan(context.active(), currentSpan), function() {
              plugin._tasksCount++;
              xhrMem.sendStartTime = hrTime4();
              currentSpan.addEvent(EventNames2.METHOD_SEND);
              _this.addEventListener("abort", onAbort);
              _this.addEventListener("error", onError);
              _this.addEventListener("load", onLoad);
              _this.addEventListener("timeout", onTimeout);
              xhrMem.callbackToRemoveEvents = function() {
                unregister(_this);
                if (xhrMem.createdResources) {
                  xhrMem.createdResources.observer.disconnect();
                }
              };
              plugin._addHeaders(_this, spanUrl);
              plugin._addResourceObserver(_this, spanUrl);
            });
          }
          return original.apply(this, args);
        };
      };
    };
    XMLHttpRequestInstrumentation2.prototype.enable = function() {
      this._diag.debug("applying patch to", this.moduleName, this.version);
      if (isWrapped(XMLHttpRequest.prototype.open)) {
        this._unwrap(XMLHttpRequest.prototype, "open");
        this._diag.debug("removing previous patch from method open");
      }
      if (isWrapped(XMLHttpRequest.prototype.send)) {
        this._unwrap(XMLHttpRequest.prototype, "send");
        this._diag.debug("removing previous patch from method send");
      }
      this._wrap(XMLHttpRequest.prototype, "open", this._patchOpen());
      this._wrap(XMLHttpRequest.prototype, "send", this._patchSend());
    };
    XMLHttpRequestInstrumentation2.prototype.disable = function() {
      this._diag.debug("removing patch from", this.moduleName, this.version);
      this._unwrap(XMLHttpRequest.prototype, "open");
      this._unwrap(XMLHttpRequest.prototype, "send");
      this._tasksCount = 0;
      this._xhrMem = /* @__PURE__ */ new WeakMap();
      this._usedResources = /* @__PURE__ */ new WeakSet();
    };
    return XMLHttpRequestInstrumentation2;
  }(InstrumentationBase)
);

// node_modules/@redocly/realm/dist/config/product-gates.js
var e5 = "@redocly/realm";

// node_modules/@redocly/realm/dist/client/app/telemetry/otel/error-instrumentation.js
var o3 = class extends InstrumentationBase {
  sendErrorEvent;
  originalConsoleError;
  constructor(r7, e7) {
    super("errors", "1.0", r7 || {}), this.sendErrorEvent = e7;
  }
  static toErrorEvent(r7, e7) {
    return { handler: e7, type: o3.getErrorType(r7), message: o3.getErrorMessage(r7), stack: o3.getErrorStack(r7) };
  }
  enable() {
    window.addEventListener("error", this.onError), window.addEventListener("unhandledrejection", this.onUnhandledRejection), this.wrapConsoleError();
  }
  disable() {
    window.removeEventListener("error", this.onError), window.removeEventListener("unhandledrejection", this.onUnhandledRejection), this.unwrapConsoleError();
  }
  init() {
  }
  static getErrorMessage(r7) {
    return r7 ? (typeof r7 == "object" && "message" in r7 ? String(r7.message) : String(r7)).trim() : void 0;
  }
  static getErrorStack(r7) {
    if (!r7 || typeof r7 != "object" || !("stack" in r7) || !r7.stack)
      return;
    const e7 = String(r7.stack);
    return e7.length > 4096 ? e7.substring(0, 4096) : e7;
  }
  static getErrorType(r7) {
    return !r7 || typeof r7 != "object" ? typeof r7 : "name" in r7 ? String(r7.name) : "constructor" in r7 && "name" in r7.constructor ? String(r7.constructor.name) : "Error";
  }
  static combineConsoleErrorArgs(r7) {
    const e7 = r7.findIndex((n9) => n9 instanceof Error), t5 = r7.filter((n9, s10) => s10 !== e7).map((n9) => String(n9)).join(" ");
    if (e7 === -1)
      return t5;
    {
      const n9 = r7[e7];
      return t5 && (n9.message = `${n9.message} ${t5}`), n9;
    }
  }
  onError = (r7) => {
    this.sendError(r7.error, "window.onerror");
  };
  onUnhandledRejection = (r7) => {
    this.sendError(r7.reason, "window.onunhandledrejection");
  };
  wrapConsoleError() {
    this.originalConsoleError = console.error, console.error = (...r7) => {
      try {
        const e7 = o3.combineConsoleErrorArgs(r7);
        this.sendError(e7, "console.error");
      } catch (e7) {
        this.originalConsoleError?.call(console, "Error reporting failed:", e7);
      }
      this.originalConsoleError?.apply(console, r7);
    };
  }
  unwrapConsoleError() {
    this.originalConsoleError && (console.error = this.originalConsoleError, this.originalConsoleError = void 0);
  }
  sendError(r7, e7) {
    this.sendErrorEvent(o3.toErrorEvent(r7, e7));
  }
};

// node_modules/@redocly/realm/dist/client/app/telemetry/otel/telemetry.js
var A3 = class {
  sessionId;
  initialReferrer;
  init() {
    if (this.disabled())
      return;
    this.sessionId = `ses_${ulid()}`, this.initialReferrer = document.referrer || void 0;
    const e7 = new WebTracerProvider({ resource: new Resource({ [ATTR_SERVICE_NAME]: "realm-ui", [ATTR_SERVICE_VERSION]: `${e5}@${process.env.REDOCLY_PORTAL_VERSION}`, "redocly.session.id": this.sessionId }) });
    e7.addSpanProcessor(new BatchSpanProcessor(new OTLPTraceExporter({ url: t.OTEL_TRACES, headers: {} }))), e7.register({ contextManager: new ZoneContextManager(), propagator: new CompositePropagator({ propagators: [new W3CBaggagePropagator(), new W3CTraceContextPropagator()] }) }), registerInstrumentations({ instrumentations: [new DocumentLoadInstrumentation(), new FetchInstrumentation(), new XMLHttpRequestInstrumentation(), new o3(void 0, (r7) => {
      this.send("error", r7);
    })] });
  }
  send(e7, r7) {
    try {
      if (this.disabled())
        return;
      const t5 = /* @__PURE__ */ new Date(), a4 = ulid(), o4 = trace.getTracer("ClientTelemetry").startSpan(`event.${e7}`, { attributes: { "redocly.event_id": a4, "redocly.event_type": e7, "redocly.page.uri": location.href, "redocly.page.initial_referrer": this.initialReferrer }, startTime: t5 });
      Object.entries(r7).forEach(([m2, n9]) => {
        const c5 = m2.replace(/([A-Z])/g, "_$1").toLowerCase();
        n9 !== void 0 && o4.setAttribute(`redocly.event_data.${c5}`, n9);
      }), o4.end(t5);
    } catch (t5) {
      console.error("Event reporting failed:", t5);
    }
  }
  sendError(e7, r7) {
    this.send("error", o3.toErrorEvent(e7, r7));
  }
  disabled() {
    return true;
  }
};
var q2 = new A3();

// node_modules/@redocly/realm/dist/client/ErrorBoundary.js
var u5 = class extends n7.Component {
  constructor(r7) {
    super(r7), this.state = { error: void 0 };
  }
  componentDidCatch(r7, s10) {
    const { name: e7, message: t5 } = r7, o4 = { name: e7, message: t5, stack: s10.componentStack ?? void 0 };
    this.setState({ error: o4 }), s.send("client_error_caught", { message: `${e7}: ${t5}`, url: location.href }), q2.sendError(o4, "ReactErrorBoundary"), console.log(r7);
  }
  render() {
    return this.state.error && true ? n7.createElement(r, { error: this.state.error }) : this.props.children;
  }
};

// node_modules/@redocly/realm/dist/client/app/hooks/useRouteChangeTracker.js
init_src();
import { useLocation as u6, useNavigate as l2, useNavigationType as d3 } from "react-router-dom";
import { useEffect as v3, useState as P5 } from "react";

// node_modules/@redocly/realm/dist/client/runtime/generated/browser-plugins.js
var onRouteChange = (context2, themeConfig) => {
  for (const hookCallback of __onRouteChangeHooks) {
    typeof hookCallback === "function" && hookCallback(context2, themeConfig);
  }
};

// node_modules/@redocly/realm/dist/client/app/utils/resolveRouteBySlug.js
async function p7(r7, t5) {
  const e7 = await fetch(P2(t.RESOLVE_ROUTE_BY_SLUG), { method: "POST", body: JSON.stringify(r7) }), { route: o4 } = await e7.json();
  let i4 = t5;
  return (t5 === "markdown" || t5 === n) && (i4 = o4.fsPath), { file: i4.replace(/^\//g, ""), url: r7, pointer: o4.pointer, position: o4.position };
}

// node_modules/@redocly/realm/dist/client/app/hooks/useRouteChangeTracker.js
var W = () => {
  const e7 = u6(), n9 = l2(), a4 = d3(), r7 = s3(), [o4, i4] = P5(), m2 = useThemeConfig(), { sendMessage: h4 } = r4();
  v3(() => {
    w2().then(() => {
      if (e7.pathname !== o4?.pathname || e7.search !== o4.search) {
        onRouteChange({ location: e7, prevLocation: o4 }, m2);
        const t5 = `${window.origin}${e7.pathname + e7.search + e7.hash}`, s10 = o4 ? `${window.origin}${o4.pathname + o4.search + o4.hash}` : void 0;
        q2.send("page.viewed", { uri: t5, referrer: s10 || document.referrer || void 0 });
      }
    });
    const c5 = !!o4;
    i4(e7);
    const { pathname: p9, hash: g6, state: f7 } = e7;
    if (e7?.pathname.endsWith("/") && e7?.pathname !== "/") {
      const t5 = n2(e7.pathname);
      n9({ pathname: t5, search: e7.search, hash: e7.hash }, { replace: true });
    }
    c5 && p7(p9 + g6, r7?.templateId).then((t5) => {
      const s10 = a4 === "POP" ? "browser" : f7?.origin;
      s10 && h4({ type: "route-updated", origin: s10, ...t5 });
    }).catch((t5) => console.log("Resolve route by slug failed with error: ", t5.message));
  }, [e7, a4]);
};

// node_modules/@redocly/realm/dist/client/runtime/generated/routes.js
var clientRoutes = [
  "/apis-combined",
  "/openapi"
];

// node_modules/@redocly/realm/dist/client/app/PageCounter/index.js
init_styled_components_esm();
import t4 from "react";
var l3 = "pages-updated";
function f5() {
  const [a4, o4] = t4.useState(0);
  return c3(l3, (i4) => o4(i4.pages)), a4 ? t4.createElement(c4, null, t4.createElement(p8, {
    title: "Total number of pages in documentation"
  }, t4.createElement(n8, null, "pages"), t4.createElement(g5, null, a4), t4.createElement(r6, null, "pages"))) : null;
}
var r6 = styled_components_esm_default.span.withConfig({
  displayName: "PageCounter__r",
  componentId: "sc-225gxo-0"
})(["font-weight:var(--font-weight-regular);font-size:var(--font-size-sm);opacity:0;transition:opacity 0.2s ease-in-out;margin-left:var(--spacing-xxs);"]);
var g5 = styled_components_esm_default.span.withConfig({
  displayName: "PageCounter__g",
  componentId: "sc-225gxo-1"
})(["font-weight:var(--font-weight-bold);font-size:var(--font-size-lg);margin-left:var(--spacing-base);"]);
var n8 = styled_components_esm_default.span.withConfig({
  displayName: "PageCounter__n",
  componentId: "sc-225gxo-2"
})(["font-size:0.7em;writing-mode:vertical-rl;text-orientation:mixed;transform:rotate(180deg);text-transform:uppercase;letter-spacing:0.5px;opacity:0.9;margin-bottom:var(--spacing-xxs);position:absolute;left:var(--spacing-xxs);top:50%;transform:translateY(-50%) rotate(180deg);"]);
var p8 = styled_components_esm_default.div.withConfig({
  displayName: "PageCounter__p",
  componentId: "sc-225gxo-3"
})(["display:flex;align-items:center;gap:var(--spacing-xs);background:linear-gradient(to right,var(--color-sky-2),var(--color-sky-5));color:white;padding:var(--spacing-sm) var(--spacing-lg) var(--spacing-sm) var(--spacing-sm);border-radius:var(--border-radius) 0 0 var(--border-radius);font-size:var(--font-size-base);box-shadow:var(--bg-raised-shadow);min-height:48px;width:100%;min-width:120px;&:hover{background:linear-gradient(to right,var(--color-sky-4),var(--color-sky-5));}"]);
var c4 = styled_components_esm_default.div.withConfig({
  displayName: "PageCounter__c",
  componentId: "sc-225gxo-4"
})(["display:flex;flex-direction:row;align-items:center;position:fixed;top:calc(var(--navbar-height) + 70px);right:0;transform:translateX(calc(100% - 18px));transition:all 0.3s ease-in-out;z-index:var(--z-index-popover);min-width:120px;&:hover{transform:translateX(0);", "{opacity:1;}", "{opacity:0;}}"], r6, n8);

// node_modules/@redocly/realm/dist/client/App.js
globalThis.__LOADER.markdocComponents = { ...custom_components_exports, ...default_exports };
function Se() {
  const t5 = E2(), [r7, a4] = e6.useState(t5), o4 = f6(), m2 = E8();
  E(), l4(() => {
    t5 ? a4(t5) : p2(m2, o4.pathname + o4.search + o4.hash).then(() => a4(R.loadSync(o4.pathname)));
  }, [o4, m2]), D();
  const n9 = E3();
  return n9 ? (console.log(n9), e6.createElement(r, { error: { message: n9, name: "" } })) : r7 ? e6.createElement(u5, null, e6.createElement(GlobalStyle, null), e6.createElement(o.Provider, { value: t5 || r7 }, e6.createElement(z2, null, e6.createElement(V, { enabled: true }, e6.createElement(u7, null))))) : null;
}
function i3() {
  W(), p5();
  const t5 = F(), r7 = d(), { layout: a4 } = r7, o4 = { layout: a4 }, m2 = b(), n9 = t5?.props.ast && f(t5.props.ast) ? dynamic(t5.props.ast, e6, { components: { ...globalThis.__LOADER.markdocComponents, ...default_exports, ...components } }) : null, s10 = t5?.props.seo?.siteUrl, c5 = n2(t5?.slug || "");
  return l4(() => {
    document.documentElement.classList.add("ready");
  }, []), e6.createElement(e6.Suspense, null, e6.createElement(RootLayout, null, e6.createElement(PageLayout, { sidebar: m2.length > 0 && e6.createElement(Y, { layoutControls: r7 }) }, e6.createElement(d4, null, e6.createElement("title", null, t5?.props.seo?.title), s10 ? e6.createElement("link", { rel: "canonical", href: x2(s10, c5) }) : null), t5?.Template ? e6.createElement(t5.Template, { pageProps: t5?.templateId === n ? { ...t5.props, openapiOptions: o4 } : t5?.props, children: n9 }) : null), e6.createElement(N2, null), e6.createElement(f5, null), e6.createElement(x3, null)));
}
var _e = [...clientRoutes.map((t5) => ({ Component: i3, path: t5.substring(1) + "/*" })), { Component: i3, path: "*" }];

// node_modules/@redocly/realm/dist/client/server-entry.js
init_styled_components_esm();
export {
  Se as App,
  r as ErrorDetails,
  R as Loader,
  Ue as ServerStyleSheet,
  fe as StyleSheetManager,
  _e as routes
};
/*! Bundled license information:

zone.js/fesm2015/zone.js:
  (**
   * @license Angular v<unknown>
   * (c) 2010-2024 Google LLC. https://angular.io/
   * License: MIT
   *)
*/
