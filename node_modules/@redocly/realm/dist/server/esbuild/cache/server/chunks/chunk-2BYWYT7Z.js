import { createRequire as topLevelCreateRequire } from 'module';
 const require = topLevelCreateRequire(import.meta.url);
import {
  C,
  p,
  t
} from "./chunk-7WVTT2DN.js";
import {
  REDOCLY_ROUTE_RBAC,
  REDOCLY_TEAMS_RBAC
} from "./chunk-R4PATEVC.js";
import {
  __commonJS,
  __require,
  __toESM
} from "./chunk-35AYGKFE.js";

// node_modules/picomatch/lib/constants.js
var require_constants = __commonJS({
  "node_modules/picomatch/lib/constants.js"(exports, module) {
    "use strict";
    var path2 = __require("path");
    var WIN_SLASH = "\\\\/";
    var WIN_NO_SLASH = `[^${WIN_SLASH}]`;
    var DOT_LITERAL = "\\.";
    var PLUS_LITERAL = "\\+";
    var QMARK_LITERAL = "\\?";
    var SLASH_LITERAL = "\\/";
    var ONE_CHAR = "(?=.)";
    var QMARK = "[^/]";
    var END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
    var START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
    var DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
    var NO_DOT = `(?!${DOT_LITERAL})`;
    var NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
    var NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
    var NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
    var QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
    var STAR = `${QMARK}*?`;
    var POSIX_CHARS = {
      DOT_LITERAL,
      PLUS_LITERAL,
      QMARK_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      QMARK,
      END_ANCHOR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOTS,
      NO_DOT_SLASH,
      NO_DOTS_SLASH,
      QMARK_NO_DOT,
      STAR,
      START_ANCHOR
    };
    var WINDOWS_CHARS = {
      ...POSIX_CHARS,
      SLASH_LITERAL: `[${WIN_SLASH}]`,
      QMARK: WIN_NO_SLASH,
      STAR: `${WIN_NO_SLASH}*?`,
      DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
      NO_DOT: `(?!${DOT_LITERAL})`,
      NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
      NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
      START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
      END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
    };
    var POSIX_REGEX_SOURCE = {
      alnum: "a-zA-Z0-9",
      alpha: "a-zA-Z",
      ascii: "\\x00-\\x7F",
      blank: " \\t",
      cntrl: "\\x00-\\x1F\\x7F",
      digit: "0-9",
      graph: "\\x21-\\x7E",
      lower: "a-z",
      print: "\\x20-\\x7E ",
      punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
      space: " \\t\\r\\n\\v\\f",
      upper: "A-Z",
      word: "A-Za-z0-9_",
      xdigit: "A-Fa-f0-9"
    };
    module.exports = {
      MAX_LENGTH: 1024 * 64,
      POSIX_REGEX_SOURCE,
      // regular expressions
      REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
      REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
      REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
      REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
      REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
      REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
      // Replace globs with equivalent patterns to reduce parsing time.
      REPLACEMENTS: {
        "***": "*",
        "**/**": "**",
        "**/**/**": "**"
      },
      // Digits
      CHAR_0: 48,
      /* 0 */
      CHAR_9: 57,
      /* 9 */
      // Alphabet chars.
      CHAR_UPPERCASE_A: 65,
      /* A */
      CHAR_LOWERCASE_A: 97,
      /* a */
      CHAR_UPPERCASE_Z: 90,
      /* Z */
      CHAR_LOWERCASE_Z: 122,
      /* z */
      CHAR_LEFT_PARENTHESES: 40,
      /* ( */
      CHAR_RIGHT_PARENTHESES: 41,
      /* ) */
      CHAR_ASTERISK: 42,
      /* * */
      // Non-alphabetic chars.
      CHAR_AMPERSAND: 38,
      /* & */
      CHAR_AT: 64,
      /* @ */
      CHAR_BACKWARD_SLASH: 92,
      /* \ */
      CHAR_CARRIAGE_RETURN: 13,
      /* \r */
      CHAR_CIRCUMFLEX_ACCENT: 94,
      /* ^ */
      CHAR_COLON: 58,
      /* : */
      CHAR_COMMA: 44,
      /* , */
      CHAR_DOT: 46,
      /* . */
      CHAR_DOUBLE_QUOTE: 34,
      /* " */
      CHAR_EQUAL: 61,
      /* = */
      CHAR_EXCLAMATION_MARK: 33,
      /* ! */
      CHAR_FORM_FEED: 12,
      /* \f */
      CHAR_FORWARD_SLASH: 47,
      /* / */
      CHAR_GRAVE_ACCENT: 96,
      /* ` */
      CHAR_HASH: 35,
      /* # */
      CHAR_HYPHEN_MINUS: 45,
      /* - */
      CHAR_LEFT_ANGLE_BRACKET: 60,
      /* < */
      CHAR_LEFT_CURLY_BRACE: 123,
      /* { */
      CHAR_LEFT_SQUARE_BRACKET: 91,
      /* [ */
      CHAR_LINE_FEED: 10,
      /* \n */
      CHAR_NO_BREAK_SPACE: 160,
      /* \u00A0 */
      CHAR_PERCENT: 37,
      /* % */
      CHAR_PLUS: 43,
      /* + */
      CHAR_QUESTION_MARK: 63,
      /* ? */
      CHAR_RIGHT_ANGLE_BRACKET: 62,
      /* > */
      CHAR_RIGHT_CURLY_BRACE: 125,
      /* } */
      CHAR_RIGHT_SQUARE_BRACKET: 93,
      /* ] */
      CHAR_SEMICOLON: 59,
      /* ; */
      CHAR_SINGLE_QUOTE: 39,
      /* ' */
      CHAR_SPACE: 32,
      /*   */
      CHAR_TAB: 9,
      /* \t */
      CHAR_UNDERSCORE: 95,
      /* _ */
      CHAR_VERTICAL_LINE: 124,
      /* | */
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
      /* \uFEFF */
      SEP: path2.sep,
      /**
       * Create EXTGLOB_CHARS
       */
      extglobChars(chars) {
        return {
          "!": { type: "negate", open: "(?:(?!(?:", close: `))${chars.STAR})` },
          "?": { type: "qmark", open: "(?:", close: ")?" },
          "+": { type: "plus", open: "(?:", close: ")+" },
          "*": { type: "star", open: "(?:", close: ")*" },
          "@": { type: "at", open: "(?:", close: ")" }
        };
      },
      /**
       * Create GLOB_CHARS
       */
      globChars(win32) {
        return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;
      }
    };
  }
});

// node_modules/picomatch/lib/utils.js
var require_utils = __commonJS({
  "node_modules/picomatch/lib/utils.js"(exports) {
    "use strict";
    var path2 = __require("path");
    var win32 = process.platform === "win32";
    var {
      REGEX_BACKSLASH,
      REGEX_REMOVE_BACKSLASH,
      REGEX_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_GLOBAL
    } = require_constants();
    exports.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    exports.hasRegexChars = (str) => REGEX_SPECIAL_CHARS.test(str);
    exports.isRegexChar = (str) => str.length === 1 && exports.hasRegexChars(str);
    exports.escapeRegex = (str) => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
    exports.toPosixSlashes = (str) => str.replace(REGEX_BACKSLASH, "/");
    exports.removeBackslashes = (str) => {
      return str.replace(REGEX_REMOVE_BACKSLASH, (match2) => {
        return match2 === "\\" ? "" : match2;
      });
    };
    exports.supportsLookbehinds = () => {
      const segs = process.version.slice(1).split(".").map(Number);
      if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {
        return true;
      }
      return false;
    };
    exports.isWindows = (options) => {
      if (options && typeof options.windows === "boolean") {
        return options.windows;
      }
      return win32 === true || path2.sep === "\\";
    };
    exports.escapeLast = (input, char, lastIdx) => {
      const idx = input.lastIndexOf(char, lastIdx);
      if (idx === -1)
        return input;
      if (input[idx - 1] === "\\")
        return exports.escapeLast(input, char, idx - 1);
      return `${input.slice(0, idx)}\\${input.slice(idx)}`;
    };
    exports.removePrefix = (input, state = {}) => {
      let output = input;
      if (output.startsWith("./")) {
        output = output.slice(2);
        state.prefix = "./";
      }
      return output;
    };
    exports.wrapOutput = (input, state = {}, options = {}) => {
      const prepend = options.contains ? "" : "^";
      const append = options.contains ? "" : "$";
      let output = `${prepend}(?:${input})${append}`;
      if (state.negated === true) {
        output = `(?:^(?!${output}).*$)`;
      }
      return output;
    };
  }
});

// node_modules/picomatch/lib/scan.js
var require_scan = __commonJS({
  "node_modules/picomatch/lib/scan.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var {
      CHAR_ASTERISK,
      /* * */
      CHAR_AT,
      /* @ */
      CHAR_BACKWARD_SLASH,
      /* \ */
      CHAR_COMMA,
      /* , */
      CHAR_DOT,
      /* . */
      CHAR_EXCLAMATION_MARK,
      /* ! */
      CHAR_FORWARD_SLASH,
      /* / */
      CHAR_LEFT_CURLY_BRACE,
      /* { */
      CHAR_LEFT_PARENTHESES,
      /* ( */
      CHAR_LEFT_SQUARE_BRACKET,
      /* [ */
      CHAR_PLUS,
      /* + */
      CHAR_QUESTION_MARK,
      /* ? */
      CHAR_RIGHT_CURLY_BRACE,
      /* } */
      CHAR_RIGHT_PARENTHESES,
      /* ) */
      CHAR_RIGHT_SQUARE_BRACKET
      /* ] */
    } = require_constants();
    var isPathSeparator = (code) => {
      return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
    };
    var depth = (token) => {
      if (token.isPrefix !== true) {
        token.depth = token.isGlobstar ? Infinity : 1;
      }
    };
    var scan = (input, options) => {
      const opts = options || {};
      const length = input.length - 1;
      const scanToEnd = opts.parts === true || opts.scanToEnd === true;
      const slashes = [];
      const tokens = [];
      const parts = [];
      let str = input;
      let index = -1;
      let start = 0;
      let lastIndex = 0;
      let isBrace = false;
      let isBracket = false;
      let isGlob = false;
      let isExtglob = false;
      let isGlobstar = false;
      let braceEscaped = false;
      let backslashes = false;
      let negated = false;
      let negatedExtglob = false;
      let finished = false;
      let braces = 0;
      let prev;
      let code;
      let token = { value: "", depth: 0, isGlob: false };
      const eos = () => index >= length;
      const peek = () => str.charCodeAt(index + 1);
      const advance = () => {
        prev = code;
        return str.charCodeAt(++index);
      };
      while (index < length) {
        code = advance();
        let next;
        if (code === CHAR_BACKWARD_SLASH) {
          backslashes = token.backslashes = true;
          code = advance();
          if (code === CHAR_LEFT_CURLY_BRACE) {
            braceEscaped = true;
          }
          continue;
        }
        if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
          braces++;
          while (eos() !== true && (code = advance())) {
            if (code === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance();
              continue;
            }
            if (code === CHAR_LEFT_CURLY_BRACE) {
              braces++;
              continue;
            }
            if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (braceEscaped !== true && code === CHAR_COMMA) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (code === CHAR_RIGHT_CURLY_BRACE) {
              braces--;
              if (braces === 0) {
                braceEscaped = false;
                isBrace = token.isBrace = true;
                finished = true;
                break;
              }
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_FORWARD_SLASH) {
          slashes.push(index);
          tokens.push(token);
          token = { value: "", depth: 0, isGlob: false };
          if (finished === true)
            continue;
          if (prev === CHAR_DOT && index === start + 1) {
            start += 2;
            continue;
          }
          lastIndex = index + 1;
          continue;
        }
        if (opts.noext !== true) {
          const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;
          if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
            isGlob = token.isGlob = true;
            isExtglob = token.isExtglob = true;
            finished = true;
            if (code === CHAR_EXCLAMATION_MARK && index === start) {
              negatedExtglob = true;
            }
            if (scanToEnd === true) {
              while (eos() !== true && (code = advance())) {
                if (code === CHAR_BACKWARD_SLASH) {
                  backslashes = token.backslashes = true;
                  code = advance();
                  continue;
                }
                if (code === CHAR_RIGHT_PARENTHESES) {
                  isGlob = token.isGlob = true;
                  finished = true;
                  break;
                }
              }
              continue;
            }
            break;
          }
        }
        if (code === CHAR_ASTERISK) {
          if (prev === CHAR_ASTERISK)
            isGlobstar = token.isGlobstar = true;
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_QUESTION_MARK) {
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_LEFT_SQUARE_BRACKET) {
          while (eos() !== true && (next = advance())) {
            if (next === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET) {
              isBracket = token.isBracket = true;
              isGlob = token.isGlob = true;
              finished = true;
              break;
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {
          negated = token.negated = true;
          start++;
          continue;
        }
        if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
          isGlob = token.isGlob = true;
          if (scanToEnd === true) {
            while (eos() !== true && (code = advance())) {
              if (code === CHAR_LEFT_PARENTHESES) {
                backslashes = token.backslashes = true;
                code = advance();
                continue;
              }
              if (code === CHAR_RIGHT_PARENTHESES) {
                finished = true;
                break;
              }
            }
            continue;
          }
          break;
        }
        if (isGlob === true) {
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
      }
      if (opts.noext === true) {
        isExtglob = false;
        isGlob = false;
      }
      let base = str;
      let prefix = "";
      let glob = "";
      if (start > 0) {
        prefix = str.slice(0, start);
        str = str.slice(start);
        lastIndex -= start;
      }
      if (base && isGlob === true && lastIndex > 0) {
        base = str.slice(0, lastIndex);
        glob = str.slice(lastIndex);
      } else if (isGlob === true) {
        base = "";
        glob = str;
      } else {
        base = str;
      }
      if (base && base !== "" && base !== "/" && base !== str) {
        if (isPathSeparator(base.charCodeAt(base.length - 1))) {
          base = base.slice(0, -1);
        }
      }
      if (opts.unescape === true) {
        if (glob)
          glob = utils.removeBackslashes(glob);
        if (base && backslashes === true) {
          base = utils.removeBackslashes(base);
        }
      }
      const state = {
        prefix,
        input,
        start,
        base,
        glob,
        isBrace,
        isBracket,
        isGlob,
        isExtglob,
        isGlobstar,
        negated,
        negatedExtglob
      };
      if (opts.tokens === true) {
        state.maxDepth = 0;
        if (!isPathSeparator(code)) {
          tokens.push(token);
        }
        state.tokens = tokens;
      }
      if (opts.parts === true || opts.tokens === true) {
        let prevIndex;
        for (let idx = 0; idx < slashes.length; idx++) {
          const n3 = prevIndex ? prevIndex + 1 : start;
          const i4 = slashes[idx];
          const value = input.slice(n3, i4);
          if (opts.tokens) {
            if (idx === 0 && start !== 0) {
              tokens[idx].isPrefix = true;
              tokens[idx].value = prefix;
            } else {
              tokens[idx].value = value;
            }
            depth(tokens[idx]);
            state.maxDepth += tokens[idx].depth;
          }
          if (idx !== 0 || value !== "") {
            parts.push(value);
          }
          prevIndex = i4;
        }
        if (prevIndex && prevIndex + 1 < input.length) {
          const value = input.slice(prevIndex + 1);
          parts.push(value);
          if (opts.tokens) {
            tokens[tokens.length - 1].value = value;
            depth(tokens[tokens.length - 1]);
            state.maxDepth += tokens[tokens.length - 1].depth;
          }
        }
        state.slashes = slashes;
        state.parts = parts;
      }
      return state;
    };
    module.exports = scan;
  }
});

// node_modules/picomatch/lib/parse.js
var require_parse = __commonJS({
  "node_modules/picomatch/lib/parse.js"(exports, module) {
    "use strict";
    var constants = require_constants();
    var utils = require_utils();
    var {
      MAX_LENGTH,
      POSIX_REGEX_SOURCE,
      REGEX_NON_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_BACKREF,
      REPLACEMENTS
    } = constants;
    var expandRange = (args, options) => {
      if (typeof options.expandRange === "function") {
        return options.expandRange(...args, options);
      }
      args.sort();
      const value = `[${args.join("-")}]`;
      try {
        new RegExp(value);
      } catch (ex) {
        return args.map((v) => utils.escapeRegex(v)).join("..");
      }
      return value;
    };
    var syntaxError = (type, char) => {
      return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
    };
    var parse = (input, options) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      input = REPLACEMENTS[input] || input;
      const opts = { ...options };
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      let len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      const bos = { type: "bos", value: "", output: opts.prepend || "" };
      const tokens = [bos];
      const capture = opts.capture ? "" : "?:";
      const win32 = utils.isWindows(options);
      const PLATFORM_CHARS = constants.globChars(win32);
      const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);
      const {
        DOT_LITERAL,
        PLUS_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOT_SLASH,
        NO_DOTS_SLASH,
        QMARK,
        QMARK_NO_DOT,
        STAR,
        START_ANCHOR
      } = PLATFORM_CHARS;
      const globstar = (opts2) => {
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const nodot = opts.dot ? "" : NO_DOT;
      const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
      let star2 = opts.bash === true ? globstar(opts) : STAR;
      if (opts.capture) {
        star2 = `(${star2})`;
      }
      if (typeof opts.noext === "boolean") {
        opts.noextglob = opts.noext;
      }
      const state = {
        input,
        index: -1,
        start: 0,
        dot: opts.dot === true,
        consumed: "",
        output: "",
        prefix: "",
        backtrack: false,
        negated: false,
        brackets: 0,
        braces: 0,
        parens: 0,
        quotes: 0,
        globstar: false,
        tokens
      };
      input = utils.removePrefix(input, state);
      len = input.length;
      const extglobs = [];
      const braces = [];
      const stack = [];
      let prev = bos;
      let value;
      const eos = () => state.index === len - 1;
      const peek = state.peek = (n3 = 1) => input[state.index + n3];
      const advance = state.advance = () => input[++state.index] || "";
      const remaining = () => input.slice(state.index + 1);
      const consume = (value2 = "", num = 0) => {
        state.consumed += value2;
        state.index += num;
      };
      const append = (token) => {
        state.output += token.output != null ? token.output : token.value;
        consume(token.value);
      };
      const negate = () => {
        let count = 1;
        while (peek() === "!" && (peek(2) !== "(" || peek(3) === "?")) {
          advance();
          state.start++;
          count++;
        }
        if (count % 2 === 0) {
          return false;
        }
        state.negated = true;
        state.start++;
        return true;
      };
      const increment = (type) => {
        state[type]++;
        stack.push(type);
      };
      const decrement = (type) => {
        state[type]--;
        stack.pop();
      };
      const push = (tok) => {
        if (prev.type === "globstar") {
          const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace");
          const isExtglob = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
          if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob) {
            state.output = state.output.slice(0, -prev.output.length);
            prev.type = "star";
            prev.value = "*";
            prev.output = star2;
            state.output += prev.output;
          }
        }
        if (extglobs.length && tok.type !== "paren") {
          extglobs[extglobs.length - 1].inner += tok.value;
        }
        if (tok.value || tok.output)
          append(tok);
        if (prev && prev.type === "text" && tok.type === "text") {
          prev.value += tok.value;
          prev.output = (prev.output || "") + tok.value;
          return;
        }
        tok.prev = prev;
        tokens.push(tok);
        prev = tok;
      };
      const extglobOpen = (type, value2) => {
        const token = { ...EXTGLOB_CHARS[value2], conditions: 1, inner: "" };
        token.prev = prev;
        token.parens = state.parens;
        token.output = state.output;
        const output = (opts.capture ? "(" : "") + token.open;
        increment("parens");
        push({ type, value: value2, output: state.output ? "" : ONE_CHAR });
        push({ type: "paren", extglob: true, value: advance(), output });
        extglobs.push(token);
      };
      const extglobClose = (token) => {
        let output = token.close + (opts.capture ? ")" : "");
        let rest;
        if (token.type === "negate") {
          let extglobStar = star2;
          if (token.inner && token.inner.length > 1 && token.inner.includes("/")) {
            extglobStar = globstar(opts);
          }
          if (extglobStar !== star2 || eos() || /^\)+$/.test(remaining())) {
            output = token.close = `)$))${extglobStar}`;
          }
          if (token.inner.includes("*") && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
            const expression = parse(rest, { ...options, fastpaths: false }).output;
            output = token.close = `)${expression})${extglobStar})`;
          }
          if (token.prev.type === "bos") {
            state.negatedExtglob = true;
          }
        }
        push({ type: "paren", extglob: true, value, output });
        decrement("parens");
      };
      if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
        let backslashes = false;
        let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m2, esc, chars, first, rest, index) => {
          if (first === "\\") {
            backslashes = true;
            return m2;
          }
          if (first === "?") {
            if (esc) {
              return esc + first + (rest ? QMARK.repeat(rest.length) : "");
            }
            if (index === 0) {
              return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : "");
            }
            return QMARK.repeat(chars.length);
          }
          if (first === ".") {
            return DOT_LITERAL.repeat(chars.length);
          }
          if (first === "*") {
            if (esc) {
              return esc + first + (rest ? star2 : "");
            }
            return star2;
          }
          return esc ? m2 : `\\${m2}`;
        });
        if (backslashes === true) {
          if (opts.unescape === true) {
            output = output.replace(/\\/g, "");
          } else {
            output = output.replace(/\\+/g, (m2) => {
              return m2.length % 2 === 0 ? "\\\\" : m2 ? "\\" : "";
            });
          }
        }
        if (output === input && opts.contains === true) {
          state.output = input;
          return state;
        }
        state.output = utils.wrapOutput(output, state, options);
        return state;
      }
      while (!eos()) {
        value = advance();
        if (value === "\0") {
          continue;
        }
        if (value === "\\") {
          const next = peek();
          if (next === "/" && opts.bash !== true) {
            continue;
          }
          if (next === "." || next === ";") {
            continue;
          }
          if (!next) {
            value += "\\";
            push({ type: "text", value });
            continue;
          }
          const match2 = /^\\+/.exec(remaining());
          let slashes = 0;
          if (match2 && match2[0].length > 2) {
            slashes = match2[0].length;
            state.index += slashes;
            if (slashes % 2 !== 0) {
              value += "\\";
            }
          }
          if (opts.unescape === true) {
            value = advance();
          } else {
            value += advance();
          }
          if (state.brackets === 0) {
            push({ type: "text", value });
            continue;
          }
        }
        if (state.brackets > 0 && (value !== "]" || prev.value === "[" || prev.value === "[^")) {
          if (opts.posix !== false && value === ":") {
            const inner = prev.value.slice(1);
            if (inner.includes("[")) {
              prev.posix = true;
              if (inner.includes(":")) {
                const idx = prev.value.lastIndexOf("[");
                const pre = prev.value.slice(0, idx);
                const rest2 = prev.value.slice(idx + 2);
                const posix = POSIX_REGEX_SOURCE[rest2];
                if (posix) {
                  prev.value = pre + posix;
                  state.backtrack = true;
                  advance();
                  if (!bos.output && tokens.indexOf(prev) === 1) {
                    bos.output = ONE_CHAR;
                  }
                  continue;
                }
              }
            }
          }
          if (value === "[" && peek() !== ":" || value === "-" && peek() === "]") {
            value = `\\${value}`;
          }
          if (value === "]" && (prev.value === "[" || prev.value === "[^")) {
            value = `\\${value}`;
          }
          if (opts.posix === true && value === "!" && prev.value === "[") {
            value = "^";
          }
          prev.value += value;
          append({ value });
          continue;
        }
        if (state.quotes === 1 && value !== '"') {
          value = utils.escapeRegex(value);
          prev.value += value;
          append({ value });
          continue;
        }
        if (value === '"') {
          state.quotes = state.quotes === 1 ? 0 : 1;
          if (opts.keepQuotes === true) {
            push({ type: "text", value });
          }
          continue;
        }
        if (value === "(") {
          increment("parens");
          push({ type: "paren", value });
          continue;
        }
        if (value === ")") {
          if (state.parens === 0 && opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError("opening", "("));
          }
          const extglob = extglobs[extglobs.length - 1];
          if (extglob && state.parens === extglob.parens + 1) {
            extglobClose(extglobs.pop());
            continue;
          }
          push({ type: "paren", value, output: state.parens ? ")" : "\\)" });
          decrement("parens");
          continue;
        }
        if (value === "[") {
          if (opts.nobracket === true || !remaining().includes("]")) {
            if (opts.nobracket !== true && opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("closing", "]"));
            }
            value = `\\${value}`;
          } else {
            increment("brackets");
          }
          push({ type: "bracket", value });
          continue;
        }
        if (value === "]") {
          if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
            push({ type: "text", value, output: `\\${value}` });
            continue;
          }
          if (state.brackets === 0) {
            if (opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("opening", "["));
            }
            push({ type: "text", value, output: `\\${value}` });
            continue;
          }
          decrement("brackets");
          const prevValue = prev.value.slice(1);
          if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) {
            value = `/${value}`;
          }
          prev.value += value;
          append({ value });
          if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
            continue;
          }
          const escaped = utils.escapeRegex(prev.value);
          state.output = state.output.slice(0, -prev.value.length);
          if (opts.literalBrackets === true) {
            state.output += escaped;
            prev.value = escaped;
            continue;
          }
          prev.value = `(${capture}${escaped}|${prev.value})`;
          state.output += prev.value;
          continue;
        }
        if (value === "{" && opts.nobrace !== true) {
          increment("braces");
          const open = {
            type: "brace",
            value,
            output: "(",
            outputIndex: state.output.length,
            tokensIndex: state.tokens.length
          };
          braces.push(open);
          push(open);
          continue;
        }
        if (value === "}") {
          const brace = braces[braces.length - 1];
          if (opts.nobrace === true || !brace) {
            push({ type: "text", value, output: value });
            continue;
          }
          let output = ")";
          if (brace.dots === true) {
            const arr = tokens.slice();
            const range = [];
            for (let i4 = arr.length - 1; i4 >= 0; i4--) {
              tokens.pop();
              if (arr[i4].type === "brace") {
                break;
              }
              if (arr[i4].type !== "dots") {
                range.unshift(arr[i4].value);
              }
            }
            output = expandRange(range, opts);
            state.backtrack = true;
          }
          if (brace.comma !== true && brace.dots !== true) {
            const out = state.output.slice(0, brace.outputIndex);
            const toks = state.tokens.slice(brace.tokensIndex);
            brace.value = brace.output = "\\{";
            value = output = "\\}";
            state.output = out;
            for (const t4 of toks) {
              state.output += t4.output || t4.value;
            }
          }
          push({ type: "brace", value, output });
          decrement("braces");
          braces.pop();
          continue;
        }
        if (value === "|") {
          if (extglobs.length > 0) {
            extglobs[extglobs.length - 1].conditions++;
          }
          push({ type: "text", value });
          continue;
        }
        if (value === ",") {
          let output = value;
          const brace = braces[braces.length - 1];
          if (brace && stack[stack.length - 1] === "braces") {
            brace.comma = true;
            output = "|";
          }
          push({ type: "comma", value, output });
          continue;
        }
        if (value === "/") {
          if (prev.type === "dot" && state.index === state.start + 1) {
            state.start = state.index + 1;
            state.consumed = "";
            state.output = "";
            tokens.pop();
            prev = bos;
            continue;
          }
          push({ type: "slash", value, output: SLASH_LITERAL });
          continue;
        }
        if (value === ".") {
          if (state.braces > 0 && prev.type === "dot") {
            if (prev.value === ".")
              prev.output = DOT_LITERAL;
            const brace = braces[braces.length - 1];
            prev.type = "dots";
            prev.output += value;
            prev.value += value;
            brace.dots = true;
            continue;
          }
          if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
            push({ type: "text", value, output: DOT_LITERAL });
            continue;
          }
          push({ type: "dot", value, output: DOT_LITERAL });
          continue;
        }
        if (value === "?") {
          const isGroup = prev && prev.value === "(";
          if (!isGroup && opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("qmark", value);
            continue;
          }
          if (prev && prev.type === "paren") {
            const next = peek();
            let output = value;
            if (next === "<" && !utils.supportsLookbehinds()) {
              throw new Error("Node.js v10 or higher is required for regex lookbehinds");
            }
            if (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) {
              output = `\\${value}`;
            }
            push({ type: "text", value, output });
            continue;
          }
          if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
            push({ type: "qmark", value, output: QMARK_NO_DOT });
            continue;
          }
          push({ type: "qmark", value, output: QMARK });
          continue;
        }
        if (value === "!") {
          if (opts.noextglob !== true && peek() === "(") {
            if (peek(2) !== "?" || !/[!=<:]/.test(peek(3))) {
              extglobOpen("negate", value);
              continue;
            }
          }
          if (opts.nonegate !== true && state.index === 0) {
            negate();
            continue;
          }
        }
        if (value === "+") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("plus", value);
            continue;
          }
          if (prev && prev.value === "(" || opts.regex === false) {
            push({ type: "plus", value, output: PLUS_LITERAL });
            continue;
          }
          if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
            push({ type: "plus", value });
            continue;
          }
          push({ type: "plus", value: PLUS_LITERAL });
          continue;
        }
        if (value === "@") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            push({ type: "at", extglob: true, value, output: "" });
            continue;
          }
          push({ type: "text", value });
          continue;
        }
        if (value !== "*") {
          if (value === "$" || value === "^") {
            value = `\\${value}`;
          }
          const match2 = REGEX_NON_SPECIAL_CHARS.exec(remaining());
          if (match2) {
            value += match2[0];
            state.index += match2[0].length;
          }
          push({ type: "text", value });
          continue;
        }
        if (prev && (prev.type === "globstar" || prev.star === true)) {
          prev.type = "star";
          prev.star = true;
          prev.value += value;
          prev.output = star2;
          state.backtrack = true;
          state.globstar = true;
          consume(value);
          continue;
        }
        let rest = remaining();
        if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
          extglobOpen("star", value);
          continue;
        }
        if (prev.type === "star") {
          if (opts.noglobstar === true) {
            consume(value);
            continue;
          }
          const prior = prev.prev;
          const before = prior.prev;
          const isStart = prior.type === "slash" || prior.type === "bos";
          const afterStar = before && (before.type === "star" || before.type === "globstar");
          if (opts.bash === true && (!isStart || rest[0] && rest[0] !== "/")) {
            push({ type: "star", value, output: "" });
            continue;
          }
          const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace");
          const isExtglob = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
          if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob) {
            push({ type: "star", value, output: "" });
            continue;
          }
          while (rest.slice(0, 3) === "/**") {
            const after = input[state.index + 4];
            if (after && after !== "/") {
              break;
            }
            rest = rest.slice(3);
            consume("/**", 3);
          }
          if (prior.type === "bos" && eos()) {
            prev.type = "globstar";
            prev.value += value;
            prev.output = globstar(opts);
            state.output = prev.output;
            state.globstar = true;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
            prev.value += value;
            state.globstar = true;
            state.output += prior.output + prev.output;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
            const end = rest[1] !== void 0 ? "|$" : "";
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
            prev.value += value;
            state.output += prior.output + prev.output;
            state.globstar = true;
            consume(value + advance());
            push({ type: "slash", value: "/", output: "" });
            continue;
          }
          if (prior.type === "bos" && rest[0] === "/") {
            prev.type = "globstar";
            prev.value += value;
            prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
            state.output = prev.output;
            state.globstar = true;
            consume(value + advance());
            push({ type: "slash", value: "/", output: "" });
            continue;
          }
          state.output = state.output.slice(0, -prev.output.length);
          prev.type = "globstar";
          prev.output = globstar(opts);
          prev.value += value;
          state.output += prev.output;
          state.globstar = true;
          consume(value);
          continue;
        }
        const token = { type: "star", value, output: star2 };
        if (opts.bash === true) {
          token.output = ".*?";
          if (prev.type === "bos" || prev.type === "slash") {
            token.output = nodot + token.output;
          }
          push(token);
          continue;
        }
        if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
          token.output = value;
          push(token);
          continue;
        }
        if (state.index === state.start || prev.type === "slash" || prev.type === "dot") {
          if (prev.type === "dot") {
            state.output += NO_DOT_SLASH;
            prev.output += NO_DOT_SLASH;
          } else if (opts.dot === true) {
            state.output += NO_DOTS_SLASH;
            prev.output += NO_DOTS_SLASH;
          } else {
            state.output += nodot;
            prev.output += nodot;
          }
          if (peek() !== "*") {
            state.output += ONE_CHAR;
            prev.output += ONE_CHAR;
          }
        }
        push(token);
      }
      while (state.brackets > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", "]"));
        state.output = utils.escapeLast(state.output, "[");
        decrement("brackets");
      }
      while (state.parens > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", ")"));
        state.output = utils.escapeLast(state.output, "(");
        decrement("parens");
      }
      while (state.braces > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", "}"));
        state.output = utils.escapeLast(state.output, "{");
        decrement("braces");
      }
      if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) {
        push({ type: "maybe_slash", value: "", output: `${SLASH_LITERAL}?` });
      }
      if (state.backtrack === true) {
        state.output = "";
        for (const token of state.tokens) {
          state.output += token.output != null ? token.output : token.value;
          if (token.suffix) {
            state.output += token.suffix;
          }
        }
      }
      return state;
    };
    parse.fastpaths = (input, options) => {
      const opts = { ...options };
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      const len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      input = REPLACEMENTS[input] || input;
      const win32 = utils.isWindows(options);
      const {
        DOT_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOTS,
        NO_DOTS_SLASH,
        STAR,
        START_ANCHOR
      } = constants.globChars(win32);
      const nodot = opts.dot ? NO_DOTS : NO_DOT;
      const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
      const capture = opts.capture ? "" : "?:";
      const state = { negated: false, prefix: "" };
      let star2 = opts.bash === true ? ".*?" : STAR;
      if (opts.capture) {
        star2 = `(${star2})`;
      }
      const globstar = (opts2) => {
        if (opts2.noglobstar === true)
          return star2;
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const create = (str) => {
        switch (str) {
          case "*":
            return `${nodot}${ONE_CHAR}${star2}`;
          case ".*":
            return `${DOT_LITERAL}${ONE_CHAR}${star2}`;
          case "*.*":
            return `${nodot}${star2}${DOT_LITERAL}${ONE_CHAR}${star2}`;
          case "*/*":
            return `${nodot}${star2}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star2}`;
          case "**":
            return nodot + globstar(opts);
          case "**/*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star2}`;
          case "**/*.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star2}${DOT_LITERAL}${ONE_CHAR}${star2}`;
          case "**/.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star2}`;
          default: {
            const match2 = /^(.*?)\.(\w+)$/.exec(str);
            if (!match2)
              return;
            const source2 = create(match2[1]);
            if (!source2)
              return;
            return source2 + DOT_LITERAL + match2[2];
          }
        }
      };
      const output = utils.removePrefix(input, state);
      let source = create(output);
      if (source && opts.strictSlashes !== true) {
        source += `${SLASH_LITERAL}?`;
      }
      return source;
    };
    module.exports = parse;
  }
});

// node_modules/picomatch/lib/picomatch.js
var require_picomatch = __commonJS({
  "node_modules/picomatch/lib/picomatch.js"(exports, module) {
    "use strict";
    var path2 = __require("path");
    var scan = require_scan();
    var parse = require_parse();
    var utils = require_utils();
    var constants = require_constants();
    var isObject = (val) => val && typeof val === "object" && !Array.isArray(val);
    var picomatch = (glob, options, returnState = false) => {
      if (Array.isArray(glob)) {
        const fns = glob.map((input) => picomatch(input, options, returnState));
        const arrayMatcher = (str) => {
          for (const isMatch of fns) {
            const state2 = isMatch(str);
            if (state2)
              return state2;
          }
          return false;
        };
        return arrayMatcher;
      }
      const isState = isObject(glob) && glob.tokens && glob.input;
      if (glob === "" || typeof glob !== "string" && !isState) {
        throw new TypeError("Expected pattern to be a non-empty string");
      }
      const opts = options || {};
      const posix = utils.isWindows(options);
      const regex = isState ? picomatch.compileRe(glob, options) : picomatch.makeRe(glob, options, false, true);
      const state = regex.state;
      delete regex.state;
      let isIgnored = () => false;
      if (opts.ignore) {
        const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };
        isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
      }
      const matcher = (input, returnObject = false) => {
        const { isMatch, match: match2, output } = picomatch.test(input, regex, options, { glob, posix });
        const result = { glob, state, regex, posix, input, output, match: match2, isMatch };
        if (typeof opts.onResult === "function") {
          opts.onResult(result);
        }
        if (isMatch === false) {
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (isIgnored(input)) {
          if (typeof opts.onIgnore === "function") {
            opts.onIgnore(result);
          }
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (typeof opts.onMatch === "function") {
          opts.onMatch(result);
        }
        return returnObject ? result : true;
      };
      if (returnState) {
        matcher.state = state;
      }
      return matcher;
    };
    picomatch.test = (input, regex, options, { glob, posix } = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected input to be a string");
      }
      if (input === "") {
        return { isMatch: false, output: "" };
      }
      const opts = options || {};
      const format = opts.format || (posix ? utils.toPosixSlashes : null);
      let match2 = input === glob;
      let output = match2 && format ? format(input) : input;
      if (match2 === false) {
        output = format ? format(input) : input;
        match2 = output === glob;
      }
      if (match2 === false || opts.capture === true) {
        if (opts.matchBase === true || opts.basename === true) {
          match2 = picomatch.matchBase(input, regex, options, posix);
        } else {
          match2 = regex.exec(output);
        }
      }
      return { isMatch: Boolean(match2), match: match2, output };
    };
    picomatch.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {
      const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);
      return regex.test(path2.basename(input));
    };
    picomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
    picomatch.parse = (pattern, options) => {
      if (Array.isArray(pattern))
        return pattern.map((p8) => picomatch.parse(p8, options));
      return parse(pattern, { ...options, fastpaths: false });
    };
    picomatch.scan = (input, options) => scan(input, options);
    picomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {
      if (returnOutput === true) {
        return state.output;
      }
      const opts = options || {};
      const prepend = opts.contains ? "" : "^";
      const append = opts.contains ? "" : "$";
      let source = `${prepend}(?:${state.output})${append}`;
      if (state && state.negated === true) {
        source = `^(?!${source}).*$`;
      }
      const regex = picomatch.toRegex(source, options);
      if (returnState === true) {
        regex.state = state;
      }
      return regex;
    };
    picomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {
      if (!input || typeof input !== "string") {
        throw new TypeError("Expected a non-empty string");
      }
      let parsed = { negated: false, fastpaths: true };
      if (options.fastpaths !== false && (input[0] === "." || input[0] === "*")) {
        parsed.output = parse.fastpaths(input, options);
      }
      if (!parsed.output) {
        parsed = parse(input, options);
      }
      return picomatch.compileRe(parsed, options, returnOutput, returnState);
    };
    picomatch.toRegex = (source, options) => {
      try {
        const opts = options || {};
        return new RegExp(source, opts.flags || (opts.nocase ? "i" : ""));
      } catch (err) {
        if (options && options.debug === true)
          throw err;
        return /$^/;
      }
    };
    picomatch.constants = constants;
    module.exports = picomatch;
  }
});

// node_modules/picomatch/index.js
var require_picomatch2 = __commonJS({
  "node_modules/picomatch/index.js"(exports, module) {
    "use strict";
    module.exports = require_picomatch();
  }
});

// node_modules/@xmldom/xmldom/lib/conventions.js
var require_conventions = __commonJS({
  "node_modules/@xmldom/xmldom/lib/conventions.js"(exports) {
    "use strict";
    function find(list, predicate, ac) {
      if (ac === void 0) {
        ac = Array.prototype;
      }
      if (list && typeof ac.find === "function") {
        return ac.find.call(list, predicate);
      }
      for (var i4 = 0; i4 < list.length; i4++) {
        if (Object.prototype.hasOwnProperty.call(list, i4)) {
          var item = list[i4];
          if (predicate.call(void 0, item, i4, list)) {
            return item;
          }
        }
      }
    }
    function freeze(object, oc) {
      if (oc === void 0) {
        oc = Object;
      }
      return oc && typeof oc.freeze === "function" ? oc.freeze(object) : object;
    }
    function assign(target, source) {
      if (target === null || typeof target !== "object") {
        throw new TypeError("target is not an object");
      }
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
      return target;
    }
    var MIME_TYPE = freeze({
      /**
       * `text/html`, the only mime type that triggers treating an XML document as HTML.
       *
       * @see DOMParser.SupportedType.isHTML
       * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
       * @see https://en.wikipedia.org/wiki/HTML Wikipedia
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
       * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring WHATWG HTML Spec
       */
      HTML: "text/html",
      /**
       * Helper method to check a mime type if it indicates an HTML document
       *
       * @param {string} [value]
       * @returns {boolean}
       *
       * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
       * @see https://en.wikipedia.org/wiki/HTML Wikipedia
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
       * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring 	 */
      isHTML: function(value) {
        return value === MIME_TYPE.HTML;
      },
      /**
       * `application/xml`, the standard mime type for XML documents.
       *
       * @see https://www.iana.org/assignments/media-types/application/xml IANA MimeType registration
       * @see https://tools.ietf.org/html/rfc7303#section-9.1 RFC 7303
       * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
       */
      XML_APPLICATION: "application/xml",
      /**
       * `text/html`, an alias for `application/xml`.
       *
       * @see https://tools.ietf.org/html/rfc7303#section-9.2 RFC 7303
       * @see https://www.iana.org/assignments/media-types/text/xml IANA MimeType registration
       * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
       */
      XML_TEXT: "text/xml",
      /**
       * `application/xhtml+xml`, indicates an XML document that has the default HTML namespace,
       * but is parsed as an XML document.
       *
       * @see https://www.iana.org/assignments/media-types/application/xhtml+xml IANA MimeType registration
       * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument WHATWG DOM Spec
       * @see https://en.wikipedia.org/wiki/XHTML Wikipedia
       */
      XML_XHTML_APPLICATION: "application/xhtml+xml",
      /**
       * `image/svg+xml`,
       *
       * @see https://www.iana.org/assignments/media-types/image/svg+xml IANA MimeType registration
       * @see https://www.w3.org/TR/SVG11/ W3C SVG 1.1
       * @see https://en.wikipedia.org/wiki/Scalable_Vector_Graphics Wikipedia
       */
      XML_SVG_IMAGE: "image/svg+xml"
    });
    var NAMESPACE = freeze({
      /**
       * The XHTML namespace.
       *
       * @see http://www.w3.org/1999/xhtml
       */
      HTML: "http://www.w3.org/1999/xhtml",
      /**
       * Checks if `uri` equals `NAMESPACE.HTML`.
       *
       * @param {string} [uri]
       *
       * @see NAMESPACE.HTML
       */
      isHTML: function(uri) {
        return uri === NAMESPACE.HTML;
      },
      /**
       * The SVG namespace.
       *
       * @see http://www.w3.org/2000/svg
       */
      SVG: "http://www.w3.org/2000/svg",
      /**
       * The `xml:` namespace.
       *
       * @see http://www.w3.org/XML/1998/namespace
       */
      XML: "http://www.w3.org/XML/1998/namespace",
      /**
       * The `xmlns:` namespace
       *
       * @see https://www.w3.org/2000/xmlns/
       */
      XMLNS: "http://www.w3.org/2000/xmlns/"
    });
    exports.assign = assign;
    exports.find = find;
    exports.freeze = freeze;
    exports.MIME_TYPE = MIME_TYPE;
    exports.NAMESPACE = NAMESPACE;
  }
});

// node_modules/@xmldom/xmldom/lib/dom.js
var require_dom = __commonJS({
  "node_modules/@xmldom/xmldom/lib/dom.js"(exports) {
    var conventions = require_conventions();
    var find = conventions.find;
    var NAMESPACE = conventions.NAMESPACE;
    function notEmptyString(input) {
      return input !== "";
    }
    function splitOnASCIIWhitespace(input) {
      return input ? input.split(/[\t\n\f\r ]+/).filter(notEmptyString) : [];
    }
    function orderedSetReducer(current, element) {
      if (!current.hasOwnProperty(element)) {
        current[element] = true;
      }
      return current;
    }
    function toOrderedSet(input) {
      if (!input)
        return [];
      var list = splitOnASCIIWhitespace(input);
      return Object.keys(list.reduce(orderedSetReducer, {}));
    }
    function arrayIncludes(list) {
      return function(element) {
        return list && list.indexOf(element) !== -1;
      };
    }
    function copy(src, dest) {
      for (var p8 in src) {
        if (Object.prototype.hasOwnProperty.call(src, p8)) {
          dest[p8] = src[p8];
        }
      }
    }
    function _extends(Class, Super) {
      var pt = Class.prototype;
      if (!(pt instanceof Super)) {
        let t5 = function() {
        };
        var t4 = t5;
        ;
        t5.prototype = Super.prototype;
        t5 = new t5();
        copy(pt, t5);
        Class.prototype = pt = t5;
      }
      if (pt.constructor != Class) {
        if (typeof Class != "function") {
          console.error("unknown Class:" + Class);
        }
        pt.constructor = Class;
      }
    }
    var NodeType = {};
    var ELEMENT_NODE = NodeType.ELEMENT_NODE = 1;
    var ATTRIBUTE_NODE = NodeType.ATTRIBUTE_NODE = 2;
    var TEXT_NODE = NodeType.TEXT_NODE = 3;
    var CDATA_SECTION_NODE = NodeType.CDATA_SECTION_NODE = 4;
    var ENTITY_REFERENCE_NODE = NodeType.ENTITY_REFERENCE_NODE = 5;
    var ENTITY_NODE = NodeType.ENTITY_NODE = 6;
    var PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE = 7;
    var COMMENT_NODE = NodeType.COMMENT_NODE = 8;
    var DOCUMENT_NODE = NodeType.DOCUMENT_NODE = 9;
    var DOCUMENT_TYPE_NODE = NodeType.DOCUMENT_TYPE_NODE = 10;
    var DOCUMENT_FRAGMENT_NODE = NodeType.DOCUMENT_FRAGMENT_NODE = 11;
    var NOTATION_NODE = NodeType.NOTATION_NODE = 12;
    var ExceptionCode = {};
    var ExceptionMessage = {};
    var INDEX_SIZE_ERR = ExceptionCode.INDEX_SIZE_ERR = (ExceptionMessage[1] = "Index size error", 1);
    var DOMSTRING_SIZE_ERR = ExceptionCode.DOMSTRING_SIZE_ERR = (ExceptionMessage[2] = "DOMString size error", 2);
    var HIERARCHY_REQUEST_ERR = ExceptionCode.HIERARCHY_REQUEST_ERR = (ExceptionMessage[3] = "Hierarchy request error", 3);
    var WRONG_DOCUMENT_ERR = ExceptionCode.WRONG_DOCUMENT_ERR = (ExceptionMessage[4] = "Wrong document", 4);
    var INVALID_CHARACTER_ERR = ExceptionCode.INVALID_CHARACTER_ERR = (ExceptionMessage[5] = "Invalid character", 5);
    var NO_DATA_ALLOWED_ERR = ExceptionCode.NO_DATA_ALLOWED_ERR = (ExceptionMessage[6] = "No data allowed", 6);
    var NO_MODIFICATION_ALLOWED_ERR = ExceptionCode.NO_MODIFICATION_ALLOWED_ERR = (ExceptionMessage[7] = "No modification allowed", 7);
    var NOT_FOUND_ERR = ExceptionCode.NOT_FOUND_ERR = (ExceptionMessage[8] = "Not found", 8);
    var NOT_SUPPORTED_ERR = ExceptionCode.NOT_SUPPORTED_ERR = (ExceptionMessage[9] = "Not supported", 9);
    var INUSE_ATTRIBUTE_ERR = ExceptionCode.INUSE_ATTRIBUTE_ERR = (ExceptionMessage[10] = "Attribute in use", 10);
    var INVALID_STATE_ERR = ExceptionCode.INVALID_STATE_ERR = (ExceptionMessage[11] = "Invalid state", 11);
    var SYNTAX_ERR = ExceptionCode.SYNTAX_ERR = (ExceptionMessage[12] = "Syntax error", 12);
    var INVALID_MODIFICATION_ERR = ExceptionCode.INVALID_MODIFICATION_ERR = (ExceptionMessage[13] = "Invalid modification", 13);
    var NAMESPACE_ERR = ExceptionCode.NAMESPACE_ERR = (ExceptionMessage[14] = "Invalid namespace", 14);
    var INVALID_ACCESS_ERR = ExceptionCode.INVALID_ACCESS_ERR = (ExceptionMessage[15] = "Invalid access", 15);
    function DOMException(code, message) {
      if (message instanceof Error) {
        var error = message;
      } else {
        error = this;
        Error.call(this, ExceptionMessage[code]);
        this.message = ExceptionMessage[code];
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, DOMException);
      }
      error.code = code;
      if (message)
        this.message = this.message + ": " + message;
      return error;
    }
    DOMException.prototype = Error.prototype;
    copy(ExceptionCode, DOMException);
    function NodeList() {
    }
    NodeList.prototype = {
      /**
       * The number of nodes in the list. The range of valid child node indices is 0 to length-1 inclusive.
       * @standard level1
       */
      length: 0,
      /**
       * Returns the indexth item in the collection. If index is greater than or equal to the number of nodes in the list, this returns null.
       * @standard level1
       * @param index  unsigned long
       *   Index into the collection.
       * @return Node
       * 	The node at the indexth position in the NodeList, or null if that is not a valid index.
       */
      item: function(index) {
        return index >= 0 && index < this.length ? this[index] : null;
      },
      toString: function(isHTML, nodeFilter) {
        for (var buf = [], i4 = 0; i4 < this.length; i4++) {
          serializeToString(this[i4], buf, isHTML, nodeFilter);
        }
        return buf.join("");
      },
      /**
       * @private
       * @param {function (Node):boolean} predicate
       * @returns {Node[]}
       */
      filter: function(predicate) {
        return Array.prototype.filter.call(this, predicate);
      },
      /**
       * @private
       * @param {Node} item
       * @returns {number}
       */
      indexOf: function(item) {
        return Array.prototype.indexOf.call(this, item);
      }
    };
    function LiveNodeList(node, refresh) {
      this._node = node;
      this._refresh = refresh;
      _updateLiveList(this);
    }
    function _updateLiveList(list) {
      var inc = list._node._inc || list._node.ownerDocument._inc;
      if (list._inc !== inc) {
        var ls = list._refresh(list._node);
        __set__(list, "length", ls.length);
        if (!list.$$length || ls.length < list.$$length) {
          for (var i4 = ls.length; i4 in list; i4++) {
            if (Object.prototype.hasOwnProperty.call(list, i4)) {
              delete list[i4];
            }
          }
        }
        copy(ls, list);
        list._inc = inc;
      }
    }
    LiveNodeList.prototype.item = function(i4) {
      _updateLiveList(this);
      return this[i4] || null;
    };
    _extends(LiveNodeList, NodeList);
    function NamedNodeMap() {
    }
    function _findNodeIndex(list, node) {
      var i4 = list.length;
      while (i4--) {
        if (list[i4] === node) {
          return i4;
        }
      }
    }
    function _addNamedNode(el, list, newAttr, oldAttr) {
      if (oldAttr) {
        list[_findNodeIndex(list, oldAttr)] = newAttr;
      } else {
        list[list.length++] = newAttr;
      }
      if (el) {
        newAttr.ownerElement = el;
        var doc = el.ownerDocument;
        if (doc) {
          oldAttr && _onRemoveAttribute(doc, el, oldAttr);
          _onAddAttribute(doc, el, newAttr);
        }
      }
    }
    function _removeNamedNode(el, list, attr) {
      var i4 = _findNodeIndex(list, attr);
      if (i4 >= 0) {
        var lastIndex = list.length - 1;
        while (i4 < lastIndex) {
          list[i4] = list[++i4];
        }
        list.length = lastIndex;
        if (el) {
          var doc = el.ownerDocument;
          if (doc) {
            _onRemoveAttribute(doc, el, attr);
            attr.ownerElement = null;
          }
        }
      } else {
        throw new DOMException(NOT_FOUND_ERR, new Error(el.tagName + "@" + attr));
      }
    }
    NamedNodeMap.prototype = {
      length: 0,
      item: NodeList.prototype.item,
      getNamedItem: function(key) {
        var i4 = this.length;
        while (i4--) {
          var attr = this[i4];
          if (attr.nodeName == key) {
            return attr;
          }
        }
      },
      setNamedItem: function(attr) {
        var el = attr.ownerElement;
        if (el && el != this._ownerElement) {
          throw new DOMException(INUSE_ATTRIBUTE_ERR);
        }
        var oldAttr = this.getNamedItem(attr.nodeName);
        _addNamedNode(this._ownerElement, this, attr, oldAttr);
        return oldAttr;
      },
      /* returns Node */
      setNamedItemNS: function(attr) {
        var el = attr.ownerElement, oldAttr;
        if (el && el != this._ownerElement) {
          throw new DOMException(INUSE_ATTRIBUTE_ERR);
        }
        oldAttr = this.getNamedItemNS(attr.namespaceURI, attr.localName);
        _addNamedNode(this._ownerElement, this, attr, oldAttr);
        return oldAttr;
      },
      /* returns Node */
      removeNamedItem: function(key) {
        var attr = this.getNamedItem(key);
        _removeNamedNode(this._ownerElement, this, attr);
        return attr;
      },
      // raises: NOT_FOUND_ERR,NO_MODIFICATION_ALLOWED_ERR
      //for level2
      removeNamedItemNS: function(namespaceURI, localName) {
        var attr = this.getNamedItemNS(namespaceURI, localName);
        _removeNamedNode(this._ownerElement, this, attr);
        return attr;
      },
      getNamedItemNS: function(namespaceURI, localName) {
        var i4 = this.length;
        while (i4--) {
          var node = this[i4];
          if (node.localName == localName && node.namespaceURI == namespaceURI) {
            return node;
          }
        }
        return null;
      }
    };
    function DOMImplementation() {
    }
    DOMImplementation.prototype = {
      /**
       * The DOMImplementation.hasFeature() method returns a Boolean flag indicating if a given feature is supported.
       * The different implementations fairly diverged in what kind of features were reported.
       * The latest version of the spec settled to force this method to always return true, where the functionality was accurate and in use.
       *
       * @deprecated It is deprecated and modern browsers return true in all cases.
       *
       * @param {string} feature
       * @param {string} [version]
       * @returns {boolean} always true
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/hasFeature MDN
       * @see https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-5CED94D7 DOM Level 1 Core
       * @see https://dom.spec.whatwg.org/#dom-domimplementation-hasfeature DOM Living Standard
       */
      hasFeature: function(feature, version) {
        return true;
      },
      /**
       * Creates an XML Document object of the specified type with its document element.
       *
       * __It behaves slightly different from the description in the living standard__:
       * - There is no interface/class `XMLDocument`, it returns a `Document` instance.
       * - `contentType`, `encoding`, `mode`, `origin`, `url` fields are currently not declared.
       * - this implementation is not validating names or qualified names
       *   (when parsing XML strings, the SAX parser takes care of that)
       *
       * @param {string|null} namespaceURI
       * @param {string} qualifiedName
       * @param {DocumentType=null} doctype
       * @returns {Document}
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocument MDN
       * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocument DOM Level 2 Core (initial)
       * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument  DOM Level 2 Core
       *
       * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
       * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
       * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
       */
      createDocument: function(namespaceURI, qualifiedName, doctype) {
        var doc = new Document();
        doc.implementation = this;
        doc.childNodes = new NodeList();
        doc.doctype = doctype || null;
        if (doctype) {
          doc.appendChild(doctype);
        }
        if (qualifiedName) {
          var root = doc.createElementNS(namespaceURI, qualifiedName);
          doc.appendChild(root);
        }
        return doc;
      },
      /**
       * Returns a doctype, with the given `qualifiedName`, `publicId`, and `systemId`.
       *
       * __This behavior is slightly different from the in the specs__:
       * - this implementation is not validating names or qualified names
       *   (when parsing XML strings, the SAX parser takes care of that)
       *
       * @param {string} qualifiedName
       * @param {string} [publicId]
       * @param {string} [systemId]
       * @returns {DocumentType} which can either be used with `DOMImplementation.createDocument` upon document creation
       * 				  or can be put into the document via methods like `Node.insertBefore()` or `Node.replaceChild()`
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocumentType MDN
       * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocType DOM Level 2 Core
       * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocumenttype DOM Living Standard
       *
       * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
       * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
       * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
       */
      createDocumentType: function(qualifiedName, publicId, systemId) {
        var node = new DocumentType();
        node.name = qualifiedName;
        node.nodeName = qualifiedName;
        node.publicId = publicId || "";
        node.systemId = systemId || "";
        return node;
      }
    };
    function Node() {
    }
    Node.prototype = {
      firstChild: null,
      lastChild: null,
      previousSibling: null,
      nextSibling: null,
      attributes: null,
      parentNode: null,
      childNodes: null,
      ownerDocument: null,
      nodeValue: null,
      namespaceURI: null,
      prefix: null,
      localName: null,
      // Modified in DOM Level 2:
      insertBefore: function(newChild, refChild) {
        return _insertBefore(this, newChild, refChild);
      },
      replaceChild: function(newChild, oldChild) {
        _insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);
        if (oldChild) {
          this.removeChild(oldChild);
        }
      },
      removeChild: function(oldChild) {
        return _removeChild(this, oldChild);
      },
      appendChild: function(newChild) {
        return this.insertBefore(newChild, null);
      },
      hasChildNodes: function() {
        return this.firstChild != null;
      },
      cloneNode: function(deep) {
        return cloneNode(this.ownerDocument || this, this, deep);
      },
      // Modified in DOM Level 2:
      normalize: function() {
        var child = this.firstChild;
        while (child) {
          var next = child.nextSibling;
          if (next && next.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE) {
            this.removeChild(next);
            child.appendData(next.data);
          } else {
            child.normalize();
            child = next;
          }
        }
      },
      // Introduced in DOM Level 2:
      isSupported: function(feature, version) {
        return this.ownerDocument.implementation.hasFeature(feature, version);
      },
      // Introduced in DOM Level 2:
      hasAttributes: function() {
        return this.attributes.length > 0;
      },
      /**
       * Look up the prefix associated to the given namespace URI, starting from this node.
       * **The default namespace declarations are ignored by this method.**
       * See Namespace Prefix Lookup for details on the algorithm used by this method.
       *
       * _Note: The implementation seems to be incomplete when compared to the algorithm described in the specs._
       *
       * @param {string | null} namespaceURI
       * @returns {string | null}
       * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-lookupNamespacePrefix
       * @see https://www.w3.org/TR/DOM-Level-3-Core/namespaces-algorithms.html#lookupNamespacePrefixAlgo
       * @see https://dom.spec.whatwg.org/#dom-node-lookupprefix
       * @see https://github.com/xmldom/xmldom/issues/322
       */
      lookupPrefix: function(namespaceURI) {
        var el = this;
        while (el) {
          var map = el._nsMap;
          if (map) {
            for (var n3 in map) {
              if (Object.prototype.hasOwnProperty.call(map, n3) && map[n3] === namespaceURI) {
                return n3;
              }
            }
          }
          el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;
        }
        return null;
      },
      // Introduced in DOM Level 3:
      lookupNamespaceURI: function(prefix) {
        var el = this;
        while (el) {
          var map = el._nsMap;
          if (map) {
            if (Object.prototype.hasOwnProperty.call(map, prefix)) {
              return map[prefix];
            }
          }
          el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;
        }
        return null;
      },
      // Introduced in DOM Level 3:
      isDefaultNamespace: function(namespaceURI) {
        var prefix = this.lookupPrefix(namespaceURI);
        return prefix == null;
      }
    };
    function _xmlEncoder(c6) {
      return c6 == "<" && "&lt;" || c6 == ">" && "&gt;" || c6 == "&" && "&amp;" || c6 == '"' && "&quot;" || "&#" + c6.charCodeAt() + ";";
    }
    copy(NodeType, Node);
    copy(NodeType, Node.prototype);
    function _visitNode(node, callback) {
      if (callback(node)) {
        return true;
      }
      if (node = node.firstChild) {
        do {
          if (_visitNode(node, callback)) {
            return true;
          }
        } while (node = node.nextSibling);
      }
    }
    function Document() {
      this.ownerDocument = this;
    }
    function _onAddAttribute(doc, el, newAttr) {
      doc && doc._inc++;
      var ns = newAttr.namespaceURI;
      if (ns === NAMESPACE.XMLNS) {
        el._nsMap[newAttr.prefix ? newAttr.localName : ""] = newAttr.value;
      }
    }
    function _onRemoveAttribute(doc, el, newAttr, remove) {
      doc && doc._inc++;
      var ns = newAttr.namespaceURI;
      if (ns === NAMESPACE.XMLNS) {
        delete el._nsMap[newAttr.prefix ? newAttr.localName : ""];
      }
    }
    function _onUpdateChild(doc, el, newChild) {
      if (doc && doc._inc) {
        doc._inc++;
        var cs = el.childNodes;
        if (newChild) {
          cs[cs.length++] = newChild;
        } else {
          var child = el.firstChild;
          var i4 = 0;
          while (child) {
            cs[i4++] = child;
            child = child.nextSibling;
          }
          cs.length = i4;
          delete cs[cs.length];
        }
      }
    }
    function _removeChild(parentNode, child) {
      var previous = child.previousSibling;
      var next = child.nextSibling;
      if (previous) {
        previous.nextSibling = next;
      } else {
        parentNode.firstChild = next;
      }
      if (next) {
        next.previousSibling = previous;
      } else {
        parentNode.lastChild = previous;
      }
      child.parentNode = null;
      child.previousSibling = null;
      child.nextSibling = null;
      _onUpdateChild(parentNode.ownerDocument, parentNode);
      return child;
    }
    function hasValidParentNodeType(node) {
      return node && (node.nodeType === Node.DOCUMENT_NODE || node.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node.ELEMENT_NODE);
    }
    function hasInsertableNodeType(node) {
      return node && (isElementNode(node) || isTextNode(node) || isDocTypeNode(node) || node.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node.COMMENT_NODE || node.nodeType === Node.PROCESSING_INSTRUCTION_NODE);
    }
    function isDocTypeNode(node) {
      return node && node.nodeType === Node.DOCUMENT_TYPE_NODE;
    }
    function isElementNode(node) {
      return node && node.nodeType === Node.ELEMENT_NODE;
    }
    function isTextNode(node) {
      return node && node.nodeType === Node.TEXT_NODE;
    }
    function isElementInsertionPossible(doc, child) {
      var parentChildNodes = doc.childNodes || [];
      if (find(parentChildNodes, isElementNode) || isDocTypeNode(child)) {
        return false;
      }
      var docTypeNode = find(parentChildNodes, isDocTypeNode);
      return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
    }
    function isElementReplacementPossible(doc, child) {
      var parentChildNodes = doc.childNodes || [];
      function hasElementChildThatIsNotChild(node) {
        return isElementNode(node) && node !== child;
      }
      if (find(parentChildNodes, hasElementChildThatIsNotChild)) {
        return false;
      }
      var docTypeNode = find(parentChildNodes, isDocTypeNode);
      return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
    }
    function assertPreInsertionValidity1to5(parent, node, child) {
      if (!hasValidParentNodeType(parent)) {
        throw new DOMException(HIERARCHY_REQUEST_ERR, "Unexpected parent node type " + parent.nodeType);
      }
      if (child && child.parentNode !== parent) {
        throw new DOMException(NOT_FOUND_ERR, "child not in parent");
      }
      if (
        // 4. If `node` is not a DocumentFragment, DocumentType, Element, or CharacterData node, then throw a "HierarchyRequestError" DOMException.
        !hasInsertableNodeType(node) || // 5. If either `node` is a Text node and `parent` is a document,
        // the sax parser currently adds top level text nodes, this will be fixed in 0.9.0
        // || (node.nodeType === Node.TEXT_NODE && parent.nodeType === Node.DOCUMENT_NODE)
        // or `node` is a doctype and `parent` is not a document, then throw a "HierarchyRequestError" DOMException.
        isDocTypeNode(node) && parent.nodeType !== Node.DOCUMENT_NODE
      ) {
        throw new DOMException(
          HIERARCHY_REQUEST_ERR,
          "Unexpected node type " + node.nodeType + " for parent node type " + parent.nodeType
        );
      }
    }
    function assertPreInsertionValidityInDocument(parent, node, child) {
      var parentChildNodes = parent.childNodes || [];
      var nodeChildNodes = node.childNodes || [];
      if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
        var nodeChildElements = nodeChildNodes.filter(isElementNode);
        if (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "More than one element or text in fragment");
        }
        if (nodeChildElements.length === 1 && !isElementInsertionPossible(parent, child)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Element in fragment can not be inserted before doctype");
        }
      }
      if (isElementNode(node)) {
        if (!isElementInsertionPossible(parent, child)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one element can be added and only after doctype");
        }
      }
      if (isDocTypeNode(node)) {
        if (find(parentChildNodes, isDocTypeNode)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one doctype is allowed");
        }
        var parentElementChild = find(parentChildNodes, isElementNode);
        if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can only be inserted before an element");
        }
        if (!child && parentElementChild) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can not be appended since element is present");
        }
      }
    }
    function assertPreReplacementValidityInDocument(parent, node, child) {
      var parentChildNodes = parent.childNodes || [];
      var nodeChildNodes = node.childNodes || [];
      if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
        var nodeChildElements = nodeChildNodes.filter(isElementNode);
        if (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "More than one element or text in fragment");
        }
        if (nodeChildElements.length === 1 && !isElementReplacementPossible(parent, child)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Element in fragment can not be inserted before doctype");
        }
      }
      if (isElementNode(node)) {
        if (!isElementReplacementPossible(parent, child)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one element can be added and only after doctype");
        }
      }
      if (isDocTypeNode(node)) {
        let hasDoctypeChildThatIsNotChild2 = function(node2) {
          return isDocTypeNode(node2) && node2 !== child;
        };
        var hasDoctypeChildThatIsNotChild = hasDoctypeChildThatIsNotChild2;
        if (find(parentChildNodes, hasDoctypeChildThatIsNotChild2)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one doctype is allowed");
        }
        var parentElementChild = find(parentChildNodes, isElementNode);
        if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can only be inserted before an element");
        }
      }
    }
    function _insertBefore(parent, node, child, _inDocumentAssertion) {
      assertPreInsertionValidity1to5(parent, node, child);
      if (parent.nodeType === Node.DOCUMENT_NODE) {
        (_inDocumentAssertion || assertPreInsertionValidityInDocument)(parent, node, child);
      }
      var cp = node.parentNode;
      if (cp) {
        cp.removeChild(node);
      }
      if (node.nodeType === DOCUMENT_FRAGMENT_NODE) {
        var newFirst = node.firstChild;
        if (newFirst == null) {
          return node;
        }
        var newLast = node.lastChild;
      } else {
        newFirst = newLast = node;
      }
      var pre = child ? child.previousSibling : parent.lastChild;
      newFirst.previousSibling = pre;
      newLast.nextSibling = child;
      if (pre) {
        pre.nextSibling = newFirst;
      } else {
        parent.firstChild = newFirst;
      }
      if (child == null) {
        parent.lastChild = newLast;
      } else {
        child.previousSibling = newLast;
      }
      do {
        newFirst.parentNode = parent;
      } while (newFirst !== newLast && (newFirst = newFirst.nextSibling));
      _onUpdateChild(parent.ownerDocument || parent, parent);
      if (node.nodeType == DOCUMENT_FRAGMENT_NODE) {
        node.firstChild = node.lastChild = null;
      }
      return node;
    }
    function _appendSingleChild(parentNode, newChild) {
      if (newChild.parentNode) {
        newChild.parentNode.removeChild(newChild);
      }
      newChild.parentNode = parentNode;
      newChild.previousSibling = parentNode.lastChild;
      newChild.nextSibling = null;
      if (newChild.previousSibling) {
        newChild.previousSibling.nextSibling = newChild;
      } else {
        parentNode.firstChild = newChild;
      }
      parentNode.lastChild = newChild;
      _onUpdateChild(parentNode.ownerDocument, parentNode, newChild);
      return newChild;
    }
    Document.prototype = {
      //implementation : null,
      nodeName: "#document",
      nodeType: DOCUMENT_NODE,
      /**
       * The DocumentType node of the document.
       *
       * @readonly
       * @type DocumentType
       */
      doctype: null,
      documentElement: null,
      _inc: 1,
      insertBefore: function(newChild, refChild) {
        if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {
          var child = newChild.firstChild;
          while (child) {
            var next = child.nextSibling;
            this.insertBefore(child, refChild);
            child = next;
          }
          return newChild;
        }
        _insertBefore(this, newChild, refChild);
        newChild.ownerDocument = this;
        if (this.documentElement === null && newChild.nodeType === ELEMENT_NODE) {
          this.documentElement = newChild;
        }
        return newChild;
      },
      removeChild: function(oldChild) {
        if (this.documentElement == oldChild) {
          this.documentElement = null;
        }
        return _removeChild(this, oldChild);
      },
      replaceChild: function(newChild, oldChild) {
        _insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);
        newChild.ownerDocument = this;
        if (oldChild) {
          this.removeChild(oldChild);
        }
        if (isElementNode(newChild)) {
          this.documentElement = newChild;
        }
      },
      // Introduced in DOM Level 2:
      importNode: function(importedNode, deep) {
        return importNode(this, importedNode, deep);
      },
      // Introduced in DOM Level 2:
      getElementById: function(id) {
        var rtv = null;
        _visitNode(this.documentElement, function(node) {
          if (node.nodeType == ELEMENT_NODE) {
            if (node.getAttribute("id") == id) {
              rtv = node;
              return true;
            }
          }
        });
        return rtv;
      },
      /**
       * The `getElementsByClassName` method of `Document` interface returns an array-like object
       * of all child elements which have **all** of the given class name(s).
       *
       * Returns an empty list if `classeNames` is an empty string or only contains HTML white space characters.
       *
       *
       * Warning: This is a live LiveNodeList.
       * Changes in the DOM will reflect in the array as the changes occur.
       * If an element selected by this array no longer qualifies for the selector,
       * it will automatically be removed. Be aware of this for iteration purposes.
       *
       * @param {string} classNames is a string representing the class name(s) to match; multiple class names are separated by (ASCII-)whitespace
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName
       * @see https://dom.spec.whatwg.org/#concept-getelementsbyclassname
       */
      getElementsByClassName: function(classNames) {
        var classNamesSet = toOrderedSet(classNames);
        return new LiveNodeList(this, function(base) {
          var ls = [];
          if (classNamesSet.length > 0) {
            _visitNode(base.documentElement, function(node) {
              if (node !== base && node.nodeType === ELEMENT_NODE) {
                var nodeClassNames = node.getAttribute("class");
                if (nodeClassNames) {
                  var matches = classNames === nodeClassNames;
                  if (!matches) {
                    var nodeClassNamesSet = toOrderedSet(nodeClassNames);
                    matches = classNamesSet.every(arrayIncludes(nodeClassNamesSet));
                  }
                  if (matches) {
                    ls.push(node);
                  }
                }
              }
            });
          }
          return ls;
        });
      },
      //document factory method:
      createElement: function(tagName) {
        var node = new Element();
        node.ownerDocument = this;
        node.nodeName = tagName;
        node.tagName = tagName;
        node.localName = tagName;
        node.childNodes = new NodeList();
        var attrs = node.attributes = new NamedNodeMap();
        attrs._ownerElement = node;
        return node;
      },
      createDocumentFragment: function() {
        var node = new DocumentFragment();
        node.ownerDocument = this;
        node.childNodes = new NodeList();
        return node;
      },
      createTextNode: function(data) {
        var node = new Text();
        node.ownerDocument = this;
        node.appendData(data);
        return node;
      },
      createComment: function(data) {
        var node = new Comment();
        node.ownerDocument = this;
        node.appendData(data);
        return node;
      },
      createCDATASection: function(data) {
        var node = new CDATASection();
        node.ownerDocument = this;
        node.appendData(data);
        return node;
      },
      createProcessingInstruction: function(target, data) {
        var node = new ProcessingInstruction();
        node.ownerDocument = this;
        node.tagName = node.nodeName = node.target = target;
        node.nodeValue = node.data = data;
        return node;
      },
      createAttribute: function(name2) {
        var node = new Attr();
        node.ownerDocument = this;
        node.name = name2;
        node.nodeName = name2;
        node.localName = name2;
        node.specified = true;
        return node;
      },
      createEntityReference: function(name2) {
        var node = new EntityReference();
        node.ownerDocument = this;
        node.nodeName = name2;
        return node;
      },
      // Introduced in DOM Level 2:
      createElementNS: function(namespaceURI, qualifiedName) {
        var node = new Element();
        var pl = qualifiedName.split(":");
        var attrs = node.attributes = new NamedNodeMap();
        node.childNodes = new NodeList();
        node.ownerDocument = this;
        node.nodeName = qualifiedName;
        node.tagName = qualifiedName;
        node.namespaceURI = namespaceURI;
        if (pl.length == 2) {
          node.prefix = pl[0];
          node.localName = pl[1];
        } else {
          node.localName = qualifiedName;
        }
        attrs._ownerElement = node;
        return node;
      },
      // Introduced in DOM Level 2:
      createAttributeNS: function(namespaceURI, qualifiedName) {
        var node = new Attr();
        var pl = qualifiedName.split(":");
        node.ownerDocument = this;
        node.nodeName = qualifiedName;
        node.name = qualifiedName;
        node.namespaceURI = namespaceURI;
        node.specified = true;
        if (pl.length == 2) {
          node.prefix = pl[0];
          node.localName = pl[1];
        } else {
          node.localName = qualifiedName;
        }
        return node;
      }
    };
    _extends(Document, Node);
    function Element() {
      this._nsMap = {};
    }
    Element.prototype = {
      nodeType: ELEMENT_NODE,
      hasAttribute: function(name2) {
        return this.getAttributeNode(name2) != null;
      },
      getAttribute: function(name2) {
        var attr = this.getAttributeNode(name2);
        return attr && attr.value || "";
      },
      getAttributeNode: function(name2) {
        return this.attributes.getNamedItem(name2);
      },
      setAttribute: function(name2, value) {
        var attr = this.ownerDocument.createAttribute(name2);
        attr.value = attr.nodeValue = "" + value;
        this.setAttributeNode(attr);
      },
      removeAttribute: function(name2) {
        var attr = this.getAttributeNode(name2);
        attr && this.removeAttributeNode(attr);
      },
      //four real opeartion method
      appendChild: function(newChild) {
        if (newChild.nodeType === DOCUMENT_FRAGMENT_NODE) {
          return this.insertBefore(newChild, null);
        } else {
          return _appendSingleChild(this, newChild);
        }
      },
      setAttributeNode: function(newAttr) {
        return this.attributes.setNamedItem(newAttr);
      },
      setAttributeNodeNS: function(newAttr) {
        return this.attributes.setNamedItemNS(newAttr);
      },
      removeAttributeNode: function(oldAttr) {
        return this.attributes.removeNamedItem(oldAttr.nodeName);
      },
      //get real attribute name,and remove it by removeAttributeNode
      removeAttributeNS: function(namespaceURI, localName) {
        var old = this.getAttributeNodeNS(namespaceURI, localName);
        old && this.removeAttributeNode(old);
      },
      hasAttributeNS: function(namespaceURI, localName) {
        return this.getAttributeNodeNS(namespaceURI, localName) != null;
      },
      getAttributeNS: function(namespaceURI, localName) {
        var attr = this.getAttributeNodeNS(namespaceURI, localName);
        return attr && attr.value || "";
      },
      setAttributeNS: function(namespaceURI, qualifiedName, value) {
        var attr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);
        attr.value = attr.nodeValue = "" + value;
        this.setAttributeNode(attr);
      },
      getAttributeNodeNS: function(namespaceURI, localName) {
        return this.attributes.getNamedItemNS(namespaceURI, localName);
      },
      getElementsByTagName: function(tagName) {
        return new LiveNodeList(this, function(base) {
          var ls = [];
          _visitNode(base, function(node) {
            if (node !== base && node.nodeType == ELEMENT_NODE && (tagName === "*" || node.tagName == tagName)) {
              ls.push(node);
            }
          });
          return ls;
        });
      },
      getElementsByTagNameNS: function(namespaceURI, localName) {
        return new LiveNodeList(this, function(base) {
          var ls = [];
          _visitNode(base, function(node) {
            if (node !== base && node.nodeType === ELEMENT_NODE && (namespaceURI === "*" || node.namespaceURI === namespaceURI) && (localName === "*" || node.localName == localName)) {
              ls.push(node);
            }
          });
          return ls;
        });
      }
    };
    Document.prototype.getElementsByTagName = Element.prototype.getElementsByTagName;
    Document.prototype.getElementsByTagNameNS = Element.prototype.getElementsByTagNameNS;
    _extends(Element, Node);
    function Attr() {
    }
    Attr.prototype.nodeType = ATTRIBUTE_NODE;
    _extends(Attr, Node);
    function CharacterData() {
    }
    CharacterData.prototype = {
      data: "",
      substringData: function(offset, count) {
        return this.data.substring(offset, offset + count);
      },
      appendData: function(text) {
        text = this.data + text;
        this.nodeValue = this.data = text;
        this.length = text.length;
      },
      insertData: function(offset, text) {
        this.replaceData(offset, 0, text);
      },
      appendChild: function(newChild) {
        throw new Error(ExceptionMessage[HIERARCHY_REQUEST_ERR]);
      },
      deleteData: function(offset, count) {
        this.replaceData(offset, count, "");
      },
      replaceData: function(offset, count, text) {
        var start = this.data.substring(0, offset);
        var end = this.data.substring(offset + count);
        text = start + text + end;
        this.nodeValue = this.data = text;
        this.length = text.length;
      }
    };
    _extends(CharacterData, Node);
    function Text() {
    }
    Text.prototype = {
      nodeName: "#text",
      nodeType: TEXT_NODE,
      splitText: function(offset) {
        var text = this.data;
        var newText = text.substring(offset);
        text = text.substring(0, offset);
        this.data = this.nodeValue = text;
        this.length = text.length;
        var newNode = this.ownerDocument.createTextNode(newText);
        if (this.parentNode) {
          this.parentNode.insertBefore(newNode, this.nextSibling);
        }
        return newNode;
      }
    };
    _extends(Text, CharacterData);
    function Comment() {
    }
    Comment.prototype = {
      nodeName: "#comment",
      nodeType: COMMENT_NODE
    };
    _extends(Comment, CharacterData);
    function CDATASection() {
    }
    CDATASection.prototype = {
      nodeName: "#cdata-section",
      nodeType: CDATA_SECTION_NODE
    };
    _extends(CDATASection, CharacterData);
    function DocumentType() {
    }
    DocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;
    _extends(DocumentType, Node);
    function Notation() {
    }
    Notation.prototype.nodeType = NOTATION_NODE;
    _extends(Notation, Node);
    function Entity() {
    }
    Entity.prototype.nodeType = ENTITY_NODE;
    _extends(Entity, Node);
    function EntityReference() {
    }
    EntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;
    _extends(EntityReference, Node);
    function DocumentFragment() {
    }
    DocumentFragment.prototype.nodeName = "#document-fragment";
    DocumentFragment.prototype.nodeType = DOCUMENT_FRAGMENT_NODE;
    _extends(DocumentFragment, Node);
    function ProcessingInstruction() {
    }
    ProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;
    _extends(ProcessingInstruction, Node);
    function XMLSerializer() {
    }
    XMLSerializer.prototype.serializeToString = function(node, isHtml, nodeFilter) {
      return nodeSerializeToString.call(node, isHtml, nodeFilter);
    };
    Node.prototype.toString = nodeSerializeToString;
    function nodeSerializeToString(isHtml, nodeFilter) {
      var buf = [];
      var refNode = this.nodeType == 9 && this.documentElement || this;
      var prefix = refNode.prefix;
      var uri = refNode.namespaceURI;
      if (uri && prefix == null) {
        var prefix = refNode.lookupPrefix(uri);
        if (prefix == null) {
          var visibleNamespaces = [
            { namespace: uri, prefix: null }
            //{namespace:uri,prefix:''}
          ];
        }
      }
      serializeToString(this, buf, isHtml, nodeFilter, visibleNamespaces);
      return buf.join("");
    }
    function needNamespaceDefine(node, isHTML, visibleNamespaces) {
      var prefix = node.prefix || "";
      var uri = node.namespaceURI;
      if (!uri) {
        return false;
      }
      if (prefix === "xml" && uri === NAMESPACE.XML || uri === NAMESPACE.XMLNS) {
        return false;
      }
      var i4 = visibleNamespaces.length;
      while (i4--) {
        var ns = visibleNamespaces[i4];
        if (ns.prefix === prefix) {
          return ns.namespace !== uri;
        }
      }
      return true;
    }
    function addSerializedAttribute(buf, qualifiedName, value) {
      buf.push(" ", qualifiedName, '="', value.replace(/[<>&"\t\n\r]/g, _xmlEncoder), '"');
    }
    function serializeToString(node, buf, isHTML, nodeFilter, visibleNamespaces) {
      if (!visibleNamespaces) {
        visibleNamespaces = [];
      }
      if (nodeFilter) {
        node = nodeFilter(node);
        if (node) {
          if (typeof node == "string") {
            buf.push(node);
            return;
          }
        } else {
          return;
        }
      }
      switch (node.nodeType) {
        case ELEMENT_NODE:
          var attrs = node.attributes;
          var len = attrs.length;
          var child = node.firstChild;
          var nodeName = node.tagName;
          isHTML = NAMESPACE.isHTML(node.namespaceURI) || isHTML;
          var prefixedNodeName = nodeName;
          if (!isHTML && !node.prefix && node.namespaceURI) {
            var defaultNS;
            for (var ai = 0; ai < attrs.length; ai++) {
              if (attrs.item(ai).name === "xmlns") {
                defaultNS = attrs.item(ai).value;
                break;
              }
            }
            if (!defaultNS) {
              for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
                var namespace = visibleNamespaces[nsi];
                if (namespace.prefix === "" && namespace.namespace === node.namespaceURI) {
                  defaultNS = namespace.namespace;
                  break;
                }
              }
            }
            if (defaultNS !== node.namespaceURI) {
              for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
                var namespace = visibleNamespaces[nsi];
                if (namespace.namespace === node.namespaceURI) {
                  if (namespace.prefix) {
                    prefixedNodeName = namespace.prefix + ":" + nodeName;
                  }
                  break;
                }
              }
            }
          }
          buf.push("<", prefixedNodeName);
          for (var i4 = 0; i4 < len; i4++) {
            var attr = attrs.item(i4);
            if (attr.prefix == "xmlns") {
              visibleNamespaces.push({ prefix: attr.localName, namespace: attr.value });
            } else if (attr.nodeName == "xmlns") {
              visibleNamespaces.push({ prefix: "", namespace: attr.value });
            }
          }
          for (var i4 = 0; i4 < len; i4++) {
            var attr = attrs.item(i4);
            if (needNamespaceDefine(attr, isHTML, visibleNamespaces)) {
              var prefix = attr.prefix || "";
              var uri = attr.namespaceURI;
              addSerializedAttribute(buf, prefix ? "xmlns:" + prefix : "xmlns", uri);
              visibleNamespaces.push({ prefix, namespace: uri });
            }
            serializeToString(attr, buf, isHTML, nodeFilter, visibleNamespaces);
          }
          if (nodeName === prefixedNodeName && needNamespaceDefine(node, isHTML, visibleNamespaces)) {
            var prefix = node.prefix || "";
            var uri = node.namespaceURI;
            addSerializedAttribute(buf, prefix ? "xmlns:" + prefix : "xmlns", uri);
            visibleNamespaces.push({ prefix, namespace: uri });
          }
          if (child || isHTML && !/^(?:meta|link|img|br|hr|input)$/i.test(nodeName)) {
            buf.push(">");
            if (isHTML && /^script$/i.test(nodeName)) {
              while (child) {
                if (child.data) {
                  buf.push(child.data);
                } else {
                  serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
                }
                child = child.nextSibling;
              }
            } else {
              while (child) {
                serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
                child = child.nextSibling;
              }
            }
            buf.push("</", prefixedNodeName, ">");
          } else {
            buf.push("/>");
          }
          return;
        case DOCUMENT_NODE:
        case DOCUMENT_FRAGMENT_NODE:
          var child = node.firstChild;
          while (child) {
            serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
            child = child.nextSibling;
          }
          return;
        case ATTRIBUTE_NODE:
          return addSerializedAttribute(buf, node.name, node.value);
        case TEXT_NODE:
          return buf.push(
            node.data.replace(/[<&>]/g, _xmlEncoder)
          );
        case CDATA_SECTION_NODE:
          return buf.push("<![CDATA[", node.data, "]]>");
        case COMMENT_NODE:
          return buf.push("<!--", node.data, "-->");
        case DOCUMENT_TYPE_NODE:
          var pubid = node.publicId;
          var sysid = node.systemId;
          buf.push("<!DOCTYPE ", node.name);
          if (pubid) {
            buf.push(" PUBLIC ", pubid);
            if (sysid && sysid != ".") {
              buf.push(" ", sysid);
            }
            buf.push(">");
          } else if (sysid && sysid != ".") {
            buf.push(" SYSTEM ", sysid, ">");
          } else {
            var sub = node.internalSubset;
            if (sub) {
              buf.push(" [", sub, "]");
            }
            buf.push(">");
          }
          return;
        case PROCESSING_INSTRUCTION_NODE:
          return buf.push("<?", node.target, " ", node.data, "?>");
        case ENTITY_REFERENCE_NODE:
          return buf.push("&", node.nodeName, ";");
        default:
          buf.push("??", node.nodeName);
      }
    }
    function importNode(doc, node, deep) {
      var node2;
      switch (node.nodeType) {
        case ELEMENT_NODE:
          node2 = node.cloneNode(false);
          node2.ownerDocument = doc;
        case DOCUMENT_FRAGMENT_NODE:
          break;
        case ATTRIBUTE_NODE:
          deep = true;
          break;
      }
      if (!node2) {
        node2 = node.cloneNode(false);
      }
      node2.ownerDocument = doc;
      node2.parentNode = null;
      if (deep) {
        var child = node.firstChild;
        while (child) {
          node2.appendChild(importNode(doc, child, deep));
          child = child.nextSibling;
        }
      }
      return node2;
    }
    function cloneNode(doc, node, deep) {
      var node2 = new node.constructor();
      for (var n3 in node) {
        if (Object.prototype.hasOwnProperty.call(node, n3)) {
          var v = node[n3];
          if (typeof v != "object") {
            if (v != node2[n3]) {
              node2[n3] = v;
            }
          }
        }
      }
      if (node.childNodes) {
        node2.childNodes = new NodeList();
      }
      node2.ownerDocument = doc;
      switch (node2.nodeType) {
        case ELEMENT_NODE:
          var attrs = node.attributes;
          var attrs2 = node2.attributes = new NamedNodeMap();
          var len = attrs.length;
          attrs2._ownerElement = node2;
          for (var i4 = 0; i4 < len; i4++) {
            node2.setAttributeNode(cloneNode(doc, attrs.item(i4), true));
          }
          break;
          ;
        case ATTRIBUTE_NODE:
          deep = true;
      }
      if (deep) {
        var child = node.firstChild;
        while (child) {
          node2.appendChild(cloneNode(doc, child, deep));
          child = child.nextSibling;
        }
      }
      return node2;
    }
    function __set__(object, key, value) {
      object[key] = value;
    }
    try {
      if (Object.defineProperty) {
        let getTextContent2 = function(node) {
          switch (node.nodeType) {
            case ELEMENT_NODE:
            case DOCUMENT_FRAGMENT_NODE:
              var buf = [];
              node = node.firstChild;
              while (node) {
                if (node.nodeType !== 7 && node.nodeType !== 8) {
                  buf.push(getTextContent2(node));
                }
                node = node.nextSibling;
              }
              return buf.join("");
            default:
              return node.nodeValue;
          }
        };
        getTextContent = getTextContent2;
        Object.defineProperty(LiveNodeList.prototype, "length", {
          get: function() {
            _updateLiveList(this);
            return this.$$length;
          }
        });
        Object.defineProperty(Node.prototype, "textContent", {
          get: function() {
            return getTextContent2(this);
          },
          set: function(data) {
            switch (this.nodeType) {
              case ELEMENT_NODE:
              case DOCUMENT_FRAGMENT_NODE:
                while (this.firstChild) {
                  this.removeChild(this.firstChild);
                }
                if (data || String(data)) {
                  this.appendChild(this.ownerDocument.createTextNode(data));
                }
                break;
              default:
                this.data = data;
                this.value = data;
                this.nodeValue = data;
            }
          }
        });
        __set__ = function(object, key, value) {
          object["$$" + key] = value;
        };
      }
    } catch (e2) {
    }
    var getTextContent;
    exports.DocumentType = DocumentType;
    exports.DOMException = DOMException;
    exports.DOMImplementation = DOMImplementation;
    exports.Element = Element;
    exports.Node = Node;
    exports.NodeList = NodeList;
    exports.XMLSerializer = XMLSerializer;
  }
});

// node_modules/@xmldom/xmldom/lib/entities.js
var require_entities = __commonJS({
  "node_modules/@xmldom/xmldom/lib/entities.js"(exports) {
    "use strict";
    var freeze = require_conventions().freeze;
    exports.XML_ENTITIES = freeze({
      amp: "&",
      apos: "'",
      gt: ">",
      lt: "<",
      quot: '"'
    });
    exports.HTML_ENTITIES = freeze({
      Aacute: "\xC1",
      aacute: "\xE1",
      Abreve: "\u0102",
      abreve: "\u0103",
      ac: "\u223E",
      acd: "\u223F",
      acE: "\u223E\u0333",
      Acirc: "\xC2",
      acirc: "\xE2",
      acute: "\xB4",
      Acy: "\u0410",
      acy: "\u0430",
      AElig: "\xC6",
      aelig: "\xE6",
      af: "\u2061",
      Afr: "\u{1D504}",
      afr: "\u{1D51E}",
      Agrave: "\xC0",
      agrave: "\xE0",
      alefsym: "\u2135",
      aleph: "\u2135",
      Alpha: "\u0391",
      alpha: "\u03B1",
      Amacr: "\u0100",
      amacr: "\u0101",
      amalg: "\u2A3F",
      AMP: "&",
      amp: "&",
      And: "\u2A53",
      and: "\u2227",
      andand: "\u2A55",
      andd: "\u2A5C",
      andslope: "\u2A58",
      andv: "\u2A5A",
      ang: "\u2220",
      ange: "\u29A4",
      angle: "\u2220",
      angmsd: "\u2221",
      angmsdaa: "\u29A8",
      angmsdab: "\u29A9",
      angmsdac: "\u29AA",
      angmsdad: "\u29AB",
      angmsdae: "\u29AC",
      angmsdaf: "\u29AD",
      angmsdag: "\u29AE",
      angmsdah: "\u29AF",
      angrt: "\u221F",
      angrtvb: "\u22BE",
      angrtvbd: "\u299D",
      angsph: "\u2222",
      angst: "\xC5",
      angzarr: "\u237C",
      Aogon: "\u0104",
      aogon: "\u0105",
      Aopf: "\u{1D538}",
      aopf: "\u{1D552}",
      ap: "\u2248",
      apacir: "\u2A6F",
      apE: "\u2A70",
      ape: "\u224A",
      apid: "\u224B",
      apos: "'",
      ApplyFunction: "\u2061",
      approx: "\u2248",
      approxeq: "\u224A",
      Aring: "\xC5",
      aring: "\xE5",
      Ascr: "\u{1D49C}",
      ascr: "\u{1D4B6}",
      Assign: "\u2254",
      ast: "*",
      asymp: "\u2248",
      asympeq: "\u224D",
      Atilde: "\xC3",
      atilde: "\xE3",
      Auml: "\xC4",
      auml: "\xE4",
      awconint: "\u2233",
      awint: "\u2A11",
      backcong: "\u224C",
      backepsilon: "\u03F6",
      backprime: "\u2035",
      backsim: "\u223D",
      backsimeq: "\u22CD",
      Backslash: "\u2216",
      Barv: "\u2AE7",
      barvee: "\u22BD",
      Barwed: "\u2306",
      barwed: "\u2305",
      barwedge: "\u2305",
      bbrk: "\u23B5",
      bbrktbrk: "\u23B6",
      bcong: "\u224C",
      Bcy: "\u0411",
      bcy: "\u0431",
      bdquo: "\u201E",
      becaus: "\u2235",
      Because: "\u2235",
      because: "\u2235",
      bemptyv: "\u29B0",
      bepsi: "\u03F6",
      bernou: "\u212C",
      Bernoullis: "\u212C",
      Beta: "\u0392",
      beta: "\u03B2",
      beth: "\u2136",
      between: "\u226C",
      Bfr: "\u{1D505}",
      bfr: "\u{1D51F}",
      bigcap: "\u22C2",
      bigcirc: "\u25EF",
      bigcup: "\u22C3",
      bigodot: "\u2A00",
      bigoplus: "\u2A01",
      bigotimes: "\u2A02",
      bigsqcup: "\u2A06",
      bigstar: "\u2605",
      bigtriangledown: "\u25BD",
      bigtriangleup: "\u25B3",
      biguplus: "\u2A04",
      bigvee: "\u22C1",
      bigwedge: "\u22C0",
      bkarow: "\u290D",
      blacklozenge: "\u29EB",
      blacksquare: "\u25AA",
      blacktriangle: "\u25B4",
      blacktriangledown: "\u25BE",
      blacktriangleleft: "\u25C2",
      blacktriangleright: "\u25B8",
      blank: "\u2423",
      blk12: "\u2592",
      blk14: "\u2591",
      blk34: "\u2593",
      block: "\u2588",
      bne: "=\u20E5",
      bnequiv: "\u2261\u20E5",
      bNot: "\u2AED",
      bnot: "\u2310",
      Bopf: "\u{1D539}",
      bopf: "\u{1D553}",
      bot: "\u22A5",
      bottom: "\u22A5",
      bowtie: "\u22C8",
      boxbox: "\u29C9",
      boxDL: "\u2557",
      boxDl: "\u2556",
      boxdL: "\u2555",
      boxdl: "\u2510",
      boxDR: "\u2554",
      boxDr: "\u2553",
      boxdR: "\u2552",
      boxdr: "\u250C",
      boxH: "\u2550",
      boxh: "\u2500",
      boxHD: "\u2566",
      boxHd: "\u2564",
      boxhD: "\u2565",
      boxhd: "\u252C",
      boxHU: "\u2569",
      boxHu: "\u2567",
      boxhU: "\u2568",
      boxhu: "\u2534",
      boxminus: "\u229F",
      boxplus: "\u229E",
      boxtimes: "\u22A0",
      boxUL: "\u255D",
      boxUl: "\u255C",
      boxuL: "\u255B",
      boxul: "\u2518",
      boxUR: "\u255A",
      boxUr: "\u2559",
      boxuR: "\u2558",
      boxur: "\u2514",
      boxV: "\u2551",
      boxv: "\u2502",
      boxVH: "\u256C",
      boxVh: "\u256B",
      boxvH: "\u256A",
      boxvh: "\u253C",
      boxVL: "\u2563",
      boxVl: "\u2562",
      boxvL: "\u2561",
      boxvl: "\u2524",
      boxVR: "\u2560",
      boxVr: "\u255F",
      boxvR: "\u255E",
      boxvr: "\u251C",
      bprime: "\u2035",
      Breve: "\u02D8",
      breve: "\u02D8",
      brvbar: "\xA6",
      Bscr: "\u212C",
      bscr: "\u{1D4B7}",
      bsemi: "\u204F",
      bsim: "\u223D",
      bsime: "\u22CD",
      bsol: "\\",
      bsolb: "\u29C5",
      bsolhsub: "\u27C8",
      bull: "\u2022",
      bullet: "\u2022",
      bump: "\u224E",
      bumpE: "\u2AAE",
      bumpe: "\u224F",
      Bumpeq: "\u224E",
      bumpeq: "\u224F",
      Cacute: "\u0106",
      cacute: "\u0107",
      Cap: "\u22D2",
      cap: "\u2229",
      capand: "\u2A44",
      capbrcup: "\u2A49",
      capcap: "\u2A4B",
      capcup: "\u2A47",
      capdot: "\u2A40",
      CapitalDifferentialD: "\u2145",
      caps: "\u2229\uFE00",
      caret: "\u2041",
      caron: "\u02C7",
      Cayleys: "\u212D",
      ccaps: "\u2A4D",
      Ccaron: "\u010C",
      ccaron: "\u010D",
      Ccedil: "\xC7",
      ccedil: "\xE7",
      Ccirc: "\u0108",
      ccirc: "\u0109",
      Cconint: "\u2230",
      ccups: "\u2A4C",
      ccupssm: "\u2A50",
      Cdot: "\u010A",
      cdot: "\u010B",
      cedil: "\xB8",
      Cedilla: "\xB8",
      cemptyv: "\u29B2",
      cent: "\xA2",
      CenterDot: "\xB7",
      centerdot: "\xB7",
      Cfr: "\u212D",
      cfr: "\u{1D520}",
      CHcy: "\u0427",
      chcy: "\u0447",
      check: "\u2713",
      checkmark: "\u2713",
      Chi: "\u03A7",
      chi: "\u03C7",
      cir: "\u25CB",
      circ: "\u02C6",
      circeq: "\u2257",
      circlearrowleft: "\u21BA",
      circlearrowright: "\u21BB",
      circledast: "\u229B",
      circledcirc: "\u229A",
      circleddash: "\u229D",
      CircleDot: "\u2299",
      circledR: "\xAE",
      circledS: "\u24C8",
      CircleMinus: "\u2296",
      CirclePlus: "\u2295",
      CircleTimes: "\u2297",
      cirE: "\u29C3",
      cire: "\u2257",
      cirfnint: "\u2A10",
      cirmid: "\u2AEF",
      cirscir: "\u29C2",
      ClockwiseContourIntegral: "\u2232",
      CloseCurlyDoubleQuote: "\u201D",
      CloseCurlyQuote: "\u2019",
      clubs: "\u2663",
      clubsuit: "\u2663",
      Colon: "\u2237",
      colon: ":",
      Colone: "\u2A74",
      colone: "\u2254",
      coloneq: "\u2254",
      comma: ",",
      commat: "@",
      comp: "\u2201",
      compfn: "\u2218",
      complement: "\u2201",
      complexes: "\u2102",
      cong: "\u2245",
      congdot: "\u2A6D",
      Congruent: "\u2261",
      Conint: "\u222F",
      conint: "\u222E",
      ContourIntegral: "\u222E",
      Copf: "\u2102",
      copf: "\u{1D554}",
      coprod: "\u2210",
      Coproduct: "\u2210",
      COPY: "\xA9",
      copy: "\xA9",
      copysr: "\u2117",
      CounterClockwiseContourIntegral: "\u2233",
      crarr: "\u21B5",
      Cross: "\u2A2F",
      cross: "\u2717",
      Cscr: "\u{1D49E}",
      cscr: "\u{1D4B8}",
      csub: "\u2ACF",
      csube: "\u2AD1",
      csup: "\u2AD0",
      csupe: "\u2AD2",
      ctdot: "\u22EF",
      cudarrl: "\u2938",
      cudarrr: "\u2935",
      cuepr: "\u22DE",
      cuesc: "\u22DF",
      cularr: "\u21B6",
      cularrp: "\u293D",
      Cup: "\u22D3",
      cup: "\u222A",
      cupbrcap: "\u2A48",
      CupCap: "\u224D",
      cupcap: "\u2A46",
      cupcup: "\u2A4A",
      cupdot: "\u228D",
      cupor: "\u2A45",
      cups: "\u222A\uFE00",
      curarr: "\u21B7",
      curarrm: "\u293C",
      curlyeqprec: "\u22DE",
      curlyeqsucc: "\u22DF",
      curlyvee: "\u22CE",
      curlywedge: "\u22CF",
      curren: "\xA4",
      curvearrowleft: "\u21B6",
      curvearrowright: "\u21B7",
      cuvee: "\u22CE",
      cuwed: "\u22CF",
      cwconint: "\u2232",
      cwint: "\u2231",
      cylcty: "\u232D",
      Dagger: "\u2021",
      dagger: "\u2020",
      daleth: "\u2138",
      Darr: "\u21A1",
      dArr: "\u21D3",
      darr: "\u2193",
      dash: "\u2010",
      Dashv: "\u2AE4",
      dashv: "\u22A3",
      dbkarow: "\u290F",
      dblac: "\u02DD",
      Dcaron: "\u010E",
      dcaron: "\u010F",
      Dcy: "\u0414",
      dcy: "\u0434",
      DD: "\u2145",
      dd: "\u2146",
      ddagger: "\u2021",
      ddarr: "\u21CA",
      DDotrahd: "\u2911",
      ddotseq: "\u2A77",
      deg: "\xB0",
      Del: "\u2207",
      Delta: "\u0394",
      delta: "\u03B4",
      demptyv: "\u29B1",
      dfisht: "\u297F",
      Dfr: "\u{1D507}",
      dfr: "\u{1D521}",
      dHar: "\u2965",
      dharl: "\u21C3",
      dharr: "\u21C2",
      DiacriticalAcute: "\xB4",
      DiacriticalDot: "\u02D9",
      DiacriticalDoubleAcute: "\u02DD",
      DiacriticalGrave: "`",
      DiacriticalTilde: "\u02DC",
      diam: "\u22C4",
      Diamond: "\u22C4",
      diamond: "\u22C4",
      diamondsuit: "\u2666",
      diams: "\u2666",
      die: "\xA8",
      DifferentialD: "\u2146",
      digamma: "\u03DD",
      disin: "\u22F2",
      div: "\xF7",
      divide: "\xF7",
      divideontimes: "\u22C7",
      divonx: "\u22C7",
      DJcy: "\u0402",
      djcy: "\u0452",
      dlcorn: "\u231E",
      dlcrop: "\u230D",
      dollar: "$",
      Dopf: "\u{1D53B}",
      dopf: "\u{1D555}",
      Dot: "\xA8",
      dot: "\u02D9",
      DotDot: "\u20DC",
      doteq: "\u2250",
      doteqdot: "\u2251",
      DotEqual: "\u2250",
      dotminus: "\u2238",
      dotplus: "\u2214",
      dotsquare: "\u22A1",
      doublebarwedge: "\u2306",
      DoubleContourIntegral: "\u222F",
      DoubleDot: "\xA8",
      DoubleDownArrow: "\u21D3",
      DoubleLeftArrow: "\u21D0",
      DoubleLeftRightArrow: "\u21D4",
      DoubleLeftTee: "\u2AE4",
      DoubleLongLeftArrow: "\u27F8",
      DoubleLongLeftRightArrow: "\u27FA",
      DoubleLongRightArrow: "\u27F9",
      DoubleRightArrow: "\u21D2",
      DoubleRightTee: "\u22A8",
      DoubleUpArrow: "\u21D1",
      DoubleUpDownArrow: "\u21D5",
      DoubleVerticalBar: "\u2225",
      DownArrow: "\u2193",
      Downarrow: "\u21D3",
      downarrow: "\u2193",
      DownArrowBar: "\u2913",
      DownArrowUpArrow: "\u21F5",
      DownBreve: "\u0311",
      downdownarrows: "\u21CA",
      downharpoonleft: "\u21C3",
      downharpoonright: "\u21C2",
      DownLeftRightVector: "\u2950",
      DownLeftTeeVector: "\u295E",
      DownLeftVector: "\u21BD",
      DownLeftVectorBar: "\u2956",
      DownRightTeeVector: "\u295F",
      DownRightVector: "\u21C1",
      DownRightVectorBar: "\u2957",
      DownTee: "\u22A4",
      DownTeeArrow: "\u21A7",
      drbkarow: "\u2910",
      drcorn: "\u231F",
      drcrop: "\u230C",
      Dscr: "\u{1D49F}",
      dscr: "\u{1D4B9}",
      DScy: "\u0405",
      dscy: "\u0455",
      dsol: "\u29F6",
      Dstrok: "\u0110",
      dstrok: "\u0111",
      dtdot: "\u22F1",
      dtri: "\u25BF",
      dtrif: "\u25BE",
      duarr: "\u21F5",
      duhar: "\u296F",
      dwangle: "\u29A6",
      DZcy: "\u040F",
      dzcy: "\u045F",
      dzigrarr: "\u27FF",
      Eacute: "\xC9",
      eacute: "\xE9",
      easter: "\u2A6E",
      Ecaron: "\u011A",
      ecaron: "\u011B",
      ecir: "\u2256",
      Ecirc: "\xCA",
      ecirc: "\xEA",
      ecolon: "\u2255",
      Ecy: "\u042D",
      ecy: "\u044D",
      eDDot: "\u2A77",
      Edot: "\u0116",
      eDot: "\u2251",
      edot: "\u0117",
      ee: "\u2147",
      efDot: "\u2252",
      Efr: "\u{1D508}",
      efr: "\u{1D522}",
      eg: "\u2A9A",
      Egrave: "\xC8",
      egrave: "\xE8",
      egs: "\u2A96",
      egsdot: "\u2A98",
      el: "\u2A99",
      Element: "\u2208",
      elinters: "\u23E7",
      ell: "\u2113",
      els: "\u2A95",
      elsdot: "\u2A97",
      Emacr: "\u0112",
      emacr: "\u0113",
      empty: "\u2205",
      emptyset: "\u2205",
      EmptySmallSquare: "\u25FB",
      emptyv: "\u2205",
      EmptyVerySmallSquare: "\u25AB",
      emsp: "\u2003",
      emsp13: "\u2004",
      emsp14: "\u2005",
      ENG: "\u014A",
      eng: "\u014B",
      ensp: "\u2002",
      Eogon: "\u0118",
      eogon: "\u0119",
      Eopf: "\u{1D53C}",
      eopf: "\u{1D556}",
      epar: "\u22D5",
      eparsl: "\u29E3",
      eplus: "\u2A71",
      epsi: "\u03B5",
      Epsilon: "\u0395",
      epsilon: "\u03B5",
      epsiv: "\u03F5",
      eqcirc: "\u2256",
      eqcolon: "\u2255",
      eqsim: "\u2242",
      eqslantgtr: "\u2A96",
      eqslantless: "\u2A95",
      Equal: "\u2A75",
      equals: "=",
      EqualTilde: "\u2242",
      equest: "\u225F",
      Equilibrium: "\u21CC",
      equiv: "\u2261",
      equivDD: "\u2A78",
      eqvparsl: "\u29E5",
      erarr: "\u2971",
      erDot: "\u2253",
      Escr: "\u2130",
      escr: "\u212F",
      esdot: "\u2250",
      Esim: "\u2A73",
      esim: "\u2242",
      Eta: "\u0397",
      eta: "\u03B7",
      ETH: "\xD0",
      eth: "\xF0",
      Euml: "\xCB",
      euml: "\xEB",
      euro: "\u20AC",
      excl: "!",
      exist: "\u2203",
      Exists: "\u2203",
      expectation: "\u2130",
      ExponentialE: "\u2147",
      exponentiale: "\u2147",
      fallingdotseq: "\u2252",
      Fcy: "\u0424",
      fcy: "\u0444",
      female: "\u2640",
      ffilig: "\uFB03",
      fflig: "\uFB00",
      ffllig: "\uFB04",
      Ffr: "\u{1D509}",
      ffr: "\u{1D523}",
      filig: "\uFB01",
      FilledSmallSquare: "\u25FC",
      FilledVerySmallSquare: "\u25AA",
      fjlig: "fj",
      flat: "\u266D",
      fllig: "\uFB02",
      fltns: "\u25B1",
      fnof: "\u0192",
      Fopf: "\u{1D53D}",
      fopf: "\u{1D557}",
      ForAll: "\u2200",
      forall: "\u2200",
      fork: "\u22D4",
      forkv: "\u2AD9",
      Fouriertrf: "\u2131",
      fpartint: "\u2A0D",
      frac12: "\xBD",
      frac13: "\u2153",
      frac14: "\xBC",
      frac15: "\u2155",
      frac16: "\u2159",
      frac18: "\u215B",
      frac23: "\u2154",
      frac25: "\u2156",
      frac34: "\xBE",
      frac35: "\u2157",
      frac38: "\u215C",
      frac45: "\u2158",
      frac56: "\u215A",
      frac58: "\u215D",
      frac78: "\u215E",
      frasl: "\u2044",
      frown: "\u2322",
      Fscr: "\u2131",
      fscr: "\u{1D4BB}",
      gacute: "\u01F5",
      Gamma: "\u0393",
      gamma: "\u03B3",
      Gammad: "\u03DC",
      gammad: "\u03DD",
      gap: "\u2A86",
      Gbreve: "\u011E",
      gbreve: "\u011F",
      Gcedil: "\u0122",
      Gcirc: "\u011C",
      gcirc: "\u011D",
      Gcy: "\u0413",
      gcy: "\u0433",
      Gdot: "\u0120",
      gdot: "\u0121",
      gE: "\u2267",
      ge: "\u2265",
      gEl: "\u2A8C",
      gel: "\u22DB",
      geq: "\u2265",
      geqq: "\u2267",
      geqslant: "\u2A7E",
      ges: "\u2A7E",
      gescc: "\u2AA9",
      gesdot: "\u2A80",
      gesdoto: "\u2A82",
      gesdotol: "\u2A84",
      gesl: "\u22DB\uFE00",
      gesles: "\u2A94",
      Gfr: "\u{1D50A}",
      gfr: "\u{1D524}",
      Gg: "\u22D9",
      gg: "\u226B",
      ggg: "\u22D9",
      gimel: "\u2137",
      GJcy: "\u0403",
      gjcy: "\u0453",
      gl: "\u2277",
      gla: "\u2AA5",
      glE: "\u2A92",
      glj: "\u2AA4",
      gnap: "\u2A8A",
      gnapprox: "\u2A8A",
      gnE: "\u2269",
      gne: "\u2A88",
      gneq: "\u2A88",
      gneqq: "\u2269",
      gnsim: "\u22E7",
      Gopf: "\u{1D53E}",
      gopf: "\u{1D558}",
      grave: "`",
      GreaterEqual: "\u2265",
      GreaterEqualLess: "\u22DB",
      GreaterFullEqual: "\u2267",
      GreaterGreater: "\u2AA2",
      GreaterLess: "\u2277",
      GreaterSlantEqual: "\u2A7E",
      GreaterTilde: "\u2273",
      Gscr: "\u{1D4A2}",
      gscr: "\u210A",
      gsim: "\u2273",
      gsime: "\u2A8E",
      gsiml: "\u2A90",
      Gt: "\u226B",
      GT: ">",
      gt: ">",
      gtcc: "\u2AA7",
      gtcir: "\u2A7A",
      gtdot: "\u22D7",
      gtlPar: "\u2995",
      gtquest: "\u2A7C",
      gtrapprox: "\u2A86",
      gtrarr: "\u2978",
      gtrdot: "\u22D7",
      gtreqless: "\u22DB",
      gtreqqless: "\u2A8C",
      gtrless: "\u2277",
      gtrsim: "\u2273",
      gvertneqq: "\u2269\uFE00",
      gvnE: "\u2269\uFE00",
      Hacek: "\u02C7",
      hairsp: "\u200A",
      half: "\xBD",
      hamilt: "\u210B",
      HARDcy: "\u042A",
      hardcy: "\u044A",
      hArr: "\u21D4",
      harr: "\u2194",
      harrcir: "\u2948",
      harrw: "\u21AD",
      Hat: "^",
      hbar: "\u210F",
      Hcirc: "\u0124",
      hcirc: "\u0125",
      hearts: "\u2665",
      heartsuit: "\u2665",
      hellip: "\u2026",
      hercon: "\u22B9",
      Hfr: "\u210C",
      hfr: "\u{1D525}",
      HilbertSpace: "\u210B",
      hksearow: "\u2925",
      hkswarow: "\u2926",
      hoarr: "\u21FF",
      homtht: "\u223B",
      hookleftarrow: "\u21A9",
      hookrightarrow: "\u21AA",
      Hopf: "\u210D",
      hopf: "\u{1D559}",
      horbar: "\u2015",
      HorizontalLine: "\u2500",
      Hscr: "\u210B",
      hscr: "\u{1D4BD}",
      hslash: "\u210F",
      Hstrok: "\u0126",
      hstrok: "\u0127",
      HumpDownHump: "\u224E",
      HumpEqual: "\u224F",
      hybull: "\u2043",
      hyphen: "\u2010",
      Iacute: "\xCD",
      iacute: "\xED",
      ic: "\u2063",
      Icirc: "\xCE",
      icirc: "\xEE",
      Icy: "\u0418",
      icy: "\u0438",
      Idot: "\u0130",
      IEcy: "\u0415",
      iecy: "\u0435",
      iexcl: "\xA1",
      iff: "\u21D4",
      Ifr: "\u2111",
      ifr: "\u{1D526}",
      Igrave: "\xCC",
      igrave: "\xEC",
      ii: "\u2148",
      iiiint: "\u2A0C",
      iiint: "\u222D",
      iinfin: "\u29DC",
      iiota: "\u2129",
      IJlig: "\u0132",
      ijlig: "\u0133",
      Im: "\u2111",
      Imacr: "\u012A",
      imacr: "\u012B",
      image: "\u2111",
      ImaginaryI: "\u2148",
      imagline: "\u2110",
      imagpart: "\u2111",
      imath: "\u0131",
      imof: "\u22B7",
      imped: "\u01B5",
      Implies: "\u21D2",
      in: "\u2208",
      incare: "\u2105",
      infin: "\u221E",
      infintie: "\u29DD",
      inodot: "\u0131",
      Int: "\u222C",
      int: "\u222B",
      intcal: "\u22BA",
      integers: "\u2124",
      Integral: "\u222B",
      intercal: "\u22BA",
      Intersection: "\u22C2",
      intlarhk: "\u2A17",
      intprod: "\u2A3C",
      InvisibleComma: "\u2063",
      InvisibleTimes: "\u2062",
      IOcy: "\u0401",
      iocy: "\u0451",
      Iogon: "\u012E",
      iogon: "\u012F",
      Iopf: "\u{1D540}",
      iopf: "\u{1D55A}",
      Iota: "\u0399",
      iota: "\u03B9",
      iprod: "\u2A3C",
      iquest: "\xBF",
      Iscr: "\u2110",
      iscr: "\u{1D4BE}",
      isin: "\u2208",
      isindot: "\u22F5",
      isinE: "\u22F9",
      isins: "\u22F4",
      isinsv: "\u22F3",
      isinv: "\u2208",
      it: "\u2062",
      Itilde: "\u0128",
      itilde: "\u0129",
      Iukcy: "\u0406",
      iukcy: "\u0456",
      Iuml: "\xCF",
      iuml: "\xEF",
      Jcirc: "\u0134",
      jcirc: "\u0135",
      Jcy: "\u0419",
      jcy: "\u0439",
      Jfr: "\u{1D50D}",
      jfr: "\u{1D527}",
      jmath: "\u0237",
      Jopf: "\u{1D541}",
      jopf: "\u{1D55B}",
      Jscr: "\u{1D4A5}",
      jscr: "\u{1D4BF}",
      Jsercy: "\u0408",
      jsercy: "\u0458",
      Jukcy: "\u0404",
      jukcy: "\u0454",
      Kappa: "\u039A",
      kappa: "\u03BA",
      kappav: "\u03F0",
      Kcedil: "\u0136",
      kcedil: "\u0137",
      Kcy: "\u041A",
      kcy: "\u043A",
      Kfr: "\u{1D50E}",
      kfr: "\u{1D528}",
      kgreen: "\u0138",
      KHcy: "\u0425",
      khcy: "\u0445",
      KJcy: "\u040C",
      kjcy: "\u045C",
      Kopf: "\u{1D542}",
      kopf: "\u{1D55C}",
      Kscr: "\u{1D4A6}",
      kscr: "\u{1D4C0}",
      lAarr: "\u21DA",
      Lacute: "\u0139",
      lacute: "\u013A",
      laemptyv: "\u29B4",
      lagran: "\u2112",
      Lambda: "\u039B",
      lambda: "\u03BB",
      Lang: "\u27EA",
      lang: "\u27E8",
      langd: "\u2991",
      langle: "\u27E8",
      lap: "\u2A85",
      Laplacetrf: "\u2112",
      laquo: "\xAB",
      Larr: "\u219E",
      lArr: "\u21D0",
      larr: "\u2190",
      larrb: "\u21E4",
      larrbfs: "\u291F",
      larrfs: "\u291D",
      larrhk: "\u21A9",
      larrlp: "\u21AB",
      larrpl: "\u2939",
      larrsim: "\u2973",
      larrtl: "\u21A2",
      lat: "\u2AAB",
      lAtail: "\u291B",
      latail: "\u2919",
      late: "\u2AAD",
      lates: "\u2AAD\uFE00",
      lBarr: "\u290E",
      lbarr: "\u290C",
      lbbrk: "\u2772",
      lbrace: "{",
      lbrack: "[",
      lbrke: "\u298B",
      lbrksld: "\u298F",
      lbrkslu: "\u298D",
      Lcaron: "\u013D",
      lcaron: "\u013E",
      Lcedil: "\u013B",
      lcedil: "\u013C",
      lceil: "\u2308",
      lcub: "{",
      Lcy: "\u041B",
      lcy: "\u043B",
      ldca: "\u2936",
      ldquo: "\u201C",
      ldquor: "\u201E",
      ldrdhar: "\u2967",
      ldrushar: "\u294B",
      ldsh: "\u21B2",
      lE: "\u2266",
      le: "\u2264",
      LeftAngleBracket: "\u27E8",
      LeftArrow: "\u2190",
      Leftarrow: "\u21D0",
      leftarrow: "\u2190",
      LeftArrowBar: "\u21E4",
      LeftArrowRightArrow: "\u21C6",
      leftarrowtail: "\u21A2",
      LeftCeiling: "\u2308",
      LeftDoubleBracket: "\u27E6",
      LeftDownTeeVector: "\u2961",
      LeftDownVector: "\u21C3",
      LeftDownVectorBar: "\u2959",
      LeftFloor: "\u230A",
      leftharpoondown: "\u21BD",
      leftharpoonup: "\u21BC",
      leftleftarrows: "\u21C7",
      LeftRightArrow: "\u2194",
      Leftrightarrow: "\u21D4",
      leftrightarrow: "\u2194",
      leftrightarrows: "\u21C6",
      leftrightharpoons: "\u21CB",
      leftrightsquigarrow: "\u21AD",
      LeftRightVector: "\u294E",
      LeftTee: "\u22A3",
      LeftTeeArrow: "\u21A4",
      LeftTeeVector: "\u295A",
      leftthreetimes: "\u22CB",
      LeftTriangle: "\u22B2",
      LeftTriangleBar: "\u29CF",
      LeftTriangleEqual: "\u22B4",
      LeftUpDownVector: "\u2951",
      LeftUpTeeVector: "\u2960",
      LeftUpVector: "\u21BF",
      LeftUpVectorBar: "\u2958",
      LeftVector: "\u21BC",
      LeftVectorBar: "\u2952",
      lEg: "\u2A8B",
      leg: "\u22DA",
      leq: "\u2264",
      leqq: "\u2266",
      leqslant: "\u2A7D",
      les: "\u2A7D",
      lescc: "\u2AA8",
      lesdot: "\u2A7F",
      lesdoto: "\u2A81",
      lesdotor: "\u2A83",
      lesg: "\u22DA\uFE00",
      lesges: "\u2A93",
      lessapprox: "\u2A85",
      lessdot: "\u22D6",
      lesseqgtr: "\u22DA",
      lesseqqgtr: "\u2A8B",
      LessEqualGreater: "\u22DA",
      LessFullEqual: "\u2266",
      LessGreater: "\u2276",
      lessgtr: "\u2276",
      LessLess: "\u2AA1",
      lesssim: "\u2272",
      LessSlantEqual: "\u2A7D",
      LessTilde: "\u2272",
      lfisht: "\u297C",
      lfloor: "\u230A",
      Lfr: "\u{1D50F}",
      lfr: "\u{1D529}",
      lg: "\u2276",
      lgE: "\u2A91",
      lHar: "\u2962",
      lhard: "\u21BD",
      lharu: "\u21BC",
      lharul: "\u296A",
      lhblk: "\u2584",
      LJcy: "\u0409",
      ljcy: "\u0459",
      Ll: "\u22D8",
      ll: "\u226A",
      llarr: "\u21C7",
      llcorner: "\u231E",
      Lleftarrow: "\u21DA",
      llhard: "\u296B",
      lltri: "\u25FA",
      Lmidot: "\u013F",
      lmidot: "\u0140",
      lmoust: "\u23B0",
      lmoustache: "\u23B0",
      lnap: "\u2A89",
      lnapprox: "\u2A89",
      lnE: "\u2268",
      lne: "\u2A87",
      lneq: "\u2A87",
      lneqq: "\u2268",
      lnsim: "\u22E6",
      loang: "\u27EC",
      loarr: "\u21FD",
      lobrk: "\u27E6",
      LongLeftArrow: "\u27F5",
      Longleftarrow: "\u27F8",
      longleftarrow: "\u27F5",
      LongLeftRightArrow: "\u27F7",
      Longleftrightarrow: "\u27FA",
      longleftrightarrow: "\u27F7",
      longmapsto: "\u27FC",
      LongRightArrow: "\u27F6",
      Longrightarrow: "\u27F9",
      longrightarrow: "\u27F6",
      looparrowleft: "\u21AB",
      looparrowright: "\u21AC",
      lopar: "\u2985",
      Lopf: "\u{1D543}",
      lopf: "\u{1D55D}",
      loplus: "\u2A2D",
      lotimes: "\u2A34",
      lowast: "\u2217",
      lowbar: "_",
      LowerLeftArrow: "\u2199",
      LowerRightArrow: "\u2198",
      loz: "\u25CA",
      lozenge: "\u25CA",
      lozf: "\u29EB",
      lpar: "(",
      lparlt: "\u2993",
      lrarr: "\u21C6",
      lrcorner: "\u231F",
      lrhar: "\u21CB",
      lrhard: "\u296D",
      lrm: "\u200E",
      lrtri: "\u22BF",
      lsaquo: "\u2039",
      Lscr: "\u2112",
      lscr: "\u{1D4C1}",
      Lsh: "\u21B0",
      lsh: "\u21B0",
      lsim: "\u2272",
      lsime: "\u2A8D",
      lsimg: "\u2A8F",
      lsqb: "[",
      lsquo: "\u2018",
      lsquor: "\u201A",
      Lstrok: "\u0141",
      lstrok: "\u0142",
      Lt: "\u226A",
      LT: "<",
      lt: "<",
      ltcc: "\u2AA6",
      ltcir: "\u2A79",
      ltdot: "\u22D6",
      lthree: "\u22CB",
      ltimes: "\u22C9",
      ltlarr: "\u2976",
      ltquest: "\u2A7B",
      ltri: "\u25C3",
      ltrie: "\u22B4",
      ltrif: "\u25C2",
      ltrPar: "\u2996",
      lurdshar: "\u294A",
      luruhar: "\u2966",
      lvertneqq: "\u2268\uFE00",
      lvnE: "\u2268\uFE00",
      macr: "\xAF",
      male: "\u2642",
      malt: "\u2720",
      maltese: "\u2720",
      Map: "\u2905",
      map: "\u21A6",
      mapsto: "\u21A6",
      mapstodown: "\u21A7",
      mapstoleft: "\u21A4",
      mapstoup: "\u21A5",
      marker: "\u25AE",
      mcomma: "\u2A29",
      Mcy: "\u041C",
      mcy: "\u043C",
      mdash: "\u2014",
      mDDot: "\u223A",
      measuredangle: "\u2221",
      MediumSpace: "\u205F",
      Mellintrf: "\u2133",
      Mfr: "\u{1D510}",
      mfr: "\u{1D52A}",
      mho: "\u2127",
      micro: "\xB5",
      mid: "\u2223",
      midast: "*",
      midcir: "\u2AF0",
      middot: "\xB7",
      minus: "\u2212",
      minusb: "\u229F",
      minusd: "\u2238",
      minusdu: "\u2A2A",
      MinusPlus: "\u2213",
      mlcp: "\u2ADB",
      mldr: "\u2026",
      mnplus: "\u2213",
      models: "\u22A7",
      Mopf: "\u{1D544}",
      mopf: "\u{1D55E}",
      mp: "\u2213",
      Mscr: "\u2133",
      mscr: "\u{1D4C2}",
      mstpos: "\u223E",
      Mu: "\u039C",
      mu: "\u03BC",
      multimap: "\u22B8",
      mumap: "\u22B8",
      nabla: "\u2207",
      Nacute: "\u0143",
      nacute: "\u0144",
      nang: "\u2220\u20D2",
      nap: "\u2249",
      napE: "\u2A70\u0338",
      napid: "\u224B\u0338",
      napos: "\u0149",
      napprox: "\u2249",
      natur: "\u266E",
      natural: "\u266E",
      naturals: "\u2115",
      nbsp: "\xA0",
      nbump: "\u224E\u0338",
      nbumpe: "\u224F\u0338",
      ncap: "\u2A43",
      Ncaron: "\u0147",
      ncaron: "\u0148",
      Ncedil: "\u0145",
      ncedil: "\u0146",
      ncong: "\u2247",
      ncongdot: "\u2A6D\u0338",
      ncup: "\u2A42",
      Ncy: "\u041D",
      ncy: "\u043D",
      ndash: "\u2013",
      ne: "\u2260",
      nearhk: "\u2924",
      neArr: "\u21D7",
      nearr: "\u2197",
      nearrow: "\u2197",
      nedot: "\u2250\u0338",
      NegativeMediumSpace: "\u200B",
      NegativeThickSpace: "\u200B",
      NegativeThinSpace: "\u200B",
      NegativeVeryThinSpace: "\u200B",
      nequiv: "\u2262",
      nesear: "\u2928",
      nesim: "\u2242\u0338",
      NestedGreaterGreater: "\u226B",
      NestedLessLess: "\u226A",
      NewLine: "\n",
      nexist: "\u2204",
      nexists: "\u2204",
      Nfr: "\u{1D511}",
      nfr: "\u{1D52B}",
      ngE: "\u2267\u0338",
      nge: "\u2271",
      ngeq: "\u2271",
      ngeqq: "\u2267\u0338",
      ngeqslant: "\u2A7E\u0338",
      nges: "\u2A7E\u0338",
      nGg: "\u22D9\u0338",
      ngsim: "\u2275",
      nGt: "\u226B\u20D2",
      ngt: "\u226F",
      ngtr: "\u226F",
      nGtv: "\u226B\u0338",
      nhArr: "\u21CE",
      nharr: "\u21AE",
      nhpar: "\u2AF2",
      ni: "\u220B",
      nis: "\u22FC",
      nisd: "\u22FA",
      niv: "\u220B",
      NJcy: "\u040A",
      njcy: "\u045A",
      nlArr: "\u21CD",
      nlarr: "\u219A",
      nldr: "\u2025",
      nlE: "\u2266\u0338",
      nle: "\u2270",
      nLeftarrow: "\u21CD",
      nleftarrow: "\u219A",
      nLeftrightarrow: "\u21CE",
      nleftrightarrow: "\u21AE",
      nleq: "\u2270",
      nleqq: "\u2266\u0338",
      nleqslant: "\u2A7D\u0338",
      nles: "\u2A7D\u0338",
      nless: "\u226E",
      nLl: "\u22D8\u0338",
      nlsim: "\u2274",
      nLt: "\u226A\u20D2",
      nlt: "\u226E",
      nltri: "\u22EA",
      nltrie: "\u22EC",
      nLtv: "\u226A\u0338",
      nmid: "\u2224",
      NoBreak: "\u2060",
      NonBreakingSpace: "\xA0",
      Nopf: "\u2115",
      nopf: "\u{1D55F}",
      Not: "\u2AEC",
      not: "\xAC",
      NotCongruent: "\u2262",
      NotCupCap: "\u226D",
      NotDoubleVerticalBar: "\u2226",
      NotElement: "\u2209",
      NotEqual: "\u2260",
      NotEqualTilde: "\u2242\u0338",
      NotExists: "\u2204",
      NotGreater: "\u226F",
      NotGreaterEqual: "\u2271",
      NotGreaterFullEqual: "\u2267\u0338",
      NotGreaterGreater: "\u226B\u0338",
      NotGreaterLess: "\u2279",
      NotGreaterSlantEqual: "\u2A7E\u0338",
      NotGreaterTilde: "\u2275",
      NotHumpDownHump: "\u224E\u0338",
      NotHumpEqual: "\u224F\u0338",
      notin: "\u2209",
      notindot: "\u22F5\u0338",
      notinE: "\u22F9\u0338",
      notinva: "\u2209",
      notinvb: "\u22F7",
      notinvc: "\u22F6",
      NotLeftTriangle: "\u22EA",
      NotLeftTriangleBar: "\u29CF\u0338",
      NotLeftTriangleEqual: "\u22EC",
      NotLess: "\u226E",
      NotLessEqual: "\u2270",
      NotLessGreater: "\u2278",
      NotLessLess: "\u226A\u0338",
      NotLessSlantEqual: "\u2A7D\u0338",
      NotLessTilde: "\u2274",
      NotNestedGreaterGreater: "\u2AA2\u0338",
      NotNestedLessLess: "\u2AA1\u0338",
      notni: "\u220C",
      notniva: "\u220C",
      notnivb: "\u22FE",
      notnivc: "\u22FD",
      NotPrecedes: "\u2280",
      NotPrecedesEqual: "\u2AAF\u0338",
      NotPrecedesSlantEqual: "\u22E0",
      NotReverseElement: "\u220C",
      NotRightTriangle: "\u22EB",
      NotRightTriangleBar: "\u29D0\u0338",
      NotRightTriangleEqual: "\u22ED",
      NotSquareSubset: "\u228F\u0338",
      NotSquareSubsetEqual: "\u22E2",
      NotSquareSuperset: "\u2290\u0338",
      NotSquareSupersetEqual: "\u22E3",
      NotSubset: "\u2282\u20D2",
      NotSubsetEqual: "\u2288",
      NotSucceeds: "\u2281",
      NotSucceedsEqual: "\u2AB0\u0338",
      NotSucceedsSlantEqual: "\u22E1",
      NotSucceedsTilde: "\u227F\u0338",
      NotSuperset: "\u2283\u20D2",
      NotSupersetEqual: "\u2289",
      NotTilde: "\u2241",
      NotTildeEqual: "\u2244",
      NotTildeFullEqual: "\u2247",
      NotTildeTilde: "\u2249",
      NotVerticalBar: "\u2224",
      npar: "\u2226",
      nparallel: "\u2226",
      nparsl: "\u2AFD\u20E5",
      npart: "\u2202\u0338",
      npolint: "\u2A14",
      npr: "\u2280",
      nprcue: "\u22E0",
      npre: "\u2AAF\u0338",
      nprec: "\u2280",
      npreceq: "\u2AAF\u0338",
      nrArr: "\u21CF",
      nrarr: "\u219B",
      nrarrc: "\u2933\u0338",
      nrarrw: "\u219D\u0338",
      nRightarrow: "\u21CF",
      nrightarrow: "\u219B",
      nrtri: "\u22EB",
      nrtrie: "\u22ED",
      nsc: "\u2281",
      nsccue: "\u22E1",
      nsce: "\u2AB0\u0338",
      Nscr: "\u{1D4A9}",
      nscr: "\u{1D4C3}",
      nshortmid: "\u2224",
      nshortparallel: "\u2226",
      nsim: "\u2241",
      nsime: "\u2244",
      nsimeq: "\u2244",
      nsmid: "\u2224",
      nspar: "\u2226",
      nsqsube: "\u22E2",
      nsqsupe: "\u22E3",
      nsub: "\u2284",
      nsubE: "\u2AC5\u0338",
      nsube: "\u2288",
      nsubset: "\u2282\u20D2",
      nsubseteq: "\u2288",
      nsubseteqq: "\u2AC5\u0338",
      nsucc: "\u2281",
      nsucceq: "\u2AB0\u0338",
      nsup: "\u2285",
      nsupE: "\u2AC6\u0338",
      nsupe: "\u2289",
      nsupset: "\u2283\u20D2",
      nsupseteq: "\u2289",
      nsupseteqq: "\u2AC6\u0338",
      ntgl: "\u2279",
      Ntilde: "\xD1",
      ntilde: "\xF1",
      ntlg: "\u2278",
      ntriangleleft: "\u22EA",
      ntrianglelefteq: "\u22EC",
      ntriangleright: "\u22EB",
      ntrianglerighteq: "\u22ED",
      Nu: "\u039D",
      nu: "\u03BD",
      num: "#",
      numero: "\u2116",
      numsp: "\u2007",
      nvap: "\u224D\u20D2",
      nVDash: "\u22AF",
      nVdash: "\u22AE",
      nvDash: "\u22AD",
      nvdash: "\u22AC",
      nvge: "\u2265\u20D2",
      nvgt: ">\u20D2",
      nvHarr: "\u2904",
      nvinfin: "\u29DE",
      nvlArr: "\u2902",
      nvle: "\u2264\u20D2",
      nvlt: "<\u20D2",
      nvltrie: "\u22B4\u20D2",
      nvrArr: "\u2903",
      nvrtrie: "\u22B5\u20D2",
      nvsim: "\u223C\u20D2",
      nwarhk: "\u2923",
      nwArr: "\u21D6",
      nwarr: "\u2196",
      nwarrow: "\u2196",
      nwnear: "\u2927",
      Oacute: "\xD3",
      oacute: "\xF3",
      oast: "\u229B",
      ocir: "\u229A",
      Ocirc: "\xD4",
      ocirc: "\xF4",
      Ocy: "\u041E",
      ocy: "\u043E",
      odash: "\u229D",
      Odblac: "\u0150",
      odblac: "\u0151",
      odiv: "\u2A38",
      odot: "\u2299",
      odsold: "\u29BC",
      OElig: "\u0152",
      oelig: "\u0153",
      ofcir: "\u29BF",
      Ofr: "\u{1D512}",
      ofr: "\u{1D52C}",
      ogon: "\u02DB",
      Ograve: "\xD2",
      ograve: "\xF2",
      ogt: "\u29C1",
      ohbar: "\u29B5",
      ohm: "\u03A9",
      oint: "\u222E",
      olarr: "\u21BA",
      olcir: "\u29BE",
      olcross: "\u29BB",
      oline: "\u203E",
      olt: "\u29C0",
      Omacr: "\u014C",
      omacr: "\u014D",
      Omega: "\u03A9",
      omega: "\u03C9",
      Omicron: "\u039F",
      omicron: "\u03BF",
      omid: "\u29B6",
      ominus: "\u2296",
      Oopf: "\u{1D546}",
      oopf: "\u{1D560}",
      opar: "\u29B7",
      OpenCurlyDoubleQuote: "\u201C",
      OpenCurlyQuote: "\u2018",
      operp: "\u29B9",
      oplus: "\u2295",
      Or: "\u2A54",
      or: "\u2228",
      orarr: "\u21BB",
      ord: "\u2A5D",
      order: "\u2134",
      orderof: "\u2134",
      ordf: "\xAA",
      ordm: "\xBA",
      origof: "\u22B6",
      oror: "\u2A56",
      orslope: "\u2A57",
      orv: "\u2A5B",
      oS: "\u24C8",
      Oscr: "\u{1D4AA}",
      oscr: "\u2134",
      Oslash: "\xD8",
      oslash: "\xF8",
      osol: "\u2298",
      Otilde: "\xD5",
      otilde: "\xF5",
      Otimes: "\u2A37",
      otimes: "\u2297",
      otimesas: "\u2A36",
      Ouml: "\xD6",
      ouml: "\xF6",
      ovbar: "\u233D",
      OverBar: "\u203E",
      OverBrace: "\u23DE",
      OverBracket: "\u23B4",
      OverParenthesis: "\u23DC",
      par: "\u2225",
      para: "\xB6",
      parallel: "\u2225",
      parsim: "\u2AF3",
      parsl: "\u2AFD",
      part: "\u2202",
      PartialD: "\u2202",
      Pcy: "\u041F",
      pcy: "\u043F",
      percnt: "%",
      period: ".",
      permil: "\u2030",
      perp: "\u22A5",
      pertenk: "\u2031",
      Pfr: "\u{1D513}",
      pfr: "\u{1D52D}",
      Phi: "\u03A6",
      phi: "\u03C6",
      phiv: "\u03D5",
      phmmat: "\u2133",
      phone: "\u260E",
      Pi: "\u03A0",
      pi: "\u03C0",
      pitchfork: "\u22D4",
      piv: "\u03D6",
      planck: "\u210F",
      planckh: "\u210E",
      plankv: "\u210F",
      plus: "+",
      plusacir: "\u2A23",
      plusb: "\u229E",
      pluscir: "\u2A22",
      plusdo: "\u2214",
      plusdu: "\u2A25",
      pluse: "\u2A72",
      PlusMinus: "\xB1",
      plusmn: "\xB1",
      plussim: "\u2A26",
      plustwo: "\u2A27",
      pm: "\xB1",
      Poincareplane: "\u210C",
      pointint: "\u2A15",
      Popf: "\u2119",
      popf: "\u{1D561}",
      pound: "\xA3",
      Pr: "\u2ABB",
      pr: "\u227A",
      prap: "\u2AB7",
      prcue: "\u227C",
      prE: "\u2AB3",
      pre: "\u2AAF",
      prec: "\u227A",
      precapprox: "\u2AB7",
      preccurlyeq: "\u227C",
      Precedes: "\u227A",
      PrecedesEqual: "\u2AAF",
      PrecedesSlantEqual: "\u227C",
      PrecedesTilde: "\u227E",
      preceq: "\u2AAF",
      precnapprox: "\u2AB9",
      precneqq: "\u2AB5",
      precnsim: "\u22E8",
      precsim: "\u227E",
      Prime: "\u2033",
      prime: "\u2032",
      primes: "\u2119",
      prnap: "\u2AB9",
      prnE: "\u2AB5",
      prnsim: "\u22E8",
      prod: "\u220F",
      Product: "\u220F",
      profalar: "\u232E",
      profline: "\u2312",
      profsurf: "\u2313",
      prop: "\u221D",
      Proportion: "\u2237",
      Proportional: "\u221D",
      propto: "\u221D",
      prsim: "\u227E",
      prurel: "\u22B0",
      Pscr: "\u{1D4AB}",
      pscr: "\u{1D4C5}",
      Psi: "\u03A8",
      psi: "\u03C8",
      puncsp: "\u2008",
      Qfr: "\u{1D514}",
      qfr: "\u{1D52E}",
      qint: "\u2A0C",
      Qopf: "\u211A",
      qopf: "\u{1D562}",
      qprime: "\u2057",
      Qscr: "\u{1D4AC}",
      qscr: "\u{1D4C6}",
      quaternions: "\u210D",
      quatint: "\u2A16",
      quest: "?",
      questeq: "\u225F",
      QUOT: '"',
      quot: '"',
      rAarr: "\u21DB",
      race: "\u223D\u0331",
      Racute: "\u0154",
      racute: "\u0155",
      radic: "\u221A",
      raemptyv: "\u29B3",
      Rang: "\u27EB",
      rang: "\u27E9",
      rangd: "\u2992",
      range: "\u29A5",
      rangle: "\u27E9",
      raquo: "\xBB",
      Rarr: "\u21A0",
      rArr: "\u21D2",
      rarr: "\u2192",
      rarrap: "\u2975",
      rarrb: "\u21E5",
      rarrbfs: "\u2920",
      rarrc: "\u2933",
      rarrfs: "\u291E",
      rarrhk: "\u21AA",
      rarrlp: "\u21AC",
      rarrpl: "\u2945",
      rarrsim: "\u2974",
      Rarrtl: "\u2916",
      rarrtl: "\u21A3",
      rarrw: "\u219D",
      rAtail: "\u291C",
      ratail: "\u291A",
      ratio: "\u2236",
      rationals: "\u211A",
      RBarr: "\u2910",
      rBarr: "\u290F",
      rbarr: "\u290D",
      rbbrk: "\u2773",
      rbrace: "}",
      rbrack: "]",
      rbrke: "\u298C",
      rbrksld: "\u298E",
      rbrkslu: "\u2990",
      Rcaron: "\u0158",
      rcaron: "\u0159",
      Rcedil: "\u0156",
      rcedil: "\u0157",
      rceil: "\u2309",
      rcub: "}",
      Rcy: "\u0420",
      rcy: "\u0440",
      rdca: "\u2937",
      rdldhar: "\u2969",
      rdquo: "\u201D",
      rdquor: "\u201D",
      rdsh: "\u21B3",
      Re: "\u211C",
      real: "\u211C",
      realine: "\u211B",
      realpart: "\u211C",
      reals: "\u211D",
      rect: "\u25AD",
      REG: "\xAE",
      reg: "\xAE",
      ReverseElement: "\u220B",
      ReverseEquilibrium: "\u21CB",
      ReverseUpEquilibrium: "\u296F",
      rfisht: "\u297D",
      rfloor: "\u230B",
      Rfr: "\u211C",
      rfr: "\u{1D52F}",
      rHar: "\u2964",
      rhard: "\u21C1",
      rharu: "\u21C0",
      rharul: "\u296C",
      Rho: "\u03A1",
      rho: "\u03C1",
      rhov: "\u03F1",
      RightAngleBracket: "\u27E9",
      RightArrow: "\u2192",
      Rightarrow: "\u21D2",
      rightarrow: "\u2192",
      RightArrowBar: "\u21E5",
      RightArrowLeftArrow: "\u21C4",
      rightarrowtail: "\u21A3",
      RightCeiling: "\u2309",
      RightDoubleBracket: "\u27E7",
      RightDownTeeVector: "\u295D",
      RightDownVector: "\u21C2",
      RightDownVectorBar: "\u2955",
      RightFloor: "\u230B",
      rightharpoondown: "\u21C1",
      rightharpoonup: "\u21C0",
      rightleftarrows: "\u21C4",
      rightleftharpoons: "\u21CC",
      rightrightarrows: "\u21C9",
      rightsquigarrow: "\u219D",
      RightTee: "\u22A2",
      RightTeeArrow: "\u21A6",
      RightTeeVector: "\u295B",
      rightthreetimes: "\u22CC",
      RightTriangle: "\u22B3",
      RightTriangleBar: "\u29D0",
      RightTriangleEqual: "\u22B5",
      RightUpDownVector: "\u294F",
      RightUpTeeVector: "\u295C",
      RightUpVector: "\u21BE",
      RightUpVectorBar: "\u2954",
      RightVector: "\u21C0",
      RightVectorBar: "\u2953",
      ring: "\u02DA",
      risingdotseq: "\u2253",
      rlarr: "\u21C4",
      rlhar: "\u21CC",
      rlm: "\u200F",
      rmoust: "\u23B1",
      rmoustache: "\u23B1",
      rnmid: "\u2AEE",
      roang: "\u27ED",
      roarr: "\u21FE",
      robrk: "\u27E7",
      ropar: "\u2986",
      Ropf: "\u211D",
      ropf: "\u{1D563}",
      roplus: "\u2A2E",
      rotimes: "\u2A35",
      RoundImplies: "\u2970",
      rpar: ")",
      rpargt: "\u2994",
      rppolint: "\u2A12",
      rrarr: "\u21C9",
      Rrightarrow: "\u21DB",
      rsaquo: "\u203A",
      Rscr: "\u211B",
      rscr: "\u{1D4C7}",
      Rsh: "\u21B1",
      rsh: "\u21B1",
      rsqb: "]",
      rsquo: "\u2019",
      rsquor: "\u2019",
      rthree: "\u22CC",
      rtimes: "\u22CA",
      rtri: "\u25B9",
      rtrie: "\u22B5",
      rtrif: "\u25B8",
      rtriltri: "\u29CE",
      RuleDelayed: "\u29F4",
      ruluhar: "\u2968",
      rx: "\u211E",
      Sacute: "\u015A",
      sacute: "\u015B",
      sbquo: "\u201A",
      Sc: "\u2ABC",
      sc: "\u227B",
      scap: "\u2AB8",
      Scaron: "\u0160",
      scaron: "\u0161",
      sccue: "\u227D",
      scE: "\u2AB4",
      sce: "\u2AB0",
      Scedil: "\u015E",
      scedil: "\u015F",
      Scirc: "\u015C",
      scirc: "\u015D",
      scnap: "\u2ABA",
      scnE: "\u2AB6",
      scnsim: "\u22E9",
      scpolint: "\u2A13",
      scsim: "\u227F",
      Scy: "\u0421",
      scy: "\u0441",
      sdot: "\u22C5",
      sdotb: "\u22A1",
      sdote: "\u2A66",
      searhk: "\u2925",
      seArr: "\u21D8",
      searr: "\u2198",
      searrow: "\u2198",
      sect: "\xA7",
      semi: ";",
      seswar: "\u2929",
      setminus: "\u2216",
      setmn: "\u2216",
      sext: "\u2736",
      Sfr: "\u{1D516}",
      sfr: "\u{1D530}",
      sfrown: "\u2322",
      sharp: "\u266F",
      SHCHcy: "\u0429",
      shchcy: "\u0449",
      SHcy: "\u0428",
      shcy: "\u0448",
      ShortDownArrow: "\u2193",
      ShortLeftArrow: "\u2190",
      shortmid: "\u2223",
      shortparallel: "\u2225",
      ShortRightArrow: "\u2192",
      ShortUpArrow: "\u2191",
      shy: "\xAD",
      Sigma: "\u03A3",
      sigma: "\u03C3",
      sigmaf: "\u03C2",
      sigmav: "\u03C2",
      sim: "\u223C",
      simdot: "\u2A6A",
      sime: "\u2243",
      simeq: "\u2243",
      simg: "\u2A9E",
      simgE: "\u2AA0",
      siml: "\u2A9D",
      simlE: "\u2A9F",
      simne: "\u2246",
      simplus: "\u2A24",
      simrarr: "\u2972",
      slarr: "\u2190",
      SmallCircle: "\u2218",
      smallsetminus: "\u2216",
      smashp: "\u2A33",
      smeparsl: "\u29E4",
      smid: "\u2223",
      smile: "\u2323",
      smt: "\u2AAA",
      smte: "\u2AAC",
      smtes: "\u2AAC\uFE00",
      SOFTcy: "\u042C",
      softcy: "\u044C",
      sol: "/",
      solb: "\u29C4",
      solbar: "\u233F",
      Sopf: "\u{1D54A}",
      sopf: "\u{1D564}",
      spades: "\u2660",
      spadesuit: "\u2660",
      spar: "\u2225",
      sqcap: "\u2293",
      sqcaps: "\u2293\uFE00",
      sqcup: "\u2294",
      sqcups: "\u2294\uFE00",
      Sqrt: "\u221A",
      sqsub: "\u228F",
      sqsube: "\u2291",
      sqsubset: "\u228F",
      sqsubseteq: "\u2291",
      sqsup: "\u2290",
      sqsupe: "\u2292",
      sqsupset: "\u2290",
      sqsupseteq: "\u2292",
      squ: "\u25A1",
      Square: "\u25A1",
      square: "\u25A1",
      SquareIntersection: "\u2293",
      SquareSubset: "\u228F",
      SquareSubsetEqual: "\u2291",
      SquareSuperset: "\u2290",
      SquareSupersetEqual: "\u2292",
      SquareUnion: "\u2294",
      squarf: "\u25AA",
      squf: "\u25AA",
      srarr: "\u2192",
      Sscr: "\u{1D4AE}",
      sscr: "\u{1D4C8}",
      ssetmn: "\u2216",
      ssmile: "\u2323",
      sstarf: "\u22C6",
      Star: "\u22C6",
      star: "\u2606",
      starf: "\u2605",
      straightepsilon: "\u03F5",
      straightphi: "\u03D5",
      strns: "\xAF",
      Sub: "\u22D0",
      sub: "\u2282",
      subdot: "\u2ABD",
      subE: "\u2AC5",
      sube: "\u2286",
      subedot: "\u2AC3",
      submult: "\u2AC1",
      subnE: "\u2ACB",
      subne: "\u228A",
      subplus: "\u2ABF",
      subrarr: "\u2979",
      Subset: "\u22D0",
      subset: "\u2282",
      subseteq: "\u2286",
      subseteqq: "\u2AC5",
      SubsetEqual: "\u2286",
      subsetneq: "\u228A",
      subsetneqq: "\u2ACB",
      subsim: "\u2AC7",
      subsub: "\u2AD5",
      subsup: "\u2AD3",
      succ: "\u227B",
      succapprox: "\u2AB8",
      succcurlyeq: "\u227D",
      Succeeds: "\u227B",
      SucceedsEqual: "\u2AB0",
      SucceedsSlantEqual: "\u227D",
      SucceedsTilde: "\u227F",
      succeq: "\u2AB0",
      succnapprox: "\u2ABA",
      succneqq: "\u2AB6",
      succnsim: "\u22E9",
      succsim: "\u227F",
      SuchThat: "\u220B",
      Sum: "\u2211",
      sum: "\u2211",
      sung: "\u266A",
      Sup: "\u22D1",
      sup: "\u2283",
      sup1: "\xB9",
      sup2: "\xB2",
      sup3: "\xB3",
      supdot: "\u2ABE",
      supdsub: "\u2AD8",
      supE: "\u2AC6",
      supe: "\u2287",
      supedot: "\u2AC4",
      Superset: "\u2283",
      SupersetEqual: "\u2287",
      suphsol: "\u27C9",
      suphsub: "\u2AD7",
      suplarr: "\u297B",
      supmult: "\u2AC2",
      supnE: "\u2ACC",
      supne: "\u228B",
      supplus: "\u2AC0",
      Supset: "\u22D1",
      supset: "\u2283",
      supseteq: "\u2287",
      supseteqq: "\u2AC6",
      supsetneq: "\u228B",
      supsetneqq: "\u2ACC",
      supsim: "\u2AC8",
      supsub: "\u2AD4",
      supsup: "\u2AD6",
      swarhk: "\u2926",
      swArr: "\u21D9",
      swarr: "\u2199",
      swarrow: "\u2199",
      swnwar: "\u292A",
      szlig: "\xDF",
      Tab: "	",
      target: "\u2316",
      Tau: "\u03A4",
      tau: "\u03C4",
      tbrk: "\u23B4",
      Tcaron: "\u0164",
      tcaron: "\u0165",
      Tcedil: "\u0162",
      tcedil: "\u0163",
      Tcy: "\u0422",
      tcy: "\u0442",
      tdot: "\u20DB",
      telrec: "\u2315",
      Tfr: "\u{1D517}",
      tfr: "\u{1D531}",
      there4: "\u2234",
      Therefore: "\u2234",
      therefore: "\u2234",
      Theta: "\u0398",
      theta: "\u03B8",
      thetasym: "\u03D1",
      thetav: "\u03D1",
      thickapprox: "\u2248",
      thicksim: "\u223C",
      ThickSpace: "\u205F\u200A",
      thinsp: "\u2009",
      ThinSpace: "\u2009",
      thkap: "\u2248",
      thksim: "\u223C",
      THORN: "\xDE",
      thorn: "\xFE",
      Tilde: "\u223C",
      tilde: "\u02DC",
      TildeEqual: "\u2243",
      TildeFullEqual: "\u2245",
      TildeTilde: "\u2248",
      times: "\xD7",
      timesb: "\u22A0",
      timesbar: "\u2A31",
      timesd: "\u2A30",
      tint: "\u222D",
      toea: "\u2928",
      top: "\u22A4",
      topbot: "\u2336",
      topcir: "\u2AF1",
      Topf: "\u{1D54B}",
      topf: "\u{1D565}",
      topfork: "\u2ADA",
      tosa: "\u2929",
      tprime: "\u2034",
      TRADE: "\u2122",
      trade: "\u2122",
      triangle: "\u25B5",
      triangledown: "\u25BF",
      triangleleft: "\u25C3",
      trianglelefteq: "\u22B4",
      triangleq: "\u225C",
      triangleright: "\u25B9",
      trianglerighteq: "\u22B5",
      tridot: "\u25EC",
      trie: "\u225C",
      triminus: "\u2A3A",
      TripleDot: "\u20DB",
      triplus: "\u2A39",
      trisb: "\u29CD",
      tritime: "\u2A3B",
      trpezium: "\u23E2",
      Tscr: "\u{1D4AF}",
      tscr: "\u{1D4C9}",
      TScy: "\u0426",
      tscy: "\u0446",
      TSHcy: "\u040B",
      tshcy: "\u045B",
      Tstrok: "\u0166",
      tstrok: "\u0167",
      twixt: "\u226C",
      twoheadleftarrow: "\u219E",
      twoheadrightarrow: "\u21A0",
      Uacute: "\xDA",
      uacute: "\xFA",
      Uarr: "\u219F",
      uArr: "\u21D1",
      uarr: "\u2191",
      Uarrocir: "\u2949",
      Ubrcy: "\u040E",
      ubrcy: "\u045E",
      Ubreve: "\u016C",
      ubreve: "\u016D",
      Ucirc: "\xDB",
      ucirc: "\xFB",
      Ucy: "\u0423",
      ucy: "\u0443",
      udarr: "\u21C5",
      Udblac: "\u0170",
      udblac: "\u0171",
      udhar: "\u296E",
      ufisht: "\u297E",
      Ufr: "\u{1D518}",
      ufr: "\u{1D532}",
      Ugrave: "\xD9",
      ugrave: "\xF9",
      uHar: "\u2963",
      uharl: "\u21BF",
      uharr: "\u21BE",
      uhblk: "\u2580",
      ulcorn: "\u231C",
      ulcorner: "\u231C",
      ulcrop: "\u230F",
      ultri: "\u25F8",
      Umacr: "\u016A",
      umacr: "\u016B",
      uml: "\xA8",
      UnderBar: "_",
      UnderBrace: "\u23DF",
      UnderBracket: "\u23B5",
      UnderParenthesis: "\u23DD",
      Union: "\u22C3",
      UnionPlus: "\u228E",
      Uogon: "\u0172",
      uogon: "\u0173",
      Uopf: "\u{1D54C}",
      uopf: "\u{1D566}",
      UpArrow: "\u2191",
      Uparrow: "\u21D1",
      uparrow: "\u2191",
      UpArrowBar: "\u2912",
      UpArrowDownArrow: "\u21C5",
      UpDownArrow: "\u2195",
      Updownarrow: "\u21D5",
      updownarrow: "\u2195",
      UpEquilibrium: "\u296E",
      upharpoonleft: "\u21BF",
      upharpoonright: "\u21BE",
      uplus: "\u228E",
      UpperLeftArrow: "\u2196",
      UpperRightArrow: "\u2197",
      Upsi: "\u03D2",
      upsi: "\u03C5",
      upsih: "\u03D2",
      Upsilon: "\u03A5",
      upsilon: "\u03C5",
      UpTee: "\u22A5",
      UpTeeArrow: "\u21A5",
      upuparrows: "\u21C8",
      urcorn: "\u231D",
      urcorner: "\u231D",
      urcrop: "\u230E",
      Uring: "\u016E",
      uring: "\u016F",
      urtri: "\u25F9",
      Uscr: "\u{1D4B0}",
      uscr: "\u{1D4CA}",
      utdot: "\u22F0",
      Utilde: "\u0168",
      utilde: "\u0169",
      utri: "\u25B5",
      utrif: "\u25B4",
      uuarr: "\u21C8",
      Uuml: "\xDC",
      uuml: "\xFC",
      uwangle: "\u29A7",
      vangrt: "\u299C",
      varepsilon: "\u03F5",
      varkappa: "\u03F0",
      varnothing: "\u2205",
      varphi: "\u03D5",
      varpi: "\u03D6",
      varpropto: "\u221D",
      vArr: "\u21D5",
      varr: "\u2195",
      varrho: "\u03F1",
      varsigma: "\u03C2",
      varsubsetneq: "\u228A\uFE00",
      varsubsetneqq: "\u2ACB\uFE00",
      varsupsetneq: "\u228B\uFE00",
      varsupsetneqq: "\u2ACC\uFE00",
      vartheta: "\u03D1",
      vartriangleleft: "\u22B2",
      vartriangleright: "\u22B3",
      Vbar: "\u2AEB",
      vBar: "\u2AE8",
      vBarv: "\u2AE9",
      Vcy: "\u0412",
      vcy: "\u0432",
      VDash: "\u22AB",
      Vdash: "\u22A9",
      vDash: "\u22A8",
      vdash: "\u22A2",
      Vdashl: "\u2AE6",
      Vee: "\u22C1",
      vee: "\u2228",
      veebar: "\u22BB",
      veeeq: "\u225A",
      vellip: "\u22EE",
      Verbar: "\u2016",
      verbar: "|",
      Vert: "\u2016",
      vert: "|",
      VerticalBar: "\u2223",
      VerticalLine: "|",
      VerticalSeparator: "\u2758",
      VerticalTilde: "\u2240",
      VeryThinSpace: "\u200A",
      Vfr: "\u{1D519}",
      vfr: "\u{1D533}",
      vltri: "\u22B2",
      vnsub: "\u2282\u20D2",
      vnsup: "\u2283\u20D2",
      Vopf: "\u{1D54D}",
      vopf: "\u{1D567}",
      vprop: "\u221D",
      vrtri: "\u22B3",
      Vscr: "\u{1D4B1}",
      vscr: "\u{1D4CB}",
      vsubnE: "\u2ACB\uFE00",
      vsubne: "\u228A\uFE00",
      vsupnE: "\u2ACC\uFE00",
      vsupne: "\u228B\uFE00",
      Vvdash: "\u22AA",
      vzigzag: "\u299A",
      Wcirc: "\u0174",
      wcirc: "\u0175",
      wedbar: "\u2A5F",
      Wedge: "\u22C0",
      wedge: "\u2227",
      wedgeq: "\u2259",
      weierp: "\u2118",
      Wfr: "\u{1D51A}",
      wfr: "\u{1D534}",
      Wopf: "\u{1D54E}",
      wopf: "\u{1D568}",
      wp: "\u2118",
      wr: "\u2240",
      wreath: "\u2240",
      Wscr: "\u{1D4B2}",
      wscr: "\u{1D4CC}",
      xcap: "\u22C2",
      xcirc: "\u25EF",
      xcup: "\u22C3",
      xdtri: "\u25BD",
      Xfr: "\u{1D51B}",
      xfr: "\u{1D535}",
      xhArr: "\u27FA",
      xharr: "\u27F7",
      Xi: "\u039E",
      xi: "\u03BE",
      xlArr: "\u27F8",
      xlarr: "\u27F5",
      xmap: "\u27FC",
      xnis: "\u22FB",
      xodot: "\u2A00",
      Xopf: "\u{1D54F}",
      xopf: "\u{1D569}",
      xoplus: "\u2A01",
      xotime: "\u2A02",
      xrArr: "\u27F9",
      xrarr: "\u27F6",
      Xscr: "\u{1D4B3}",
      xscr: "\u{1D4CD}",
      xsqcup: "\u2A06",
      xuplus: "\u2A04",
      xutri: "\u25B3",
      xvee: "\u22C1",
      xwedge: "\u22C0",
      Yacute: "\xDD",
      yacute: "\xFD",
      YAcy: "\u042F",
      yacy: "\u044F",
      Ycirc: "\u0176",
      ycirc: "\u0177",
      Ycy: "\u042B",
      ycy: "\u044B",
      yen: "\xA5",
      Yfr: "\u{1D51C}",
      yfr: "\u{1D536}",
      YIcy: "\u0407",
      yicy: "\u0457",
      Yopf: "\u{1D550}",
      yopf: "\u{1D56A}",
      Yscr: "\u{1D4B4}",
      yscr: "\u{1D4CE}",
      YUcy: "\u042E",
      yucy: "\u044E",
      Yuml: "\u0178",
      yuml: "\xFF",
      Zacute: "\u0179",
      zacute: "\u017A",
      Zcaron: "\u017D",
      zcaron: "\u017E",
      Zcy: "\u0417",
      zcy: "\u0437",
      Zdot: "\u017B",
      zdot: "\u017C",
      zeetrf: "\u2128",
      ZeroWidthSpace: "\u200B",
      Zeta: "\u0396",
      zeta: "\u03B6",
      Zfr: "\u2128",
      zfr: "\u{1D537}",
      ZHcy: "\u0416",
      zhcy: "\u0436",
      zigrarr: "\u21DD",
      Zopf: "\u2124",
      zopf: "\u{1D56B}",
      Zscr: "\u{1D4B5}",
      zscr: "\u{1D4CF}",
      zwj: "\u200D",
      zwnj: "\u200C"
    });
    exports.entityMap = exports.HTML_ENTITIES;
  }
});

// node_modules/@xmldom/xmldom/lib/sax.js
var require_sax = __commonJS({
  "node_modules/@xmldom/xmldom/lib/sax.js"(exports) {
    var NAMESPACE = require_conventions().NAMESPACE;
    var nameStartChar = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
    var nameChar = new RegExp("[\\-\\.0-9" + nameStartChar.source.slice(1, -1) + "\\u00B7\\u0300-\\u036F\\u203F-\\u2040]");
    var tagNamePattern = new RegExp("^" + nameStartChar.source + nameChar.source + "*(?::" + nameStartChar.source + nameChar.source + "*)?$");
    var S_TAG = 0;
    var S_ATTR = 1;
    var S_ATTR_SPACE = 2;
    var S_EQ = 3;
    var S_ATTR_NOQUOT_VALUE = 4;
    var S_ATTR_END = 5;
    var S_TAG_SPACE = 6;
    var S_TAG_CLOSE = 7;
    function ParseError(message, locator) {
      this.message = message;
      this.locator = locator;
      if (Error.captureStackTrace)
        Error.captureStackTrace(this, ParseError);
    }
    ParseError.prototype = new Error();
    ParseError.prototype.name = ParseError.name;
    function XMLReader() {
    }
    XMLReader.prototype = {
      parse: function(source, defaultNSMap, entityMap) {
        var domBuilder = this.domBuilder;
        domBuilder.startDocument();
        _copy(defaultNSMap, defaultNSMap = {});
        parse(
          source,
          defaultNSMap,
          entityMap,
          domBuilder,
          this.errorHandler
        );
        domBuilder.endDocument();
      }
    };
    function parse(source, defaultNSMapCopy, entityMap, domBuilder, errorHandler) {
      function fixedFromCharCode(code) {
        if (code > 65535) {
          code -= 65536;
          var surrogate1 = 55296 + (code >> 10), surrogate2 = 56320 + (code & 1023);
          return String.fromCharCode(surrogate1, surrogate2);
        } else {
          return String.fromCharCode(code);
        }
      }
      function entityReplacer(a4) {
        var k = a4.slice(1, -1);
        if (Object.hasOwnProperty.call(entityMap, k)) {
          return entityMap[k];
        } else if (k.charAt(0) === "#") {
          return fixedFromCharCode(parseInt(k.substr(1).replace("x", "0x")));
        } else {
          errorHandler.error("entity not found:" + a4);
          return a4;
        }
      }
      function appendText(end2) {
        if (end2 > start) {
          var xt = source.substring(start, end2).replace(/&#?\w+;/g, entityReplacer);
          locator && position(start);
          domBuilder.characters(xt, 0, end2 - start);
          start = end2;
        }
      }
      function position(p8, m2) {
        while (p8 >= lineEnd && (m2 = linePattern.exec(source))) {
          lineStart = m2.index;
          lineEnd = lineStart + m2[0].length;
          locator.lineNumber++;
        }
        locator.columnNumber = p8 - lineStart + 1;
      }
      var lineStart = 0;
      var lineEnd = 0;
      var linePattern = /.*(?:\r\n?|\n)|.*$/g;
      var locator = domBuilder.locator;
      var parseStack = [{ currentNSMap: defaultNSMapCopy }];
      var closeMap = {};
      var start = 0;
      while (true) {
        try {
          var tagStart = source.indexOf("<", start);
          if (tagStart < 0) {
            if (!source.substr(start).match(/^\s*$/)) {
              var doc = domBuilder.doc;
              var text = doc.createTextNode(source.substr(start));
              doc.appendChild(text);
              domBuilder.currentElement = text;
            }
            return;
          }
          if (tagStart > start) {
            appendText(tagStart);
          }
          switch (source.charAt(tagStart + 1)) {
            case "/":
              var end = source.indexOf(">", tagStart + 3);
              var tagName = source.substring(tagStart + 2, end).replace(/[ \t\n\r]+$/g, "");
              var config = parseStack.pop();
              if (end < 0) {
                tagName = source.substring(tagStart + 2).replace(/[\s<].*/, "");
                errorHandler.error("end tag name: " + tagName + " is not complete:" + config.tagName);
                end = tagStart + 1 + tagName.length;
              } else if (tagName.match(/\s</)) {
                tagName = tagName.replace(/[\s<].*/, "");
                errorHandler.error("end tag name: " + tagName + " maybe not complete");
                end = tagStart + 1 + tagName.length;
              }
              var localNSMap = config.localNSMap;
              var endMatch = config.tagName == tagName;
              var endIgnoreCaseMach = endMatch || config.tagName && config.tagName.toLowerCase() == tagName.toLowerCase();
              if (endIgnoreCaseMach) {
                domBuilder.endElement(config.uri, config.localName, tagName);
                if (localNSMap) {
                  for (var prefix in localNSMap) {
                    if (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) {
                      domBuilder.endPrefixMapping(prefix);
                    }
                  }
                }
                if (!endMatch) {
                  errorHandler.fatalError("end tag name: " + tagName + " is not match the current start tagName:" + config.tagName);
                }
              } else {
                parseStack.push(config);
              }
              end++;
              break;
            case "?":
              locator && position(tagStart);
              end = parseInstruction(source, tagStart, domBuilder);
              break;
            case "!":
              locator && position(tagStart);
              end = parseDCC(source, tagStart, domBuilder, errorHandler);
              break;
            default:
              locator && position(tagStart);
              var el = new ElementAttributes();
              var currentNSMap = parseStack[parseStack.length - 1].currentNSMap;
              var end = parseElementStartPart(source, tagStart, el, currentNSMap, entityReplacer, errorHandler);
              var len = el.length;
              if (!el.closed && fixSelfClosed(source, end, el.tagName, closeMap)) {
                el.closed = true;
                if (!entityMap.nbsp) {
                  errorHandler.warning("unclosed xml attribute");
                }
              }
              if (locator && len) {
                var locator2 = copyLocator(locator, {});
                for (var i4 = 0; i4 < len; i4++) {
                  var a3 = el[i4];
                  position(a3.offset);
                  a3.locator = copyLocator(locator, {});
                }
                domBuilder.locator = locator2;
                if (appendElement(el, domBuilder, currentNSMap)) {
                  parseStack.push(el);
                }
                domBuilder.locator = locator;
              } else {
                if (appendElement(el, domBuilder, currentNSMap)) {
                  parseStack.push(el);
                }
              }
              if (NAMESPACE.isHTML(el.uri) && !el.closed) {
                end = parseHtmlSpecialContent(source, end, el.tagName, entityReplacer, domBuilder);
              } else {
                end++;
              }
          }
        } catch (e2) {
          if (e2 instanceof ParseError) {
            throw e2;
          }
          errorHandler.error("element parse error: " + e2);
          end = -1;
        }
        if (end > start) {
          start = end;
        } else {
          appendText(Math.max(tagStart, start) + 1);
        }
      }
    }
    function copyLocator(f3, t4) {
      t4.lineNumber = f3.lineNumber;
      t4.columnNumber = f3.columnNumber;
      return t4;
    }
    function parseElementStartPart(source, start, el, currentNSMap, entityReplacer, errorHandler) {
      function addAttribute(qname, value2, startIndex) {
        if (el.attributeNames.hasOwnProperty(qname)) {
          errorHandler.fatalError("Attribute " + qname + " redefined");
        }
        el.addValue(
          qname,
          // @see https://www.w3.org/TR/xml/#AVNormalize
          // since the xmldom sax parser does not "interpret" DTD the following is not implemented:
          // - recursive replacement of (DTD) entity references
          // - trimming and collapsing multiple spaces into a single one for attributes that are not of type CDATA
          value2.replace(/[\t\n\r]/g, " ").replace(/&#?\w+;/g, entityReplacer),
          startIndex
        );
      }
      var attrName;
      var value;
      var p8 = ++start;
      var s4 = S_TAG;
      while (true) {
        var c6 = source.charAt(p8);
        switch (c6) {
          case "=":
            if (s4 === S_ATTR) {
              attrName = source.slice(start, p8);
              s4 = S_EQ;
            } else if (s4 === S_ATTR_SPACE) {
              s4 = S_EQ;
            } else {
              throw new Error("attribute equal must after attrName");
            }
            break;
          case "'":
          case '"':
            if (s4 === S_EQ || s4 === S_ATTR) {
              if (s4 === S_ATTR) {
                errorHandler.warning('attribute value must after "="');
                attrName = source.slice(start, p8);
              }
              start = p8 + 1;
              p8 = source.indexOf(c6, start);
              if (p8 > 0) {
                value = source.slice(start, p8);
                addAttribute(attrName, value, start - 1);
                s4 = S_ATTR_END;
              } else {
                throw new Error("attribute value no end '" + c6 + "' match");
              }
            } else if (s4 == S_ATTR_NOQUOT_VALUE) {
              value = source.slice(start, p8);
              addAttribute(attrName, value, start);
              errorHandler.warning('attribute "' + attrName + '" missed start quot(' + c6 + ")!!");
              start = p8 + 1;
              s4 = S_ATTR_END;
            } else {
              throw new Error('attribute value must after "="');
            }
            break;
          case "/":
            switch (s4) {
              case S_TAG:
                el.setTagName(source.slice(start, p8));
              case S_ATTR_END:
              case S_TAG_SPACE:
              case S_TAG_CLOSE:
                s4 = S_TAG_CLOSE;
                el.closed = true;
              case S_ATTR_NOQUOT_VALUE:
              case S_ATTR:
                break;
              case S_ATTR_SPACE:
                el.closed = true;
                break;
              default:
                throw new Error("attribute invalid close char('/')");
            }
            break;
          case "":
            errorHandler.error("unexpected end of input");
            if (s4 == S_TAG) {
              el.setTagName(source.slice(start, p8));
            }
            return p8;
          case ">":
            switch (s4) {
              case S_TAG:
                el.setTagName(source.slice(start, p8));
              case S_ATTR_END:
              case S_TAG_SPACE:
              case S_TAG_CLOSE:
                break;
              case S_ATTR_NOQUOT_VALUE:
              case S_ATTR:
                value = source.slice(start, p8);
                if (value.slice(-1) === "/") {
                  el.closed = true;
                  value = value.slice(0, -1);
                }
              case S_ATTR_SPACE:
                if (s4 === S_ATTR_SPACE) {
                  value = attrName;
                }
                if (s4 == S_ATTR_NOQUOT_VALUE) {
                  errorHandler.warning('attribute "' + value + '" missed quot(")!');
                  addAttribute(attrName, value, start);
                } else {
                  if (!NAMESPACE.isHTML(currentNSMap[""]) || !value.match(/^(?:disabled|checked|selected)$/i)) {
                    errorHandler.warning('attribute "' + value + '" missed value!! "' + value + '" instead!!');
                  }
                  addAttribute(value, value, start);
                }
                break;
              case S_EQ:
                throw new Error("attribute value missed!!");
            }
            return p8;
          case "\x80":
            c6 = " ";
          default:
            if (c6 <= " ") {
              switch (s4) {
                case S_TAG:
                  el.setTagName(source.slice(start, p8));
                  s4 = S_TAG_SPACE;
                  break;
                case S_ATTR:
                  attrName = source.slice(start, p8);
                  s4 = S_ATTR_SPACE;
                  break;
                case S_ATTR_NOQUOT_VALUE:
                  var value = source.slice(start, p8);
                  errorHandler.warning('attribute "' + value + '" missed quot(")!!');
                  addAttribute(attrName, value, start);
                case S_ATTR_END:
                  s4 = S_TAG_SPACE;
                  break;
              }
            } else {
              switch (s4) {
                case S_ATTR_SPACE:
                  var tagName = el.tagName;
                  if (!NAMESPACE.isHTML(currentNSMap[""]) || !attrName.match(/^(?:disabled|checked|selected)$/i)) {
                    errorHandler.warning('attribute "' + attrName + '" missed value!! "' + attrName + '" instead2!!');
                  }
                  addAttribute(attrName, attrName, start);
                  start = p8;
                  s4 = S_ATTR;
                  break;
                case S_ATTR_END:
                  errorHandler.warning('attribute space is required"' + attrName + '"!!');
                case S_TAG_SPACE:
                  s4 = S_ATTR;
                  start = p8;
                  break;
                case S_EQ:
                  s4 = S_ATTR_NOQUOT_VALUE;
                  start = p8;
                  break;
                case S_TAG_CLOSE:
                  throw new Error("elements closed character '/' and '>' must be connected to");
              }
            }
        }
        p8++;
      }
    }
    function appendElement(el, domBuilder, currentNSMap) {
      var tagName = el.tagName;
      var localNSMap = null;
      var i4 = el.length;
      while (i4--) {
        var a3 = el[i4];
        var qName = a3.qName;
        var value = a3.value;
        var nsp = qName.indexOf(":");
        if (nsp > 0) {
          var prefix = a3.prefix = qName.slice(0, nsp);
          var localName = qName.slice(nsp + 1);
          var nsPrefix = prefix === "xmlns" && localName;
        } else {
          localName = qName;
          prefix = null;
          nsPrefix = qName === "xmlns" && "";
        }
        a3.localName = localName;
        if (nsPrefix !== false) {
          if (localNSMap == null) {
            localNSMap = {};
            _copy(currentNSMap, currentNSMap = {});
          }
          currentNSMap[nsPrefix] = localNSMap[nsPrefix] = value;
          a3.uri = NAMESPACE.XMLNS;
          domBuilder.startPrefixMapping(nsPrefix, value);
        }
      }
      var i4 = el.length;
      while (i4--) {
        a3 = el[i4];
        var prefix = a3.prefix;
        if (prefix) {
          if (prefix === "xml") {
            a3.uri = NAMESPACE.XML;
          }
          if (prefix !== "xmlns") {
            a3.uri = currentNSMap[prefix || ""];
          }
        }
      }
      var nsp = tagName.indexOf(":");
      if (nsp > 0) {
        prefix = el.prefix = tagName.slice(0, nsp);
        localName = el.localName = tagName.slice(nsp + 1);
      } else {
        prefix = null;
        localName = el.localName = tagName;
      }
      var ns = el.uri = currentNSMap[prefix || ""];
      domBuilder.startElement(ns, localName, tagName, el);
      if (el.closed) {
        domBuilder.endElement(ns, localName, tagName);
        if (localNSMap) {
          for (prefix in localNSMap) {
            if (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) {
              domBuilder.endPrefixMapping(prefix);
            }
          }
        }
      } else {
        el.currentNSMap = currentNSMap;
        el.localNSMap = localNSMap;
        return true;
      }
    }
    function parseHtmlSpecialContent(source, elStartEnd, tagName, entityReplacer, domBuilder) {
      if (/^(?:script|textarea)$/i.test(tagName)) {
        var elEndStart = source.indexOf("</" + tagName + ">", elStartEnd);
        var text = source.substring(elStartEnd + 1, elEndStart);
        if (/[&<]/.test(text)) {
          if (/^script$/i.test(tagName)) {
            domBuilder.characters(text, 0, text.length);
            return elEndStart;
          }
          text = text.replace(/&#?\w+;/g, entityReplacer);
          domBuilder.characters(text, 0, text.length);
          return elEndStart;
        }
      }
      return elStartEnd + 1;
    }
    function fixSelfClosed(source, elStartEnd, tagName, closeMap) {
      var pos = closeMap[tagName];
      if (pos == null) {
        pos = source.lastIndexOf("</" + tagName + ">");
        if (pos < elStartEnd) {
          pos = source.lastIndexOf("</" + tagName);
        }
        closeMap[tagName] = pos;
      }
      return pos < elStartEnd;
    }
    function _copy(source, target) {
      for (var n3 in source) {
        if (Object.prototype.hasOwnProperty.call(source, n3)) {
          target[n3] = source[n3];
        }
      }
    }
    function parseDCC(source, start, domBuilder, errorHandler) {
      var next = source.charAt(start + 2);
      switch (next) {
        case "-":
          if (source.charAt(start + 3) === "-") {
            var end = source.indexOf("-->", start + 4);
            if (end > start) {
              domBuilder.comment(source, start + 4, end - start - 4);
              return end + 3;
            } else {
              errorHandler.error("Unclosed comment");
              return -1;
            }
          } else {
            return -1;
          }
        default:
          if (source.substr(start + 3, 6) == "CDATA[") {
            var end = source.indexOf("]]>", start + 9);
            domBuilder.startCDATA();
            domBuilder.characters(source, start + 9, end - start - 9);
            domBuilder.endCDATA();
            return end + 3;
          }
          var matchs = split(source, start);
          var len = matchs.length;
          if (len > 1 && /!doctype/i.test(matchs[0][0])) {
            var name2 = matchs[1][0];
            var pubid = false;
            var sysid = false;
            if (len > 3) {
              if (/^public$/i.test(matchs[2][0])) {
                pubid = matchs[3][0];
                sysid = len > 4 && matchs[4][0];
              } else if (/^system$/i.test(matchs[2][0])) {
                sysid = matchs[3][0];
              }
            }
            var lastMatch = matchs[len - 1];
            domBuilder.startDTD(name2, pubid, sysid);
            domBuilder.endDTD();
            return lastMatch.index + lastMatch[0].length;
          }
      }
      return -1;
    }
    function parseInstruction(source, start, domBuilder) {
      var end = source.indexOf("?>", start);
      if (end) {
        var match2 = source.substring(start, end).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
        if (match2) {
          var len = match2[0].length;
          domBuilder.processingInstruction(match2[1], match2[2]);
          return end + 2;
        } else {
          return -1;
        }
      }
      return -1;
    }
    function ElementAttributes() {
      this.attributeNames = {};
    }
    ElementAttributes.prototype = {
      setTagName: function(tagName) {
        if (!tagNamePattern.test(tagName)) {
          throw new Error("invalid tagName:" + tagName);
        }
        this.tagName = tagName;
      },
      addValue: function(qName, value, offset) {
        if (!tagNamePattern.test(qName)) {
          throw new Error("invalid attribute:" + qName);
        }
        this.attributeNames[qName] = this.length;
        this[this.length++] = { qName, value, offset };
      },
      length: 0,
      getLocalName: function(i4) {
        return this[i4].localName;
      },
      getLocator: function(i4) {
        return this[i4].locator;
      },
      getQName: function(i4) {
        return this[i4].qName;
      },
      getURI: function(i4) {
        return this[i4].uri;
      },
      getValue: function(i4) {
        return this[i4].value;
      }
      //	,getIndex:function(uri, localName)){
      //		if(localName){
      //
      //		}else{
      //			var qName = uri
      //		}
      //	},
      //	getValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},
      //	getType:function(uri,localName){}
      //	getType:function(i){},
    };
    function split(source, start) {
      var match2;
      var buf = [];
      var reg = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
      reg.lastIndex = start;
      reg.exec(source);
      while (match2 = reg.exec(source)) {
        buf.push(match2);
        if (match2[1])
          return buf;
      }
    }
    exports.XMLReader = XMLReader;
    exports.ParseError = ParseError;
  }
});

// node_modules/@xmldom/xmldom/lib/dom-parser.js
var require_dom_parser = __commonJS({
  "node_modules/@xmldom/xmldom/lib/dom-parser.js"(exports) {
    var conventions = require_conventions();
    var dom = require_dom();
    var entities = require_entities();
    var sax = require_sax();
    var DOMImplementation = dom.DOMImplementation;
    var NAMESPACE = conventions.NAMESPACE;
    var ParseError = sax.ParseError;
    var XMLReader = sax.XMLReader;
    function normalizeLineEndings(input) {
      return input.replace(/\r[\n\u0085]/g, "\n").replace(/[\r\u0085\u2028]/g, "\n");
    }
    function DOMParser(options) {
      this.options = options || { locator: {} };
    }
    DOMParser.prototype.parseFromString = function(source, mimeType) {
      var options = this.options;
      var sax2 = new XMLReader();
      var domBuilder = options.domBuilder || new DOMHandler();
      var errorHandler = options.errorHandler;
      var locator = options.locator;
      var defaultNSMap = options.xmlns || {};
      var isHTML = /\/x?html?$/.test(mimeType);
      var entityMap = isHTML ? entities.HTML_ENTITIES : entities.XML_ENTITIES;
      if (locator) {
        domBuilder.setDocumentLocator(locator);
      }
      sax2.errorHandler = buildErrorHandler(errorHandler, domBuilder, locator);
      sax2.domBuilder = options.domBuilder || domBuilder;
      if (isHTML) {
        defaultNSMap[""] = NAMESPACE.HTML;
      }
      defaultNSMap.xml = defaultNSMap.xml || NAMESPACE.XML;
      var normalize = options.normalizeLineEndings || normalizeLineEndings;
      if (source && typeof source === "string") {
        sax2.parse(
          normalize(source),
          defaultNSMap,
          entityMap
        );
      } else {
        sax2.errorHandler.error("invalid doc source");
      }
      return domBuilder.doc;
    };
    function buildErrorHandler(errorImpl, domBuilder, locator) {
      if (!errorImpl) {
        if (domBuilder instanceof DOMHandler) {
          return domBuilder;
        }
        errorImpl = domBuilder;
      }
      var errorHandler = {};
      var isCallback = errorImpl instanceof Function;
      locator = locator || {};
      function build(key) {
        var fn2 = errorImpl[key];
        if (!fn2 && isCallback) {
          fn2 = errorImpl.length == 2 ? function(msg) {
            errorImpl(key, msg);
          } : errorImpl;
        }
        errorHandler[key] = fn2 && function(msg) {
          fn2("[xmldom " + key + "]	" + msg + _locator(locator));
        } || function() {
        };
      }
      build("warning");
      build("error");
      build("fatalError");
      return errorHandler;
    }
    function DOMHandler() {
      this.cdata = false;
    }
    function position(locator, node) {
      node.lineNumber = locator.lineNumber;
      node.columnNumber = locator.columnNumber;
    }
    DOMHandler.prototype = {
      startDocument: function() {
        this.doc = new DOMImplementation().createDocument(null, null, null);
        if (this.locator) {
          this.doc.documentURI = this.locator.systemId;
        }
      },
      startElement: function(namespaceURI, localName, qName, attrs) {
        var doc = this.doc;
        var el = doc.createElementNS(namespaceURI, qName || localName);
        var len = attrs.length;
        appendElement(this, el);
        this.currentElement = el;
        this.locator && position(this.locator, el);
        for (var i4 = 0; i4 < len; i4++) {
          var namespaceURI = attrs.getURI(i4);
          var value = attrs.getValue(i4);
          var qName = attrs.getQName(i4);
          var attr = doc.createAttributeNS(namespaceURI, qName);
          this.locator && position(attrs.getLocator(i4), attr);
          attr.value = attr.nodeValue = value;
          el.setAttributeNode(attr);
        }
      },
      endElement: function(namespaceURI, localName, qName) {
        var current = this.currentElement;
        var tagName = current.tagName;
        this.currentElement = current.parentNode;
      },
      startPrefixMapping: function(prefix, uri) {
      },
      endPrefixMapping: function(prefix) {
      },
      processingInstruction: function(target, data) {
        var ins = this.doc.createProcessingInstruction(target, data);
        this.locator && position(this.locator, ins);
        appendElement(this, ins);
      },
      ignorableWhitespace: function(ch, start, length) {
      },
      characters: function(chars, start, length) {
        chars = _toString.apply(this, arguments);
        if (chars) {
          if (this.cdata) {
            var charNode = this.doc.createCDATASection(chars);
          } else {
            var charNode = this.doc.createTextNode(chars);
          }
          if (this.currentElement) {
            this.currentElement.appendChild(charNode);
          } else if (/^\s*$/.test(chars)) {
            this.doc.appendChild(charNode);
          }
          this.locator && position(this.locator, charNode);
        }
      },
      skippedEntity: function(name2) {
      },
      endDocument: function() {
        this.doc.normalize();
      },
      setDocumentLocator: function(locator) {
        if (this.locator = locator) {
          locator.lineNumber = 0;
        }
      },
      //LexicalHandler
      comment: function(chars, start, length) {
        chars = _toString.apply(this, arguments);
        var comm = this.doc.createComment(chars);
        this.locator && position(this.locator, comm);
        appendElement(this, comm);
      },
      startCDATA: function() {
        this.cdata = true;
      },
      endCDATA: function() {
        this.cdata = false;
      },
      startDTD: function(name2, publicId, systemId) {
        var impl = this.doc.implementation;
        if (impl && impl.createDocumentType) {
          var dt = impl.createDocumentType(name2, publicId, systemId);
          this.locator && position(this.locator, dt);
          appendElement(this, dt);
          this.doc.doctype = dt;
        }
      },
      /**
       * @see org.xml.sax.ErrorHandler
       * @link http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html
       */
      warning: function(error) {
        console.warn("[xmldom warning]	" + error, _locator(this.locator));
      },
      error: function(error) {
        console.error("[xmldom error]	" + error, _locator(this.locator));
      },
      fatalError: function(error) {
        throw new ParseError(error, this.locator);
      }
    };
    function _locator(l4) {
      if (l4) {
        return "\n@" + (l4.systemId || "") + "#[line:" + l4.lineNumber + ",col:" + l4.columnNumber + "]";
      }
    }
    function _toString(chars, start, length) {
      if (typeof chars == "string") {
        return chars.substr(start, length);
      } else {
        if (chars.length >= start + length || start) {
          return new java.lang.String(chars, start, length) + "";
        }
        return chars;
      }
    }
    "endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g, function(key) {
      DOMHandler.prototype[key] = function() {
        return null;
      };
    });
    function appendElement(hander, node) {
      if (!hander.currentElement) {
        hander.doc.appendChild(node);
      } else {
        hander.currentElement.appendChild(node);
      }
    }
    exports.__DOMHandler = DOMHandler;
    exports.normalizeLineEndings = normalizeLineEndings;
    exports.DOMParser = DOMParser;
  }
});

// node_modules/@xmldom/xmldom/lib/index.js
var require_lib = __commonJS({
  "node_modules/@xmldom/xmldom/lib/index.js"(exports) {
    var dom = require_dom();
    exports.DOMImplementation = dom.DOMImplementation;
    exports.XMLSerializer = dom.XMLSerializer;
    exports.DOMParser = require_dom_parser().DOMParser;
  }
});

// node_modules/xpath/xpath.js
var require_xpath = __commonJS({
  "node_modules/xpath/xpath.js"(exports) {
    var xpath = typeof exports === "undefined" ? {} : exports;
    (function(exports2) {
      "use strict";
      function curry(func) {
        var slice = Array.prototype.slice, totalargs = func.length, partial = function(args, fn3) {
          return function() {
            return fn3.apply(this, args.concat(slice.call(arguments)));
          };
        }, fn2 = function() {
          var args = slice.call(arguments);
          return args.length < totalargs ? partial(args, fn2) : func.apply(this, slice.apply(arguments, [0, totalargs]));
        };
        return fn2;
      }
      var forEach = function(f3, xs) {
        for (var i4 = 0; i4 < xs.length; i4 += 1) {
          f3(xs[i4], i4, xs);
        }
      };
      var reduce = function(f3, seed, xs) {
        var acc = seed;
        forEach(function(x3, i4) {
          acc = f3(acc, x3, i4);
        }, xs);
        return acc;
      };
      var map = function(f3, xs) {
        var mapped = new Array(xs.length);
        forEach(function(x3, i4) {
          mapped[i4] = f3(x3);
        }, xs);
        return mapped;
      };
      var filter2 = function(f3, xs) {
        var filtered = [];
        forEach(function(x3, i4) {
          if (f3(x3, i4)) {
            filtered.push(x3);
          }
        }, xs);
        return filtered;
      };
      var includes = function(values, value) {
        for (var i4 = 0; i4 < values.length; i4 += 1) {
          if (values[i4] === value) {
            return true;
          }
        }
        return false;
      };
      function always(value) {
        return function() {
          return value;
        };
      }
      function toString(x3) {
        return x3.toString();
      }
      var join = function(s4, xs) {
        return xs.join(s4);
      };
      var wrap = function(pref, suf, str) {
        return pref + str + suf;
      };
      var prototypeConcat = Array.prototype.concat;
      var MAX_ARGUMENT_LENGTH = 32767;
      function flatten(arr) {
        var result = [];
        for (var start = 0; start < arr.length; start += MAX_ARGUMENT_LENGTH) {
          var chunk = arr.slice(start, start + MAX_ARGUMENT_LENGTH);
          result = prototypeConcat.apply(result, chunk);
        }
        return result;
      }
      function assign(target, varArgs) {
        var to = Object(target);
        for (var index = 1; index < arguments.length; index++) {
          var nextSource = arguments[index];
          if (nextSource != null) {
            for (var nextKey in nextSource) {
              if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
                to[nextKey] = nextSource[nextKey];
              }
            }
          }
        }
        return to;
      }
      XPathParser.prototype = new Object();
      XPathParser.prototype.constructor = XPathParser;
      XPathParser.superclass = Object.prototype;
      function XPathParser() {
        this.init();
      }
      XPathParser.prototype.init = function() {
        this.reduceActions = [];
        this.reduceActions[3] = function(rhs) {
          return new OrOperation(rhs[0], rhs[2]);
        };
        this.reduceActions[5] = function(rhs) {
          return new AndOperation(rhs[0], rhs[2]);
        };
        this.reduceActions[7] = function(rhs) {
          return new EqualsOperation(rhs[0], rhs[2]);
        };
        this.reduceActions[8] = function(rhs) {
          return new NotEqualOperation(rhs[0], rhs[2]);
        };
        this.reduceActions[10] = function(rhs) {
          return new LessThanOperation(rhs[0], rhs[2]);
        };
        this.reduceActions[11] = function(rhs) {
          return new GreaterThanOperation(rhs[0], rhs[2]);
        };
        this.reduceActions[12] = function(rhs) {
          return new LessThanOrEqualOperation(rhs[0], rhs[2]);
        };
        this.reduceActions[13] = function(rhs) {
          return new GreaterThanOrEqualOperation(rhs[0], rhs[2]);
        };
        this.reduceActions[15] = function(rhs) {
          return new PlusOperation(rhs[0], rhs[2]);
        };
        this.reduceActions[16] = function(rhs) {
          return new MinusOperation(rhs[0], rhs[2]);
        };
        this.reduceActions[18] = function(rhs) {
          return new MultiplyOperation(rhs[0], rhs[2]);
        };
        this.reduceActions[19] = function(rhs) {
          return new DivOperation(rhs[0], rhs[2]);
        };
        this.reduceActions[20] = function(rhs) {
          return new ModOperation(rhs[0], rhs[2]);
        };
        this.reduceActions[22] = function(rhs) {
          return new UnaryMinusOperation(rhs[1]);
        };
        this.reduceActions[24] = function(rhs) {
          return new BarOperation(rhs[0], rhs[2]);
        };
        this.reduceActions[25] = function(rhs) {
          return new PathExpr(void 0, void 0, rhs[0]);
        };
        this.reduceActions[27] = function(rhs) {
          rhs[0].locationPath = rhs[2];
          return rhs[0];
        };
        this.reduceActions[28] = function(rhs) {
          rhs[0].locationPath = rhs[2];
          rhs[0].locationPath.steps.unshift(new Step(Step.DESCENDANTORSELF, NodeTest.nodeTest, []));
          return rhs[0];
        };
        this.reduceActions[29] = function(rhs) {
          return new PathExpr(rhs[0], [], void 0);
        };
        this.reduceActions[30] = function(rhs) {
          if (Utilities.instance_of(rhs[0], PathExpr)) {
            if (rhs[0].filterPredicates == void 0) {
              rhs[0].filterPredicates = [];
            }
            rhs[0].filterPredicates.push(rhs[1]);
            return rhs[0];
          } else {
            return new PathExpr(rhs[0], [rhs[1]], void 0);
          }
        };
        this.reduceActions[32] = function(rhs) {
          return rhs[1];
        };
        this.reduceActions[33] = function(rhs) {
          return new XString(rhs[0]);
        };
        this.reduceActions[34] = function(rhs) {
          return new XNumber(rhs[0]);
        };
        this.reduceActions[36] = function(rhs) {
          return new FunctionCall(rhs[0], []);
        };
        this.reduceActions[37] = function(rhs) {
          return new FunctionCall(rhs[0], rhs[2]);
        };
        this.reduceActions[38] = function(rhs) {
          return [rhs[0]];
        };
        this.reduceActions[39] = function(rhs) {
          rhs[2].unshift(rhs[0]);
          return rhs[2];
        };
        this.reduceActions[43] = function(rhs) {
          return new LocationPath(true, []);
        };
        this.reduceActions[44] = function(rhs) {
          rhs[1].absolute = true;
          return rhs[1];
        };
        this.reduceActions[46] = function(rhs) {
          return new LocationPath(false, [rhs[0]]);
        };
        this.reduceActions[47] = function(rhs) {
          rhs[0].steps.push(rhs[2]);
          return rhs[0];
        };
        this.reduceActions[49] = function(rhs) {
          return new Step(rhs[0], rhs[1], []);
        };
        this.reduceActions[50] = function(rhs) {
          return new Step(Step.CHILD, rhs[0], []);
        };
        this.reduceActions[51] = function(rhs) {
          return new Step(rhs[0], rhs[1], rhs[2]);
        };
        this.reduceActions[52] = function(rhs) {
          return new Step(Step.CHILD, rhs[0], rhs[1]);
        };
        this.reduceActions[54] = function(rhs) {
          return [rhs[0]];
        };
        this.reduceActions[55] = function(rhs) {
          rhs[1].unshift(rhs[0]);
          return rhs[1];
        };
        this.reduceActions[56] = function(rhs) {
          if (rhs[0] == "ancestor") {
            return Step.ANCESTOR;
          } else if (rhs[0] == "ancestor-or-self") {
            return Step.ANCESTORORSELF;
          } else if (rhs[0] == "attribute") {
            return Step.ATTRIBUTE;
          } else if (rhs[0] == "child") {
            return Step.CHILD;
          } else if (rhs[0] == "descendant") {
            return Step.DESCENDANT;
          } else if (rhs[0] == "descendant-or-self") {
            return Step.DESCENDANTORSELF;
          } else if (rhs[0] == "following") {
            return Step.FOLLOWING;
          } else if (rhs[0] == "following-sibling") {
            return Step.FOLLOWINGSIBLING;
          } else if (rhs[0] == "namespace") {
            return Step.NAMESPACE;
          } else if (rhs[0] == "parent") {
            return Step.PARENT;
          } else if (rhs[0] == "preceding") {
            return Step.PRECEDING;
          } else if (rhs[0] == "preceding-sibling") {
            return Step.PRECEDINGSIBLING;
          } else if (rhs[0] == "self") {
            return Step.SELF;
          }
          return -1;
        };
        this.reduceActions[57] = function(rhs) {
          return Step.ATTRIBUTE;
        };
        this.reduceActions[59] = function(rhs) {
          if (rhs[0] == "comment") {
            return NodeTest.commentTest;
          } else if (rhs[0] == "text") {
            return NodeTest.textTest;
          } else if (rhs[0] == "processing-instruction") {
            return NodeTest.anyPiTest;
          } else if (rhs[0] == "node") {
            return NodeTest.nodeTest;
          }
          return new NodeTest(-1, void 0);
        };
        this.reduceActions[60] = function(rhs) {
          return new NodeTest.PITest(rhs[2]);
        };
        this.reduceActions[61] = function(rhs) {
          return rhs[1];
        };
        this.reduceActions[63] = function(rhs) {
          rhs[1].absolute = true;
          rhs[1].steps.unshift(new Step(Step.DESCENDANTORSELF, NodeTest.nodeTest, []));
          return rhs[1];
        };
        this.reduceActions[64] = function(rhs) {
          rhs[0].steps.push(new Step(Step.DESCENDANTORSELF, NodeTest.nodeTest, []));
          rhs[0].steps.push(rhs[2]);
          return rhs[0];
        };
        this.reduceActions[65] = function(rhs) {
          return new Step(Step.SELF, NodeTest.nodeTest, []);
        };
        this.reduceActions[66] = function(rhs) {
          return new Step(Step.PARENT, NodeTest.nodeTest, []);
        };
        this.reduceActions[67] = function(rhs) {
          return new VariableReference(rhs[1]);
        };
        this.reduceActions[68] = function(rhs) {
          return NodeTest.nameTestAny;
        };
        this.reduceActions[69] = function(rhs) {
          return new NodeTest.NameTestPrefixAny(rhs[0].split(":")[0]);
        };
        this.reduceActions[70] = function(rhs) {
          return new NodeTest.NameTestQName(rhs[0]);
        };
      };
      XPathParser.actionTable = [
        " s s        sssssssss    s ss  s  ss",
        "                 s                  ",
        "r  rrrrrrrrr         rrrrrrr rr  r  ",
        "                rrrrr               ",
        " s s        sssssssss    s ss  s  ss",
        "rs  rrrrrrrr s  sssssrrrrrr  rrs rs ",
        " s s        sssssssss    s ss  s  ss",
        "                            s       ",
        "                            s       ",
        "r  rrrrrrrrr         rrrrrrr rr rr  ",
        "r  rrrrrrrrr         rrrrrrr rr rr  ",
        "r  rrrrrrrrr         rrrrrrr rr rr  ",
        "r  rrrrrrrrr         rrrrrrr rr rr  ",
        "r  rrrrrrrrr         rrrrrrr rr rr  ",
        "  s                                 ",
        "                            s       ",
        " s           s  sssss          s  s ",
        "r  rrrrrrrrr         rrrrrrr rr  r  ",
        "a                                   ",
        "r       s                    rr  r  ",
        "r      sr                    rr  r  ",
        "r   s  rr            s       rr  r  ",
        "r   rssrr            rss     rr  r  ",
        "r   rrrrr            rrrss   rr  r  ",
        "r   rrrrrsss         rrrrr   rr  r  ",
        "r   rrrrrrrr         rrrrr   rr  r  ",
        "r   rrrrrrrr         rrrrrs  rr  r  ",
        "r   rrrrrrrr         rrrrrr  rr  r  ",
        "r   rrrrrrrr         rrrrrr  rr  r  ",
        "r  srrrrrrrr         rrrrrrs rr sr  ",
        "r  srrrrrrrr         rrrrrrs rr  r  ",
        "r  rrrrrrrrr         rrrrrrr rr rr  ",
        "r  rrrrrrrrr         rrrrrrr rr rr  ",
        "r  rrrrrrrrr         rrrrrrr rr rr  ",
        "r   rrrrrrrr         rrrrrr  rr  r  ",
        "r   rrrrrrrr         rrrrrr  rr  r  ",
        "r  rrrrrrrrr         rrrrrrr rr  r  ",
        "r  rrrrrrrrr         rrrrrrr rr  r  ",
        "                sssss               ",
        "r  rrrrrrrrr         rrrrrrr rr sr  ",
        "r  rrrrrrrrr         rrrrrrr rr  r  ",
        "r  rrrrrrrrr         rrrrrrr rr rr  ",
        "r  rrrrrrrrr         rrrrrrr rr rr  ",
        "                             s      ",
        "r  srrrrrrrr         rrrrrrs rr  r  ",
        "r   rrrrrrrr         rrrrr   rr  r  ",
        "              s                     ",
        "                             s      ",
        "                rrrrr               ",
        " s s        sssssssss    s sss s  ss",
        "r  srrrrrrrr         rrrrrrs rr  r  ",
        " s s        sssssssss    s ss  s  ss",
        " s s        sssssssss    s ss  s  ss",
        " s s        sssssssss    s ss  s  ss",
        " s s        sssssssss    s ss  s  ss",
        " s s        sssssssss    s ss  s  ss",
        " s s        sssssssss    s ss  s  ss",
        " s s        sssssssss    s ss  s  ss",
        " s s        sssssssss    s ss  s  ss",
        " s s        sssssssss    s ss  s  ss",
        " s s        sssssssss    s ss  s  ss",
        " s s        sssssssss    s ss  s  ss",
        " s s        sssssssss    s ss  s  ss",
        " s s        sssssssss    s ss  s  ss",
        " s s        sssssssss      ss  s  ss",
        " s s        sssssssss    s ss  s  ss",
        " s           s  sssss          s  s ",
        " s           s  sssss          s  s ",
        "r  rrrrrrrrr         rrrrrrr rr rr  ",
        " s           s  sssss          s  s ",
        " s           s  sssss          s  s ",
        "r  rrrrrrrrr         rrrrrrr rr sr  ",
        "r  rrrrrrrrr         rrrrrrr rr sr  ",
        "r  rrrrrrrrr         rrrrrrr rr  r  ",
        "r  rrrrrrrrr         rrrrrrr rr rr  ",
        "                             s      ",
        "r  rrrrrrrrr         rrrrrrr rr rr  ",
        "r  rrrrrrrrr         rrrrrrr rr rr  ",
        "                             rr     ",
        "                             s      ",
        "                             rs     ",
        "r      sr                    rr  r  ",
        "r   s  rr            s       rr  r  ",
        "r   rssrr            rss     rr  r  ",
        "r   rssrr            rss     rr  r  ",
        "r   rrrrr            rrrss   rr  r  ",
        "r   rrrrr            rrrss   rr  r  ",
        "r   rrrrr            rrrss   rr  r  ",
        "r   rrrrr            rrrss   rr  r  ",
        "r   rrrrrsss         rrrrr   rr  r  ",
        "r   rrrrrsss         rrrrr   rr  r  ",
        "r   rrrrrrrr         rrrrr   rr  r  ",
        "r   rrrrrrrr         rrrrr   rr  r  ",
        "r   rrrrrrrr         rrrrr   rr  r  ",
        "r   rrrrrrrr         rrrrrr  rr  r  ",
        "                                 r  ",
        "                                 s  ",
        "r  srrrrrrrr         rrrrrrs rr  r  ",
        "r  srrrrrrrr         rrrrrrs rr  r  ",
        "r  rrrrrrrrr         rrrrrrr rr  r  ",
        "r  rrrrrrrrr         rrrrrrr rr  r  ",
        "r  rrrrrrrrr         rrrrrrr rr  r  ",
        "r  rrrrrrrrr         rrrrrrr rr  r  ",
        "r  rrrrrrrrr         rrrrrrr rr rr  ",
        "r  rrrrrrrrr         rrrrrrr rr rr  ",
        " s s        sssssssss    s ss  s  ss",
        "r  rrrrrrrrr         rrrrrrr rr rr  ",
        "                             r      "
      ];
      XPathParser.actionTableNumber = [
        ` 1 0        /.-,+*)('    & %$  #  "!`,
        "                 J                  ",
        "a  aaaaaaaaa         aaaaaaa aa  a  ",
        "                YYYYY               ",
        ` 1 0        /.-,+*)('    & %$  #  "!`,
        `K1  KKKKKKKK .  +*)('KKKKKK  KK# K" `,
        ` 1 0        /.-,+*)('    & %$  #  "!`,
        "                            N       ",
        "                            O       ",
        "e  eeeeeeeee         eeeeeee ee ee  ",
        "f  fffffffff         fffffff ff ff  ",
        "d  ddddddddd         ddddddd dd dd  ",
        "B  BBBBBBBBB         BBBBBBB BB BB  ",
        "A  AAAAAAAAA         AAAAAAA AA AA  ",
        "  P                                 ",
        "                            Q       ",
        ` 1           .  +*)('          #  " `,
        "b  bbbbbbbbb         bbbbbbb bb  b  ",
        "                                    ",
        "!       S                    !!  !  ",
        '"      T"                    ""  "  ',
        "$   V  $$            U       $$  $  ",
        "&   &ZY&&            &XW     &&  &  ",
        ")   )))))            )))\\[   ))  )  ",
        ".   ....._^]         .....   ..  .  ",
        "1   11111111         11111   11  1  ",
        "5   55555555         55555`  55  5  ",
        "7   77777777         777777  77  7  ",
        "9   99999999         999999  99  9  ",
        ":  c::::::::         ::::::b :: a:  ",
        "I  fIIIIIIII         IIIIIIe II  I  ",
        "=  =========         ======= == ==  ",
        "?  ?????????         ??????? ?? ??  ",
        "C  CCCCCCCCC         CCCCCCC CC CC  ",
        "J   JJJJJJJJ         JJJJJJ  JJ  J  ",
        "M   MMMMMMMM         MMMMMM  MM  M  ",
        "N  NNNNNNNNN         NNNNNNN NN  N  ",
        "P  PPPPPPPPP         PPPPPPP PP  P  ",
        "                +*)('               ",
        "R  RRRRRRRRR         RRRRRRR RR aR  ",
        "U  UUUUUUUUU         UUUUUUU UU  U  ",
        "Z  ZZZZZZZZZ         ZZZZZZZ ZZ ZZ  ",
        "c  ccccccccc         ccccccc cc cc  ",
        "                             j      ",
        "L  fLLLLLLLL         LLLLLLe LL  L  ",
        "6   66666666         66666   66  6  ",
        "              k                     ",
        "                             l      ",
        "                XXXXX               ",
        ` 1 0        /.-,+*)('    & %$m #  "!`,
        "_  f________         ______e __  _  ",
        ` 1 0        /.-,+*)('    & %$  #  "!`,
        ` 1 0        /.-,+*)('    & %$  #  "!`,
        ` 1 0        /.-,+*)('    & %$  #  "!`,
        ` 1 0        /.-,+*)('    & %$  #  "!`,
        ` 1 0        /.-,+*)('    & %$  #  "!`,
        ` 1 0        /.-,+*)('    & %$  #  "!`,
        ` 1 0        /.-,+*)('    & %$  #  "!`,
        ` 1 0        /.-,+*)('    & %$  #  "!`,
        ` 1 0        /.-,+*)('    & %$  #  "!`,
        ` 1 0        /.-,+*)('    & %$  #  "!`,
        ` 1 0        /.-,+*)('    & %$  #  "!`,
        ` 1 0        /.-,+*)('    & %$  #  "!`,
        ` 1 0        /.-,+*)('    & %$  #  "!`,
        ` 1 0        /.-,+*)('      %$  #  "!`,
        ` 1 0        /.-,+*)('    & %$  #  "!`,
        ` 1           .  +*)('          #  " `,
        ` 1           .  +*)('          #  " `,
        ">  >>>>>>>>>         >>>>>>> >> >>  ",
        ` 1           .  +*)('          #  " `,
        ` 1           .  +*)('          #  " `,
        "Q  QQQQQQQQQ         QQQQQQQ QQ aQ  ",
        "V  VVVVVVVVV         VVVVVVV VV aV  ",
        "T  TTTTTTTTT         TTTTTTT TT  T  ",
        "@  @@@@@@@@@         @@@@@@@ @@ @@  ",
        "                             \x87      ",
        "[  [[[[[[[[[         [[[[[[[ [[ [[  ",
        "D  DDDDDDDDD         DDDDDDD DD DD  ",
        "                             HH     ",
        "                             \x88      ",
        "                             F\x89     ",
        "#      T#                    ##  #  ",
        "%   V  %%            U       %%  %  ",
        "'   'ZY''            'XW     ''  '  ",
        "(   (ZY((            (XW     ((  (  ",
        "+   +++++            +++\\[   ++  +  ",
        "*   *****            ***\\[   **  *  ",
        "-   -----            ---\\[   --  -  ",
        ",   ,,,,,            ,,,\\[   ,,  ,  ",
        "0   00000_^]         00000   00  0  ",
        "/   /////_^]         /////   //  /  ",
        "2   22222222         22222   22  2  ",
        "3   33333333         33333   33  3  ",
        "4   44444444         44444   44  4  ",
        "8   88888888         888888  88  8  ",
        "                                 ^  ",
        "                                 \x8A  ",
        ";  f;;;;;;;;         ;;;;;;e ;;  ;  ",
        "<  f<<<<<<<<         <<<<<<e <<  <  ",
        "O  OOOOOOOOO         OOOOOOO OO  O  ",
        "`  `````````         ``````` ``  `  ",
        "S  SSSSSSSSS         SSSSSSS SS  S  ",
        "W  WWWWWWWWW         WWWWWWW WW  W  ",
        "\\  \\\\\\\\\\\\\\\\\\         \\\\\\\\\\\\\\ \\\\ \\\\  ",
        "E  EEEEEEEEE         EEEEEEE EE EE  ",
        ` 1 0        /.-,+*)('    & %$  #  "!`,
        "]  ]]]]]]]]]         ]]]]]]] ]] ]]  ",
        "                             G      "
      ];
      XPathParser.gotoTable = [
        "3456789:;<=>?@ AB  CDEFGH IJ ",
        "                             ",
        "                             ",
        "                             ",
        "L456789:;<=>?@ AB  CDEFGH IJ ",
        "            M        EFGH IJ ",
        "       N;<=>?@ AB  CDEFGH IJ ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "            S        EFGH IJ ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "              e              ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                        h  J ",
        "              i          j   ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "o456789:;<=>?@ ABpqCDEFGH IJ ",
        "                             ",
        "  r6789:;<=>?@ AB  CDEFGH IJ ",
        "   s789:;<=>?@ AB  CDEFGH IJ ",
        "    t89:;<=>?@ AB  CDEFGH IJ ",
        "    u89:;<=>?@ AB  CDEFGH IJ ",
        "     v9:;<=>?@ AB  CDEFGH IJ ",
        "     w9:;<=>?@ AB  CDEFGH IJ ",
        "     x9:;<=>?@ AB  CDEFGH IJ ",
        "     y9:;<=>?@ AB  CDEFGH IJ ",
        "      z:;<=>?@ AB  CDEFGH IJ ",
        "      {:;<=>?@ AB  CDEFGH IJ ",
        "       |;<=>?@ AB  CDEFGH IJ ",
        "       };<=>?@ AB  CDEFGH IJ ",
        "       ~;<=>?@ AB  CDEFGH IJ ",
        "         \x7F=>?@ AB  CDEFGH IJ ",
        "\x80456789:;<=>?@ AB  CDEFGH IJ\x81",
        "            \x82        EFGH IJ ",
        "            \x83        EFGH IJ ",
        "                             ",
        "                     \x84 GH IJ ",
        "                     \x85 GH IJ ",
        "              i          \x86   ",
        "              i          \x87   ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "o456789:;<=>?@ AB\x8CqCDEFGH IJ ",
        "                             ",
        "                             "
      ];
      XPathParser.productions = [
        [1, 1, 2],
        [2, 1, 3],
        [3, 1, 4],
        [3, 3, 3, -9, 4],
        [4, 1, 5],
        [4, 3, 4, -8, 5],
        [5, 1, 6],
        [5, 3, 5, -22, 6],
        [5, 3, 5, -5, 6],
        [6, 1, 7],
        [6, 3, 6, -23, 7],
        [6, 3, 6, -24, 7],
        [6, 3, 6, -6, 7],
        [6, 3, 6, -7, 7],
        [7, 1, 8],
        [7, 3, 7, -25, 8],
        [7, 3, 7, -26, 8],
        [8, 1, 9],
        [8, 3, 8, -12, 9],
        [8, 3, 8, -11, 9],
        [8, 3, 8, -10, 9],
        [9, 1, 10],
        [9, 2, -26, 9],
        [10, 1, 11],
        [10, 3, 10, -27, 11],
        [11, 1, 12],
        [11, 1, 13],
        [11, 3, 13, -28, 14],
        [11, 3, 13, -4, 14],
        [13, 1, 15],
        [13, 2, 13, 16],
        [15, 1, 17],
        [15, 3, -29, 2, -30],
        [15, 1, -15],
        [15, 1, -16],
        [15, 1, 18],
        [18, 3, -13, -29, -30],
        [18, 4, -13, -29, 19, -30],
        [19, 1, 20],
        [19, 3, 20, -31, 19],
        [20, 1, 2],
        [12, 1, 14],
        [12, 1, 21],
        [21, 1, -28],
        [21, 2, -28, 14],
        [21, 1, 22],
        [14, 1, 23],
        [14, 3, 14, -28, 23],
        [14, 1, 24],
        [23, 2, 25, 26],
        [23, 1, 26],
        [23, 3, 25, 26, 27],
        [23, 2, 26, 27],
        [23, 1, 28],
        [27, 1, 16],
        [27, 2, 16, 27],
        [25, 2, -14, -3],
        [25, 1, -32],
        [26, 1, 29],
        [26, 3, -20, -29, -30],
        [26, 4, -21, -29, -15, -30],
        [16, 3, -33, 30, -34],
        [30, 1, 2],
        [22, 2, -4, 14],
        [24, 3, 14, -4, 23],
        [28, 1, -35],
        [28, 1, -2],
        [17, 2, -36, -18],
        [29, 1, -17],
        [29, 1, -19],
        [29, 1, -18]
      ];
      XPathParser.DOUBLEDOT = 2;
      XPathParser.DOUBLECOLON = 3;
      XPathParser.DOUBLESLASH = 4;
      XPathParser.NOTEQUAL = 5;
      XPathParser.LESSTHANOREQUAL = 6;
      XPathParser.GREATERTHANOREQUAL = 7;
      XPathParser.AND = 8;
      XPathParser.OR = 9;
      XPathParser.MOD = 10;
      XPathParser.DIV = 11;
      XPathParser.MULTIPLYOPERATOR = 12;
      XPathParser.FUNCTIONNAME = 13;
      XPathParser.AXISNAME = 14;
      XPathParser.LITERAL = 15;
      XPathParser.NUMBER = 16;
      XPathParser.ASTERISKNAMETEST = 17;
      XPathParser.QNAME = 18;
      XPathParser.NCNAMECOLONASTERISK = 19;
      XPathParser.NODETYPE = 20;
      XPathParser.PROCESSINGINSTRUCTIONWITHLITERAL = 21;
      XPathParser.EQUALS = 22;
      XPathParser.LESSTHAN = 23;
      XPathParser.GREATERTHAN = 24;
      XPathParser.PLUS = 25;
      XPathParser.MINUS = 26;
      XPathParser.BAR = 27;
      XPathParser.SLASH = 28;
      XPathParser.LEFTPARENTHESIS = 29;
      XPathParser.RIGHTPARENTHESIS = 30;
      XPathParser.COMMA = 31;
      XPathParser.AT = 32;
      XPathParser.LEFTBRACKET = 33;
      XPathParser.RIGHTBRACKET = 34;
      XPathParser.DOT = 35;
      XPathParser.DOLLAR = 36;
      XPathParser.prototype.tokenize = function(s1) {
        var types = [];
        var values = [];
        var s4 = s1 + "\0";
        var pos = 0;
        var c6 = s4.charAt(pos++);
        while (1) {
          while (c6 == " " || c6 == "	" || c6 == "\r" || c6 == "\n") {
            c6 = s4.charAt(pos++);
          }
          if (c6 == "\0" || pos >= s4.length) {
            break;
          }
          if (c6 == "(") {
            types.push(XPathParser.LEFTPARENTHESIS);
            values.push(c6);
            c6 = s4.charAt(pos++);
            continue;
          }
          if (c6 == ")") {
            types.push(XPathParser.RIGHTPARENTHESIS);
            values.push(c6);
            c6 = s4.charAt(pos++);
            continue;
          }
          if (c6 == "[") {
            types.push(XPathParser.LEFTBRACKET);
            values.push(c6);
            c6 = s4.charAt(pos++);
            continue;
          }
          if (c6 == "]") {
            types.push(XPathParser.RIGHTBRACKET);
            values.push(c6);
            c6 = s4.charAt(pos++);
            continue;
          }
          if (c6 == "@") {
            types.push(XPathParser.AT);
            values.push(c6);
            c6 = s4.charAt(pos++);
            continue;
          }
          if (c6 == ",") {
            types.push(XPathParser.COMMA);
            values.push(c6);
            c6 = s4.charAt(pos++);
            continue;
          }
          if (c6 == "|") {
            types.push(XPathParser.BAR);
            values.push(c6);
            c6 = s4.charAt(pos++);
            continue;
          }
          if (c6 == "+") {
            types.push(XPathParser.PLUS);
            values.push(c6);
            c6 = s4.charAt(pos++);
            continue;
          }
          if (c6 == "-") {
            types.push(XPathParser.MINUS);
            values.push(c6);
            c6 = s4.charAt(pos++);
            continue;
          }
          if (c6 == "=") {
            types.push(XPathParser.EQUALS);
            values.push(c6);
            c6 = s4.charAt(pos++);
            continue;
          }
          if (c6 == "$") {
            types.push(XPathParser.DOLLAR);
            values.push(c6);
            c6 = s4.charAt(pos++);
            continue;
          }
          if (c6 == ".") {
            c6 = s4.charAt(pos++);
            if (c6 == ".") {
              types.push(XPathParser.DOUBLEDOT);
              values.push("..");
              c6 = s4.charAt(pos++);
              continue;
            }
            if (c6 >= "0" && c6 <= "9") {
              var number = "." + c6;
              c6 = s4.charAt(pos++);
              while (c6 >= "0" && c6 <= "9") {
                number += c6;
                c6 = s4.charAt(pos++);
              }
              types.push(XPathParser.NUMBER);
              values.push(number);
              continue;
            }
            types.push(XPathParser.DOT);
            values.push(".");
            continue;
          }
          if (c6 == "'" || c6 == '"') {
            var delimiter = c6;
            var literal = "";
            while (pos < s4.length && (c6 = s4.charAt(pos)) !== delimiter) {
              literal += c6;
              pos += 1;
            }
            if (c6 !== delimiter) {
              throw XPathException.fromMessage("Unterminated string literal: " + delimiter + literal);
            }
            pos += 1;
            types.push(XPathParser.LITERAL);
            values.push(literal);
            c6 = s4.charAt(pos++);
            continue;
          }
          if (c6 >= "0" && c6 <= "9") {
            var number = c6;
            c6 = s4.charAt(pos++);
            while (c6 >= "0" && c6 <= "9") {
              number += c6;
              c6 = s4.charAt(pos++);
            }
            if (c6 == ".") {
              if (s4.charAt(pos) >= "0" && s4.charAt(pos) <= "9") {
                number += c6;
                number += s4.charAt(pos++);
                c6 = s4.charAt(pos++);
                while (c6 >= "0" && c6 <= "9") {
                  number += c6;
                  c6 = s4.charAt(pos++);
                }
              }
            }
            types.push(XPathParser.NUMBER);
            values.push(number);
            continue;
          }
          if (c6 == "*") {
            if (types.length > 0) {
              var last = types[types.length - 1];
              if (last != XPathParser.AT && last != XPathParser.DOUBLECOLON && last != XPathParser.LEFTPARENTHESIS && last != XPathParser.LEFTBRACKET && last != XPathParser.AND && last != XPathParser.OR && last != XPathParser.MOD && last != XPathParser.DIV && last != XPathParser.MULTIPLYOPERATOR && last != XPathParser.SLASH && last != XPathParser.DOUBLESLASH && last != XPathParser.BAR && last != XPathParser.PLUS && last != XPathParser.MINUS && last != XPathParser.EQUALS && last != XPathParser.NOTEQUAL && last != XPathParser.LESSTHAN && last != XPathParser.LESSTHANOREQUAL && last != XPathParser.GREATERTHAN && last != XPathParser.GREATERTHANOREQUAL) {
                types.push(XPathParser.MULTIPLYOPERATOR);
                values.push(c6);
                c6 = s4.charAt(pos++);
                continue;
              }
            }
            types.push(XPathParser.ASTERISKNAMETEST);
            values.push(c6);
            c6 = s4.charAt(pos++);
            continue;
          }
          if (c6 == ":") {
            if (s4.charAt(pos) == ":") {
              types.push(XPathParser.DOUBLECOLON);
              values.push("::");
              pos++;
              c6 = s4.charAt(pos++);
              continue;
            }
          }
          if (c6 == "/") {
            c6 = s4.charAt(pos++);
            if (c6 == "/") {
              types.push(XPathParser.DOUBLESLASH);
              values.push("//");
              c6 = s4.charAt(pos++);
              continue;
            }
            types.push(XPathParser.SLASH);
            values.push("/");
            continue;
          }
          if (c6 == "!") {
            if (s4.charAt(pos) == "=") {
              types.push(XPathParser.NOTEQUAL);
              values.push("!=");
              pos++;
              c6 = s4.charAt(pos++);
              continue;
            }
          }
          if (c6 == "<") {
            if (s4.charAt(pos) == "=") {
              types.push(XPathParser.LESSTHANOREQUAL);
              values.push("<=");
              pos++;
              c6 = s4.charAt(pos++);
              continue;
            }
            types.push(XPathParser.LESSTHAN);
            values.push("<");
            c6 = s4.charAt(pos++);
            continue;
          }
          if (c6 == ">") {
            if (s4.charAt(pos) == "=") {
              types.push(XPathParser.GREATERTHANOREQUAL);
              values.push(">=");
              pos++;
              c6 = s4.charAt(pos++);
              continue;
            }
            types.push(XPathParser.GREATERTHAN);
            values.push(">");
            c6 = s4.charAt(pos++);
            continue;
          }
          if (c6 == "_" || Utilities.isLetter(c6.charCodeAt(0))) {
            var name2 = c6;
            c6 = s4.charAt(pos++);
            while (Utilities.isNCNameChar(c6.charCodeAt(0))) {
              name2 += c6;
              c6 = s4.charAt(pos++);
            }
            if (types.length > 0) {
              var last = types[types.length - 1];
              if (last != XPathParser.AT && last != XPathParser.DOUBLECOLON && last != XPathParser.LEFTPARENTHESIS && last != XPathParser.LEFTBRACKET && last != XPathParser.AND && last != XPathParser.OR && last != XPathParser.MOD && last != XPathParser.DIV && last != XPathParser.MULTIPLYOPERATOR && last != XPathParser.SLASH && last != XPathParser.DOUBLESLASH && last != XPathParser.BAR && last != XPathParser.PLUS && last != XPathParser.MINUS && last != XPathParser.EQUALS && last != XPathParser.NOTEQUAL && last != XPathParser.LESSTHAN && last != XPathParser.LESSTHANOREQUAL && last != XPathParser.GREATERTHAN && last != XPathParser.GREATERTHANOREQUAL) {
                if (name2 == "and") {
                  types.push(XPathParser.AND);
                  values.push(name2);
                  continue;
                }
                if (name2 == "or") {
                  types.push(XPathParser.OR);
                  values.push(name2);
                  continue;
                }
                if (name2 == "mod") {
                  types.push(XPathParser.MOD);
                  values.push(name2);
                  continue;
                }
                if (name2 == "div") {
                  types.push(XPathParser.DIV);
                  values.push(name2);
                  continue;
                }
              }
            }
            if (c6 == ":") {
              if (s4.charAt(pos) == "*") {
                types.push(XPathParser.NCNAMECOLONASTERISK);
                values.push(name2 + ":*");
                pos++;
                c6 = s4.charAt(pos++);
                continue;
              }
              if (s4.charAt(pos) == "_" || Utilities.isLetter(s4.charCodeAt(pos))) {
                name2 += ":";
                c6 = s4.charAt(pos++);
                while (Utilities.isNCNameChar(c6.charCodeAt(0))) {
                  name2 += c6;
                  c6 = s4.charAt(pos++);
                }
                if (c6 == "(") {
                  types.push(XPathParser.FUNCTIONNAME);
                  values.push(name2);
                  continue;
                }
                types.push(XPathParser.QNAME);
                values.push(name2);
                continue;
              }
              if (s4.charAt(pos) == ":") {
                types.push(XPathParser.AXISNAME);
                values.push(name2);
                continue;
              }
            }
            if (c6 == "(") {
              if (name2 == "comment" || name2 == "text" || name2 == "node") {
                types.push(XPathParser.NODETYPE);
                values.push(name2);
                continue;
              }
              if (name2 == "processing-instruction") {
                if (s4.charAt(pos) == ")") {
                  types.push(XPathParser.NODETYPE);
                } else {
                  types.push(XPathParser.PROCESSINGINSTRUCTIONWITHLITERAL);
                }
                values.push(name2);
                continue;
              }
              types.push(XPathParser.FUNCTIONNAME);
              values.push(name2);
              continue;
            }
            types.push(XPathParser.QNAME);
            values.push(name2);
            continue;
          }
          throw new Error("Unexpected character " + c6);
        }
        types.push(1);
        values.push("[EOF]");
        return [types, values];
      };
      XPathParser.SHIFT = "s";
      XPathParser.REDUCE = "r";
      XPathParser.ACCEPT = "a";
      XPathParser.prototype.parse = function(s4) {
        var types;
        var values;
        var res = this.tokenize(s4);
        if (res == void 0) {
          return void 0;
        }
        types = res[0];
        values = res[1];
        var tokenPos = 0;
        var state = [];
        var tokenType = [];
        var tokenValue = [];
        var s4;
        var a3;
        var t4;
        state.push(0);
        tokenType.push(1);
        tokenValue.push("_S");
        a3 = types[tokenPos];
        t4 = values[tokenPos++];
        while (1) {
          s4 = state[state.length - 1];
          switch (XPathParser.actionTable[s4].charAt(a3 - 1)) {
            case XPathParser.SHIFT:
              tokenType.push(-a3);
              tokenValue.push(t4);
              state.push(XPathParser.actionTableNumber[s4].charCodeAt(a3 - 1) - 32);
              a3 = types[tokenPos];
              t4 = values[tokenPos++];
              break;
            case XPathParser.REDUCE:
              var num = XPathParser.productions[XPathParser.actionTableNumber[s4].charCodeAt(a3 - 1) - 32][1];
              var rhs = [];
              for (var i4 = 0; i4 < num; i4++) {
                tokenType.pop();
                rhs.unshift(tokenValue.pop());
                state.pop();
              }
              var s_ = state[state.length - 1];
              tokenType.push(XPathParser.productions[XPathParser.actionTableNumber[s4].charCodeAt(a3 - 1) - 32][0]);
              if (this.reduceActions[XPathParser.actionTableNumber[s4].charCodeAt(a3 - 1) - 32] == void 0) {
                tokenValue.push(rhs[0]);
              } else {
                tokenValue.push(this.reduceActions[XPathParser.actionTableNumber[s4].charCodeAt(a3 - 1) - 32](rhs));
              }
              state.push(XPathParser.gotoTable[s_].charCodeAt(XPathParser.productions[XPathParser.actionTableNumber[s4].charCodeAt(a3 - 1) - 32][0] - 2) - 33);
              break;
            case XPathParser.ACCEPT:
              return new XPath(tokenValue.pop());
            default:
              throw new Error("XPath parse error");
          }
        }
      };
      XPath.prototype = new Object();
      XPath.prototype.constructor = XPath;
      XPath.superclass = Object.prototype;
      function XPath(e2) {
        this.expression = e2;
      }
      XPath.prototype.toString = function() {
        return this.expression.toString();
      };
      function setIfUnset(obj, prop, value) {
        if (!(prop in obj)) {
          obj[prop] = value;
        }
      }
      XPath.prototype.evaluate = function(c6) {
        c6.contextNode = c6.expressionContextNode;
        c6.contextSize = 1;
        c6.contextPosition = 1;
        if (c6.isHtml) {
          setIfUnset(c6, "caseInsensitive", true);
          setIfUnset(c6, "allowAnyNamespaceForNoPrefix", true);
        }
        setIfUnset(c6, "caseInsensitive", false);
        return this.expression.evaluate(c6);
      };
      XPath.XML_NAMESPACE_URI = "http://www.w3.org/XML/1998/namespace";
      XPath.XMLNS_NAMESPACE_URI = "http://www.w3.org/2000/xmlns/";
      Expression.prototype = new Object();
      Expression.prototype.constructor = Expression;
      Expression.superclass = Object.prototype;
      function Expression() {
      }
      Expression.prototype.init = function() {
      };
      Expression.prototype.toString = function() {
        return "<Expression>";
      };
      Expression.prototype.evaluate = function(c6) {
        throw new Error("Could not evaluate expression.");
      };
      UnaryOperation.prototype = new Expression();
      UnaryOperation.prototype.constructor = UnaryOperation;
      UnaryOperation.superclass = Expression.prototype;
      function UnaryOperation(rhs) {
        if (arguments.length > 0) {
          this.init(rhs);
        }
      }
      UnaryOperation.prototype.init = function(rhs) {
        this.rhs = rhs;
      };
      UnaryMinusOperation.prototype = new UnaryOperation();
      UnaryMinusOperation.prototype.constructor = UnaryMinusOperation;
      UnaryMinusOperation.superclass = UnaryOperation.prototype;
      function UnaryMinusOperation(rhs) {
        if (arguments.length > 0) {
          this.init(rhs);
        }
      }
      UnaryMinusOperation.prototype.init = function(rhs) {
        UnaryMinusOperation.superclass.init.call(this, rhs);
      };
      UnaryMinusOperation.prototype.evaluate = function(c6) {
        return this.rhs.evaluate(c6).number().negate();
      };
      UnaryMinusOperation.prototype.toString = function() {
        return "-" + this.rhs.toString();
      };
      BinaryOperation.prototype = new Expression();
      BinaryOperation.prototype.constructor = BinaryOperation;
      BinaryOperation.superclass = Expression.prototype;
      function BinaryOperation(lhs, rhs) {
        if (arguments.length > 0) {
          this.init(lhs, rhs);
        }
      }
      BinaryOperation.prototype.init = function(lhs, rhs) {
        this.lhs = lhs;
        this.rhs = rhs;
      };
      OrOperation.prototype = new BinaryOperation();
      OrOperation.prototype.constructor = OrOperation;
      OrOperation.superclass = BinaryOperation.prototype;
      function OrOperation(lhs, rhs) {
        if (arguments.length > 0) {
          this.init(lhs, rhs);
        }
      }
      OrOperation.prototype.init = function(lhs, rhs) {
        OrOperation.superclass.init.call(this, lhs, rhs);
      };
      OrOperation.prototype.toString = function() {
        return "(" + this.lhs.toString() + " or " + this.rhs.toString() + ")";
      };
      OrOperation.prototype.evaluate = function(c6) {
        var b2 = this.lhs.evaluate(c6).bool();
        if (b2.booleanValue()) {
          return b2;
        }
        return this.rhs.evaluate(c6).bool();
      };
      AndOperation.prototype = new BinaryOperation();
      AndOperation.prototype.constructor = AndOperation;
      AndOperation.superclass = BinaryOperation.prototype;
      function AndOperation(lhs, rhs) {
        if (arguments.length > 0) {
          this.init(lhs, rhs);
        }
      }
      AndOperation.prototype.init = function(lhs, rhs) {
        AndOperation.superclass.init.call(this, lhs, rhs);
      };
      AndOperation.prototype.toString = function() {
        return "(" + this.lhs.toString() + " and " + this.rhs.toString() + ")";
      };
      AndOperation.prototype.evaluate = function(c6) {
        var b2 = this.lhs.evaluate(c6).bool();
        if (!b2.booleanValue()) {
          return b2;
        }
        return this.rhs.evaluate(c6).bool();
      };
      EqualsOperation.prototype = new BinaryOperation();
      EqualsOperation.prototype.constructor = EqualsOperation;
      EqualsOperation.superclass = BinaryOperation.prototype;
      function EqualsOperation(lhs, rhs) {
        if (arguments.length > 0) {
          this.init(lhs, rhs);
        }
      }
      EqualsOperation.prototype.init = function(lhs, rhs) {
        EqualsOperation.superclass.init.call(this, lhs, rhs);
      };
      EqualsOperation.prototype.toString = function() {
        return "(" + this.lhs.toString() + " = " + this.rhs.toString() + ")";
      };
      EqualsOperation.prototype.evaluate = function(c6) {
        return this.lhs.evaluate(c6).equals(this.rhs.evaluate(c6));
      };
      NotEqualOperation.prototype = new BinaryOperation();
      NotEqualOperation.prototype.constructor = NotEqualOperation;
      NotEqualOperation.superclass = BinaryOperation.prototype;
      function NotEqualOperation(lhs, rhs) {
        if (arguments.length > 0) {
          this.init(lhs, rhs);
        }
      }
      NotEqualOperation.prototype.init = function(lhs, rhs) {
        NotEqualOperation.superclass.init.call(this, lhs, rhs);
      };
      NotEqualOperation.prototype.toString = function() {
        return "(" + this.lhs.toString() + " != " + this.rhs.toString() + ")";
      };
      NotEqualOperation.prototype.evaluate = function(c6) {
        return this.lhs.evaluate(c6).notequal(this.rhs.evaluate(c6));
      };
      LessThanOperation.prototype = new BinaryOperation();
      LessThanOperation.prototype.constructor = LessThanOperation;
      LessThanOperation.superclass = BinaryOperation.prototype;
      function LessThanOperation(lhs, rhs) {
        if (arguments.length > 0) {
          this.init(lhs, rhs);
        }
      }
      LessThanOperation.prototype.init = function(lhs, rhs) {
        LessThanOperation.superclass.init.call(this, lhs, rhs);
      };
      LessThanOperation.prototype.evaluate = function(c6) {
        return this.lhs.evaluate(c6).lessthan(this.rhs.evaluate(c6));
      };
      LessThanOperation.prototype.toString = function() {
        return "(" + this.lhs.toString() + " < " + this.rhs.toString() + ")";
      };
      GreaterThanOperation.prototype = new BinaryOperation();
      GreaterThanOperation.prototype.constructor = GreaterThanOperation;
      GreaterThanOperation.superclass = BinaryOperation.prototype;
      function GreaterThanOperation(lhs, rhs) {
        if (arguments.length > 0) {
          this.init(lhs, rhs);
        }
      }
      GreaterThanOperation.prototype.init = function(lhs, rhs) {
        GreaterThanOperation.superclass.init.call(this, lhs, rhs);
      };
      GreaterThanOperation.prototype.evaluate = function(c6) {
        return this.lhs.evaluate(c6).greaterthan(this.rhs.evaluate(c6));
      };
      GreaterThanOperation.prototype.toString = function() {
        return "(" + this.lhs.toString() + " > " + this.rhs.toString() + ")";
      };
      LessThanOrEqualOperation.prototype = new BinaryOperation();
      LessThanOrEqualOperation.prototype.constructor = LessThanOrEqualOperation;
      LessThanOrEqualOperation.superclass = BinaryOperation.prototype;
      function LessThanOrEqualOperation(lhs, rhs) {
        if (arguments.length > 0) {
          this.init(lhs, rhs);
        }
      }
      LessThanOrEqualOperation.prototype.init = function(lhs, rhs) {
        LessThanOrEqualOperation.superclass.init.call(this, lhs, rhs);
      };
      LessThanOrEqualOperation.prototype.evaluate = function(c6) {
        return this.lhs.evaluate(c6).lessthanorequal(this.rhs.evaluate(c6));
      };
      LessThanOrEqualOperation.prototype.toString = function() {
        return "(" + this.lhs.toString() + " <= " + this.rhs.toString() + ")";
      };
      GreaterThanOrEqualOperation.prototype = new BinaryOperation();
      GreaterThanOrEqualOperation.prototype.constructor = GreaterThanOrEqualOperation;
      GreaterThanOrEqualOperation.superclass = BinaryOperation.prototype;
      function GreaterThanOrEqualOperation(lhs, rhs) {
        if (arguments.length > 0) {
          this.init(lhs, rhs);
        }
      }
      GreaterThanOrEqualOperation.prototype.init = function(lhs, rhs) {
        GreaterThanOrEqualOperation.superclass.init.call(this, lhs, rhs);
      };
      GreaterThanOrEqualOperation.prototype.evaluate = function(c6) {
        return this.lhs.evaluate(c6).greaterthanorequal(this.rhs.evaluate(c6));
      };
      GreaterThanOrEqualOperation.prototype.toString = function() {
        return "(" + this.lhs.toString() + " >= " + this.rhs.toString() + ")";
      };
      PlusOperation.prototype = new BinaryOperation();
      PlusOperation.prototype.constructor = PlusOperation;
      PlusOperation.superclass = BinaryOperation.prototype;
      function PlusOperation(lhs, rhs) {
        if (arguments.length > 0) {
          this.init(lhs, rhs);
        }
      }
      PlusOperation.prototype.init = function(lhs, rhs) {
        PlusOperation.superclass.init.call(this, lhs, rhs);
      };
      PlusOperation.prototype.evaluate = function(c6) {
        return this.lhs.evaluate(c6).number().plus(this.rhs.evaluate(c6).number());
      };
      PlusOperation.prototype.toString = function() {
        return "(" + this.lhs.toString() + " + " + this.rhs.toString() + ")";
      };
      MinusOperation.prototype = new BinaryOperation();
      MinusOperation.prototype.constructor = MinusOperation;
      MinusOperation.superclass = BinaryOperation.prototype;
      function MinusOperation(lhs, rhs) {
        if (arguments.length > 0) {
          this.init(lhs, rhs);
        }
      }
      MinusOperation.prototype.init = function(lhs, rhs) {
        MinusOperation.superclass.init.call(this, lhs, rhs);
      };
      MinusOperation.prototype.evaluate = function(c6) {
        return this.lhs.evaluate(c6).number().minus(this.rhs.evaluate(c6).number());
      };
      MinusOperation.prototype.toString = function() {
        return "(" + this.lhs.toString() + " - " + this.rhs.toString() + ")";
      };
      MultiplyOperation.prototype = new BinaryOperation();
      MultiplyOperation.prototype.constructor = MultiplyOperation;
      MultiplyOperation.superclass = BinaryOperation.prototype;
      function MultiplyOperation(lhs, rhs) {
        if (arguments.length > 0) {
          this.init(lhs, rhs);
        }
      }
      MultiplyOperation.prototype.init = function(lhs, rhs) {
        MultiplyOperation.superclass.init.call(this, lhs, rhs);
      };
      MultiplyOperation.prototype.evaluate = function(c6) {
        return this.lhs.evaluate(c6).number().multiply(this.rhs.evaluate(c6).number());
      };
      MultiplyOperation.prototype.toString = function() {
        return "(" + this.lhs.toString() + " * " + this.rhs.toString() + ")";
      };
      DivOperation.prototype = new BinaryOperation();
      DivOperation.prototype.constructor = DivOperation;
      DivOperation.superclass = BinaryOperation.prototype;
      function DivOperation(lhs, rhs) {
        if (arguments.length > 0) {
          this.init(lhs, rhs);
        }
      }
      DivOperation.prototype.init = function(lhs, rhs) {
        DivOperation.superclass.init.call(this, lhs, rhs);
      };
      DivOperation.prototype.evaluate = function(c6) {
        return this.lhs.evaluate(c6).number().div(this.rhs.evaluate(c6).number());
      };
      DivOperation.prototype.toString = function() {
        return "(" + this.lhs.toString() + " div " + this.rhs.toString() + ")";
      };
      ModOperation.prototype = new BinaryOperation();
      ModOperation.prototype.constructor = ModOperation;
      ModOperation.superclass = BinaryOperation.prototype;
      function ModOperation(lhs, rhs) {
        if (arguments.length > 0) {
          this.init(lhs, rhs);
        }
      }
      ModOperation.prototype.init = function(lhs, rhs) {
        ModOperation.superclass.init.call(this, lhs, rhs);
      };
      ModOperation.prototype.evaluate = function(c6) {
        return this.lhs.evaluate(c6).number().mod(this.rhs.evaluate(c6).number());
      };
      ModOperation.prototype.toString = function() {
        return "(" + this.lhs.toString() + " mod " + this.rhs.toString() + ")";
      };
      BarOperation.prototype = new BinaryOperation();
      BarOperation.prototype.constructor = BarOperation;
      BarOperation.superclass = BinaryOperation.prototype;
      function BarOperation(lhs, rhs) {
        if (arguments.length > 0) {
          this.init(lhs, rhs);
        }
      }
      BarOperation.prototype.init = function(lhs, rhs) {
        BarOperation.superclass.init.call(this, lhs, rhs);
      };
      BarOperation.prototype.evaluate = function(c6) {
        return this.lhs.evaluate(c6).nodeset().union(this.rhs.evaluate(c6).nodeset());
      };
      BarOperation.prototype.toString = function() {
        return map(toString, [this.lhs, this.rhs]).join(" | ");
      };
      PathExpr.prototype = new Expression();
      PathExpr.prototype.constructor = PathExpr;
      PathExpr.superclass = Expression.prototype;
      function PathExpr(filter3, filterPreds, locpath) {
        if (arguments.length > 0) {
          this.init(filter3, filterPreds, locpath);
        }
      }
      PathExpr.prototype.init = function(filter3, filterPreds, locpath) {
        PathExpr.superclass.init.call(this);
        this.filter = filter3;
        this.filterPredicates = filterPreds;
        this.locationPath = locpath;
      };
      function findRoot(node) {
        while (node && node.parentNode) {
          node = node.parentNode;
        }
        return node;
      }
      PathExpr.applyPredicates = function(predicates, c6, nodes) {
        if (predicates.length === 0) {
          return nodes;
        }
        var ctx = c6.extend({});
        return reduce(
          function(inNodes, pred) {
            ctx.contextSize = inNodes.length;
            return filter2(
              function(node, i4) {
                ctx.contextNode = node;
                ctx.contextPosition = i4 + 1;
                return PathExpr.predicateMatches(pred, ctx);
              },
              inNodes
            );
          },
          nodes,
          predicates
        );
      };
      PathExpr.getRoot = function(xpc, nodes) {
        var firstNode = nodes[0];
        if (firstNode.nodeType === 9) {
          return firstNode;
        }
        if (xpc.virtualRoot) {
          return xpc.virtualRoot;
        }
        var ownerDoc = firstNode.ownerDocument;
        if (ownerDoc) {
          return ownerDoc;
        }
        var n3 = firstNode;
        while (n3.parentNode != null) {
          n3 = n3.parentNode;
        }
        return n3;
      };
      PathExpr.applyStep = function(step, xpc, node) {
        var self = this;
        var newNodes = [];
        xpc.contextNode = node;
        switch (step.axis) {
          case Step.ANCESTOR:
            if (xpc.contextNode === xpc.virtualRoot) {
              break;
            }
            var m2;
            if (xpc.contextNode.nodeType == 2) {
              m2 = PathExpr.getOwnerElement(xpc.contextNode);
            } else {
              m2 = xpc.contextNode.parentNode;
            }
            while (m2 != null) {
              if (step.nodeTest.matches(m2, xpc)) {
                newNodes.push(m2);
              }
              if (m2 === xpc.virtualRoot) {
                break;
              }
              m2 = m2.parentNode;
            }
            break;
          case Step.ANCESTORORSELF:
            for (var m2 = xpc.contextNode; m2 != null; m2 = m2.nodeType == 2 ? PathExpr.getOwnerElement(m2) : m2.parentNode) {
              if (step.nodeTest.matches(m2, xpc)) {
                newNodes.push(m2);
              }
              if (m2 === xpc.virtualRoot) {
                break;
              }
            }
            break;
          case Step.ATTRIBUTE:
            var nnm = xpc.contextNode.attributes;
            if (nnm != null) {
              for (var k = 0; k < nnm.length; k++) {
                var m2 = nnm.item(k);
                if (step.nodeTest.matches(m2, xpc)) {
                  newNodes.push(m2);
                }
              }
            }
            break;
          case Step.CHILD:
            for (var m2 = xpc.contextNode.firstChild; m2 != null; m2 = m2.nextSibling) {
              if (step.nodeTest.matches(m2, xpc)) {
                newNodes.push(m2);
              }
            }
            break;
          case Step.DESCENDANT:
            var st = [xpc.contextNode.firstChild];
            while (st.length > 0) {
              for (var m2 = st.pop(); m2 != null; ) {
                if (step.nodeTest.matches(m2, xpc)) {
                  newNodes.push(m2);
                }
                if (m2.firstChild != null) {
                  st.push(m2.nextSibling);
                  m2 = m2.firstChild;
                } else {
                  m2 = m2.nextSibling;
                }
              }
            }
            break;
          case Step.DESCENDANTORSELF:
            if (step.nodeTest.matches(xpc.contextNode, xpc)) {
              newNodes.push(xpc.contextNode);
            }
            var st = [xpc.contextNode.firstChild];
            while (st.length > 0) {
              for (var m2 = st.pop(); m2 != null; ) {
                if (step.nodeTest.matches(m2, xpc)) {
                  newNodes.push(m2);
                }
                if (m2.firstChild != null) {
                  st.push(m2.nextSibling);
                  m2 = m2.firstChild;
                } else {
                  m2 = m2.nextSibling;
                }
              }
            }
            break;
          case Step.FOLLOWING:
            if (xpc.contextNode === xpc.virtualRoot) {
              break;
            }
            var st = [];
            if (xpc.contextNode.firstChild != null) {
              st.unshift(xpc.contextNode.firstChild);
            } else {
              st.unshift(xpc.contextNode.nextSibling);
            }
            for (var m2 = xpc.contextNode.parentNode; m2 != null && m2.nodeType != 9 && m2 !== xpc.virtualRoot; m2 = m2.parentNode) {
              st.unshift(m2.nextSibling);
            }
            do {
              for (var m2 = st.pop(); m2 != null; ) {
                if (step.nodeTest.matches(m2, xpc)) {
                  newNodes.push(m2);
                }
                if (m2.firstChild != null) {
                  st.push(m2.nextSibling);
                  m2 = m2.firstChild;
                } else {
                  m2 = m2.nextSibling;
                }
              }
            } while (st.length > 0);
            break;
          case Step.FOLLOWINGSIBLING:
            if (xpc.contextNode === xpc.virtualRoot) {
              break;
            }
            for (var m2 = xpc.contextNode.nextSibling; m2 != null; m2 = m2.nextSibling) {
              if (step.nodeTest.matches(m2, xpc)) {
                newNodes.push(m2);
              }
            }
            break;
          case Step.NAMESPACE:
            var n3 = {};
            if (xpc.contextNode.nodeType == 1) {
              n3["xml"] = XPath.XML_NAMESPACE_URI;
              n3["xmlns"] = XPath.XMLNS_NAMESPACE_URI;
              for (var m2 = xpc.contextNode; m2 != null && m2.nodeType == 1; m2 = m2.parentNode) {
                for (var k = 0; k < m2.attributes.length; k++) {
                  var attr = m2.attributes.item(k);
                  var nm = String(attr.name);
                  if (nm == "xmlns") {
                    if (n3[""] == void 0) {
                      n3[""] = attr.value;
                    }
                  } else if (nm.length > 6 && nm.substring(0, 6) == "xmlns:") {
                    var pre = nm.substring(6, nm.length);
                    if (n3[pre] == void 0) {
                      n3[pre] = attr.value;
                    }
                  }
                }
              }
              for (var pre in n3) {
                var nsn = new XPathNamespace(pre, n3[pre], xpc.contextNode);
                if (step.nodeTest.matches(nsn, xpc)) {
                  newNodes.push(nsn);
                }
              }
            }
            break;
          case Step.PARENT:
            m2 = null;
            if (xpc.contextNode !== xpc.virtualRoot) {
              if (xpc.contextNode.nodeType == 2) {
                m2 = PathExpr.getOwnerElement(xpc.contextNode);
              } else {
                m2 = xpc.contextNode.parentNode;
              }
            }
            if (m2 != null && step.nodeTest.matches(m2, xpc)) {
              newNodes.push(m2);
            }
            break;
          case Step.PRECEDING:
            var st;
            if (xpc.virtualRoot != null) {
              st = [xpc.virtualRoot];
            } else {
              st = [findRoot(xpc.contextNode)];
            }
            outer:
              while (st.length > 0) {
                for (var m2 = st.pop(); m2 != null; ) {
                  if (m2 == xpc.contextNode) {
                    break outer;
                  }
                  if (step.nodeTest.matches(m2, xpc)) {
                    newNodes.unshift(m2);
                  }
                  if (m2.firstChild != null) {
                    st.push(m2.nextSibling);
                    m2 = m2.firstChild;
                  } else {
                    m2 = m2.nextSibling;
                  }
                }
              }
            break;
          case Step.PRECEDINGSIBLING:
            if (xpc.contextNode === xpc.virtualRoot) {
              break;
            }
            for (var m2 = xpc.contextNode.previousSibling; m2 != null; m2 = m2.previousSibling) {
              if (step.nodeTest.matches(m2, xpc)) {
                newNodes.push(m2);
              }
            }
            break;
          case Step.SELF:
            if (step.nodeTest.matches(xpc.contextNode, xpc)) {
              newNodes.push(xpc.contextNode);
            }
            break;
          default:
        }
        return newNodes;
      };
      function applyStepWithPredicates(step, xpc, node) {
        return PathExpr.applyPredicates(
          step.predicates,
          xpc,
          PathExpr.applyStep(step, xpc, node)
        );
      }
      function applyStepToNodes(context, nodes, step) {
        return flatten(
          map(
            applyStepWithPredicates.bind(null, step, context),
            nodes
          )
        );
      }
      PathExpr.applySteps = function(steps, xpc, nodes) {
        return reduce(
          applyStepToNodes.bind(null, xpc),
          nodes,
          steps
        );
      };
      PathExpr.prototype.applyFilter = function(c6, xpc) {
        if (!this.filter) {
          return { nodes: [c6.contextNode] };
        }
        var ns = this.filter.evaluate(c6);
        if (!Utilities.instance_of(ns, XNodeSet)) {
          if (this.filterPredicates != null && this.filterPredicates.length > 0 || this.locationPath != null) {
            throw new Error("Path expression filter must evaluate to a nodeset if predicates or location path are used");
          }
          return { nonNodes: ns };
        }
        return {
          nodes: PathExpr.applyPredicates(this.filterPredicates || [], xpc, ns.toUnsortedArray())
        };
      };
      PathExpr.applyLocationPath = function(locationPath, xpc, nodes) {
        if (!locationPath) {
          return nodes;
        }
        var startNodes = locationPath.absolute ? [PathExpr.getRoot(xpc, nodes)] : nodes;
        return PathExpr.applySteps(locationPath.steps, xpc, startNodes);
      };
      PathExpr.prototype.evaluate = function(c6) {
        var xpc = assign(new XPathContext(), c6);
        var filterResult = this.applyFilter(c6, xpc);
        if ("nonNodes" in filterResult) {
          return filterResult.nonNodes;
        }
        var ns = new XNodeSet();
        ns.addArray(PathExpr.applyLocationPath(this.locationPath, xpc, filterResult.nodes));
        return ns;
      };
      PathExpr.predicateMatches = function(pred, c6) {
        var res = pred.evaluate(c6);
        return Utilities.instance_of(res, XNumber) ? c6.contextPosition === res.numberValue() : res.booleanValue();
      };
      PathExpr.predicateString = function(predicate) {
        return wrap("[", "]", predicate.toString());
      };
      PathExpr.predicatesString = function(predicates) {
        return join(
          "",
          map(PathExpr.predicateString, predicates)
        );
      };
      PathExpr.prototype.toString = function() {
        if (this.filter != void 0) {
          var filterStr = toString(this.filter);
          if (Utilities.instance_of(this.filter, XString)) {
            return wrap("'", "'", filterStr);
          }
          if (this.filterPredicates != void 0 && this.filterPredicates.length) {
            return wrap("(", ")", filterStr) + PathExpr.predicatesString(this.filterPredicates);
          }
          if (this.locationPath != void 0) {
            return filterStr + (this.locationPath.absolute ? "" : "/") + toString(this.locationPath);
          }
          return filterStr;
        }
        return toString(this.locationPath);
      };
      PathExpr.getOwnerElement = function(n3) {
        if (n3.ownerElement) {
          return n3.ownerElement;
        }
        try {
          if (n3.selectSingleNode) {
            return n3.selectSingleNode("..");
          }
        } catch (e2) {
        }
        var doc = n3.nodeType == 9 ? n3 : n3.ownerDocument;
        var elts = doc.getElementsByTagName("*");
        for (var i4 = 0; i4 < elts.length; i4++) {
          var elt = elts.item(i4);
          var nnm = elt.attributes;
          for (var j = 0; j < nnm.length; j++) {
            var an = nnm.item(j);
            if (an === n3) {
              return elt;
            }
          }
        }
        return null;
      };
      LocationPath.prototype = new Object();
      LocationPath.prototype.constructor = LocationPath;
      LocationPath.superclass = Object.prototype;
      function LocationPath(abs, steps) {
        if (arguments.length > 0) {
          this.init(abs, steps);
        }
      }
      LocationPath.prototype.init = function(abs, steps) {
        this.absolute = abs;
        this.steps = steps;
      };
      LocationPath.prototype.toString = function() {
        return (this.absolute ? "/" : "") + map(toString, this.steps).join("/");
      };
      Step.prototype = new Object();
      Step.prototype.constructor = Step;
      Step.superclass = Object.prototype;
      function Step(axis, nodetest, preds) {
        if (arguments.length > 0) {
          this.init(axis, nodetest, preds);
        }
      }
      Step.prototype.init = function(axis, nodetest, preds) {
        this.axis = axis;
        this.nodeTest = nodetest;
        this.predicates = preds;
      };
      Step.prototype.toString = function() {
        return Step.STEPNAMES[this.axis] + "::" + this.nodeTest.toString() + PathExpr.predicatesString(this.predicates);
      };
      Step.ANCESTOR = 0;
      Step.ANCESTORORSELF = 1;
      Step.ATTRIBUTE = 2;
      Step.CHILD = 3;
      Step.DESCENDANT = 4;
      Step.DESCENDANTORSELF = 5;
      Step.FOLLOWING = 6;
      Step.FOLLOWINGSIBLING = 7;
      Step.NAMESPACE = 8;
      Step.PARENT = 9;
      Step.PRECEDING = 10;
      Step.PRECEDINGSIBLING = 11;
      Step.SELF = 12;
      Step.STEPNAMES = reduce(function(acc, x3) {
        return acc[x3[0]] = x3[1], acc;
      }, {}, [
        [Step.ANCESTOR, "ancestor"],
        [Step.ANCESTORORSELF, "ancestor-or-self"],
        [Step.ATTRIBUTE, "attribute"],
        [Step.CHILD, "child"],
        [Step.DESCENDANT, "descendant"],
        [Step.DESCENDANTORSELF, "descendant-or-self"],
        [Step.FOLLOWING, "following"],
        [Step.FOLLOWINGSIBLING, "following-sibling"],
        [Step.NAMESPACE, "namespace"],
        [Step.PARENT, "parent"],
        [Step.PRECEDING, "preceding"],
        [Step.PRECEDINGSIBLING, "preceding-sibling"],
        [Step.SELF, "self"]
      ]);
      NodeTest.prototype = new Object();
      NodeTest.prototype.constructor = NodeTest;
      NodeTest.superclass = Object.prototype;
      function NodeTest(type, value) {
        if (arguments.length > 0) {
          this.init(type, value);
        }
      }
      NodeTest.prototype.init = function(type, value) {
        this.type = type;
        this.value = value;
      };
      NodeTest.prototype.toString = function() {
        return "<unknown nodetest type>";
      };
      NodeTest.prototype.matches = function(n3, xpc) {
        console.warn("unknown node test type");
      };
      NodeTest.NAMETESTANY = 0;
      NodeTest.NAMETESTPREFIXANY = 1;
      NodeTest.NAMETESTQNAME = 2;
      NodeTest.COMMENT = 3;
      NodeTest.TEXT = 4;
      NodeTest.PI = 5;
      NodeTest.NODE = 6;
      NodeTest.isNodeType = function(types) {
        return function(node) {
          return includes(types, node.nodeType);
        };
      };
      NodeTest.makeNodeTestType = function(type, members, ctor) {
        var newType = ctor || function() {
        };
        newType.prototype = new NodeTest(type);
        newType.prototype.constructor = newType;
        assign(newType.prototype, members);
        return newType;
      };
      NodeTest.makeNodeTypeTest = function(type, nodeTypes, stringVal) {
        return new (NodeTest.makeNodeTestType(type, {
          matches: NodeTest.isNodeType(nodeTypes),
          toString: always(stringVal)
        }))();
      };
      NodeTest.hasPrefix = function(node) {
        return node.prefix || (node.nodeName || node.tagName).indexOf(":") !== -1;
      };
      NodeTest.isElementOrAttribute = NodeTest.isNodeType([1, 2]);
      NodeTest.nameSpaceMatches = function(prefix, xpc, n3) {
        var nNamespace = n3.namespaceURI || "";
        if (!prefix) {
          return !nNamespace || xpc.allowAnyNamespaceForNoPrefix && !NodeTest.hasPrefix(n3);
        }
        var ns = xpc.namespaceResolver.getNamespace(prefix, xpc.expressionContextNode);
        if (ns == null) {
          throw new Error("Cannot resolve QName " + prefix);
        }
        return ns === nNamespace;
      };
      NodeTest.localNameMatches = function(localName, xpc, n3) {
        var nLocalName = n3.localName || n3.nodeName;
        return xpc.caseInsensitive ? localName.toLowerCase() === nLocalName.toLowerCase() : localName === nLocalName;
      };
      NodeTest.NameTestPrefixAny = NodeTest.makeNodeTestType(
        NodeTest.NAMETESTPREFIXANY,
        {
          matches: function(n3, xpc) {
            return NodeTest.isElementOrAttribute(n3) && NodeTest.nameSpaceMatches(this.prefix, xpc, n3);
          },
          toString: function() {
            return this.prefix + ":*";
          }
        },
        function NameTestPrefixAny(prefix) {
          this.prefix = prefix;
        }
      );
      NodeTest.NameTestQName = NodeTest.makeNodeTestType(
        NodeTest.NAMETESTQNAME,
        {
          matches: function(n3, xpc) {
            return NodeTest.isNodeType([1, 2, XPathNamespace.XPATH_NAMESPACE_NODE])(n3) && NodeTest.nameSpaceMatches(this.prefix, xpc, n3) && NodeTest.localNameMatches(this.localName, xpc, n3);
          },
          toString: function() {
            return this.name;
          }
        },
        function NameTestQName(name2) {
          var nameParts = name2.split(":");
          this.name = name2;
          this.prefix = nameParts.length > 1 ? nameParts[0] : null;
          this.localName = nameParts[nameParts.length > 1 ? 1 : 0];
        }
      );
      NodeTest.PITest = NodeTest.makeNodeTestType(NodeTest.PI, {
        matches: function(n3, xpc) {
          return NodeTest.isNodeType([7])(n3) && (n3.target || n3.nodeName) === this.name;
        },
        toString: function() {
          return wrap('processing-instruction("', '")', this.name);
        }
      }, function(name2) {
        this.name = name2;
      });
      NodeTest.nameTestAny = NodeTest.makeNodeTypeTest(NodeTest.NAMETESTANY, [1, 2, XPathNamespace.XPATH_NAMESPACE_NODE], "*");
      NodeTest.textTest = NodeTest.makeNodeTypeTest(NodeTest.TEXT, [3, 4], "text()");
      NodeTest.commentTest = NodeTest.makeNodeTypeTest(NodeTest.COMMENT, [8], "comment()");
      NodeTest.nodeTest = NodeTest.makeNodeTypeTest(NodeTest.NODE, [1, 2, 3, 4, 7, 8, 9], "node()");
      NodeTest.anyPiTest = NodeTest.makeNodeTypeTest(NodeTest.PI, [7], "processing-instruction()");
      VariableReference.prototype = new Expression();
      VariableReference.prototype.constructor = VariableReference;
      VariableReference.superclass = Expression.prototype;
      function VariableReference(v) {
        if (arguments.length > 0) {
          this.init(v);
        }
      }
      VariableReference.prototype.init = function(v) {
        this.variable = v;
      };
      VariableReference.prototype.toString = function() {
        return "$" + this.variable;
      };
      VariableReference.prototype.evaluate = function(c6) {
        var parts = Utilities.resolveQName(this.variable, c6.namespaceResolver, c6.contextNode, false);
        if (parts[0] == null) {
          throw new Error("Cannot resolve QName " + fn);
        }
        var result = c6.variableResolver.getVariable(parts[1], parts[0]);
        if (!result) {
          throw XPathException.fromMessage("Undeclared variable: " + this.toString());
        }
        return result;
      };
      FunctionCall.prototype = new Expression();
      FunctionCall.prototype.constructor = FunctionCall;
      FunctionCall.superclass = Expression.prototype;
      function FunctionCall(fn2, args) {
        if (arguments.length > 0) {
          this.init(fn2, args);
        }
      }
      FunctionCall.prototype.init = function(fn2, args) {
        this.functionName = fn2;
        this.arguments = args;
      };
      FunctionCall.prototype.toString = function() {
        var s4 = this.functionName + "(";
        for (var i4 = 0; i4 < this.arguments.length; i4++) {
          if (i4 > 0) {
            s4 += ", ";
          }
          s4 += this.arguments[i4].toString();
        }
        return s4 + ")";
      };
      FunctionCall.prototype.evaluate = function(c6) {
        var f3 = FunctionResolver.getFunctionFromContext(this.functionName, c6);
        if (!f3) {
          throw new Error("Unknown function " + this.functionName);
        }
        var a3 = [c6].concat(this.arguments);
        return f3.apply(c6.functionResolver.thisArg, a3);
      };
      var Operators = new Object();
      Operators.equals = function(l4, r2) {
        return l4.equals(r2);
      };
      Operators.notequal = function(l4, r2) {
        return l4.notequal(r2);
      };
      Operators.lessthan = function(l4, r2) {
        return l4.lessthan(r2);
      };
      Operators.greaterthan = function(l4, r2) {
        return l4.greaterthan(r2);
      };
      Operators.lessthanorequal = function(l4, r2) {
        return l4.lessthanorequal(r2);
      };
      Operators.greaterthanorequal = function(l4, r2) {
        return l4.greaterthanorequal(r2);
      };
      XString.prototype = new Expression();
      XString.prototype.constructor = XString;
      XString.superclass = Expression.prototype;
      function XString(s4) {
        if (arguments.length > 0) {
          this.init(s4);
        }
      }
      XString.prototype.init = function(s4) {
        this.str = String(s4);
      };
      XString.prototype.toString = function() {
        return this.str;
      };
      XString.prototype.evaluate = function(c6) {
        return this;
      };
      XString.prototype.string = function() {
        return this;
      };
      XString.prototype.number = function() {
        return new XNumber(this.str);
      };
      XString.prototype.bool = function() {
        return new XBoolean(this.str);
      };
      XString.prototype.nodeset = function() {
        throw new Error("Cannot convert string to nodeset");
      };
      XString.prototype.stringValue = function() {
        return this.str;
      };
      XString.prototype.numberValue = function() {
        return this.number().numberValue();
      };
      XString.prototype.booleanValue = function() {
        return this.bool().booleanValue();
      };
      XString.prototype.equals = function(r2) {
        if (Utilities.instance_of(r2, XBoolean)) {
          return this.bool().equals(r2);
        }
        if (Utilities.instance_of(r2, XNumber)) {
          return this.number().equals(r2);
        }
        if (Utilities.instance_of(r2, XNodeSet)) {
          return r2.compareWithString(this, Operators.equals);
        }
        return new XBoolean(this.str == r2.str);
      };
      XString.prototype.notequal = function(r2) {
        if (Utilities.instance_of(r2, XBoolean)) {
          return this.bool().notequal(r2);
        }
        if (Utilities.instance_of(r2, XNumber)) {
          return this.number().notequal(r2);
        }
        if (Utilities.instance_of(r2, XNodeSet)) {
          return r2.compareWithString(this, Operators.notequal);
        }
        return new XBoolean(this.str != r2.str);
      };
      XString.prototype.lessthan = function(r2) {
        return this.number().lessthan(r2);
      };
      XString.prototype.greaterthan = function(r2) {
        return this.number().greaterthan(r2);
      };
      XString.prototype.lessthanorequal = function(r2) {
        return this.number().lessthanorequal(r2);
      };
      XString.prototype.greaterthanorequal = function(r2) {
        return this.number().greaterthanorequal(r2);
      };
      XNumber.prototype = new Expression();
      XNumber.prototype.constructor = XNumber;
      XNumber.superclass = Expression.prototype;
      function XNumber(n3) {
        if (arguments.length > 0) {
          this.init(n3);
        }
      }
      XNumber.prototype.init = function(n3) {
        this.num = typeof n3 === "string" ? this.parse(n3) : Number(n3);
      };
      XNumber.prototype.numberFormat = /^\s*-?[0-9]*\.?[0-9]+\s*$/;
      XNumber.prototype.parse = function(s4) {
        return this.numberFormat.test(s4) ? parseFloat(s4) : Number.NaN;
      };
      function padSmallNumber(numberStr) {
        var parts = numberStr.split("e-");
        var base = parts[0].replace(".", "");
        var exponent = Number(parts[1]);
        for (var i4 = 0; i4 < exponent - 1; i4 += 1) {
          base = "0" + base;
        }
        return "0." + base;
      }
      function padLargeNumber(numberStr) {
        var parts = numberStr.split("e");
        var base = parts[0].replace(".", "");
        var exponent = Number(parts[1]);
        var zerosToAppend = exponent + 1 - base.length;
        for (var i4 = 0; i4 < zerosToAppend; i4 += 1) {
          base += "0";
        }
        return base;
      }
      XNumber.prototype.toString = function() {
        var strValue = this.num.toString();
        if (strValue.indexOf("e-") !== -1) {
          return padSmallNumber(strValue);
        }
        if (strValue.indexOf("e") !== -1) {
          return padLargeNumber(strValue);
        }
        return strValue;
      };
      XNumber.prototype.evaluate = function(c6) {
        return this;
      };
      XNumber.prototype.string = function() {
        return new XString(this.toString());
      };
      XNumber.prototype.number = function() {
        return this;
      };
      XNumber.prototype.bool = function() {
        return new XBoolean(this.num);
      };
      XNumber.prototype.nodeset = function() {
        throw new Error("Cannot convert number to nodeset");
      };
      XNumber.prototype.stringValue = function() {
        return this.string().stringValue();
      };
      XNumber.prototype.numberValue = function() {
        return this.num;
      };
      XNumber.prototype.booleanValue = function() {
        return this.bool().booleanValue();
      };
      XNumber.prototype.negate = function() {
        return new XNumber(-this.num);
      };
      XNumber.prototype.equals = function(r2) {
        if (Utilities.instance_of(r2, XBoolean)) {
          return this.bool().equals(r2);
        }
        if (Utilities.instance_of(r2, XString)) {
          return this.equals(r2.number());
        }
        if (Utilities.instance_of(r2, XNodeSet)) {
          return r2.compareWithNumber(this, Operators.equals);
        }
        return new XBoolean(this.num == r2.num);
      };
      XNumber.prototype.notequal = function(r2) {
        if (Utilities.instance_of(r2, XBoolean)) {
          return this.bool().notequal(r2);
        }
        if (Utilities.instance_of(r2, XString)) {
          return this.notequal(r2.number());
        }
        if (Utilities.instance_of(r2, XNodeSet)) {
          return r2.compareWithNumber(this, Operators.notequal);
        }
        return new XBoolean(this.num != r2.num);
      };
      XNumber.prototype.lessthan = function(r2) {
        if (Utilities.instance_of(r2, XNodeSet)) {
          return r2.compareWithNumber(this, Operators.greaterthan);
        }
        if (Utilities.instance_of(r2, XBoolean) || Utilities.instance_of(r2, XString)) {
          return this.lessthan(r2.number());
        }
        return new XBoolean(this.num < r2.num);
      };
      XNumber.prototype.greaterthan = function(r2) {
        if (Utilities.instance_of(r2, XNodeSet)) {
          return r2.compareWithNumber(this, Operators.lessthan);
        }
        if (Utilities.instance_of(r2, XBoolean) || Utilities.instance_of(r2, XString)) {
          return this.greaterthan(r2.number());
        }
        return new XBoolean(this.num > r2.num);
      };
      XNumber.prototype.lessthanorequal = function(r2) {
        if (Utilities.instance_of(r2, XNodeSet)) {
          return r2.compareWithNumber(this, Operators.greaterthanorequal);
        }
        if (Utilities.instance_of(r2, XBoolean) || Utilities.instance_of(r2, XString)) {
          return this.lessthanorequal(r2.number());
        }
        return new XBoolean(this.num <= r2.num);
      };
      XNumber.prototype.greaterthanorequal = function(r2) {
        if (Utilities.instance_of(r2, XNodeSet)) {
          return r2.compareWithNumber(this, Operators.lessthanorequal);
        }
        if (Utilities.instance_of(r2, XBoolean) || Utilities.instance_of(r2, XString)) {
          return this.greaterthanorequal(r2.number());
        }
        return new XBoolean(this.num >= r2.num);
      };
      XNumber.prototype.plus = function(r2) {
        return new XNumber(this.num + r2.num);
      };
      XNumber.prototype.minus = function(r2) {
        return new XNumber(this.num - r2.num);
      };
      XNumber.prototype.multiply = function(r2) {
        return new XNumber(this.num * r2.num);
      };
      XNumber.prototype.div = function(r2) {
        return new XNumber(this.num / r2.num);
      };
      XNumber.prototype.mod = function(r2) {
        return new XNumber(this.num % r2.num);
      };
      XBoolean.prototype = new Expression();
      XBoolean.prototype.constructor = XBoolean;
      XBoolean.superclass = Expression.prototype;
      function XBoolean(b2) {
        if (arguments.length > 0) {
          this.init(b2);
        }
      }
      XBoolean.prototype.init = function(b2) {
        this.b = Boolean(b2);
      };
      XBoolean.prototype.toString = function() {
        return this.b.toString();
      };
      XBoolean.prototype.evaluate = function(c6) {
        return this;
      };
      XBoolean.prototype.string = function() {
        return new XString(this.b);
      };
      XBoolean.prototype.number = function() {
        return new XNumber(this.b);
      };
      XBoolean.prototype.bool = function() {
        return this;
      };
      XBoolean.prototype.nodeset = function() {
        throw new Error("Cannot convert boolean to nodeset");
      };
      XBoolean.prototype.stringValue = function() {
        return this.string().stringValue();
      };
      XBoolean.prototype.numberValue = function() {
        return this.number().numberValue();
      };
      XBoolean.prototype.booleanValue = function() {
        return this.b;
      };
      XBoolean.prototype.not = function() {
        return new XBoolean(!this.b);
      };
      XBoolean.prototype.equals = function(r2) {
        if (Utilities.instance_of(r2, XString) || Utilities.instance_of(r2, XNumber)) {
          return this.equals(r2.bool());
        }
        if (Utilities.instance_of(r2, XNodeSet)) {
          return r2.compareWithBoolean(this, Operators.equals);
        }
        return new XBoolean(this.b == r2.b);
      };
      XBoolean.prototype.notequal = function(r2) {
        if (Utilities.instance_of(r2, XString) || Utilities.instance_of(r2, XNumber)) {
          return this.notequal(r2.bool());
        }
        if (Utilities.instance_of(r2, XNodeSet)) {
          return r2.compareWithBoolean(this, Operators.notequal);
        }
        return new XBoolean(this.b != r2.b);
      };
      XBoolean.prototype.lessthan = function(r2) {
        return this.number().lessthan(r2);
      };
      XBoolean.prototype.greaterthan = function(r2) {
        return this.number().greaterthan(r2);
      };
      XBoolean.prototype.lessthanorequal = function(r2) {
        return this.number().lessthanorequal(r2);
      };
      XBoolean.prototype.greaterthanorequal = function(r2) {
        return this.number().greaterthanorequal(r2);
      };
      XBoolean.true_ = new XBoolean(true);
      XBoolean.false_ = new XBoolean(false);
      AVLTree.prototype = new Object();
      AVLTree.prototype.constructor = AVLTree;
      AVLTree.superclass = Object.prototype;
      function AVLTree(n3) {
        this.init(n3);
      }
      AVLTree.prototype.init = function(n3) {
        this.left = null;
        this.right = null;
        this.node = n3;
        this.depth = 1;
      };
      AVLTree.prototype.balance = function() {
        var ldepth = this.left == null ? 0 : this.left.depth;
        var rdepth = this.right == null ? 0 : this.right.depth;
        if (ldepth > rdepth + 1) {
          var lldepth = this.left.left == null ? 0 : this.left.left.depth;
          var lrdepth = this.left.right == null ? 0 : this.left.right.depth;
          if (lldepth < lrdepth) {
            this.left.rotateRR();
          }
          this.rotateLL();
        } else if (ldepth + 1 < rdepth) {
          var rrdepth = this.right.right == null ? 0 : this.right.right.depth;
          var rldepth = this.right.left == null ? 0 : this.right.left.depth;
          if (rldepth > rrdepth) {
            this.right.rotateLL();
          }
          this.rotateRR();
        }
      };
      AVLTree.prototype.rotateLL = function() {
        var nodeBefore = this.node;
        var rightBefore = this.right;
        this.node = this.left.node;
        this.right = this.left;
        this.left = this.left.left;
        this.right.left = this.right.right;
        this.right.right = rightBefore;
        this.right.node = nodeBefore;
        this.right.updateInNewLocation();
        this.updateInNewLocation();
      };
      AVLTree.prototype.rotateRR = function() {
        var nodeBefore = this.node;
        var leftBefore = this.left;
        this.node = this.right.node;
        this.left = this.right;
        this.right = this.right.right;
        this.left.right = this.left.left;
        this.left.left = leftBefore;
        this.left.node = nodeBefore;
        this.left.updateInNewLocation();
        this.updateInNewLocation();
      };
      AVLTree.prototype.updateInNewLocation = function() {
        this.getDepthFromChildren();
      };
      AVLTree.prototype.getDepthFromChildren = function() {
        this.depth = this.node == null ? 0 : 1;
        if (this.left != null) {
          this.depth = this.left.depth + 1;
        }
        if (this.right != null && this.depth <= this.right.depth) {
          this.depth = this.right.depth + 1;
        }
      };
      function nodeOrder(n1, n22) {
        if (n1 === n22) {
          return 0;
        }
        if (n1.compareDocumentPosition) {
          var cpos = n1.compareDocumentPosition(n22);
          if (cpos & 1) {
            return 1;
          }
          if (cpos & 10) {
            return 1;
          }
          if (cpos & 20) {
            return -1;
          }
          return 0;
        }
        var d1 = 0, d22 = 0;
        for (var m1 = n1; m1 != null; m1 = m1.parentNode || m1.ownerElement) {
          d1++;
        }
        for (var m2 = n22; m2 != null; m2 = m2.parentNode || m2.ownerElement) {
          d22++;
        }
        if (d1 > d22) {
          while (d1 > d22) {
            n1 = n1.parentNode || n1.ownerElement;
            d1--;
          }
          if (n1 === n22) {
            return 1;
          }
        } else if (d22 > d1) {
          while (d22 > d1) {
            n22 = n22.parentNode || n22.ownerElement;
            d22--;
          }
          if (n1 === n22) {
            return -1;
          }
        }
        var n1Par = n1.parentNode || n1.ownerElement, n2Par = n22.parentNode || n22.ownerElement;
        while (n1Par !== n2Par) {
          n1 = n1Par;
          n22 = n2Par;
          n1Par = n1.parentNode || n1.ownerElement;
          n2Par = n22.parentNode || n22.ownerElement;
        }
        var n1isAttr = Utilities.isAttribute(n1);
        var n2isAttr = Utilities.isAttribute(n22);
        if (n1isAttr && !n2isAttr) {
          return -1;
        }
        if (!n1isAttr && n2isAttr) {
          return 1;
        }
        if (n1Par) {
          var cn = n1isAttr ? n1Par.attributes : n1Par.childNodes, len = cn.length;
          for (var i4 = 0; i4 < len; i4 += 1) {
            var n3 = cn[i4];
            if (n3 === n1) {
              return -1;
            }
            if (n3 === n22) {
              return 1;
            }
          }
        }
        throw new Error("Unexpected: could not determine node order");
      }
      AVLTree.prototype.add = function(n3) {
        if (n3 === this.node) {
          return false;
        }
        var o3 = nodeOrder(n3, this.node);
        var ret = false;
        if (o3 == -1) {
          if (this.left == null) {
            this.left = new AVLTree(n3);
            ret = true;
          } else {
            ret = this.left.add(n3);
            if (ret) {
              this.balance();
            }
          }
        } else if (o3 == 1) {
          if (this.right == null) {
            this.right = new AVLTree(n3);
            ret = true;
          } else {
            ret = this.right.add(n3);
            if (ret) {
              this.balance();
            }
          }
        }
        if (ret) {
          this.getDepthFromChildren();
        }
        return ret;
      };
      XNodeSet.prototype = new Expression();
      XNodeSet.prototype.constructor = XNodeSet;
      XNodeSet.superclass = Expression.prototype;
      function XNodeSet() {
        this.init();
      }
      XNodeSet.prototype.init = function() {
        this.tree = null;
        this.nodes = [];
        this.size = 0;
      };
      XNodeSet.prototype.toString = function() {
        var p8 = this.first();
        if (p8 == null) {
          return "";
        }
        return this.stringForNode(p8);
      };
      XNodeSet.prototype.evaluate = function(c6) {
        return this;
      };
      XNodeSet.prototype.string = function() {
        return new XString(this.toString());
      };
      XNodeSet.prototype.stringValue = function() {
        return this.toString();
      };
      XNodeSet.prototype.number = function() {
        return new XNumber(this.string());
      };
      XNodeSet.prototype.numberValue = function() {
        return Number(this.string());
      };
      XNodeSet.prototype.bool = function() {
        return new XBoolean(this.booleanValue());
      };
      XNodeSet.prototype.booleanValue = function() {
        return !!this.size;
      };
      XNodeSet.prototype.nodeset = function() {
        return this;
      };
      XNodeSet.prototype.stringForNode = function(n3) {
        if (n3.nodeType == 9 || n3.nodeType == 1 || n3.nodeType === 11) {
          return this.stringForContainerNode(n3);
        }
        if (n3.nodeType === 2) {
          return n3.value || n3.nodeValue;
        }
        if (n3.isNamespaceNode) {
          return n3.namespace;
        }
        return n3.nodeValue;
      };
      XNodeSet.prototype.stringForContainerNode = function(n3) {
        var s4 = "";
        for (var n22 = n3.firstChild; n22 != null; n22 = n22.nextSibling) {
          var nt2 = n22.nodeType;
          if (nt2 === 1 || nt2 === 3 || nt2 === 4 || nt2 === 9 || nt2 === 11) {
            s4 += this.stringForNode(n22);
          }
        }
        return s4;
      };
      XNodeSet.prototype.buildTree = function() {
        if (!this.tree && this.nodes.length) {
          this.tree = new AVLTree(this.nodes[0]);
          for (var i4 = 1; i4 < this.nodes.length; i4 += 1) {
            this.tree.add(this.nodes[i4]);
          }
        }
        return this.tree;
      };
      XNodeSet.prototype.first = function() {
        var p8 = this.buildTree();
        if (p8 == null) {
          return null;
        }
        while (p8.left != null) {
          p8 = p8.left;
        }
        return p8.node;
      };
      XNodeSet.prototype.add = function(n3) {
        for (var i4 = 0; i4 < this.nodes.length; i4 += 1) {
          if (n3 === this.nodes[i4]) {
            return;
          }
        }
        this.tree = null;
        this.nodes.push(n3);
        this.size += 1;
      };
      XNodeSet.prototype.addArray = function(ns) {
        var self = this;
        forEach(function(x3) {
          self.add(x3);
        }, ns);
      };
      XNodeSet.prototype.toArray = function() {
        var a3 = [];
        this.toArrayRec(this.buildTree(), a3);
        return a3;
      };
      XNodeSet.prototype.toArrayRec = function(t4, a3) {
        if (t4 != null) {
          this.toArrayRec(t4.left, a3);
          a3.push(t4.node);
          this.toArrayRec(t4.right, a3);
        }
      };
      XNodeSet.prototype.toUnsortedArray = function() {
        return this.nodes.slice();
      };
      XNodeSet.prototype.compareWithString = function(r2, o3) {
        var a3 = this.toUnsortedArray();
        for (var i4 = 0; i4 < a3.length; i4++) {
          var n3 = a3[i4];
          var l4 = new XString(this.stringForNode(n3));
          var res = o3(l4, r2);
          if (res.booleanValue()) {
            return res;
          }
        }
        return new XBoolean(false);
      };
      XNodeSet.prototype.compareWithNumber = function(r2, o3) {
        var a3 = this.toUnsortedArray();
        for (var i4 = 0; i4 < a3.length; i4++) {
          var n3 = a3[i4];
          var l4 = new XNumber(this.stringForNode(n3));
          var res = o3(l4, r2);
          if (res.booleanValue()) {
            return res;
          }
        }
        return new XBoolean(false);
      };
      XNodeSet.prototype.compareWithBoolean = function(r2, o3) {
        return o3(this.bool(), r2);
      };
      XNodeSet.prototype.compareWithNodeSet = function(r2, o3) {
        var arr = this.toUnsortedArray();
        var oInvert = function(lop, rop) {
          return o3(rop, lop);
        };
        for (var i4 = 0; i4 < arr.length; i4++) {
          var l4 = new XString(this.stringForNode(arr[i4]));
          var res = r2.compareWithString(l4, oInvert);
          if (res.booleanValue()) {
            return res;
          }
        }
        return new XBoolean(false);
      };
      XNodeSet.compareWith = curry(function(o3, r2) {
        if (Utilities.instance_of(r2, XString)) {
          return this.compareWithString(r2, o3);
        }
        if (Utilities.instance_of(r2, XNumber)) {
          return this.compareWithNumber(r2, o3);
        }
        if (Utilities.instance_of(r2, XBoolean)) {
          return this.compareWithBoolean(r2, o3);
        }
        return this.compareWithNodeSet(r2, o3);
      });
      XNodeSet.prototype.equals = XNodeSet.compareWith(Operators.equals);
      XNodeSet.prototype.notequal = XNodeSet.compareWith(Operators.notequal);
      XNodeSet.prototype.lessthan = XNodeSet.compareWith(Operators.lessthan);
      XNodeSet.prototype.greaterthan = XNodeSet.compareWith(Operators.greaterthan);
      XNodeSet.prototype.lessthanorequal = XNodeSet.compareWith(Operators.lessthanorequal);
      XNodeSet.prototype.greaterthanorequal = XNodeSet.compareWith(Operators.greaterthanorequal);
      XNodeSet.prototype.union = function(r2) {
        var ns = new XNodeSet();
        ns.addArray(this.toUnsortedArray());
        ns.addArray(r2.toUnsortedArray());
        return ns;
      };
      XPathNamespace.prototype = new Object();
      XPathNamespace.prototype.constructor = XPathNamespace;
      XPathNamespace.superclass = Object.prototype;
      function XPathNamespace(pre, ns, p8) {
        this.isXPathNamespace = true;
        this.ownerDocument = p8.ownerDocument;
        this.nodeName = "#namespace";
        this.prefix = pre;
        this.localName = pre;
        this.namespaceURI = ns;
        this.nodeValue = ns;
        this.ownerElement = p8;
        this.nodeType = XPathNamespace.XPATH_NAMESPACE_NODE;
      }
      XPathNamespace.prototype.toString = function() {
        return '{ "' + this.prefix + '", "' + this.namespaceURI + '" }';
      };
      XPathContext.prototype = new Object();
      XPathContext.prototype.constructor = XPathContext;
      XPathContext.superclass = Object.prototype;
      function XPathContext(vr, nr, fr) {
        this.variableResolver = vr != null ? vr : new VariableResolver();
        this.namespaceResolver = nr != null ? nr : new NamespaceResolver();
        this.functionResolver = fr != null ? fr : new FunctionResolver();
      }
      XPathContext.prototype.extend = function(newProps) {
        return assign(new XPathContext(), this, newProps);
      };
      VariableResolver.prototype = new Object();
      VariableResolver.prototype.constructor = VariableResolver;
      VariableResolver.superclass = Object.prototype;
      function VariableResolver() {
      }
      VariableResolver.prototype.getVariable = function(ln, ns) {
        return null;
      };
      FunctionResolver.prototype = new Object();
      FunctionResolver.prototype.constructor = FunctionResolver;
      FunctionResolver.superclass = Object.prototype;
      function FunctionResolver(thisArg) {
        this.thisArg = thisArg != null ? thisArg : Functions;
        this.functions = new Object();
        this.addStandardFunctions();
      }
      FunctionResolver.prototype.addStandardFunctions = function() {
        this.functions["{}last"] = Functions.last;
        this.functions["{}position"] = Functions.position;
        this.functions["{}count"] = Functions.count;
        this.functions["{}id"] = Functions.id;
        this.functions["{}local-name"] = Functions.localName;
        this.functions["{}namespace-uri"] = Functions.namespaceURI;
        this.functions["{}name"] = Functions.name;
        this.functions["{}string"] = Functions.string;
        this.functions["{}concat"] = Functions.concat;
        this.functions["{}starts-with"] = Functions.startsWith;
        this.functions["{}contains"] = Functions.contains;
        this.functions["{}substring-before"] = Functions.substringBefore;
        this.functions["{}substring-after"] = Functions.substringAfter;
        this.functions["{}substring"] = Functions.substring;
        this.functions["{}string-length"] = Functions.stringLength;
        this.functions["{}normalize-space"] = Functions.normalizeSpace;
        this.functions["{}translate"] = Functions.translate;
        this.functions["{}boolean"] = Functions.boolean_;
        this.functions["{}not"] = Functions.not;
        this.functions["{}true"] = Functions.true_;
        this.functions["{}false"] = Functions.false_;
        this.functions["{}lang"] = Functions.lang;
        this.functions["{}number"] = Functions.number;
        this.functions["{}sum"] = Functions.sum;
        this.functions["{}floor"] = Functions.floor;
        this.functions["{}ceiling"] = Functions.ceiling;
        this.functions["{}round"] = Functions.round;
      };
      FunctionResolver.prototype.addFunction = function(ns, ln, f3) {
        this.functions["{" + ns + "}" + ln] = f3;
      };
      FunctionResolver.getFunctionFromContext = function(qName, context) {
        var parts = Utilities.resolveQName(qName, context.namespaceResolver, context.contextNode, false);
        if (parts[0] === null) {
          throw new Error("Cannot resolve QName " + name);
        }
        return context.functionResolver.getFunction(parts[1], parts[0]);
      };
      FunctionResolver.prototype.getFunction = function(localName, namespace) {
        return this.functions["{" + namespace + "}" + localName];
      };
      NamespaceResolver.prototype = new Object();
      NamespaceResolver.prototype.constructor = NamespaceResolver;
      NamespaceResolver.superclass = Object.prototype;
      function NamespaceResolver() {
      }
      NamespaceResolver.prototype.getNamespace = function(prefix, n3) {
        if (prefix == "xml") {
          return XPath.XML_NAMESPACE_URI;
        } else if (prefix == "xmlns") {
          return XPath.XMLNS_NAMESPACE_URI;
        }
        if (n3.nodeType == 9) {
          n3 = n3.documentElement;
        } else if (n3.nodeType == 2) {
          n3 = PathExpr.getOwnerElement(n3);
        } else if (n3.nodeType != 1) {
          n3 = n3.parentNode;
        }
        while (n3 != null && n3.nodeType == 1) {
          var nnm = n3.attributes;
          for (var i4 = 0; i4 < nnm.length; i4++) {
            var a3 = nnm.item(i4);
            var aname = a3.name || a3.nodeName;
            if (aname === "xmlns" && prefix === "" || aname === "xmlns:" + prefix) {
              return String(a3.value || a3.nodeValue);
            }
          }
          n3 = n3.parentNode;
        }
        return null;
      };
      var Functions = new Object();
      Functions.last = function(c6) {
        if (arguments.length != 1) {
          throw new Error("Function last expects ()");
        }
        return new XNumber(c6.contextSize);
      };
      Functions.position = function(c6) {
        if (arguments.length != 1) {
          throw new Error("Function position expects ()");
        }
        return new XNumber(c6.contextPosition);
      };
      Functions.count = function() {
        var c6 = arguments[0];
        var ns;
        if (arguments.length != 2 || !Utilities.instance_of(ns = arguments[1].evaluate(c6), XNodeSet)) {
          throw new Error("Function count expects (node-set)");
        }
        return new XNumber(ns.size);
      };
      Functions.id = function() {
        var c6 = arguments[0];
        var id;
        if (arguments.length != 2) {
          throw new Error("Function id expects (object)");
        }
        id = arguments[1].evaluate(c6);
        if (Utilities.instance_of(id, XNodeSet)) {
          id = id.toArray().join(" ");
        } else {
          id = id.stringValue();
        }
        var ids = id.split(/[\x0d\x0a\x09\x20]+/);
        var count = 0;
        var ns = new XNodeSet();
        var doc = c6.contextNode.nodeType == 9 ? c6.contextNode : c6.contextNode.ownerDocument;
        for (var i4 = 0; i4 < ids.length; i4++) {
          var n3;
          if (doc.getElementById) {
            n3 = doc.getElementById(ids[i4]);
          } else {
            n3 = Utilities.getElementById(doc, ids[i4]);
          }
          if (n3 != null) {
            ns.add(n3);
            count++;
          }
        }
        return ns;
      };
      Functions.localName = function(c6, eNode) {
        var n3;
        if (arguments.length == 1) {
          n3 = c6.contextNode;
        } else if (arguments.length == 2) {
          n3 = eNode.evaluate(c6).first();
        } else {
          throw new Error("Function local-name expects (node-set?)");
        }
        if (n3 == null) {
          return new XString("");
        }
        return new XString(
          n3.localName || //  standard elements and attributes
          n3.baseName || //  IE
          n3.target || //  processing instructions
          n3.nodeName || //  DOM1 elements
          ""
          //  fallback
        );
      };
      Functions.namespaceURI = function() {
        var c6 = arguments[0];
        var n3;
        if (arguments.length == 1) {
          n3 = c6.contextNode;
        } else if (arguments.length == 2) {
          n3 = arguments[1].evaluate(c6).first();
        } else {
          throw new Error("Function namespace-uri expects (node-set?)");
        }
        if (n3 == null) {
          return new XString("");
        }
        return new XString(n3.namespaceURI);
      };
      Functions.name = function() {
        var c6 = arguments[0];
        var n3;
        if (arguments.length == 1) {
          n3 = c6.contextNode;
        } else if (arguments.length == 2) {
          n3 = arguments[1].evaluate(c6).first();
        } else {
          throw new Error("Function name expects (node-set?)");
        }
        if (n3 == null) {
          return new XString("");
        }
        if (n3.nodeType == 1) {
          return new XString(n3.nodeName);
        } else if (n3.nodeType == 2) {
          return new XString(n3.name || n3.nodeName);
        } else if (n3.nodeType === 7) {
          return new XString(n3.target || n3.nodeName);
        } else if (n3.localName == null) {
          return new XString("");
        } else {
          return new XString(n3.localName);
        }
      };
      Functions.string = function() {
        var c6 = arguments[0];
        if (arguments.length == 1) {
          return new XString(XNodeSet.prototype.stringForNode(c6.contextNode));
        } else if (arguments.length == 2) {
          return arguments[1].evaluate(c6).string();
        }
        throw new Error("Function string expects (object?)");
      };
      Functions.concat = function(c6) {
        if (arguments.length < 3) {
          throw new Error("Function concat expects (string, string[, string]*)");
        }
        var s4 = "";
        for (var i4 = 1; i4 < arguments.length; i4++) {
          s4 += arguments[i4].evaluate(c6).stringValue();
        }
        return new XString(s4);
      };
      Functions.startsWith = function() {
        var c6 = arguments[0];
        if (arguments.length != 3) {
          throw new Error("Function startsWith expects (string, string)");
        }
        var s1 = arguments[1].evaluate(c6).stringValue();
        var s22 = arguments[2].evaluate(c6).stringValue();
        return new XBoolean(s1.substring(0, s22.length) == s22);
      };
      Functions.contains = function() {
        var c6 = arguments[0];
        if (arguments.length != 3) {
          throw new Error("Function contains expects (string, string)");
        }
        var s1 = arguments[1].evaluate(c6).stringValue();
        var s22 = arguments[2].evaluate(c6).stringValue();
        return new XBoolean(s1.indexOf(s22) !== -1);
      };
      Functions.substringBefore = function() {
        var c6 = arguments[0];
        if (arguments.length != 3) {
          throw new Error("Function substring-before expects (string, string)");
        }
        var s1 = arguments[1].evaluate(c6).stringValue();
        var s22 = arguments[2].evaluate(c6).stringValue();
        return new XString(s1.substring(0, s1.indexOf(s22)));
      };
      Functions.substringAfter = function() {
        var c6 = arguments[0];
        if (arguments.length != 3) {
          throw new Error("Function substring-after expects (string, string)");
        }
        var s1 = arguments[1].evaluate(c6).stringValue();
        var s22 = arguments[2].evaluate(c6).stringValue();
        if (s22.length == 0) {
          return new XString(s1);
        }
        var i4 = s1.indexOf(s22);
        if (i4 == -1) {
          return new XString("");
        }
        return new XString(s1.substring(i4 + s22.length));
      };
      Functions.substring = function() {
        var c6 = arguments[0];
        if (!(arguments.length == 3 || arguments.length == 4)) {
          throw new Error("Function substring expects (string, number, number?)");
        }
        var s4 = arguments[1].evaluate(c6).stringValue();
        var n1 = Math.round(arguments[2].evaluate(c6).numberValue()) - 1;
        var n22 = arguments.length == 4 ? n1 + Math.round(arguments[3].evaluate(c6).numberValue()) : void 0;
        return new XString(s4.substring(n1, n22));
      };
      Functions.stringLength = function() {
        var c6 = arguments[0];
        var s4;
        if (arguments.length == 1) {
          s4 = XNodeSet.prototype.stringForNode(c6.contextNode);
        } else if (arguments.length == 2) {
          s4 = arguments[1].evaluate(c6).stringValue();
        } else {
          throw new Error("Function string-length expects (string?)");
        }
        return new XNumber(s4.length);
      };
      Functions.normalizeSpace = function() {
        var c6 = arguments[0];
        var s4;
        if (arguments.length == 1) {
          s4 = XNodeSet.prototype.stringForNode(c6.contextNode);
        } else if (arguments.length == 2) {
          s4 = arguments[1].evaluate(c6).stringValue();
        } else {
          throw new Error("Function normalize-space expects (string?)");
        }
        var i4 = 0;
        var j = s4.length - 1;
        while (Utilities.isSpace(s4.charCodeAt(j))) {
          j--;
        }
        var t4 = "";
        while (i4 <= j && Utilities.isSpace(s4.charCodeAt(i4))) {
          i4++;
        }
        while (i4 <= j) {
          if (Utilities.isSpace(s4.charCodeAt(i4))) {
            t4 += " ";
            while (i4 <= j && Utilities.isSpace(s4.charCodeAt(i4))) {
              i4++;
            }
          } else {
            t4 += s4.charAt(i4);
            i4++;
          }
        }
        return new XString(t4);
      };
      Functions.translate = function(c6, eValue, eFrom, eTo) {
        if (arguments.length != 4) {
          throw new Error("Function translate expects (string, string, string)");
        }
        var value = eValue.evaluate(c6).stringValue();
        var from = eFrom.evaluate(c6).stringValue();
        var to = eTo.evaluate(c6).stringValue();
        var cMap = reduce(function(acc, ch, i4) {
          if (!(ch in acc)) {
            acc[ch] = i4 > to.length ? "" : to[i4];
          }
          return acc;
        }, {}, from);
        var t4 = join(
          "",
          map(function(ch) {
            return ch in cMap ? cMap[ch] : ch;
          }, value)
        );
        return new XString(t4);
      };
      Functions.boolean_ = function() {
        var c6 = arguments[0];
        if (arguments.length != 2) {
          throw new Error("Function boolean expects (object)");
        }
        return arguments[1].evaluate(c6).bool();
      };
      Functions.not = function(c6, eValue) {
        if (arguments.length != 2) {
          throw new Error("Function not expects (object)");
        }
        return eValue.evaluate(c6).bool().not();
      };
      Functions.true_ = function() {
        if (arguments.length != 1) {
          throw new Error("Function true expects ()");
        }
        return XBoolean.true_;
      };
      Functions.false_ = function() {
        if (arguments.length != 1) {
          throw new Error("Function false expects ()");
        }
        return XBoolean.false_;
      };
      Functions.lang = function() {
        var c6 = arguments[0];
        if (arguments.length != 2) {
          throw new Error("Function lang expects (string)");
        }
        var lang;
        for (var n3 = c6.contextNode; n3 != null && n3.nodeType != 9; n3 = n3.parentNode) {
          var a3 = n3.getAttributeNS(XPath.XML_NAMESPACE_URI, "lang");
          if (a3 != null) {
            lang = String(a3);
            break;
          }
        }
        if (lang == null) {
          return XBoolean.false_;
        }
        var s4 = arguments[1].evaluate(c6).stringValue();
        return new XBoolean(lang.substring(0, s4.length) == s4 && (lang.length == s4.length || lang.charAt(s4.length) == "-"));
      };
      Functions.number = function() {
        var c6 = arguments[0];
        if (!(arguments.length == 1 || arguments.length == 2)) {
          throw new Error("Function number expects (object?)");
        }
        if (arguments.length == 1) {
          return new XNumber(XNodeSet.prototype.stringForNode(c6.contextNode));
        }
        return arguments[1].evaluate(c6).number();
      };
      Functions.sum = function() {
        var c6 = arguments[0];
        var ns;
        if (arguments.length != 2 || !Utilities.instance_of(ns = arguments[1].evaluate(c6), XNodeSet)) {
          throw new Error("Function sum expects (node-set)");
        }
        ns = ns.toUnsortedArray();
        var n3 = 0;
        for (var i4 = 0; i4 < ns.length; i4++) {
          n3 += new XNumber(XNodeSet.prototype.stringForNode(ns[i4])).numberValue();
        }
        return new XNumber(n3);
      };
      Functions.floor = function() {
        var c6 = arguments[0];
        if (arguments.length != 2) {
          throw new Error("Function floor expects (number)");
        }
        return new XNumber(Math.floor(arguments[1].evaluate(c6).numberValue()));
      };
      Functions.ceiling = function() {
        var c6 = arguments[0];
        if (arguments.length != 2) {
          throw new Error("Function ceiling expects (number)");
        }
        return new XNumber(Math.ceil(arguments[1].evaluate(c6).numberValue()));
      };
      Functions.round = function() {
        var c6 = arguments[0];
        if (arguments.length != 2) {
          throw new Error("Function round expects (number)");
        }
        return new XNumber(Math.round(arguments[1].evaluate(c6).numberValue()));
      };
      var Utilities = new Object();
      Utilities.isAttribute = function(val) {
        return val && (val.nodeType === 2 || val.ownerElement);
      };
      Utilities.splitQName = function(qn) {
        var i4 = qn.indexOf(":");
        if (i4 == -1) {
          return [null, qn];
        }
        return [qn.substring(0, i4), qn.substring(i4 + 1)];
      };
      Utilities.resolveQName = function(qn, nr, n3, useDefault) {
        var parts = Utilities.splitQName(qn);
        if (parts[0] != null) {
          parts[0] = nr.getNamespace(parts[0], n3);
        } else {
          if (useDefault) {
            parts[0] = nr.getNamespace("", n3);
            if (parts[0] == null) {
              parts[0] = "";
            }
          } else {
            parts[0] = "";
          }
        }
        return parts;
      };
      Utilities.isSpace = function(c6) {
        return c6 == 9 || c6 == 13 || c6 == 10 || c6 == 32;
      };
      Utilities.isLetter = function(c6) {
        return c6 >= 65 && c6 <= 90 || c6 >= 97 && c6 <= 122 || c6 >= 192 && c6 <= 214 || c6 >= 216 && c6 <= 246 || c6 >= 248 && c6 <= 255 || c6 >= 256 && c6 <= 305 || c6 >= 308 && c6 <= 318 || c6 >= 321 && c6 <= 328 || c6 >= 330 && c6 <= 382 || c6 >= 384 && c6 <= 451 || c6 >= 461 && c6 <= 496 || c6 >= 500 && c6 <= 501 || c6 >= 506 && c6 <= 535 || c6 >= 592 && c6 <= 680 || c6 >= 699 && c6 <= 705 || c6 == 902 || c6 >= 904 && c6 <= 906 || c6 == 908 || c6 >= 910 && c6 <= 929 || c6 >= 931 && c6 <= 974 || c6 >= 976 && c6 <= 982 || c6 == 986 || c6 == 988 || c6 == 990 || c6 == 992 || c6 >= 994 && c6 <= 1011 || c6 >= 1025 && c6 <= 1036 || c6 >= 1038 && c6 <= 1103 || c6 >= 1105 && c6 <= 1116 || c6 >= 1118 && c6 <= 1153 || c6 >= 1168 && c6 <= 1220 || c6 >= 1223 && c6 <= 1224 || c6 >= 1227 && c6 <= 1228 || c6 >= 1232 && c6 <= 1259 || c6 >= 1262 && c6 <= 1269 || c6 >= 1272 && c6 <= 1273 || c6 >= 1329 && c6 <= 1366 || c6 == 1369 || c6 >= 1377 && c6 <= 1414 || c6 >= 1488 && c6 <= 1514 || c6 >= 1520 && c6 <= 1522 || c6 >= 1569 && c6 <= 1594 || c6 >= 1601 && c6 <= 1610 || c6 >= 1649 && c6 <= 1719 || c6 >= 1722 && c6 <= 1726 || c6 >= 1728 && c6 <= 1742 || c6 >= 1744 && c6 <= 1747 || c6 == 1749 || c6 >= 1765 && c6 <= 1766 || c6 >= 2309 && c6 <= 2361 || c6 == 2365 || c6 >= 2392 && c6 <= 2401 || c6 >= 2437 && c6 <= 2444 || c6 >= 2447 && c6 <= 2448 || c6 >= 2451 && c6 <= 2472 || c6 >= 2474 && c6 <= 2480 || c6 == 2482 || c6 >= 2486 && c6 <= 2489 || c6 >= 2524 && c6 <= 2525 || c6 >= 2527 && c6 <= 2529 || c6 >= 2544 && c6 <= 2545 || c6 >= 2565 && c6 <= 2570 || c6 >= 2575 && c6 <= 2576 || c6 >= 2579 && c6 <= 2600 || c6 >= 2602 && c6 <= 2608 || c6 >= 2610 && c6 <= 2611 || c6 >= 2613 && c6 <= 2614 || c6 >= 2616 && c6 <= 2617 || c6 >= 2649 && c6 <= 2652 || c6 == 2654 || c6 >= 2674 && c6 <= 2676 || c6 >= 2693 && c6 <= 2699 || c6 == 2701 || c6 >= 2703 && c6 <= 2705 || c6 >= 2707 && c6 <= 2728 || c6 >= 2730 && c6 <= 2736 || c6 >= 2738 && c6 <= 2739 || c6 >= 2741 && c6 <= 2745 || c6 == 2749 || c6 == 2784 || c6 >= 2821 && c6 <= 2828 || c6 >= 2831 && c6 <= 2832 || c6 >= 2835 && c6 <= 2856 || c6 >= 2858 && c6 <= 2864 || c6 >= 2866 && c6 <= 2867 || c6 >= 2870 && c6 <= 2873 || c6 == 2877 || c6 >= 2908 && c6 <= 2909 || c6 >= 2911 && c6 <= 2913 || c6 >= 2949 && c6 <= 2954 || c6 >= 2958 && c6 <= 2960 || c6 >= 2962 && c6 <= 2965 || c6 >= 2969 && c6 <= 2970 || c6 == 2972 || c6 >= 2974 && c6 <= 2975 || c6 >= 2979 && c6 <= 2980 || c6 >= 2984 && c6 <= 2986 || c6 >= 2990 && c6 <= 2997 || c6 >= 2999 && c6 <= 3001 || c6 >= 3077 && c6 <= 3084 || c6 >= 3086 && c6 <= 3088 || c6 >= 3090 && c6 <= 3112 || c6 >= 3114 && c6 <= 3123 || c6 >= 3125 && c6 <= 3129 || c6 >= 3168 && c6 <= 3169 || c6 >= 3205 && c6 <= 3212 || c6 >= 3214 && c6 <= 3216 || c6 >= 3218 && c6 <= 3240 || c6 >= 3242 && c6 <= 3251 || c6 >= 3253 && c6 <= 3257 || c6 == 3294 || c6 >= 3296 && c6 <= 3297 || c6 >= 3333 && c6 <= 3340 || c6 >= 3342 && c6 <= 3344 || c6 >= 3346 && c6 <= 3368 || c6 >= 3370 && c6 <= 3385 || c6 >= 3424 && c6 <= 3425 || c6 >= 3585 && c6 <= 3630 || c6 == 3632 || c6 >= 3634 && c6 <= 3635 || c6 >= 3648 && c6 <= 3653 || c6 >= 3713 && c6 <= 3714 || c6 == 3716 || c6 >= 3719 && c6 <= 3720 || c6 == 3722 || c6 == 3725 || c6 >= 3732 && c6 <= 3735 || c6 >= 3737 && c6 <= 3743 || c6 >= 3745 && c6 <= 3747 || c6 == 3749 || c6 == 3751 || c6 >= 3754 && c6 <= 3755 || c6 >= 3757 && c6 <= 3758 || c6 == 3760 || c6 >= 3762 && c6 <= 3763 || c6 == 3773 || c6 >= 3776 && c6 <= 3780 || c6 >= 3904 && c6 <= 3911 || c6 >= 3913 && c6 <= 3945 || c6 >= 4256 && c6 <= 4293 || c6 >= 4304 && c6 <= 4342 || c6 == 4352 || c6 >= 4354 && c6 <= 4355 || c6 >= 4357 && c6 <= 4359 || c6 == 4361 || c6 >= 4363 && c6 <= 4364 || c6 >= 4366 && c6 <= 4370 || c6 == 4412 || c6 == 4414 || c6 == 4416 || c6 == 4428 || c6 == 4430 || c6 == 4432 || c6 >= 4436 && c6 <= 4437 || c6 == 4441 || c6 >= 4447 && c6 <= 4449 || c6 == 4451 || c6 == 4453 || c6 == 4455 || c6 == 4457 || c6 >= 4461 && c6 <= 4462 || c6 >= 4466 && c6 <= 4467 || c6 == 4469 || c6 == 4510 || c6 == 4520 || c6 == 4523 || c6 >= 4526 && c6 <= 4527 || c6 >= 4535 && c6 <= 4536 || c6 == 4538 || c6 >= 4540 && c6 <= 4546 || c6 == 4587 || c6 == 4592 || c6 == 4601 || c6 >= 7680 && c6 <= 7835 || c6 >= 7840 && c6 <= 7929 || c6 >= 7936 && c6 <= 7957 || c6 >= 7960 && c6 <= 7965 || c6 >= 7968 && c6 <= 8005 || c6 >= 8008 && c6 <= 8013 || c6 >= 8016 && c6 <= 8023 || c6 == 8025 || c6 == 8027 || c6 == 8029 || c6 >= 8031 && c6 <= 8061 || c6 >= 8064 && c6 <= 8116 || c6 >= 8118 && c6 <= 8124 || c6 == 8126 || c6 >= 8130 && c6 <= 8132 || c6 >= 8134 && c6 <= 8140 || c6 >= 8144 && c6 <= 8147 || c6 >= 8150 && c6 <= 8155 || c6 >= 8160 && c6 <= 8172 || c6 >= 8178 && c6 <= 8180 || c6 >= 8182 && c6 <= 8188 || c6 == 8486 || c6 >= 8490 && c6 <= 8491 || c6 == 8494 || c6 >= 8576 && c6 <= 8578 || c6 >= 12353 && c6 <= 12436 || c6 >= 12449 && c6 <= 12538 || c6 >= 12549 && c6 <= 12588 || c6 >= 44032 && c6 <= 55203 || c6 >= 19968 && c6 <= 40869 || c6 == 12295 || c6 >= 12321 && c6 <= 12329;
      };
      Utilities.isNCNameChar = function(c6) {
        return c6 >= 48 && c6 <= 57 || c6 >= 1632 && c6 <= 1641 || c6 >= 1776 && c6 <= 1785 || c6 >= 2406 && c6 <= 2415 || c6 >= 2534 && c6 <= 2543 || c6 >= 2662 && c6 <= 2671 || c6 >= 2790 && c6 <= 2799 || c6 >= 2918 && c6 <= 2927 || c6 >= 3047 && c6 <= 3055 || c6 >= 3174 && c6 <= 3183 || c6 >= 3302 && c6 <= 3311 || c6 >= 3430 && c6 <= 3439 || c6 >= 3664 && c6 <= 3673 || c6 >= 3792 && c6 <= 3801 || c6 >= 3872 && c6 <= 3881 || c6 == 46 || c6 == 45 || c6 == 95 || Utilities.isLetter(c6) || c6 >= 768 && c6 <= 837 || c6 >= 864 && c6 <= 865 || c6 >= 1155 && c6 <= 1158 || c6 >= 1425 && c6 <= 1441 || c6 >= 1443 && c6 <= 1465 || c6 >= 1467 && c6 <= 1469 || c6 == 1471 || c6 >= 1473 && c6 <= 1474 || c6 == 1476 || c6 >= 1611 && c6 <= 1618 || c6 == 1648 || c6 >= 1750 && c6 <= 1756 || c6 >= 1757 && c6 <= 1759 || c6 >= 1760 && c6 <= 1764 || c6 >= 1767 && c6 <= 1768 || c6 >= 1770 && c6 <= 1773 || c6 >= 2305 && c6 <= 2307 || c6 == 2364 || c6 >= 2366 && c6 <= 2380 || c6 == 2381 || c6 >= 2385 && c6 <= 2388 || c6 >= 2402 && c6 <= 2403 || c6 >= 2433 && c6 <= 2435 || c6 == 2492 || c6 == 2494 || c6 == 2495 || c6 >= 2496 && c6 <= 2500 || c6 >= 2503 && c6 <= 2504 || c6 >= 2507 && c6 <= 2509 || c6 == 2519 || c6 >= 2530 && c6 <= 2531 || c6 == 2562 || c6 == 2620 || c6 == 2622 || c6 == 2623 || c6 >= 2624 && c6 <= 2626 || c6 >= 2631 && c6 <= 2632 || c6 >= 2635 && c6 <= 2637 || c6 >= 2672 && c6 <= 2673 || c6 >= 2689 && c6 <= 2691 || c6 == 2748 || c6 >= 2750 && c6 <= 2757 || c6 >= 2759 && c6 <= 2761 || c6 >= 2763 && c6 <= 2765 || c6 >= 2817 && c6 <= 2819 || c6 == 2876 || c6 >= 2878 && c6 <= 2883 || c6 >= 2887 && c6 <= 2888 || c6 >= 2891 && c6 <= 2893 || c6 >= 2902 && c6 <= 2903 || c6 >= 2946 && c6 <= 2947 || c6 >= 3006 && c6 <= 3010 || c6 >= 3014 && c6 <= 3016 || c6 >= 3018 && c6 <= 3021 || c6 == 3031 || c6 >= 3073 && c6 <= 3075 || c6 >= 3134 && c6 <= 3140 || c6 >= 3142 && c6 <= 3144 || c6 >= 3146 && c6 <= 3149 || c6 >= 3157 && c6 <= 3158 || c6 >= 3202 && c6 <= 3203 || c6 >= 3262 && c6 <= 3268 || c6 >= 3270 && c6 <= 3272 || c6 >= 3274 && c6 <= 3277 || c6 >= 3285 && c6 <= 3286 || c6 >= 3330 && c6 <= 3331 || c6 >= 3390 && c6 <= 3395 || c6 >= 3398 && c6 <= 3400 || c6 >= 3402 && c6 <= 3405 || c6 == 3415 || c6 == 3633 || c6 >= 3636 && c6 <= 3642 || c6 >= 3655 && c6 <= 3662 || c6 == 3761 || c6 >= 3764 && c6 <= 3769 || c6 >= 3771 && c6 <= 3772 || c6 >= 3784 && c6 <= 3789 || c6 >= 3864 && c6 <= 3865 || c6 == 3893 || c6 == 3895 || c6 == 3897 || c6 == 3902 || c6 == 3903 || c6 >= 3953 && c6 <= 3972 || c6 >= 3974 && c6 <= 3979 || c6 >= 3984 && c6 <= 3989 || c6 == 3991 || c6 >= 3993 && c6 <= 4013 || c6 >= 4017 && c6 <= 4023 || c6 == 4025 || c6 >= 8400 && c6 <= 8412 || c6 == 8417 || c6 >= 12330 && c6 <= 12335 || c6 == 12441 || c6 == 12442 || c6 == 183 || c6 == 720 || c6 == 721 || c6 == 903 || c6 == 1600 || c6 == 3654 || c6 == 3782 || c6 == 12293 || c6 >= 12337 && c6 <= 12341 || c6 >= 12445 && c6 <= 12446 || c6 >= 12540 && c6 <= 12542;
      };
      Utilities.coalesceText = function(n3) {
        for (var m2 = n3.firstChild; m2 != null; m2 = m2.nextSibling) {
          if (m2.nodeType == 3 || m2.nodeType == 4) {
            var s4 = m2.nodeValue;
            var first = m2;
            m2 = m2.nextSibling;
            while (m2 != null && (m2.nodeType == 3 || m2.nodeType == 4)) {
              s4 += m2.nodeValue;
              var del = m2;
              m2 = m2.nextSibling;
              del.parentNode.removeChild(del);
            }
            if (first.nodeType == 4) {
              var p8 = first.parentNode;
              if (first.nextSibling == null) {
                p8.removeChild(first);
                p8.appendChild(p8.ownerDocument.createTextNode(s4));
              } else {
                var next = first.nextSibling;
                p8.removeChild(first);
                p8.insertBefore(p8.ownerDocument.createTextNode(s4), next);
              }
            } else {
              first.nodeValue = s4;
            }
            if (m2 == null) {
              break;
            }
          } else if (m2.nodeType == 1) {
            Utilities.coalesceText(m2);
          }
        }
      };
      Utilities.instance_of = function(o3, c6) {
        while (o3 != null) {
          if (o3.constructor === c6) {
            return true;
          }
          if (o3 === Object) {
            return false;
          }
          o3 = o3.constructor.superclass;
        }
        return false;
      };
      Utilities.getElementById = function(n3, id) {
        if (n3.nodeType == 1) {
          if (n3.getAttribute("id") == id || n3.getAttributeNS(null, "id") == id) {
            return n3;
          }
        }
        for (var m2 = n3.firstChild; m2 != null; m2 = m2.nextSibling) {
          var res = Utilities.getElementById(m2, id);
          if (res != null) {
            return res;
          }
        }
        return null;
      };
      var XPathException = function() {
        function getMessage(code, exception) {
          var msg = exception ? ": " + exception.toString() : "";
          switch (code) {
            case XPathException2.INVALID_EXPRESSION_ERR:
              return "Invalid expression" + msg;
            case XPathException2.TYPE_ERR:
              return "Type error" + msg;
          }
          return null;
        }
        function XPathException2(code, error, message) {
          var err = Error.call(this, getMessage(code, error) || message);
          err.code = code;
          err.exception = error;
          return err;
        }
        XPathException2.prototype = Object.create(Error.prototype);
        XPathException2.prototype.constructor = XPathException2;
        XPathException2.superclass = Error;
        XPathException2.prototype.toString = function() {
          return this.message;
        };
        XPathException2.fromMessage = function(message, error) {
          return new XPathException2(null, error, message);
        };
        XPathException2.INVALID_EXPRESSION_ERR = 51;
        XPathException2.TYPE_ERR = 52;
        return XPathException2;
      }();
      XPathExpression.prototype = {};
      XPathExpression.prototype.constructor = XPathExpression;
      XPathExpression.superclass = Object.prototype;
      function XPathExpression(e2, r2, p8) {
        this.xpath = p8.parse(e2);
        this.context = new XPathContext();
        this.context.namespaceResolver = new XPathNSResolverWrapper(r2);
      }
      XPathExpression.getOwnerDocument = function(n3) {
        return n3.nodeType === 9 ? n3 : n3.ownerDocument;
      };
      XPathExpression.detectHtmlDom = function(n3) {
        if (!n3) {
          return false;
        }
        var doc = XPathExpression.getOwnerDocument(n3);
        try {
          return doc.implementation.hasFeature("HTML", "2.0");
        } catch (e2) {
          return true;
        }
      };
      XPathExpression.prototype.evaluate = function(n3, t4, res) {
        this.context.expressionContextNode = n3;
        this.context.caseInsensitive = XPathExpression.detectHtmlDom(n3);
        var result = this.xpath.evaluate(this.context);
        return new XPathResult(result, t4);
      };
      XPathNSResolverWrapper.prototype = {};
      XPathNSResolverWrapper.prototype.constructor = XPathNSResolverWrapper;
      XPathNSResolverWrapper.superclass = Object.prototype;
      function XPathNSResolverWrapper(r2) {
        this.xpathNSResolver = r2;
      }
      XPathNSResolverWrapper.prototype.getNamespace = function(prefix, n3) {
        if (this.xpathNSResolver == null) {
          return null;
        }
        return this.xpathNSResolver.lookupNamespaceURI(prefix);
      };
      NodeXPathNSResolver.prototype = {};
      NodeXPathNSResolver.prototype.constructor = NodeXPathNSResolver;
      NodeXPathNSResolver.superclass = Object.prototype;
      function NodeXPathNSResolver(n3) {
        this.node = n3;
        this.namespaceResolver = new NamespaceResolver();
      }
      NodeXPathNSResolver.prototype.lookupNamespaceURI = function(prefix) {
        return this.namespaceResolver.getNamespace(prefix, this.node);
      };
      XPathResult.prototype = {};
      XPathResult.prototype.constructor = XPathResult;
      XPathResult.superclass = Object.prototype;
      function XPathResult(v, t4) {
        if (t4 == XPathResult.ANY_TYPE) {
          if (v.constructor === XString) {
            t4 = XPathResult.STRING_TYPE;
          } else if (v.constructor === XNumber) {
            t4 = XPathResult.NUMBER_TYPE;
          } else if (v.constructor === XBoolean) {
            t4 = XPathResult.BOOLEAN_TYPE;
          } else if (v.constructor === XNodeSet) {
            t4 = XPathResult.UNORDERED_NODE_ITERATOR_TYPE;
          }
        }
        this.resultType = t4;
        switch (t4) {
          case XPathResult.NUMBER_TYPE:
            this.numberValue = v.numberValue();
            return;
          case XPathResult.STRING_TYPE:
            this.stringValue = v.stringValue();
            return;
          case XPathResult.BOOLEAN_TYPE:
            this.booleanValue = v.booleanValue();
            return;
          case XPathResult.ANY_UNORDERED_NODE_TYPE:
          case XPathResult.FIRST_ORDERED_NODE_TYPE:
            if (v.constructor === XNodeSet) {
              this.singleNodeValue = v.first();
              return;
            }
            break;
          case XPathResult.UNORDERED_NODE_ITERATOR_TYPE:
          case XPathResult.ORDERED_NODE_ITERATOR_TYPE:
            if (v.constructor === XNodeSet) {
              this.invalidIteratorState = false;
              this.nodes = v.toArray();
              this.iteratorIndex = 0;
              return;
            }
            break;
          case XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE:
          case XPathResult.ORDERED_NODE_SNAPSHOT_TYPE:
            if (v.constructor === XNodeSet) {
              this.nodes = v.toArray();
              this.snapshotLength = this.nodes.length;
              return;
            }
            break;
        }
        throw new XPathException(XPathException.TYPE_ERR);
      }
      ;
      XPathResult.prototype.iterateNext = function() {
        if (this.resultType != XPathResult.UNORDERED_NODE_ITERATOR_TYPE && this.resultType != XPathResult.ORDERED_NODE_ITERATOR_TYPE) {
          throw new XPathException(XPathException.TYPE_ERR);
        }
        return this.nodes[this.iteratorIndex++];
      };
      XPathResult.prototype.snapshotItem = function(i4) {
        if (this.resultType != XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE && this.resultType != XPathResult.ORDERED_NODE_SNAPSHOT_TYPE) {
          throw new XPathException(XPathException.TYPE_ERR);
        }
        return this.nodes[i4];
      };
      XPathResult.ANY_TYPE = 0;
      XPathResult.NUMBER_TYPE = 1;
      XPathResult.STRING_TYPE = 2;
      XPathResult.BOOLEAN_TYPE = 3;
      XPathResult.UNORDERED_NODE_ITERATOR_TYPE = 4;
      XPathResult.ORDERED_NODE_ITERATOR_TYPE = 5;
      XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE = 6;
      XPathResult.ORDERED_NODE_SNAPSHOT_TYPE = 7;
      XPathResult.ANY_UNORDERED_NODE_TYPE = 8;
      XPathResult.FIRST_ORDERED_NODE_TYPE = 9;
      function installDOM3XPathSupport(doc, p8) {
        doc.createExpression = function(e2, r2) {
          try {
            return new XPathExpression(e2, r2, p8);
          } catch (e3) {
            throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, e3);
          }
        };
        doc.createNSResolver = function(n3) {
          return new NodeXPathNSResolver(n3);
        };
        doc.evaluate = function(e2, cn, r2, t4, res) {
          if (t4 < 0 || t4 > 9) {
            throw { code: 0, toString: function() {
              return "Request type not supported";
            } };
          }
          return doc.createExpression(e2, r2, p8).evaluate(cn, t4, res);
        };
      }
      ;
      try {
        var shouldInstall = true;
        try {
          if (document.implementation && document.implementation.hasFeature && document.implementation.hasFeature("XPath", null)) {
            shouldInstall = false;
          }
        } catch (e2) {
        }
        if (shouldInstall) {
          installDOM3XPathSupport(document, new XPathParser());
        }
      } catch (e2) {
      }
      installDOM3XPathSupport(exports2, new XPathParser());
      (function() {
        var parser = new XPathParser();
        var defaultNSResolver = new NamespaceResolver();
        var defaultFunctionResolver = new FunctionResolver();
        var defaultVariableResolver = new VariableResolver();
        function makeNSResolverFromFunction(func) {
          return {
            getNamespace: function(prefix, node) {
              var ns = func(prefix, node);
              return ns || defaultNSResolver.getNamespace(prefix, node);
            }
          };
        }
        function makeNSResolverFromObject(obj) {
          return makeNSResolverFromFunction(obj.getNamespace.bind(obj));
        }
        function makeNSResolverFromMap(map2) {
          return makeNSResolverFromFunction(function(prefix) {
            return map2[prefix];
          });
        }
        function makeNSResolver(resolver) {
          if (resolver && typeof resolver.getNamespace === "function") {
            return makeNSResolverFromObject(resolver);
          }
          if (typeof resolver === "function") {
            return makeNSResolverFromFunction(resolver);
          }
          if (typeof resolver === "object") {
            return makeNSResolverFromMap(resolver);
          }
          return defaultNSResolver;
        }
        function convertValue(value) {
          if (value === null || typeof value === "undefined" || value instanceof XString || value instanceof XBoolean || value instanceof XNumber || value instanceof XNodeSet) {
            return value;
          }
          switch (typeof value) {
            case "string":
              return new XString(value);
            case "boolean":
              return new XBoolean(value);
            case "number":
              return new XNumber(value);
          }
          var ns = new XNodeSet();
          ns.addArray([].concat(value));
          return ns;
        }
        function makeEvaluator(func) {
          return function(context) {
            var args = Array.prototype.slice.call(arguments, 1).map(function(arg) {
              return arg.evaluate(context);
            });
            var result = func.apply(this, [].concat(context, args));
            return convertValue(result);
          };
        }
        function makeFunctionResolverFromFunction(func) {
          return {
            getFunction: function(name2, namespace) {
              var found = func(name2, namespace);
              if (found) {
                return makeEvaluator(found);
              }
              return defaultFunctionResolver.getFunction(name2, namespace);
            }
          };
        }
        function makeFunctionResolverFromObject(obj) {
          return makeFunctionResolverFromFunction(obj.getFunction.bind(obj));
        }
        function makeFunctionResolverFromMap(map2) {
          return makeFunctionResolverFromFunction(function(name2) {
            return map2[name2];
          });
        }
        function makeFunctionResolver(resolver) {
          if (resolver && typeof resolver.getFunction === "function") {
            return makeFunctionResolverFromObject(resolver);
          }
          if (typeof resolver === "function") {
            return makeFunctionResolverFromFunction(resolver);
          }
          if (typeof resolver === "object") {
            return makeFunctionResolverFromMap(resolver);
          }
          return defaultFunctionResolver;
        }
        function makeVariableResolverFromFunction(func) {
          return {
            getVariable: function(name2, namespace) {
              var value = func(name2, namespace);
              return convertValue(value);
            }
          };
        }
        function makeVariableResolver(resolver) {
          if (resolver) {
            if (typeof resolver.getVariable === "function") {
              return makeVariableResolverFromFunction(resolver.getVariable.bind(resolver));
            }
            if (typeof resolver === "function") {
              return makeVariableResolverFromFunction(resolver);
            }
            if (typeof resolver === "object") {
              return makeVariableResolverFromFunction(function(name2) {
                return resolver[name2];
              });
            }
          }
          return defaultVariableResolver;
        }
        function copyIfPresent(prop, dest, source) {
          if (prop in source) {
            dest[prop] = source[prop];
          }
        }
        function makeContext(options) {
          var context = new XPathContext();
          if (options) {
            context.namespaceResolver = makeNSResolver(options.namespaces);
            context.functionResolver = makeFunctionResolver(options.functions);
            context.variableResolver = makeVariableResolver(options.variables);
            context.expressionContextNode = options.node;
            copyIfPresent("allowAnyNamespaceForNoPrefix", context, options);
            copyIfPresent("isHtml", context, options);
          } else {
            context.namespaceResolver = defaultNSResolver;
          }
          return context;
        }
        function evaluate(parsedExpression, options) {
          var context = makeContext(options);
          return parsedExpression.evaluate(context);
        }
        var evaluatorPrototype = {
          evaluate: function(options) {
            return evaluate(this.expression, options);
          },
          evaluateNumber: function(options) {
            return this.evaluate(options).numberValue();
          },
          evaluateString: function(options) {
            return this.evaluate(options).stringValue();
          },
          evaluateBoolean: function(options) {
            return this.evaluate(options).booleanValue();
          },
          evaluateNodeSet: function(options) {
            return this.evaluate(options).nodeset();
          },
          select: function(options) {
            return this.evaluateNodeSet(options).toArray();
          },
          select1: function(options) {
            return this.select(options)[0];
          }
        };
        function parse(xpath2) {
          var parsed = parser.parse(xpath2);
          return Object.create(evaluatorPrototype, {
            expression: {
              value: parsed
            }
          });
        }
        exports2.parse = parse;
      })();
      assign(
        exports2,
        {
          XPath,
          XPathParser,
          XPathResult,
          Step,
          PathExpr,
          NodeTest,
          LocationPath,
          OrOperation,
          AndOperation,
          BarOperation,
          EqualsOperation,
          NotEqualOperation,
          LessThanOperation,
          GreaterThanOperation,
          LessThanOrEqualOperation,
          GreaterThanOrEqualOperation,
          PlusOperation,
          MinusOperation,
          MultiplyOperation,
          DivOperation,
          ModOperation,
          UnaryMinusOperation,
          FunctionCall,
          VariableReference,
          XPathContext,
          XNodeSet,
          XBoolean,
          XString,
          XNumber,
          NamespaceResolver,
          FunctionResolver,
          VariableResolver,
          Utilities
        }
      );
      exports2.select = function(e2, doc, single) {
        return exports2.selectWithResolver(e2, doc, null, single);
      };
      exports2.useNamespaces = function(mappings) {
        var resolver = {
          mappings: mappings || {},
          lookupNamespaceURI: function(prefix) {
            return this.mappings[prefix];
          }
        };
        return function(e2, doc, single) {
          return exports2.selectWithResolver(e2, doc, resolver, single);
        };
      };
      exports2.selectWithResolver = function(e2, doc, resolver, single) {
        var expression = new XPathExpression(e2, resolver, new XPathParser());
        var type = XPathResult.ANY_TYPE;
        var result = expression.evaluate(doc, type, null);
        if (result.resultType == XPathResult.STRING_TYPE) {
          result = result.stringValue;
        } else if (result.resultType == XPathResult.NUMBER_TYPE) {
          result = result.numberValue;
        } else if (result.resultType == XPathResult.BOOLEAN_TYPE) {
          result = result.booleanValue;
        } else {
          result = result.nodes;
          if (single) {
            result = result[0];
          }
        }
        return result;
      };
      exports2.select1 = function(e2, doc) {
        return exports2.select(e2, doc, true);
      };
    })(xpath);
  }
});

// node_modules/@redocly/xml-crypto/lib/utils.js
var require_utils2 = __commonJS({
  "node_modules/@redocly/xml-crypto/lib/utils.js"(exports) {
    var select = require_xpath().select;
    function findAttr(node, localName, namespace) {
      for (var i4 = 0; i4 < node.attributes.length; i4++) {
        var attr = node.attributes[i4];
        if (attrEqualsExplicitly(attr, localName, namespace) || attrEqualsImplicitly(attr, localName, namespace, node)) {
          return attr;
        }
      }
      return null;
    }
    function findFirst(doc, xpath) {
      var nodes = select(xpath, doc);
      if (nodes.length == 0)
        throw "could not find xpath " + xpath;
      return nodes[0];
    }
    function findChilds(node, localName, namespace) {
      node = node.documentElement || node;
      var res = [];
      for (var i4 = 0; i4 < node.childNodes.length; i4++) {
        var child = node.childNodes[i4];
        if (child.localName == localName && (child.namespaceURI == namespace || !namespace)) {
          res.push(child);
        }
      }
      return res;
    }
    function attrEqualsExplicitly(attr, localName, namespace) {
      return attr.localName == localName && (attr.namespaceURI == namespace || !namespace);
    }
    function attrEqualsImplicitly(attr, localName, namespace, node) {
      return attr.localName == localName && (!attr.namespaceURI && node.namespaceURI == namespace || !namespace);
    }
    var xml_special_to_encoded_attribute = {
      "&": "&amp;",
      "<": "&lt;",
      '"': "&quot;",
      "\r": "&#xD;",
      "\n": "&#xA;",
      "	": "&#x9;"
    };
    var xml_special_to_encoded_text = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      "\r": "&#xD;"
    };
    function encodeSpecialCharactersInAttribute(attributeValue) {
      return attributeValue.replace(/([&<"\r\n\t])/g, function(str, item) {
        return xml_special_to_encoded_attribute[item];
      });
    }
    function encodeSpecialCharactersInText(text) {
      return text.replace(/([&<>\r])/g, function(str, item) {
        return xml_special_to_encoded_text[item];
      });
    }
    exports.findAttr = findAttr;
    exports.findChilds = findChilds;
    exports.encodeSpecialCharactersInAttribute = encodeSpecialCharactersInAttribute;
    exports.encodeSpecialCharactersInText = encodeSpecialCharactersInText;
    exports.findFirst = findFirst;
  }
});

// node_modules/@redocly/xml-crypto/lib/c14n-canonicalization.js
var require_c14n_canonicalization = __commonJS({
  "node_modules/@redocly/xml-crypto/lib/c14n-canonicalization.js"(exports) {
    var utils = require_utils2();
    exports.C14nCanonicalization = C14nCanonicalization;
    exports.C14nCanonicalizationWithComments = C14nCanonicalizationWithComments;
    function C14nCanonicalization() {
      this.includeComments = false;
    }
    C14nCanonicalization.prototype.attrCompare = function(a3, b2) {
      if (!a3.namespaceURI && b2.namespaceURI) {
        return -1;
      }
      if (!b2.namespaceURI && a3.namespaceURI) {
        return 1;
      }
      var left = a3.namespaceURI + a3.localName;
      var right = b2.namespaceURI + b2.localName;
      if (left === right)
        return 0;
      else if (left < right)
        return -1;
      else
        return 1;
    };
    C14nCanonicalization.prototype.nsCompare = function(a3, b2) {
      var attr1 = a3.prefix;
      var attr2 = b2.prefix;
      if (attr1 == attr2) {
        return 0;
      }
      return attr1.localeCompare(attr2);
    };
    C14nCanonicalization.prototype.renderAttrs = function(node, defaultNS) {
      var a3, i4, attr, res = [], attrListToRender = [];
      if (node.nodeType === 8) {
        return this.renderComment(node);
      }
      if (node.attributes) {
        for (i4 = 0; i4 < node.attributes.length; ++i4) {
          attr = node.attributes[i4];
          if (attr.name.indexOf("xmlns") === 0) {
            continue;
          }
          attrListToRender.push(attr);
        }
      }
      attrListToRender.sort(this.attrCompare);
      for (a3 in attrListToRender) {
        if (!attrListToRender.hasOwnProperty(a3)) {
          continue;
        }
        attr = attrListToRender[a3];
        res.push(" ", attr.name, '="', utils.encodeSpecialCharactersInAttribute(attr.value), '"');
      }
      return res.join("");
    };
    C14nCanonicalization.prototype.renderNs = function(node, prefixesInScope, defaultNs, defaultNsForPrefix, ancestorNamespaces) {
      var a3, i4, p8, attr, res = [], newDefaultNs = defaultNs, nsListToRender = [], currNs = node.namespaceURI || "";
      if (node.prefix) {
        if (prefixesInScope.indexOf(node.prefix) == -1) {
          nsListToRender.push({ "prefix": node.prefix, "namespaceURI": node.namespaceURI || defaultNsForPrefix[node.prefix] });
          prefixesInScope.push(node.prefix);
        }
      } else if (defaultNs != currNs) {
        newDefaultNs = node.namespaceURI;
        res.push(' xmlns="', newDefaultNs, '"');
      }
      if (node.attributes) {
        for (i4 = 0; i4 < node.attributes.length; ++i4) {
          attr = node.attributes[i4];
          if (attr.prefix === "xmlns" && prefixesInScope.indexOf(attr.localName) === -1) {
            nsListToRender.push({ "prefix": attr.localName, "namespaceURI": attr.value });
            prefixesInScope.push(attr.localName);
          }
          if (attr.prefix && prefixesInScope.indexOf(attr.prefix) == -1 && attr.prefix != "xmlns" && attr.prefix != "xml") {
            nsListToRender.push({ "prefix": attr.prefix, "namespaceURI": attr.namespaceURI });
            prefixesInScope.push(attr.prefix);
          }
        }
      }
      if (Array.isArray(ancestorNamespaces) && ancestorNamespaces.length > 0) {
        for (var p1 in ancestorNamespaces) {
          if (!ancestorNamespaces.hasOwnProperty(p1))
            continue;
          var alreadyListed = false;
          for (var p22 in nsListToRender) {
            if (nsListToRender[p22].prefix === ancestorNamespaces[p1].prefix && nsListToRender[p22].namespaceURI === ancestorNamespaces[p1].namespaceURI) {
              alreadyListed = true;
            }
          }
          if (!alreadyListed) {
            nsListToRender.push(ancestorNamespaces[p1]);
          }
        }
      }
      nsListToRender.sort(this.nsCompare);
      for (a3 in nsListToRender) {
        if (!nsListToRender.hasOwnProperty(a3)) {
          continue;
        }
        p8 = nsListToRender[a3];
        res.push(" xmlns:", p8.prefix, '="', p8.namespaceURI, '"');
      }
      return { "rendered": res.join(""), "newDefaultNs": newDefaultNs };
    };
    C14nCanonicalization.prototype.processInner = function(node, prefixesInScope, defaultNs, defaultNsForPrefix, ancestorNamespaces) {
      if (node.nodeType === 8) {
        return this.renderComment(node);
      }
      if (node.data) {
        return utils.encodeSpecialCharactersInText(node.data);
      }
      var i4, pfxCopy, ns = this.renderNs(node, prefixesInScope, defaultNs, defaultNsForPrefix, ancestorNamespaces), res = ["<", node.tagName, ns.rendered, this.renderAttrs(node, ns.newDefaultNs), ">"];
      for (i4 = 0; i4 < node.childNodes.length; ++i4) {
        pfxCopy = prefixesInScope.slice(0);
        res.push(this.processInner(node.childNodes[i4], pfxCopy, ns.newDefaultNs, defaultNsForPrefix, []));
      }
      res.push("</", node.tagName, ">");
      return res.join("");
    };
    C14nCanonicalization.prototype.renderComment = function(node) {
      if (!this.includeComments) {
        return "";
      }
      var isOutsideDocument = node.ownerDocument === node.parentNode, isBeforeDocument = null, isAfterDocument = null;
      if (isOutsideDocument) {
        var nextNode = node, previousNode = node;
        while (nextNode !== null) {
          if (nextNode === node.ownerDocument.documentElement) {
            isBeforeDocument = true;
            break;
          }
          nextNode = nextNode.nextSibling;
        }
        while (previousNode !== null) {
          if (previousNode === node.ownerDocument.documentElement) {
            isAfterDocument = true;
            break;
          }
          previousNode = previousNode.previousSibling;
        }
      }
      return (isAfterDocument ? "\n" : "") + "<!--" + utils.encodeSpecialCharactersInText(node.data) + "-->" + (isBeforeDocument ? "\n" : "");
    };
    C14nCanonicalization.prototype.process = function(node, options) {
      options = options || {};
      var defaultNs = options.defaultNs || "";
      var defaultNsForPrefix = options.defaultNsForPrefix || {};
      var ancestorNamespaces = options.ancestorNamespaces || [];
      var prefixesInScope = [];
      for (var i4 = 0; i4 < ancestorNamespaces.length; i4++) {
        prefixesInScope.push(ancestorNamespaces[i4].prefix);
      }
      var res = this.processInner(node, prefixesInScope, defaultNs, defaultNsForPrefix, ancestorNamespaces);
      return res;
    };
    C14nCanonicalization.prototype.getAlgorithmName = function() {
      return "http://www.w3.org/TR/2001/REC-xml-c14n-20010315";
    };
    exports.C14nCanonicalizationWithComments = C14nCanonicalizationWithComments;
    function C14nCanonicalizationWithComments() {
      C14nCanonicalization.call(this);
      this.includeComments = true;
    }
    C14nCanonicalizationWithComments.prototype = Object.create(C14nCanonicalization.prototype);
    C14nCanonicalizationWithComments.prototype.constructor = C14nCanonicalizationWithComments;
    C14nCanonicalizationWithComments.prototype.getAlgorithmName = function() {
      return "http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments";
    };
  }
});

// node_modules/@redocly/xml-crypto/lib/exclusive-canonicalization.js
var require_exclusive_canonicalization = __commonJS({
  "node_modules/@redocly/xml-crypto/lib/exclusive-canonicalization.js"(exports) {
    var utils = require_utils2();
    exports.ExclusiveCanonicalization = ExclusiveCanonicalization;
    exports.ExclusiveCanonicalizationWithComments = ExclusiveCanonicalizationWithComments;
    function ExclusiveCanonicalization() {
      this.includeComments = false;
    }
    ExclusiveCanonicalization.prototype.attrCompare = function(a3, b2) {
      if (!a3.namespaceURI && b2.namespaceURI) {
        return -1;
      }
      if (!b2.namespaceURI && a3.namespaceURI) {
        return 1;
      }
      var left = a3.namespaceURI + a3.localName;
      var right = b2.namespaceURI + b2.localName;
      if (left === right)
        return 0;
      else if (left < right)
        return -1;
      else
        return 1;
    };
    ExclusiveCanonicalization.prototype.nsCompare = function(a3, b2) {
      var attr1 = a3.prefix;
      var attr2 = b2.prefix;
      if (attr1 == attr2) {
        return 0;
      }
      return attr1.localeCompare(attr2);
    };
    ExclusiveCanonicalization.prototype.renderAttrs = function(node, defaultNS) {
      var a3, i4, attr, res = [], attrListToRender = [];
      if (node.nodeType === 8) {
        return this.renderComment(node);
      }
      if (node.attributes) {
        for (i4 = 0; i4 < node.attributes.length; ++i4) {
          attr = node.attributes[i4];
          if (attr.name.indexOf("xmlns") === 0) {
            continue;
          }
          attrListToRender.push(attr);
        }
      }
      attrListToRender.sort(this.attrCompare);
      for (a3 in attrListToRender) {
        if (!attrListToRender.hasOwnProperty(a3)) {
          continue;
        }
        attr = attrListToRender[a3];
        res.push(" ", attr.name, '="', utils.encodeSpecialCharactersInAttribute(attr.value), '"');
      }
      return res.join("");
    };
    function isPrefixInScope(prefixesInScope, prefix, namespaceURI) {
      var ret = false;
      prefixesInScope.forEach(function(pf) {
        if (pf.prefix === prefix && pf.namespaceURI === namespaceURI) {
          ret = true;
        }
      });
      return ret;
    }
    ExclusiveCanonicalization.prototype.renderNs = function(node, prefixesInScope, defaultNs, defaultNsForPrefix, inclusiveNamespacesPrefixList) {
      var a3, i4, p8, attr, res = [], newDefaultNs = defaultNs, nsListToRender = [], currNs = node.namespaceURI || "";
      if (node.prefix) {
        if (!isPrefixInScope(prefixesInScope, node.prefix, node.namespaceURI || defaultNsForPrefix[node.prefix])) {
          nsListToRender.push({ "prefix": node.prefix, "namespaceURI": node.namespaceURI || defaultNsForPrefix[node.prefix] });
          prefixesInScope.push({ "prefix": node.prefix, "namespaceURI": node.namespaceURI || defaultNsForPrefix[node.prefix] });
        }
      } else if (defaultNs != currNs) {
        newDefaultNs = node.namespaceURI;
        res.push(' xmlns="', newDefaultNs, '"');
      }
      if (node.attributes) {
        for (i4 = 0; i4 < node.attributes.length; ++i4) {
          attr = node.attributes[i4];
          if (attr.prefix && !isPrefixInScope(prefixesInScope, attr.localName, attr.value) && inclusiveNamespacesPrefixList.indexOf(attr.localName) >= 0) {
            nsListToRender.push({ "prefix": attr.localName, "namespaceURI": attr.value });
            prefixesInScope.push({ "prefix": attr.localName, "namespaceURI": attr.value });
          }
          if (attr.prefix && !isPrefixInScope(prefixesInScope, attr.prefix, attr.namespaceURI) && attr.prefix != "xmlns" && attr.prefix != "xml") {
            nsListToRender.push({ "prefix": attr.prefix, "namespaceURI": attr.namespaceURI });
            prefixesInScope.push({ "prefix": attr.prefix, "namespaceURI": attr.namespaceURI });
          }
        }
      }
      nsListToRender.sort(this.nsCompare);
      for (a3 in nsListToRender) {
        if (!nsListToRender.hasOwnProperty(a3)) {
          continue;
        }
        p8 = nsListToRender[a3];
        res.push(" xmlns:", p8.prefix, '="', p8.namespaceURI, '"');
      }
      return { "rendered": res.join(""), "newDefaultNs": newDefaultNs };
    };
    ExclusiveCanonicalization.prototype.processInner = function(node, prefixesInScope, defaultNs, defaultNsForPrefix, inclusiveNamespacesPrefixList) {
      if (node.nodeType === 8) {
        return this.renderComment(node);
      }
      if (node.data) {
        return utils.encodeSpecialCharactersInText(node.data);
      }
      var i4, pfxCopy, ns = this.renderNs(node, prefixesInScope, defaultNs, defaultNsForPrefix, inclusiveNamespacesPrefixList), res = ["<", node.tagName, ns.rendered, this.renderAttrs(node, ns.newDefaultNs), ">"];
      for (i4 = 0; i4 < node.childNodes.length; ++i4) {
        pfxCopy = prefixesInScope.slice(0);
        res.push(this.processInner(node.childNodes[i4], pfxCopy, ns.newDefaultNs, defaultNsForPrefix, inclusiveNamespacesPrefixList));
      }
      res.push("</", node.tagName, ">");
      return res.join("");
    };
    ExclusiveCanonicalization.prototype.renderComment = function(node) {
      if (!this.includeComments) {
        return "";
      }
      var isOutsideDocument = node.ownerDocument === node.parentNode, isBeforeDocument = null, isAfterDocument = null;
      if (isOutsideDocument) {
        var nextNode = node, previousNode = node;
        while (nextNode !== null) {
          if (nextNode === node.ownerDocument.documentElement) {
            isBeforeDocument = true;
            break;
          }
          nextNode = nextNode.nextSibling;
        }
        while (previousNode !== null) {
          if (previousNode === node.ownerDocument.documentElement) {
            isAfterDocument = true;
            break;
          }
          previousNode = previousNode.previousSibling;
        }
      }
      return (isAfterDocument ? "\n" : "") + "<!--" + utils.encodeSpecialCharactersInText(node.data) + "-->" + (isBeforeDocument ? "\n" : "");
    };
    ExclusiveCanonicalization.prototype.process = function(node, options) {
      options = options || {};
      var inclusiveNamespacesPrefixList = options.inclusiveNamespacesPrefixList || [];
      var defaultNs = options.defaultNs || "";
      var defaultNsForPrefix = options.defaultNsForPrefix || {};
      if (!(inclusiveNamespacesPrefixList instanceof Array)) {
        inclusiveNamespacesPrefixList = inclusiveNamespacesPrefixList.split(" ");
      }
      var ancestorNamespaces = options.ancestorNamespaces || [];
      if (inclusiveNamespacesPrefixList.length == 0) {
        var CanonicalizationMethod = utils.findChilds(node, "CanonicalizationMethod");
        if (CanonicalizationMethod.length != 0) {
          var inclusiveNamespaces = utils.findChilds(CanonicalizationMethod[0], "InclusiveNamespaces");
          if (inclusiveNamespaces.length != 0) {
            inclusiveNamespacesPrefixList = inclusiveNamespaces[0].getAttribute("PrefixList").split(" ");
          }
        }
      }
      if (inclusiveNamespacesPrefixList) {
        var prefixList = inclusiveNamespacesPrefixList instanceof Array ? inclusiveNamespacesPrefixList : inclusiveNamespacesPrefixList.split(" ");
        prefixList.forEach(function(prefix) {
          if (ancestorNamespaces) {
            ancestorNamespaces.forEach(function(ancestorNamespace) {
              if (prefix == ancestorNamespace.prefix) {
                node.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:" + prefix, ancestorNamespace.namespaceURI);
              }
            });
          }
        });
      }
      var res = this.processInner(node, [], defaultNs, defaultNsForPrefix, inclusiveNamespacesPrefixList);
      return res;
    };
    ExclusiveCanonicalization.prototype.getAlgorithmName = function() {
      return "http://www.w3.org/2001/10/xml-exc-c14n#";
    };
    exports.ExclusiveCanonicalizationWithComments = ExclusiveCanonicalizationWithComments;
    function ExclusiveCanonicalizationWithComments() {
      ExclusiveCanonicalization.call(this);
      this.includeComments = true;
    }
    ExclusiveCanonicalizationWithComments.prototype = Object.create(ExclusiveCanonicalization.prototype);
    ExclusiveCanonicalizationWithComments.prototype.constructor = ExclusiveCanonicalizationWithComments;
    ExclusiveCanonicalizationWithComments.prototype.getAlgorithmName = function() {
      return "http://www.w3.org/2001/10/xml-exc-c14n#WithComments";
    };
  }
});

// node_modules/@redocly/xml-crypto/lib/enveloped-signature.js
var require_enveloped_signature = __commonJS({
  "node_modules/@redocly/xml-crypto/lib/enveloped-signature.js"(exports) {
    var xpath = require_xpath();
    var utils = require_utils2();
    exports.EnvelopedSignature = EnvelopedSignature;
    function EnvelopedSignature() {
    }
    EnvelopedSignature.prototype.process = function(node, options) {
      if (null == options.signatureNode) {
        var signature = xpath.select("./*[local-name(.)='Signature' and namespace-uri(.)='http://www.w3.org/2000/09/xmldsig#']", node)[0];
        if (signature)
          signature.parentNode.removeChild(signature);
        return node;
      }
      var signatureNode = options.signatureNode;
      var expectedSignatureValue = utils.findFirst(signatureNode, ".//*[local-name(.)='SignatureValue']/text()").data;
      var signatures = xpath.select(".//*[local-name(.)='Signature' and namespace-uri(.)='http://www.w3.org/2000/09/xmldsig#']", node);
      for (var h4 in signatures) {
        if (!signatures.hasOwnProperty(h4))
          continue;
        var signature = signatures[h4];
        var signatureValue = utils.findFirst(signature, ".//*[local-name(.)='SignatureValue']/text()").data;
        if (expectedSignatureValue === signatureValue) {
          signature.parentNode.removeChild(signature);
        }
      }
      return node;
    };
    EnvelopedSignature.prototype.getAlgorithmName = function() {
      return "http://www.w3.org/2000/09/xmldsig#enveloped-signature";
    };
  }
});

// node_modules/@redocly/xml-crypto/lib/base64.js
var require_base64 = __commonJS({
  "node_modules/@redocly/xml-crypto/lib/base64.js"(exports) {
    exports.decode = decode;
    exports.encode = encode;
    var base64abc = [
      "A",
      "B",
      "C",
      "D",
      "E",
      "F",
      "G",
      "H",
      "I",
      "J",
      "K",
      "L",
      "M",
      "N",
      "O",
      "P",
      "Q",
      "R",
      "S",
      "T",
      "U",
      "V",
      "W",
      "X",
      "Y",
      "Z",
      "a",
      "b",
      "c",
      "d",
      "e",
      "f",
      "g",
      "h",
      "i",
      "j",
      "k",
      "l",
      "m",
      "n",
      "o",
      "p",
      "q",
      "r",
      "s",
      "t",
      "u",
      "v",
      "w",
      "x",
      "y",
      "z",
      "0",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9",
      "+",
      "/"
    ];
    function encode(data) {
      var uint8 = typeof data === "string" ? new TextEncoder().encode(data) : data instanceof Uint8Array ? data : new Uint8Array(data);
      var result = "", i4;
      var l4 = uint8.length;
      for (i4 = 2; i4 < l4; i4 += 3) {
        result += base64abc[uint8[i4 - 2] >> 2];
        result += base64abc[(uint8[i4 - 2] & 3) << 4 | uint8[i4 - 1] >> 4];
        result += base64abc[(uint8[i4 - 1] & 15) << 2 | uint8[i4] >> 6];
        result += base64abc[uint8[i4] & 63];
      }
      if (i4 === l4 + 1) {
        result += base64abc[uint8[i4 - 2] >> 2];
        result += base64abc[(uint8[i4 - 2] & 3) << 4];
        result += "==";
      }
      if (i4 === l4) {
        result += base64abc[uint8[i4 - 2] >> 2];
        result += base64abc[(uint8[i4 - 2] & 3) << 4 | uint8[i4 - 1] >> 4];
        result += base64abc[(uint8[i4 - 1] & 15) << 2];
        result += "=";
      }
      return result;
    }
    function decode(b64) {
      var binString = atob(b64);
      var size = binString.length;
      var bytes = new Uint8Array(size);
      for (let i4 = 0; i4 < size; i4++) {
        bytes[i4] = binString.charCodeAt(i4);
      }
      return bytes;
    }
  }
});

// node_modules/@redocly/xml-crypto/lib/cert.js
var require_cert = __commonJS({
  "node_modules/@redocly/xml-crypto/lib/cert.js"(exports) {
    var base64 = require_base64();
    exports.extractPubKey = extractPubKey;
    exports.extractSpkiFromX509 = extractSpkiFromX509;
    function checkOctet(der, idx, expected) {
      var octet = der[idx];
      if (octet != expected) {
        throw new Error(
          `Error extracting public key, idx: [${idx}], octet: [${octet.toString(
            16
          )}], expected: [${expected.toString(16)}]`
        );
      }
    }
    function isRsaOid(der, idx) {
      if (der[idx + 0] === 48 && der[idx + 1] === 13 && der[idx + 2] === 6 && der[idx + 3] === 9 && der[idx + 4] === 42 && der[idx + 5] === 134 && der[idx + 6] === 72 && der[idx + 7] === 134 && der[idx + 8] === 247 && der[idx + 9] === 13 && der[idx + 10] === 1 && der[idx + 11] === 1 && der[idx + 12] === 1) {
        return true;
      }
      return false;
    }
    function extractPubKey(der) {
      checkOctet(der, 0, 48);
      checkOctet(der, 1, 130);
      checkOctet(der, 4, 48);
      checkOctet(der, 5, 130);
      var versionStart = 8;
      var currentByte = versionStart;
      var publicKeyStart = 0;
      var publicKeyLen = 0;
      while (currentByte < der.byteLength) {
        var dataOffset = 2;
        var length = der[currentByte + 1];
        if (length === 129) {
          dataOffset = 3;
          length = der[currentByte + 2];
        } else if (length === 130) {
          dataOffset = 4;
          length = der[currentByte + 2] * 256 + der[currentByte + 3];
        } else if (length > 128) {
          throw new Error("Certificate is not supported by current implementation");
        }
        if (isRsaOid(der, currentByte + dataOffset)) {
          var view = new Uint8Array(der.buffer, currentByte, length + dataOffset);
          return new Uint8Array(view);
        }
        currentByte += length + dataOffset;
      }
      throw new Error("Failed to extract RSA public key from the certificate");
    }
    function extractPemDataString(pem) {
      return pem.replace(
        /(\n\s)*-----(BEGIN|END) (CERTIFICATE|PUBLIC KEY|PRIVATE KEY|RSA PUBLIC KEY)-----(\n\s)*/g,
        ""
      ).replace(/(\n|\r)/g, "").trim();
    }
    function extractSpkiFromX509(x509pem) {
      const pemDataBase64 = extractPemDataString(x509pem);
      const x509Der = base64.decode(pemDataBase64);
      const spkiDer = extractPubKey(x509Der);
      return spkiDer;
    }
  }
});

// node_modules/@redocly/xml-crypto/lib/signed-xml.js
var require_signed_xml = __commonJS({
  "node_modules/@redocly/xml-crypto/lib/signed-xml.js"(exports) {
    var xpath = require_xpath();
    var Dom = require_lib().DOMParser;
    var utils = require_utils2();
    var c14n = require_c14n_canonicalization();
    var execC14n = require_exclusive_canonicalization();
    var EnvelopedSignature = require_enveloped_signature().EnvelopedSignature;
    var base64 = require_base64();
    var certUtils = require_cert();
    exports.SignedXml = SignedXml;
    exports.InMemKeyInfo = InMemKeyInfo;
    function InMemKeyInfo(keyValue) {
      this.keyValue = keyValue;
      this.getKeyInfo = function(key, prefix) {
        prefix = prefix || "";
        prefix = prefix ? prefix + ":" : prefix;
        return "<" + prefix + "X509Data></" + prefix + "X509Data>";
      };
      this.getKey = function(keyInfo) {
        return this.keyValue;
      };
    }
    function SHA1() {
      this.getHash = async function(xml) {
        var encoder = new TextEncoder();
        var data = encoder.encode(xml);
        var hash = await crypto.subtle.digest("SHA-1", data);
        return base64.encode(hash);
      };
      this.getAlgorithmName = function() {
        return "http://www.w3.org/2000/09/xmldsig#sha1";
      };
    }
    function SHA256() {
      this.getHash = async function(xml) {
        var encoder = new TextEncoder();
        var data = encoder.encode(xml);
        var hash = await crypto.subtle.digest("SHA-256", data);
        return base64.encode(hash);
      };
      this.getAlgorithmName = function() {
        return "http://www.w3.org/2001/04/xmlenc#sha256";
      };
    }
    function SHA512() {
      this.getHash = async function(xml) {
        var encoder = new TextEncoder();
        var data = encoder.encode(xml);
        var hash = await crypto.subtle.digest("SHA-512", data);
        return base64.encode(hash);
      };
      this.getAlgorithmName = function() {
        return "http://www.w3.org/2001/04/xmlenc#sha512";
      };
    }
    function RSASHA1() {
      this.getSignature = function(signedInfo, signingKey, callback) {
        throw new Error("Not implemented yet");
      };
      this.verifySignature = async function(str, cert, signatureValue, callback) {
        var spki = certUtils.extractSpkiFromX509(cert);
        const pubKey = await crypto.subtle.importKey(
          "spki",
          spki,
          {
            name: "RSASSA-PKCS1-v1_5",
            hash: "SHA-1"
          },
          true,
          ["verify"]
        );
        const xmlBytes = new TextEncoder().encode(str);
        const sigBytes = base64.decode(signatureValue);
        const res = await crypto.subtle.verify("RSASSA-PKCS1-v1_5", pubKey, sigBytes.buffer, xmlBytes.buffer);
        if (callback)
          callback(null, res);
        return res;
      };
      this.getAlgorithmName = function() {
        return "http://www.w3.org/2000/09/xmldsig#rsa-sha1";
      };
    }
    function RSASHA256() {
      this.getSignature = function(signedInfo, signingKey, callback) {
        throw new Error("Not implemented yet");
      };
      this.verifySignature = async function(str, cert, signatureValue, callback) {
        var spki = certUtils.extractSpkiFromX509(cert);
        const pubKey = await crypto.subtle.importKey(
          "spki",
          spki,
          {
            name: "RSASSA-PKCS1-v1_5",
            hash: "SHA-256"
          },
          true,
          ["verify"]
        );
        const xmlBytes = new TextEncoder().encode(str);
        const sigBytes = base64.decode(signatureValue);
        const res = await crypto.subtle.verify("RSASSA-PKCS1-v1_5", pubKey, sigBytes.buffer, xmlBytes.buffer);
        if (callback)
          callback(null, res);
        return res;
      };
      this.getAlgorithmName = function() {
        return "http://www.w3.org/2001/04/xmldsig-more#rsa-sha256";
      };
    }
    function RSASHA512() {
      this.getSignature = function(signedInfo, signingKey, callback) {
        throw new Error("Not implemented yet");
      };
      this.verifySignature = async function(str, cert, signatureValue, callback) {
        var spki = certUtils.extractSpkiFromX509(cert);
        const pubKey = await crypto.subtle.importKey(
          "spki",
          spki,
          {
            name: "RSASSA-PKCS1-v1_5",
            hash: "SHA-512"
          },
          true,
          ["verify"]
        );
        const xmlBytes = new TextEncoder().encode(str);
        const sigBytes = base64.decode(signatureValue);
        const res = await crypto.subtle.verify("RSASSA-PKCS1-v1_5", pubKey, sigBytes.buffer, xmlBytes.buffer);
        if (callback)
          callback(null, res);
        return res;
      };
      this.getAlgorithmName = function() {
        return "http://www.w3.org/2001/04/xmldsig-more#rsa-sha512";
      };
    }
    function HMACSHA1() {
      this.verifySignature = async function(str, secret, signatureValue) {
        const key = await crypto.subtle.importKey(
          "raw",
          secret,
          {
            name: "HMAC",
            hash: "SHA-1"
          },
          true,
          ["sign", "verify"]
        );
        const xmlBytes = new TextEncoder().encode(str);
        const res = base64.encode(await crypto.subtle.sign("HMAC", key, xmlBytes.buffer));
        return res === signatureValue;
      };
      this.getAlgorithmName = function() {
        return "http://www.w3.org/2000/09/xmldsig#hmac-sha1";
      };
      this.getSignature = function(signedInfo, signingKey) {
        throw new Error("Not implemented yet");
      };
    }
    function findAncestorNs(doc, docSubsetXpath, namespaceResolver) {
      var docSubset = xpath.selectWithResolver(docSubsetXpath, doc, namespaceResolver);
      if (!Array.isArray(docSubset) || docSubset.length < 1) {
        return [];
      }
      var ancestorNs = collectAncestorNamespaces(docSubset[0]);
      var ancestorNsWithoutDuplicate = [];
      for (var i4 = 0; i4 < ancestorNs.length; i4++) {
        var notOnTheList = true;
        for (var v in ancestorNsWithoutDuplicate) {
          if (ancestorNsWithoutDuplicate[v].prefix === ancestorNs[i4].prefix) {
            notOnTheList = false;
            break;
          }
        }
        if (notOnTheList) {
          ancestorNsWithoutDuplicate.push(ancestorNs[i4]);
        }
      }
      var returningNs = [];
      var subsetAttributes = docSubset[0].attributes;
      for (var j = 0; j < ancestorNsWithoutDuplicate.length; j++) {
        var isUnique = true;
        for (var k = 0; k < subsetAttributes.length; k++) {
          var nodeName = subsetAttributes[k].nodeName;
          if (nodeName.search(/^xmlns:/) === -1)
            continue;
          var prefix = nodeName.replace(/^xmlns:/, "");
          if (ancestorNsWithoutDuplicate[j].prefix === prefix) {
            isUnique = false;
            break;
          }
        }
        if (isUnique) {
          returningNs.push(ancestorNsWithoutDuplicate[j]);
        }
      }
      return returningNs;
    }
    function collectAncestorNamespaces(node, nsArray) {
      if (!nsArray) {
        nsArray = [];
      }
      var parent = node.parentNode;
      if (!parent) {
        return nsArray;
      }
      if (parent.attributes && parent.attributes.length > 0) {
        for (var i4 = 0; i4 < parent.attributes.length; i4++) {
          var attr = parent.attributes[i4];
          if (attr && attr.nodeName && attr.nodeName.search(/^xmlns:/) !== -1) {
            nsArray.push({ prefix: attr.nodeName.replace(/^xmlns:/, ""), namespaceURI: attr.nodeValue });
          }
        }
      }
      return collectAncestorNamespaces(parent, nsArray);
    }
    function SignedXml(idMode, options) {
      this.options = options || {};
      this.idMode = idMode;
      this.references = [];
      this.id = 0;
      this.signingKey = null;
      this.signatureAlgorithm = this.options.signatureAlgorithm || "http://www.w3.org/2000/09/xmldsig#rsa-sha1";
      this.keyInfoProvider = null;
      this.canonicalizationAlgorithm = this.options.canonicalizationAlgorithm || "http://www.w3.org/2001/10/xml-exc-c14n#";
      this.signedXml = "";
      this.signatureXml = "";
      this.signatureNode = null;
      this.signatureValue = "";
      this.originalXmlWithIds = "";
      this.validationErrors = [];
      this.keyInfo = null;
      this.idAttributes = ["Id", "ID", "id"];
      if (this.options.idAttribute)
        this.idAttributes.splice(0, 0, this.options.idAttribute);
      this.implicitTransforms = this.options.implicitTransforms || [];
    }
    SignedXml.CanonicalizationAlgorithms = {
      "http://www.w3.org/TR/2001/REC-xml-c14n-20010315": c14n.C14nCanonicalization,
      "http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments": c14n.C14nCanonicalizationWithComments,
      "http://www.w3.org/2001/10/xml-exc-c14n#": execC14n.ExclusiveCanonicalization,
      "http://www.w3.org/2001/10/xml-exc-c14n#WithComments": execC14n.ExclusiveCanonicalizationWithComments,
      "http://www.w3.org/2000/09/xmldsig#enveloped-signature": EnvelopedSignature
    };
    SignedXml.HashAlgorithms = {
      "http://www.w3.org/2000/09/xmldsig#sha1": SHA1,
      "http://www.w3.org/2001/04/xmlenc#sha256": SHA256,
      "http://www.w3.org/2001/04/xmlenc#sha512": SHA512
    };
    SignedXml.SignatureAlgorithms = {
      "http://www.w3.org/2000/09/xmldsig#rsa-sha1": RSASHA1,
      "http://www.w3.org/2001/04/xmldsig-more#rsa-sha256": RSASHA256,
      "http://www.w3.org/2001/04/xmldsig-more#rsa-sha512": RSASHA512
      // Disabled by default due to key confusion concerns.
      // 'http://www.w3.org/2000/09/xmldsig#hmac-sha1': HMACSHA1
    };
    SignedXml.enableHMAC = function() {
      SignedXml.SignatureAlgorithms = {
        "http://www.w3.org/2000/09/xmldsig#hmac-sha1": HMACSHA1
      };
    };
    SignedXml.defaultNsForPrefix = {
      ds: "http://www.w3.org/2000/09/xmldsig#"
    };
    SignedXml.findAncestorNs = findAncestorNs;
    SignedXml.prototype.checkSignature = async function(xml, callback) {
      if (callback != null && typeof callback !== "function") {
        throw new Error("Last paramater must be a callback function");
      }
      this.validationErrors = [];
      this.signedXml = xml;
      if (!this.keyInfoProvider) {
        var err = new Error("cannot validate signature since no key info resolver was provided");
        if (!callback) {
          throw err;
        } else {
          callback(err);
          return;
        }
      }
      this.signingKey = this.keyInfoProvider.getKey(this.keyInfo);
      if (!this.signingKey) {
        var err = new Error("key info provider could not resolve key info " + this.keyInfo);
        if (!callback) {
          throw err;
        } else {
          callback(err);
          return;
        }
      }
      var doc = new Dom().parseFromString(xml);
      if (!await this.validateReferences(doc)) {
        if (!callback) {
          return false;
        } else {
          callback(new Error("Could not validate references"));
          return;
        }
      }
      if (!callback) {
        if (!await this.validateSignatureValue(doc)) {
          return false;
        }
        return true;
      } else {
        this.validateSignatureValue(doc, function(err2, isValidSignature) {
          if (err2) {
            this.validationErrors.push("invalid signature: the signature value " + this.signatureValue + " is incorrect");
            callback(err2);
          } else {
            callback(null, isValidSignature);
          }
        });
      }
    };
    SignedXml.prototype.getCanonSignedInfoXml = function(doc) {
      var signedInfo = utils.findChilds(this.signatureNode, "SignedInfo");
      if (signedInfo.length == 0)
        throw new Error("could not find SignedInfo element in the message");
      if (this.canonicalizationAlgorithm === "http://www.w3.org/TR/2001/REC-xml-c14n-20010315" || this.canonicalizationAlgorithm === "http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments") {
        if (!doc || typeof doc !== "object") {
          throw new Error(
            "When canonicalization method is non-exclusive, whole xml dom must be provided as an argument"
          );
        }
      }
      var ancestorNamespaces = [];
      ancestorNamespaces = findAncestorNs(doc, "//*[local-name()='SignedInfo']");
      var c14nOptions = {
        ancestorNamespaces
      };
      return this.getCanonXml([this.canonicalizationAlgorithm], signedInfo[0], c14nOptions);
    };
    SignedXml.prototype.getCanonReferenceXml = function(doc, ref, node) {
      if (Array.isArray(ref.transforms)) {
        ref.ancestorNamespaces = findAncestorNs(doc, ref.xpath, this.namespaceResolver);
      }
      var c14nOptions = {
        inclusiveNamespacesPrefixList: ref.inclusiveNamespacesPrefixList,
        ancestorNamespaces: ref.ancestorNamespaces
      };
      return this.getCanonXml(ref.transforms, node, c14nOptions);
    };
    SignedXml.prototype.validateSignatureValue = async function(doc, callback) {
      var signedInfoCanon = this.getCanonSignedInfoXml(doc);
      var signer = this.findSignatureAlgorithm(this.signatureAlgorithm);
      var res = await signer.verifySignature(signedInfoCanon, this.signingKey, this.signatureValue, callback);
      if (!res && !callback)
        this.validationErrors.push("invalid signature: the signature value " + this.signatureValue + " is incorrect");
      return res;
    };
    SignedXml.prototype.calculateSignatureValue = function(doc, callback) {
      var signedInfoCanon = this.getCanonSignedInfoXml(doc);
      var signer = this.findSignatureAlgorithm(this.signatureAlgorithm);
      this.signatureValue = signer.getSignature(signedInfoCanon, this.signingKey, callback);
    };
    SignedXml.prototype.findSignatureAlgorithm = function(name2) {
      var algo = SignedXml.SignatureAlgorithms[name2];
      if (algo)
        return new algo();
      else
        throw new Error("signature algorithm '" + name2 + "' is not supported");
    };
    SignedXml.prototype.findCanonicalizationAlgorithm = function(name2) {
      var algo = SignedXml.CanonicalizationAlgorithms[name2];
      if (algo)
        return new algo();
      else
        throw new Error("canonicalization algorithm '" + name2 + "' is not supported");
    };
    SignedXml.prototype.findHashAlgorithm = function(name2) {
      var algo = SignedXml.HashAlgorithms[name2];
      if (algo)
        return new algo();
      else
        throw new Error("hash algorithm '" + name2 + "' is not supported");
    };
    SignedXml.prototype.validateReferences = async function(doc) {
      for (var r2 in this.references) {
        if (!this.references.hasOwnProperty(r2))
          continue;
        var ref = this.references[r2];
        var uri = ref.uri[0] == "#" ? ref.uri.substring(1) : ref.uri;
        var elem = [];
        if (uri == "") {
          elem = xpath.select("//*", doc);
        } else if (uri.indexOf("'") != -1) {
          throw new Error("Cannot validate a uri with quotes inside it");
        } else {
          var elemXpath;
          var num_elements_for_id = 0;
          for (var index in this.idAttributes) {
            if (!this.idAttributes.hasOwnProperty(index))
              continue;
            var tmp_elemXpath = "//*[@*[local-name(.)='" + this.idAttributes[index] + "']='" + uri + "']";
            var tmp_elem = xpath.select(tmp_elemXpath, doc);
            num_elements_for_id += tmp_elem.length;
            if (tmp_elem.length > 0) {
              elem = tmp_elem;
              elemXpath = tmp_elemXpath;
            }
          }
          if (num_elements_for_id > 1) {
            throw new Error("Cannot validate a document which contains multiple elements with the same value for the ID / Id / Id attributes, in order to prevent signature wrapping attack.");
          }
          ref.xpath = elemXpath;
        }
        if (elem.length == 0) {
          this.validationErrors.push("invalid signature: the signature refernces an element with uri " + ref.uri + " but could not find such element in the xml");
          return false;
        }
        var canonXml = this.getCanonReferenceXml(doc, ref, elem[0]);
        var hash = this.findHashAlgorithm(ref.digestAlgorithm);
        var digest = await hash.getHash(canonXml);
        if (!validateDigestValue(digest, ref.digestValue)) {
          this.validationErrors.push("invalid signature: for uri " + ref.uri + " calculated digest is " + digest + " but the xml to validate supplies digest " + ref.digestValue);
          return false;
        }
      }
      return true;
    };
    function validateDigestValue(digest, expectedDigest) {
      return digest === expectedDigest;
    }
    SignedXml.prototype.loadSignature = function(signatureNode) {
      if (typeof signatureNode === "string") {
        this.signatureNode = signatureNode = new Dom().parseFromString(signatureNode);
      } else {
        this.signatureNode = signatureNode;
      }
      this.signatureXml = signatureNode.toString();
      var nodes = xpath.select(".//*[local-name(.)='CanonicalizationMethod']/@Algorithm", signatureNode);
      if (nodes.length == 0)
        throw new Error("could not find CanonicalizationMethod/@Algorithm element");
      this.canonicalizationAlgorithm = nodes[0].value;
      this.signatureAlgorithm = utils.findFirst(signatureNode, ".//*[local-name(.)='SignatureMethod']/@Algorithm").value;
      this.references = [];
      var references = xpath.select(".//*[local-name(.)='SignedInfo']/*[local-name(.)='Reference']", signatureNode);
      if (references.length == 0)
        throw new Error("could not find any Reference elements");
      for (var i4 in references) {
        if (!references.hasOwnProperty(i4))
          continue;
        this.loadReference(references[i4]);
      }
      this.signatureValue = utils.findFirst(signatureNode, ".//*[local-name(.)='SignatureValue']/text()").data.replace(/\r?\n/g, "");
      this.keyInfo = xpath.select(".//*[local-name(.)='KeyInfo']", signatureNode);
    };
    SignedXml.prototype.loadReference = function(ref) {
      var nodes = utils.findChilds(ref, "DigestMethod");
      if (nodes.length == 0)
        throw new Error("could not find DigestMethod in reference " + ref.toString());
      var digestAlgoNode = nodes[0];
      var attr = utils.findAttr(digestAlgoNode, "Algorithm");
      if (!attr)
        throw new Error("could not find Algorithm attribute in node " + digestAlgoNode.toString());
      var digestAlgo = attr.value;
      nodes = utils.findChilds(ref, "DigestValue");
      if (nodes.length == 0)
        throw new Error("could not find DigestValue node in reference " + ref.toString());
      if (nodes[0].childNodes.length == 0 || !nodes[0].firstChild.data) {
        throw new Error("could not find the value of DigestValue in " + nodes[0].toString());
      }
      var digestValue = nodes[0].firstChild.data;
      var transforms = [];
      var inclusiveNamespacesPrefixList;
      nodes = utils.findChilds(ref, "Transforms");
      if (nodes.length != 0) {
        var transformsNode = nodes[0];
        var transformsAll = utils.findChilds(transformsNode, "Transform");
        for (var t4 in transformsAll) {
          if (!transformsAll.hasOwnProperty(t4))
            continue;
          var trans = transformsAll[t4];
          transforms.push(utils.findAttr(trans, "Algorithm").value);
        }
        var inclusiveNamespaces = utils.findChilds(trans, "InclusiveNamespaces");
        if (inclusiveNamespaces.length > 0) {
          for (var i4 = 0; i4 < inclusiveNamespaces.length; i4++) {
            if (inclusiveNamespacesPrefixList) {
              inclusiveNamespacesPrefixList = inclusiveNamespacesPrefixList + " " + inclusiveNamespaces[i4].getAttribute("PrefixList");
            } else {
              inclusiveNamespacesPrefixList = inclusiveNamespaces[i4].getAttribute("PrefixList");
            }
          }
        }
      }
      var hasImplicitTransforms = Array.isArray(this.implicitTransforms) && this.implicitTransforms.length > 0;
      if (hasImplicitTransforms) {
        this.implicitTransforms.forEach(function(t5) {
          transforms.push(t5);
        });
      }
      if (transforms.length === 0 || transforms[transforms.length - 1] === "http://www.w3.org/2000/09/xmldsig#enveloped-signature") {
        transforms.push("http://www.w3.org/TR/2001/REC-xml-c14n-20010315");
      }
      this.addReference(null, transforms, digestAlgo, utils.findAttr(ref, "URI").value, digestValue, inclusiveNamespacesPrefixList, false);
    };
    SignedXml.prototype.addReference = function(xpath2, transforms, digestAlgorithm, uri, digestValue, inclusiveNamespacesPrefixList, isEmptyUri) {
      this.references.push({
        "xpath": xpath2,
        "transforms": transforms ? transforms : ["http://www.w3.org/2001/10/xml-exc-c14n#"],
        "digestAlgorithm": digestAlgorithm ? digestAlgorithm : "http://www.w3.org/2000/09/xmldsig#sha1",
        "uri": uri,
        "digestValue": digestValue,
        "inclusiveNamespacesPrefixList": inclusiveNamespacesPrefixList,
        "isEmptyUri": isEmptyUri
      });
    };
    SignedXml.prototype.computeSignature = function(xml, opts, callback) {
      if (typeof opts === "function" && callback == null) {
        callback = opts;
      }
      if (callback != null && typeof callback !== "function") {
        throw new Error("Last paramater must be a callback function");
      }
      var doc = new Dom().parseFromString(xml), xmlNsAttr = "xmlns", signatureAttrs = [], location, attrs, prefix, currentPrefix;
      var validActions = ["append", "prepend", "before", "after"];
      opts = opts || {};
      prefix = opts.prefix;
      attrs = opts.attrs || {};
      location = opts.location || {};
      var existingPrefixes = opts.existingPrefixes || {};
      this.namespaceResolver = {
        lookupNamespaceURI: function(prefix2) {
          return existingPrefixes[prefix2];
        }
      };
      location.reference = location.reference || "/*";
      location.action = location.action || "append";
      if (validActions.indexOf(location.action) === -1) {
        var err = new Error("location.action option has an invalid action: " + location.action + ", must be any of the following values: " + validActions.join(", "));
        if (!callback) {
          throw err;
        } else {
          callback(err, null);
          return;
        }
      }
      if (prefix) {
        xmlNsAttr += ":" + prefix;
        currentPrefix = prefix + ":";
      } else {
        currentPrefix = "";
      }
      Object.keys(attrs).forEach(function(name2) {
        if (name2 !== "xmlns" && name2 !== xmlNsAttr) {
          signatureAttrs.push(name2 + '="' + attrs[name2] + '"');
        }
      });
      signatureAttrs.push(xmlNsAttr + '="http://www.w3.org/2000/09/xmldsig#"');
      var signatureXml = "<" + currentPrefix + "Signature " + signatureAttrs.join(" ") + ">";
      signatureXml += this.createSignedInfo(doc, prefix);
      signatureXml += this.getKeyInfo(prefix);
      signatureXml += "</" + currentPrefix + "Signature>";
      this.originalXmlWithIds = doc.toString();
      var existingPrefixesString = "";
      Object.keys(existingPrefixes).forEach(function(key) {
        existingPrefixesString += "xmlns:" + key + '="' + existingPrefixes[key] + '" ';
      });
      var dummySignatureWrapper = "<Dummy " + existingPrefixesString + ">" + signatureXml + "</Dummy>";
      var xml = new Dom().parseFromString(dummySignatureWrapper);
      var signatureDoc = xml.documentElement.firstChild;
      var referenceNode = xpath.select(location.reference, doc);
      if (!referenceNode || referenceNode.length === 0) {
        var err = new Error("the following xpath cannot be used because it was not found: " + location.reference);
        if (!callback) {
          throw err;
        } else {
          callback(err, null);
          return;
        }
      }
      referenceNode = referenceNode[0];
      if (location.action === "append") {
        referenceNode.appendChild(signatureDoc);
      } else if (location.action === "prepend") {
        referenceNode.insertBefore(signatureDoc, referenceNode.firstChild);
      } else if (location.action === "before") {
        referenceNode.parentNode.insertBefore(signatureDoc, referenceNode);
      } else if (location.action === "after") {
        referenceNode.parentNode.insertBefore(signatureDoc, referenceNode.nextSibling);
      }
      this.signatureNode = signatureDoc;
      var signedInfoNode = utils.findChilds(this.signatureNode, "SignedInfo");
      if (signedInfoNode.length == 0) {
        var err = new Error("could not find SignedInfo element in the message");
        if (!callback) {
          throw err;
        } else {
          callback(err);
          return;
        }
      }
      signedInfoNode = signedInfoNode[0];
      if (!callback) {
        this.calculateSignatureValue(doc);
        signatureDoc.insertBefore(this.createSignature(prefix), signedInfoNode.nextSibling);
        this.signatureXml = signatureDoc.toString();
        this.signedXml = doc.toString();
      } else {
        var self = this;
        this.calculateSignatureValue(doc, function(err2, signature) {
          if (err2) {
            callback(err2);
          } else {
            self.signatureValue = signature;
            signatureDoc.insertBefore(self.createSignature(prefix), signedInfoNode.nextSibling);
            self.signatureXml = signatureDoc.toString();
            self.signedXml = doc.toString();
            callback(null, self);
          }
        });
      }
    };
    SignedXml.prototype.getKeyInfo = function(prefix) {
      var res = "";
      var currentPrefix;
      currentPrefix = prefix || "";
      currentPrefix = currentPrefix ? currentPrefix + ":" : currentPrefix;
      if (this.keyInfoProvider) {
        res += "<" + currentPrefix + "KeyInfo>";
        res += this.keyInfoProvider.getKeyInfo(this.signingKey, prefix);
        res += "</" + currentPrefix + "KeyInfo>";
      }
      return res;
    };
    SignedXml.prototype.createReferences = function(doc, prefix) {
      var res = "";
      prefix = prefix || "";
      prefix = prefix ? prefix + ":" : prefix;
      for (var n3 in this.references) {
        if (!this.references.hasOwnProperty(n3))
          continue;
        var ref = this.references[n3], nodes = xpath.selectWithResolver(ref.xpath, doc, this.namespaceResolver);
        if (nodes.length == 0) {
          throw new Error("the following xpath cannot be signed because it was not found: " + ref.xpath);
        }
        for (var h4 in nodes) {
          if (!nodes.hasOwnProperty(h4))
            continue;
          var node = nodes[h4];
          if (ref.isEmptyUri) {
            res += "<" + prefix + 'Reference URI="">';
          } else {
            var id = this.ensureHasId(node);
            ref.uri = id;
            res += "<" + prefix + 'Reference URI="#' + id + '">';
          }
          res += "<" + prefix + "Transforms>";
          for (var t4 in ref.transforms) {
            if (!ref.transforms.hasOwnProperty(t4))
              continue;
            var trans = ref.transforms[t4];
            var transform = this.findCanonicalizationAlgorithm(trans);
            res += "<" + prefix + 'Transform Algorithm="' + transform.getAlgorithmName() + '" />';
          }
          var canonXml = this.getCanonReferenceXml(doc, ref, node);
          var digestAlgorithm = this.findHashAlgorithm(ref.digestAlgorithm);
          res += "</" + prefix + "Transforms><" + prefix + 'DigestMethod Algorithm="' + digestAlgorithm.getAlgorithmName() + '" /><' + prefix + "DigestValue>" + digestAlgorithm.getHash(canonXml) + "</" + prefix + "DigestValue></" + prefix + "Reference>";
        }
      }
      return res;
    };
    SignedXml.prototype.getCanonXml = function(transforms, node, options) {
      options = options || {};
      options.defaultNsForPrefix = options.defaultNsForPrefix || SignedXml.defaultNsForPrefix;
      options.signatureNode = this.signatureNode;
      var canonXml = node.cloneNode(true);
      for (var t4 in transforms) {
        if (!transforms.hasOwnProperty(t4))
          continue;
        var transform = this.findCanonicalizationAlgorithm(transforms[t4]);
        canonXml = transform.process(canonXml, options);
      }
      return canonXml.toString();
    };
    SignedXml.prototype.ensureHasId = function(node) {
      var attr;
      if (this.idMode == "wssecurity") {
        attr = utils.findAttr(
          node,
          "Id",
          "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd"
        );
      } else {
        for (var index in this.idAttributes) {
          if (!this.idAttributes.hasOwnProperty(index))
            continue;
          attr = utils.findAttr(node, this.idAttributes[index], null);
          if (attr)
            break;
        }
      }
      if (attr)
        return attr.value;
      var id = "_" + this.id++;
      if (this.idMode == "wssecurity") {
        node.setAttributeNS(
          "http://www.w3.org/2000/xmlns/",
          "xmlns:wsu",
          "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd"
        );
        node.setAttributeNS(
          "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd",
          "wsu:Id",
          id
        );
      } else {
        node.setAttribute("Id", id);
      }
      return id;
    };
    SignedXml.prototype.createSignedInfo = function(doc, prefix) {
      var transform = this.findCanonicalizationAlgorithm(this.canonicalizationAlgorithm);
      var algo = this.findSignatureAlgorithm(this.signatureAlgorithm);
      var currentPrefix;
      currentPrefix = prefix || "";
      currentPrefix = currentPrefix ? currentPrefix + ":" : currentPrefix;
      var res = "<" + currentPrefix + "SignedInfo>";
      res += "<" + currentPrefix + 'CanonicalizationMethod Algorithm="' + transform.getAlgorithmName() + '" /><' + currentPrefix + 'SignatureMethod Algorithm="' + algo.getAlgorithmName() + '" />';
      res += this.createReferences(doc, prefix);
      res += "</" + currentPrefix + "SignedInfo>";
      return res;
    };
    SignedXml.prototype.createSignature = function(prefix) {
      var xmlNsAttr = "xmlns";
      if (prefix) {
        xmlNsAttr += ":" + prefix;
        prefix += ":";
      } else {
        prefix = "";
      }
      var signatureValueXml = "<" + prefix + "SignatureValue>" + this.signatureValue + "</" + prefix + "SignatureValue>";
      var dummySignatureWrapper = "<" + prefix + "Signature " + xmlNsAttr + '="http://www.w3.org/2000/09/xmldsig#">' + signatureValueXml + "</" + prefix + "Signature>";
      var doc = new Dom().parseFromString(dummySignatureWrapper);
      return doc.documentElement.firstChild;
    };
    SignedXml.prototype.getSignatureXml = function() {
      return this.signatureXml;
    };
    SignedXml.prototype.getOriginalXmlWithIds = function() {
      return this.originalXmlWithIds;
    };
    SignedXml.prototype.getSignedXml = function() {
      return this.signedXml;
    };
  }
});

// node_modules/@redocly/xml-crypto/index.js
var require_xml_crypto = __commonJS({
  "node_modules/@redocly/xml-crypto/index.js"(exports, module) {
    var select = require_xpath().select;
    module.exports = require_signed_xml();
    module.exports.xpath = function(node, xpath) {
      return select(xpath, node);
    };
  }
});

// node_modules/balanced-match/index.js
var require_balanced_match = __commonJS({
  "node_modules/balanced-match/index.js"(exports, module) {
    "use strict";
    module.exports = balanced;
    function balanced(a3, b2, str) {
      if (a3 instanceof RegExp)
        a3 = maybeMatch(a3, str);
      if (b2 instanceof RegExp)
        b2 = maybeMatch(b2, str);
      var r2 = range(a3, b2, str);
      return r2 && {
        start: r2[0],
        end: r2[1],
        pre: str.slice(0, r2[0]),
        body: str.slice(r2[0] + a3.length, r2[1]),
        post: str.slice(r2[1] + b2.length)
      };
    }
    function maybeMatch(reg, str) {
      var m2 = str.match(reg);
      return m2 ? m2[0] : null;
    }
    balanced.range = range;
    function range(a3, b2, str) {
      var begs, beg, left, right, result;
      var ai = str.indexOf(a3);
      var bi = str.indexOf(b2, ai + 1);
      var i4 = ai;
      if (ai >= 0 && bi > 0) {
        if (a3 === b2) {
          return [ai, bi];
        }
        begs = [];
        left = str.length;
        while (i4 >= 0 && !result) {
          if (i4 == ai) {
            begs.push(i4);
            ai = str.indexOf(a3, i4 + 1);
          } else if (begs.length == 1) {
            result = [begs.pop(), bi];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi;
            }
            bi = str.indexOf(b2, i4 + 1);
          }
          i4 = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length) {
          result = [left, right];
        }
      }
      return result;
    }
  }
});

// node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS({
  "node_modules/brace-expansion/index.js"(exports, module) {
    var balanced = require_balanced_match();
    module.exports = expandTop;
    var escSlash = "\0SLASH" + Math.random() + "\0";
    var escOpen = "\0OPEN" + Math.random() + "\0";
    var escClose = "\0CLOSE" + Math.random() + "\0";
    var escComma = "\0COMMA" + Math.random() + "\0";
    var escPeriod = "\0PERIOD" + Math.random() + "\0";
    function numeric(str) {
      return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
      return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
    }
    function unescapeBraces(str) {
      return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
    }
    function parseCommaParts(str) {
      if (!str)
        return [""];
      var parts = [];
      var m2 = balanced("{", "}", str);
      if (!m2)
        return str.split(",");
      var pre = m2.pre;
      var body = m2.body;
      var post = m2.post;
      var p8 = pre.split(",");
      p8[p8.length - 1] += "{" + body + "}";
      var postParts = parseCommaParts(post);
      if (post.length) {
        p8[p8.length - 1] += postParts.shift();
        p8.push.apply(p8, postParts);
      }
      parts.push.apply(parts, p8);
      return parts;
    }
    function expandTop(str) {
      if (!str)
        return [];
      if (str.substr(0, 2) === "{}") {
        str = "\\{\\}" + str.substr(2);
      }
      return expand2(escapeBraces(str), true).map(unescapeBraces);
    }
    function embrace(str) {
      return "{" + str + "}";
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    function lte(i4, y2) {
      return i4 <= y2;
    }
    function gte(i4, y2) {
      return i4 >= y2;
    }
    function expand2(str, isTop) {
      var expansions = [];
      var m2 = balanced("{", "}", str);
      if (!m2)
        return [str];
      var pre = m2.pre;
      var post = m2.post.length ? expand2(m2.post, false) : [""];
      if (/\$$/.test(m2.pre)) {
        for (var k = 0; k < post.length; k++) {
          var expansion = pre + "{" + m2.body + "}" + post[k];
          expansions.push(expansion);
        }
      } else {
        var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m2.body);
        var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m2.body);
        var isSequence = isNumericSequence || isAlphaSequence;
        var isOptions = m2.body.indexOf(",") >= 0;
        if (!isSequence && !isOptions) {
          if (m2.post.match(/,.*\}/)) {
            str = m2.pre + "{" + m2.body + escClose + m2.post;
            return expand2(str);
          }
          return [str];
        }
        var n3;
        if (isSequence) {
          n3 = m2.body.split(/\.\./);
        } else {
          n3 = parseCommaParts(m2.body);
          if (n3.length === 1) {
            n3 = expand2(n3[0], false).map(embrace);
            if (n3.length === 1) {
              return post.map(function(p8) {
                return m2.pre + n3[0] + p8;
              });
            }
          }
        }
        var N2;
        if (isSequence) {
          var x3 = numeric(n3[0]);
          var y2 = numeric(n3[1]);
          var width = Math.max(n3[0].length, n3[1].length);
          var incr = n3.length == 3 ? Math.abs(numeric(n3[2])) : 1;
          var test = lte;
          var reverse = y2 < x3;
          if (reverse) {
            incr *= -1;
            test = gte;
          }
          var pad = n3.some(isPadded);
          N2 = [];
          for (var i4 = x3; test(i4, y2); i4 += incr) {
            var c6;
            if (isAlphaSequence) {
              c6 = String.fromCharCode(i4);
              if (c6 === "\\")
                c6 = "";
            } else {
              c6 = String(i4);
              if (pad) {
                var need = width - c6.length;
                if (need > 0) {
                  var z = new Array(need + 1).join("0");
                  if (i4 < 0)
                    c6 = "-" + z + c6.slice(1);
                  else
                    c6 = z + c6;
                }
              }
            }
            N2.push(c6);
          }
        } else {
          N2 = [];
          for (var j = 0; j < n3.length; j++) {
            N2.push.apply(N2, expand2(n3[j], false));
          }
        }
        for (var j = 0; j < N2.length; j++) {
          for (var k = 0; k < post.length; k++) {
            var expansion = pre + N2[j] + post[k];
            if (!isTop || isSequence || expansion)
              expansions.push(expansion);
          }
        }
      }
      return expansions;
    }
  }
});

// node_modules/is-extglob/index.js
var require_is_extglob = __commonJS({
  "node_modules/is-extglob/index.js"(exports, module) {
    module.exports = function isExtglob(str) {
      if (typeof str !== "string" || str === "") {
        return false;
      }
      var match2;
      while (match2 = /(\\).|([@?!+*]\(.*\))/g.exec(str)) {
        if (match2[2])
          return true;
        str = str.slice(match2.index + match2[0].length);
      }
      return false;
    };
  }
});

// node_modules/is-glob/index.js
var require_is_glob = __commonJS({
  "node_modules/is-glob/index.js"(exports, module) {
    var isExtglob = require_is_extglob();
    var chars = { "{": "}", "(": ")", "[": "]" };
    var strictCheck = function(str) {
      if (str[0] === "!") {
        return true;
      }
      var index = 0;
      var pipeIndex = -2;
      var closeSquareIndex = -2;
      var closeCurlyIndex = -2;
      var closeParenIndex = -2;
      var backSlashIndex = -2;
      while (index < str.length) {
        if (str[index] === "*") {
          return true;
        }
        if (str[index + 1] === "?" && /[\].+)]/.test(str[index])) {
          return true;
        }
        if (closeSquareIndex !== -1 && str[index] === "[" && str[index + 1] !== "]") {
          if (closeSquareIndex < index) {
            closeSquareIndex = str.indexOf("]", index);
          }
          if (closeSquareIndex > index) {
            if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
              return true;
            }
            backSlashIndex = str.indexOf("\\", index);
            if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
              return true;
            }
          }
        }
        if (closeCurlyIndex !== -1 && str[index] === "{" && str[index + 1] !== "}") {
          closeCurlyIndex = str.indexOf("}", index);
          if (closeCurlyIndex > index) {
            backSlashIndex = str.indexOf("\\", index);
            if (backSlashIndex === -1 || backSlashIndex > closeCurlyIndex) {
              return true;
            }
          }
        }
        if (closeParenIndex !== -1 && str[index] === "(" && str[index + 1] === "?" && /[:!=]/.test(str[index + 2]) && str[index + 3] !== ")") {
          closeParenIndex = str.indexOf(")", index);
          if (closeParenIndex > index) {
            backSlashIndex = str.indexOf("\\", index);
            if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
              return true;
            }
          }
        }
        if (pipeIndex !== -1 && str[index] === "(" && str[index + 1] !== "|") {
          if (pipeIndex < index) {
            pipeIndex = str.indexOf("|", index);
          }
          if (pipeIndex !== -1 && str[pipeIndex + 1] !== ")") {
            closeParenIndex = str.indexOf(")", pipeIndex);
            if (closeParenIndex > pipeIndex) {
              backSlashIndex = str.indexOf("\\", pipeIndex);
              if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
                return true;
              }
            }
          }
        }
        if (str[index] === "\\") {
          var open = str[index + 1];
          index += 2;
          var close = chars[open];
          if (close) {
            var n3 = str.indexOf(close, index);
            if (n3 !== -1) {
              index = n3 + 1;
            }
          }
          if (str[index] === "!") {
            return true;
          }
        } else {
          index++;
        }
      }
      return false;
    };
    var relaxedCheck = function(str) {
      if (str[0] === "!") {
        return true;
      }
      var index = 0;
      while (index < str.length) {
        if (/[*?{}()[\]]/.test(str[index])) {
          return true;
        }
        if (str[index] === "\\") {
          var open = str[index + 1];
          index += 2;
          var close = chars[open];
          if (close) {
            var n3 = str.indexOf(close, index);
            if (n3 !== -1) {
              index = n3 + 1;
            }
          }
          if (str[index] === "!") {
            return true;
          }
        } else {
          index++;
        }
      }
      return false;
    };
    module.exports = function isGlob(str, options) {
      if (typeof str !== "string" || str === "") {
        return false;
      }
      if (isExtglob(str)) {
        return true;
      }
      var check = strictCheck;
      if (options && options.strict === false) {
        check = relaxedCheck;
      }
      return check(str);
    };
  }
});

// node_modules/@redocly/realm/dist/server/utils/rbac.js
var import_picomatch2 = __toESM(require_picomatch2(), 1);

// node_modules/@redocly/realm/dist/server/node-crypto-polyfill.js
import * as o from "crypto";
globalThis.crypto || (globalThis.crypto = { subtle: o.webcrypto?.subtle, randomUUID: o.webcrypto?.randomUUID.bind(o.webcrypto) });

// node_modules/@redocly/realm/dist/server/utils/rbac-expand.js
function R(e2, r2) {
  if (!e2)
    return;
  if (!p2(e2))
    return e2;
  const t4 = { reunite: {}, content: f(e2) }, n3 = i(e2, r2);
  for (const o3 of n3)
    t4.reunite[o3.teamName] = o3.projectRole, t4.content = { ...t4.content, ...Object.fromEntries((e2.teamFolders || []).flatMap((a3) => {
      const l4 = { ...e2.teamFoldersBaseRoles || { authenticated: "READ" }, [o3.teamName]: o3.projectRole, "redocly.owners": "ADMIN" }, s4 = a3.replaceAll("{teamPathSegment}", o3.teamPathSegment), m2 = s4 + "/**";
      return [[s4, l4], [m2, l4]];
    })) };
  return { reunite: { ...e2.reunite, ...t4.reunite }, content: { ...d(e2.content || {}, t4.content) } };
}
function p2(e2) {
  return Object.keys(e2).includes("teamNamePatterns") && Object.keys(e2).includes("teamFolders");
}
function u(e2, r2) {
  for (const t4 of e2.teamNamePatterns || []) {
    if (!t4.includes("{teamPathSegment}") && !t4.includes("{projectRole}"))
      continue;
    const n3 = "^" + t4.replace("{teamPathSegment}", "(?<teamPathSegment>[a-zA-Z0-9_.-]+)").replace("{projectRole}", "(?<projectRole>admin|maintain|triage|write|read|none)") + "$", a3 = new RegExp(n3, "i").exec(r2)?.groups;
    if (a3?.projectRole || a3?.teamPathSegment)
      return { teamName: r2, projectRole: a3.projectRole?.toUpperCase(), teamPathSegment: a3.teamPathSegment?.toLowerCase() };
  }
  return null;
}
function i(e2, r2) {
  const t4 = r2.map((o3) => u(e2, o3));
  let n3 = null;
  for (const o3 of t4)
    o3?.projectRole && !o3.teamPathSegment && (n3 = n3 ? rt(n3, o3.projectRole) : o3.projectRole);
  return t4.map((o3) => !o3?.teamPathSegment || !o3.projectRole && !n3 ? null : { ...o3, projectRole: o3?.projectRole ?? n3 }).filter(Boolean);
}
function f(e2) {
  const r2 = {};
  if (e2.teamFoldersBaseRoles)
    for (const t4 of e2.teamFolders) {
      const n3 = t4.replaceAll("{teamPathSegment}", "**");
      r2[n3] = e2.teamFoldersBaseRoles;
    }
  return r2;
}
function d(e2, r2) {
  const t4 = { ...e2 };
  for (const [n3, o3] of Object.entries(r2))
    t4[n3] ? t4[n3] = { ...t4[n3], ...o3 } : t4[n3] = o3;
  return t4;
}

// node_modules/@redocly/realm/dist/server/web-server/auth.js
var import_xmldom = __toESM(require_lib(), 1);
var import_xml_crypto = __toESM(require_xml_crypto(), 1);

// node_modules/@redocly/realm/dist/server/web-server/jwt/types.js
var t2;
(function(e2) {
  e2.HS256 = "HS256", e2.HS384 = "HS384", e2.HS512 = "HS512", e2.RS256 = "RS256", e2.ES256 = "ES256";
})(t2 || (t2 = {}));
var n;
(function(e2) {
  e2.RAW = "raw", e2.PKCS8 = "pkcs8", e2.SPKI = "spki", e2.JWK = "jwk";
})(n || (n = {}));
var i2;
(function(e2) {
  e2.Ecrypt = "encrypt", e2.Decrypt = "decrypt", e2.Sign = "sign", e2.Verify = "verify", e2.Deriverkey = "deriveKey", e2.DeriveBits = "deriveBits", e2.WrapKey = "wrapKey", e2.UnwrapKey = "unwrapKey";
})(i2 || (i2 = {}));

// node_modules/@redocly/realm/dist/server/utils/globs.js
var import_picomatch = __toESM(require_picomatch2(), 1);

// node_modules/minimatch/dist/mjs/index.js
var import_brace_expansion = __toESM(require_brace_expansion(), 1);

// node_modules/minimatch/dist/mjs/brace-expressions.js
var posixClasses = {
  "[:alnum:]": ["\\p{L}\\p{Nl}\\p{Nd}", true],
  "[:alpha:]": ["\\p{L}\\p{Nl}", true],
  "[:ascii:]": ["\\x00-\\x7f", false],
  "[:blank:]": ["\\p{Zs}\\t", true],
  "[:cntrl:]": ["\\p{Cc}", true],
  "[:digit:]": ["\\p{Nd}", true],
  "[:graph:]": ["\\p{Z}\\p{C}", true, true],
  "[:lower:]": ["\\p{Ll}", true],
  "[:print:]": ["\\p{C}", true],
  "[:punct:]": ["\\p{P}", true],
  "[:space:]": ["\\p{Z}\\t\\r\\n\\v\\f", true],
  "[:upper:]": ["\\p{Lu}", true],
  "[:word:]": ["\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}", true],
  "[:xdigit:]": ["A-Fa-f0-9", false]
};
var braceEscape = (s4) => s4.replace(/[[\]\\-]/g, "\\$&");
var regexpEscape = (s4) => s4.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
var rangesToString = (ranges) => ranges.join("");
var parseClass = (glob, position) => {
  const pos = position;
  if (glob.charAt(pos) !== "[") {
    throw new Error("not in a brace expression");
  }
  const ranges = [];
  const negs = [];
  let i4 = pos + 1;
  let sawStart = false;
  let uflag = false;
  let escaping = false;
  let negate = false;
  let endPos = pos;
  let rangeStart = "";
  WHILE:
    while (i4 < glob.length) {
      const c6 = glob.charAt(i4);
      if ((c6 === "!" || c6 === "^") && i4 === pos + 1) {
        negate = true;
        i4++;
        continue;
      }
      if (c6 === "]" && sawStart && !escaping) {
        endPos = i4 + 1;
        break;
      }
      sawStart = true;
      if (c6 === "\\") {
        if (!escaping) {
          escaping = true;
          i4++;
          continue;
        }
      }
      if (c6 === "[" && !escaping) {
        for (const [cls, [unip, u3, neg]] of Object.entries(posixClasses)) {
          if (glob.startsWith(cls, i4)) {
            if (rangeStart) {
              return ["$.", false, glob.length - pos, true];
            }
            i4 += cls.length;
            if (neg)
              negs.push(unip);
            else
              ranges.push(unip);
            uflag = uflag || u3;
            continue WHILE;
          }
        }
      }
      escaping = false;
      if (rangeStart) {
        if (c6 > rangeStart) {
          ranges.push(braceEscape(rangeStart) + "-" + braceEscape(c6));
        } else if (c6 === rangeStart) {
          ranges.push(braceEscape(c6));
        }
        rangeStart = "";
        i4++;
        continue;
      }
      if (glob.startsWith("-]", i4 + 1)) {
        ranges.push(braceEscape(c6 + "-"));
        i4 += 2;
        continue;
      }
      if (glob.startsWith("-", i4 + 1)) {
        rangeStart = c6;
        i4 += 2;
        continue;
      }
      ranges.push(braceEscape(c6));
      i4++;
    }
  if (endPos < i4) {
    return ["", false, 0, false];
  }
  if (!ranges.length && !negs.length) {
    return ["$.", false, glob.length - pos, true];
  }
  if (negs.length === 0 && ranges.length === 1 && /^\\?.$/.test(ranges[0]) && !negate) {
    const r2 = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];
    return [regexpEscape(r2), false, endPos - pos, false];
  }
  const sranges = "[" + (negate ? "^" : "") + rangesToString(ranges) + "]";
  const snegs = "[" + (negate ? "" : "^") + rangesToString(negs) + "]";
  const comb = ranges.length && negs.length ? "(" + sranges + "|" + snegs + ")" : ranges.length ? sranges : snegs;
  return [comb, uflag, endPos - pos, true];
};

// node_modules/minimatch/dist/mjs/escape.js
var escape = (s4, { windowsPathsNoEscape = false } = {}) => {
  return windowsPathsNoEscape ? s4.replace(/[?*()[\]]/g, "[$&]") : s4.replace(/[?*()[\]\\]/g, "\\$&");
};

// node_modules/minimatch/dist/mjs/unescape.js
var unescape = (s4, { windowsPathsNoEscape = false } = {}) => {
  return windowsPathsNoEscape ? s4.replace(/\[([^\/\\])\]/g, "$1") : s4.replace(/((?!\\).|^)\[([^\/\\])\]/g, "$1$2").replace(/\\([^\/])/g, "$1");
};

// node_modules/minimatch/dist/mjs/index.js
var minimatch = (p8, pattern, options = {}) => {
  assertValidPattern(pattern);
  if (!options.nocomment && pattern.charAt(0) === "#") {
    return false;
  }
  return new Minimatch(pattern, options).match(p8);
};
var starDotExtRE = /^\*+([^+@!?\*\[\(]*)$/;
var starDotExtTest = (ext2) => (f3) => !f3.startsWith(".") && f3.endsWith(ext2);
var starDotExtTestDot = (ext2) => (f3) => f3.endsWith(ext2);
var starDotExtTestNocase = (ext2) => {
  ext2 = ext2.toLowerCase();
  return (f3) => !f3.startsWith(".") && f3.toLowerCase().endsWith(ext2);
};
var starDotExtTestNocaseDot = (ext2) => {
  ext2 = ext2.toLowerCase();
  return (f3) => f3.toLowerCase().endsWith(ext2);
};
var starDotStarRE = /^\*+\.\*+$/;
var starDotStarTest = (f3) => !f3.startsWith(".") && f3.includes(".");
var starDotStarTestDot = (f3) => f3 !== "." && f3 !== ".." && f3.includes(".");
var dotStarRE = /^\.\*+$/;
var dotStarTest = (f3) => f3 !== "." && f3 !== ".." && f3.startsWith(".");
var starRE = /^\*+$/;
var starTest = (f3) => f3.length !== 0 && !f3.startsWith(".");
var starTestDot = (f3) => f3.length !== 0 && f3 !== "." && f3 !== "..";
var qmarksRE = /^\?+([^+@!?\*\[\(]*)?$/;
var qmarksTestNocase = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExt([$0]);
  if (!ext2)
    return noext;
  ext2 = ext2.toLowerCase();
  return (f3) => noext(f3) && f3.toLowerCase().endsWith(ext2);
};
var qmarksTestNocaseDot = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExtDot([$0]);
  if (!ext2)
    return noext;
  ext2 = ext2.toLowerCase();
  return (f3) => noext(f3) && f3.toLowerCase().endsWith(ext2);
};
var qmarksTestDot = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExtDot([$0]);
  return !ext2 ? noext : (f3) => noext(f3) && f3.endsWith(ext2);
};
var qmarksTest = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExt([$0]);
  return !ext2 ? noext : (f3) => noext(f3) && f3.endsWith(ext2);
};
var qmarksTestNoExt = ([$0]) => {
  const len = $0.length;
  return (f3) => f3.length === len && !f3.startsWith(".");
};
var qmarksTestNoExtDot = ([$0]) => {
  const len = $0.length;
  return (f3) => f3.length === len && f3 !== "." && f3 !== "..";
};
var defaultPlatform = typeof process === "object" && process ? typeof process.env === "object" && process.env && process.env.__MINIMATCH_TESTING_PLATFORM__ || process.platform : "posix";
var path = {
  win32: { sep: "\\" },
  posix: { sep: "/" }
};
var sep = defaultPlatform === "win32" ? path.win32.sep : path.posix.sep;
minimatch.sep = sep;
var GLOBSTAR = Symbol("globstar **");
minimatch.GLOBSTAR = GLOBSTAR;
var plTypes = {
  "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
  "?": { open: "(?:", close: ")?" },
  "+": { open: "(?:", close: ")+" },
  "*": { open: "(?:", close: ")*" },
  "@": { open: "(?:", close: ")" }
};
var qmark = "[^/]";
var star = qmark + "*?";
var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
var charSet = (s4) => s4.split("").reduce((set, c6) => {
  set[c6] = true;
  return set;
}, {});
var reSpecials = charSet("().*{}+?[]^$\\!");
var addPatternStartSet = charSet("[.(");
var filter = (pattern, options = {}) => (p8) => minimatch(p8, pattern, options);
minimatch.filter = filter;
var ext = (a3, b2 = {}) => Object.assign({}, a3, b2);
var defaults = (def) => {
  if (!def || typeof def !== "object" || !Object.keys(def).length) {
    return minimatch;
  }
  const orig = minimatch;
  const m2 = (p8, pattern, options = {}) => orig(p8, pattern, ext(def, options));
  return Object.assign(m2, {
    Minimatch: class Minimatch extends orig.Minimatch {
      constructor(pattern, options = {}) {
        super(pattern, ext(def, options));
      }
      static defaults(options) {
        return orig.defaults(ext(def, options)).Minimatch;
      }
    },
    unescape: (s4, options = {}) => orig.unescape(s4, ext(def, options)),
    escape: (s4, options = {}) => orig.escape(s4, ext(def, options)),
    filter: (pattern, options = {}) => orig.filter(pattern, ext(def, options)),
    defaults: (options) => orig.defaults(ext(def, options)),
    makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext(def, options)),
    braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext(def, options)),
    match: (list, pattern, options = {}) => orig.match(list, pattern, ext(def, options)),
    sep: orig.sep,
    GLOBSTAR
  });
};
minimatch.defaults = defaults;
var braceExpand = (pattern, options = {}) => {
  assertValidPattern(pattern);
  if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
    return [pattern];
  }
  return (0, import_brace_expansion.default)(pattern);
};
minimatch.braceExpand = braceExpand;
var MAX_PATTERN_LENGTH = 1024 * 64;
var assertValidPattern = (pattern) => {
  if (typeof pattern !== "string") {
    throw new TypeError("invalid pattern");
  }
  if (pattern.length > MAX_PATTERN_LENGTH) {
    throw new TypeError("pattern is too long");
  }
};
var makeRe = (pattern, options = {}) => new Minimatch(pattern, options).makeRe();
minimatch.makeRe = makeRe;
var match = (list, pattern, options = {}) => {
  const mm = new Minimatch(pattern, options);
  list = list.filter((f3) => mm.match(f3));
  if (mm.options.nonull && !list.length) {
    list.push(pattern);
  }
  return list;
};
minimatch.match = match;
var globUnescape = (s4) => s4.replace(/\\(.)/g, "$1");
var globMagic = /[?*]|[+@!]\(.*?\)|\[|\]/;
var regExpEscape = (s4) => s4.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
var Minimatch = class {
  options;
  set;
  pattern;
  windowsPathsNoEscape;
  nonegate;
  negate;
  comment;
  empty;
  preserveMultipleSlashes;
  partial;
  globSet;
  globParts;
  nocase;
  isWindows;
  platform;
  windowsNoMagicRoot;
  regexp;
  constructor(pattern, options = {}) {
    assertValidPattern(pattern);
    options = options || {};
    this.options = options;
    this.pattern = pattern;
    this.platform = options.platform || defaultPlatform;
    this.isWindows = this.platform === "win32";
    this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
    if (this.windowsPathsNoEscape) {
      this.pattern = this.pattern.replace(/\\/g, "/");
    }
    this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;
    this.regexp = null;
    this.negate = false;
    this.nonegate = !!options.nonegate;
    this.comment = false;
    this.empty = false;
    this.partial = !!options.partial;
    this.nocase = !!this.options.nocase;
    this.windowsNoMagicRoot = options.windowsNoMagicRoot !== void 0 ? options.windowsNoMagicRoot : !!(this.isWindows && this.nocase);
    this.globSet = [];
    this.globParts = [];
    this.set = [];
    this.make();
  }
  hasMagic() {
    if (this.options.magicalBraces && this.set.length > 1) {
      return true;
    }
    for (const pattern of this.set) {
      for (const part of pattern) {
        if (typeof part !== "string")
          return true;
      }
    }
    return false;
  }
  debug(..._) {
  }
  make() {
    const pattern = this.pattern;
    const options = this.options;
    if (!options.nocomment && pattern.charAt(0) === "#") {
      this.comment = true;
      return;
    }
    if (!pattern) {
      this.empty = true;
      return;
    }
    this.parseNegate();
    this.globSet = [...new Set(this.braceExpand())];
    if (options.debug) {
      this.debug = (...args) => console.error(...args);
    }
    this.debug(this.pattern, this.globSet);
    const rawGlobParts = this.globSet.map((s4) => this.slashSplit(s4));
    this.globParts = this.preprocess(rawGlobParts);
    this.debug(this.pattern, this.globParts);
    let set = this.globParts.map((s4, _, __) => {
      if (this.isWindows && this.windowsNoMagicRoot) {
        const isUNC = s4[0] === "" && s4[1] === "" && (s4[2] === "?" || !globMagic.test(s4[2])) && !globMagic.test(s4[3]);
        const isDrive = /^[a-z]:/i.test(s4[0]);
        if (isUNC) {
          return [...s4.slice(0, 4), ...s4.slice(4).map((ss) => this.parse(ss))];
        } else if (isDrive) {
          return [s4[0], ...s4.slice(1).map((ss) => this.parse(ss))];
        }
      }
      return s4.map((ss) => this.parse(ss));
    });
    this.debug(this.pattern, set);
    this.set = set.filter((s4) => s4.indexOf(false) === -1);
    if (this.isWindows) {
      for (let i4 = 0; i4 < this.set.length; i4++) {
        const p8 = this.set[i4];
        if (p8[0] === "" && p8[1] === "" && this.globParts[i4][2] === "?" && typeof p8[3] === "string" && /^[a-z]:$/i.test(p8[3])) {
          p8[2] = "?";
        }
      }
    }
    this.debug(this.pattern, this.set);
  }
  // various transforms to equivalent pattern sets that are
  // faster to process in a filesystem walk.  The goal is to
  // eliminate what we can, and push all ** patterns as far
  // to the right as possible, even if it increases the number
  // of patterns that we have to process.
  preprocess(globParts) {
    if (this.options.noglobstar) {
      for (let i4 = 0; i4 < globParts.length; i4++) {
        for (let j = 0; j < globParts[i4].length; j++) {
          if (globParts[i4][j] === "**") {
            globParts[i4][j] = "*";
          }
        }
      }
    }
    const { optimizationLevel = 1 } = this.options;
    if (optimizationLevel >= 2) {
      globParts = this.firstPhasePreProcess(globParts);
      globParts = this.secondPhasePreProcess(globParts);
    } else if (optimizationLevel >= 1) {
      globParts = this.levelOneOptimize(globParts);
    } else {
      globParts = this.adjascentGlobstarOptimize(globParts);
    }
    return globParts;
  }
  // just get rid of adjascent ** portions
  adjascentGlobstarOptimize(globParts) {
    return globParts.map((parts) => {
      let gs = -1;
      while (-1 !== (gs = parts.indexOf("**", gs + 1))) {
        let i4 = gs;
        while (parts[i4 + 1] === "**") {
          i4++;
        }
        if (i4 !== gs) {
          parts.splice(gs, i4 - gs);
        }
      }
      return parts;
    });
  }
  // get rid of adjascent ** and resolve .. portions
  levelOneOptimize(globParts) {
    return globParts.map((parts) => {
      parts = parts.reduce((set, part) => {
        const prev = set[set.length - 1];
        if (part === "**" && prev === "**") {
          return set;
        }
        if (part === "..") {
          if (prev && prev !== ".." && prev !== "." && prev !== "**") {
            set.pop();
            return set;
          }
        }
        set.push(part);
        return set;
      }, []);
      return parts.length === 0 ? [""] : parts;
    });
  }
  levelTwoFileOptimize(parts) {
    if (!Array.isArray(parts)) {
      parts = this.slashSplit(parts);
    }
    let didSomething = false;
    do {
      didSomething = false;
      if (!this.preserveMultipleSlashes) {
        for (let i4 = 1; i4 < parts.length - 1; i4++) {
          const p8 = parts[i4];
          if (i4 === 1 && p8 === "" && parts[0] === "")
            continue;
          if (p8 === "." || p8 === "") {
            didSomething = true;
            parts.splice(i4, 1);
            i4--;
          }
        }
        if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
          didSomething = true;
          parts.pop();
        }
      }
      let dd = 0;
      while (-1 !== (dd = parts.indexOf("..", dd + 1))) {
        const p8 = parts[dd - 1];
        if (p8 && p8 !== "." && p8 !== ".." && p8 !== "**") {
          didSomething = true;
          parts.splice(dd - 1, 2);
          dd -= 2;
        }
      }
    } while (didSomething);
    return parts.length === 0 ? [""] : parts;
  }
  // First phase: single-pattern processing
  // <pre> is 1 or more portions
  // <rest> is 1 or more portions
  // <p> is any portion other than ., .., '', or **
  // <e> is . or ''
  //
  // **/.. is *brutal* for filesystem walking performance, because
  // it effectively resets the recursive walk each time it occurs,
  // and ** cannot be reduced out by a .. pattern part like a regexp
  // or most strings (other than .., ., and '') can be.
  //
  // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}
  // <pre>/<e>/<rest> -> <pre>/<rest>
  // <pre>/<p>/../<rest> -> <pre>/<rest>
  // **/**/<rest> -> **/<rest>
  //
  // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow
  // this WOULD be allowed if ** did follow symlinks, or * didn't
  firstPhasePreProcess(globParts) {
    let didSomething = false;
    do {
      didSomething = false;
      for (let parts of globParts) {
        let gs = -1;
        while (-1 !== (gs = parts.indexOf("**", gs + 1))) {
          let gss = gs;
          while (parts[gss + 1] === "**") {
            gss++;
          }
          if (gss > gs) {
            parts.splice(gs + 1, gss - gs);
          }
          let next = parts[gs + 1];
          const p8 = parts[gs + 2];
          const p22 = parts[gs + 3];
          if (next !== "..")
            continue;
          if (!p8 || p8 === "." || p8 === ".." || !p22 || p22 === "." || p22 === "..") {
            continue;
          }
          didSomething = true;
          parts.splice(gs, 1);
          const other = parts.slice(0);
          other[gs] = "**";
          globParts.push(other);
          gs--;
        }
        if (!this.preserveMultipleSlashes) {
          for (let i4 = 1; i4 < parts.length - 1; i4++) {
            const p8 = parts[i4];
            if (i4 === 1 && p8 === "" && parts[0] === "")
              continue;
            if (p8 === "." || p8 === "") {
              didSomething = true;
              parts.splice(i4, 1);
              i4--;
            }
          }
          if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
            didSomething = true;
            parts.pop();
          }
        }
        let dd = 0;
        while (-1 !== (dd = parts.indexOf("..", dd + 1))) {
          const p8 = parts[dd - 1];
          if (p8 && p8 !== "." && p8 !== ".." && p8 !== "**") {
            didSomething = true;
            const needDot = dd === 1 && parts[dd + 1] === "**";
            const splin = needDot ? ["."] : [];
            parts.splice(dd - 1, 2, ...splin);
            if (parts.length === 0)
              parts.push("");
            dd -= 2;
          }
        }
      }
    } while (didSomething);
    return globParts;
  }
  // second phase: multi-pattern dedupes
  // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>
  // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>
  // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>
  //
  // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>
  // ^-- not valid because ** doens't follow symlinks
  secondPhasePreProcess(globParts) {
    for (let i4 = 0; i4 < globParts.length - 1; i4++) {
      for (let j = i4 + 1; j < globParts.length; j++) {
        const matched = this.partsMatch(globParts[i4], globParts[j], !this.preserveMultipleSlashes);
        if (!matched)
          continue;
        globParts[i4] = matched;
        globParts[j] = [];
      }
    }
    return globParts.filter((gs) => gs.length);
  }
  partsMatch(a3, b2, emptyGSMatch = false) {
    let ai = 0;
    let bi = 0;
    let result = [];
    let which = "";
    while (ai < a3.length && bi < b2.length) {
      if (a3[ai] === b2[bi]) {
        result.push(which === "b" ? b2[bi] : a3[ai]);
        ai++;
        bi++;
      } else if (emptyGSMatch && a3[ai] === "**" && b2[bi] === a3[ai + 1]) {
        result.push(a3[ai]);
        ai++;
      } else if (emptyGSMatch && b2[bi] === "**" && a3[ai] === b2[bi + 1]) {
        result.push(b2[bi]);
        bi++;
      } else if (a3[ai] === "*" && b2[bi] && (this.options.dot || !b2[bi].startsWith(".")) && b2[bi] !== "**") {
        if (which === "b")
          return false;
        which = "a";
        result.push(a3[ai]);
        ai++;
        bi++;
      } else if (b2[bi] === "*" && a3[ai] && (this.options.dot || !a3[ai].startsWith(".")) && a3[ai] !== "**") {
        if (which === "a")
          return false;
        which = "b";
        result.push(b2[bi]);
        ai++;
        bi++;
      } else {
        return false;
      }
    }
    return a3.length === b2.length && result;
  }
  parseNegate() {
    if (this.nonegate)
      return;
    const pattern = this.pattern;
    let negate = false;
    let negateOffset = 0;
    for (let i4 = 0; i4 < pattern.length && pattern.charAt(i4) === "!"; i4++) {
      negate = !negate;
      negateOffset++;
    }
    if (negateOffset)
      this.pattern = pattern.slice(negateOffset);
    this.negate = negate;
  }
  // set partial to true to test if, for example,
  // "/a/b" matches the start of "/*/b/*/d"
  // Partial means, if you run out of file before you run
  // out of pattern, then that's fine, as long as all
  // the parts match.
  matchOne(file, pattern, partial = false) {
    const options = this.options;
    if (this.isWindows) {
      const fileUNC = file[0] === "" && file[1] === "" && file[2] === "?" && typeof file[3] === "string" && /^[a-z]:$/i.test(file[3]);
      const patternUNC = pattern[0] === "" && pattern[1] === "" && pattern[2] === "?" && typeof pattern[3] === "string" && /^[a-z]:$/i.test(pattern[3]);
      if (fileUNC && patternUNC) {
        const fd = file[3];
        const pd = pattern[3];
        if (fd.toLowerCase() === pd.toLowerCase()) {
          file[3] = pd;
        }
      } else if (patternUNC && typeof file[0] === "string") {
        const pd = pattern[3];
        const fd = file[0];
        if (pd.toLowerCase() === fd.toLowerCase()) {
          pattern[3] = fd;
          pattern = pattern.slice(3);
        }
      } else if (fileUNC && typeof pattern[0] === "string") {
        const fd = file[3];
        if (fd.toLowerCase() === pattern[0].toLowerCase()) {
          pattern[0] = fd;
          file = file.slice(3);
        }
      }
    }
    const { optimizationLevel = 1 } = this.options;
    if (optimizationLevel >= 2) {
      file = this.levelTwoFileOptimize(file);
    }
    this.debug("matchOne", this, { file, pattern });
    this.debug("matchOne", file.length, pattern.length);
    for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
      this.debug("matchOne loop");
      var p8 = pattern[pi];
      var f3 = file[fi];
      this.debug(pattern, p8, f3);
      if (p8 === false) {
        return false;
      }
      if (p8 === GLOBSTAR) {
        this.debug("GLOBSTAR", [pattern, p8, f3]);
        var fr = fi;
        var pr = pi + 1;
        if (pr === pl) {
          this.debug("** at the end");
          for (; fi < fl; fi++) {
            if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
              return false;
          }
          return true;
        }
        while (fr < fl) {
          var swallowee = file[fr];
          this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
          if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
            this.debug("globstar found match!", fr, fl, swallowee);
            return true;
          } else {
            if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
              this.debug("dot detected!", file, fr, pattern, pr);
              break;
            }
            this.debug("globstar swallow a segment, and continue");
            fr++;
          }
        }
        if (partial) {
          this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
          if (fr === fl) {
            return true;
          }
        }
        return false;
      }
      let hit;
      if (typeof p8 === "string") {
        hit = f3 === p8;
        this.debug("string match", p8, f3, hit);
      } else {
        hit = p8.test(f3);
        this.debug("pattern match", p8, f3, hit);
      }
      if (!hit)
        return false;
    }
    if (fi === fl && pi === pl) {
      return true;
    } else if (fi === fl) {
      return partial;
    } else if (pi === pl) {
      return fi === fl - 1 && file[fi] === "";
    } else {
      throw new Error("wtf?");
    }
  }
  braceExpand() {
    return braceExpand(this.pattern, this.options);
  }
  parse(pattern) {
    assertValidPattern(pattern);
    const options = this.options;
    if (pattern === "**")
      return GLOBSTAR;
    if (pattern === "")
      return "";
    let m2;
    let fastTest = null;
    if (m2 = pattern.match(starRE)) {
      fastTest = options.dot ? starTestDot : starTest;
    } else if (m2 = pattern.match(starDotExtRE)) {
      fastTest = (options.nocase ? options.dot ? starDotExtTestNocaseDot : starDotExtTestNocase : options.dot ? starDotExtTestDot : starDotExtTest)(m2[1]);
    } else if (m2 = pattern.match(qmarksRE)) {
      fastTest = (options.nocase ? options.dot ? qmarksTestNocaseDot : qmarksTestNocase : options.dot ? qmarksTestDot : qmarksTest)(m2);
    } else if (m2 = pattern.match(starDotStarRE)) {
      fastTest = options.dot ? starDotStarTestDot : starDotStarTest;
    } else if (m2 = pattern.match(dotStarRE)) {
      fastTest = dotStarTest;
    }
    let re = "";
    let hasMagic = false;
    let escaping = false;
    const patternListStack = [];
    const negativeLists = [];
    let stateChar = false;
    let uflag = false;
    let pl;
    let dotTravAllowed = pattern.charAt(0) === ".";
    let dotFileAllowed = options.dot || dotTravAllowed;
    const patternStart = () => dotTravAllowed ? "" : dotFileAllowed ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
    const subPatternStart = (p8) => p8.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
    const clearStateChar = () => {
      if (stateChar) {
        switch (stateChar) {
          case "*":
            re += star;
            hasMagic = true;
            break;
          case "?":
            re += qmark;
            hasMagic = true;
            break;
          default:
            re += "\\" + stateChar;
            break;
        }
        this.debug("clearStateChar %j %j", stateChar, re);
        stateChar = false;
      }
    };
    for (let i4 = 0, c6; i4 < pattern.length && (c6 = pattern.charAt(i4)); i4++) {
      this.debug("%s	%s %s %j", pattern, i4, re, c6);
      if (escaping) {
        if (c6 === "/") {
          return false;
        }
        if (reSpecials[c6]) {
          re += "\\";
        }
        re += c6;
        escaping = false;
        continue;
      }
      switch (c6) {
        case "/": {
          return false;
        }
        case "\\":
          clearStateChar();
          escaping = true;
          continue;
        case "?":
        case "*":
        case "+":
        case "@":
        case "!":
          this.debug("%s	%s %s %j <-- stateChar", pattern, i4, re, c6);
          this.debug("call clearStateChar %j", stateChar);
          clearStateChar();
          stateChar = c6;
          if (options.noext)
            clearStateChar();
          continue;
        case "(": {
          if (!stateChar) {
            re += "\\(";
            continue;
          }
          const plEntry = {
            type: stateChar,
            start: i4 - 1,
            reStart: re.length,
            open: plTypes[stateChar].open,
            close: plTypes[stateChar].close
          };
          this.debug(this.pattern, "	", plEntry);
          patternListStack.push(plEntry);
          re += plEntry.open;
          if (plEntry.start === 0 && plEntry.type !== "!") {
            dotTravAllowed = true;
            re += subPatternStart(pattern.slice(i4 + 1));
          }
          this.debug("plType %j %j", stateChar, re);
          stateChar = false;
          continue;
        }
        case ")": {
          const plEntry = patternListStack[patternListStack.length - 1];
          if (!plEntry) {
            re += "\\)";
            continue;
          }
          patternListStack.pop();
          clearStateChar();
          hasMagic = true;
          pl = plEntry;
          re += pl.close;
          if (pl.type === "!") {
            negativeLists.push(Object.assign(pl, { reEnd: re.length }));
          }
          continue;
        }
        case "|": {
          const plEntry = patternListStack[patternListStack.length - 1];
          if (!plEntry) {
            re += "\\|";
            continue;
          }
          clearStateChar();
          re += "|";
          if (plEntry.start === 0 && plEntry.type !== "!") {
            dotTravAllowed = true;
            re += subPatternStart(pattern.slice(i4 + 1));
          }
          continue;
        }
        case "[":
          clearStateChar();
          const [src, needUflag, consumed, magic] = parseClass(pattern, i4);
          if (consumed) {
            re += src;
            uflag = uflag || needUflag;
            i4 += consumed - 1;
            hasMagic = hasMagic || magic;
          } else {
            re += "\\[";
          }
          continue;
        case "]":
          re += "\\" + c6;
          continue;
        default:
          clearStateChar();
          re += regExpEscape(c6);
          break;
      }
    }
    for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
      let tail;
      tail = re.slice(pl.reStart + pl.open.length);
      this.debug(this.pattern, "setting tail", re, pl);
      tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, (_, $1, $2) => {
        if (!$2) {
          $2 = "\\";
        }
        return $1 + $1 + $2 + "|";
      });
      this.debug("tail=%j\n   %s", tail, tail, pl, re);
      const t4 = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
      hasMagic = true;
      re = re.slice(0, pl.reStart) + t4 + "\\(" + tail;
    }
    clearStateChar();
    if (escaping) {
      re += "\\\\";
    }
    const addPatternStart = addPatternStartSet[re.charAt(0)];
    for (let n3 = negativeLists.length - 1; n3 > -1; n3--) {
      const nl = negativeLists[n3];
      const nlBefore = re.slice(0, nl.reStart);
      const nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
      let nlAfter = re.slice(nl.reEnd);
      const nlLast = re.slice(nl.reEnd - 8, nl.reEnd) + nlAfter;
      const closeParensBefore = nlBefore.split(")").length;
      const openParensBefore = nlBefore.split("(").length - closeParensBefore;
      let cleanAfter = nlAfter;
      for (let i4 = 0; i4 < openParensBefore; i4++) {
        cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
      }
      nlAfter = cleanAfter;
      const dollar = nlAfter === "" ? "(?:$|\\/)" : "";
      re = nlBefore + nlFirst + nlAfter + dollar + nlLast;
    }
    if (re !== "" && hasMagic) {
      re = "(?=.)" + re;
    }
    if (addPatternStart) {
      re = patternStart() + re;
    }
    if (options.nocase && !hasMagic && !options.nocaseMagicOnly) {
      hasMagic = pattern.toUpperCase() !== pattern.toLowerCase();
    }
    if (!hasMagic) {
      return globUnescape(re);
    }
    const flags = (options.nocase ? "i" : "") + (uflag ? "u" : "");
    try {
      const ext2 = fastTest ? {
        _glob: pattern,
        _src: re,
        test: fastTest
      } : {
        _glob: pattern,
        _src: re
      };
      return Object.assign(new RegExp("^" + re + "$", flags), ext2);
    } catch (er) {
      this.debug("invalid regexp", er);
      return new RegExp("$.");
    }
  }
  makeRe() {
    if (this.regexp || this.regexp === false)
      return this.regexp;
    const set = this.set;
    if (!set.length) {
      this.regexp = false;
      return this.regexp;
    }
    const options = this.options;
    const twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
    const flags = options.nocase ? "i" : "";
    let re = set.map((pattern) => {
      const pp = pattern.map((p8) => typeof p8 === "string" ? regExpEscape(p8) : p8 === GLOBSTAR ? GLOBSTAR : p8._src);
      pp.forEach((p8, i4) => {
        const next = pp[i4 + 1];
        const prev = pp[i4 - 1];
        if (p8 !== GLOBSTAR || prev === GLOBSTAR) {
          return;
        }
        if (prev === void 0) {
          if (next !== void 0 && next !== GLOBSTAR) {
            pp[i4 + 1] = "(?:\\/|" + twoStar + "\\/)?" + next;
          } else {
            pp[i4] = twoStar;
          }
        } else if (next === void 0) {
          pp[i4 - 1] = prev + "(?:\\/|" + twoStar + ")?";
        } else if (next !== GLOBSTAR) {
          pp[i4 - 1] = prev + "(?:\\/|\\/" + twoStar + "\\/)" + next;
          pp[i4 + 1] = GLOBSTAR;
        }
      });
      return pp.filter((p8) => p8 !== GLOBSTAR).join("/");
    }).join("|");
    re = "^(?:" + re + ")$";
    if (this.negate)
      re = "^(?!" + re + ").*$";
    try {
      this.regexp = new RegExp(re, flags);
    } catch (ex) {
      this.regexp = false;
    }
    return this.regexp;
  }
  slashSplit(p8) {
    if (this.preserveMultipleSlashes) {
      return p8.split("/");
    } else if (this.isWindows && /^\/\/[^\/]+/.test(p8)) {
      return ["", ...p8.split(/\/+/)];
    } else {
      return p8.split(/\/+/);
    }
  }
  match(f3, partial = this.partial) {
    this.debug("match", f3, this.pattern);
    if (this.comment) {
      return false;
    }
    if (this.empty) {
      return f3 === "";
    }
    if (f3 === "/" && partial) {
      return true;
    }
    const options = this.options;
    if (this.isWindows) {
      f3 = f3.split("\\").join("/");
    }
    const ff = this.slashSplit(f3);
    this.debug(this.pattern, "split", ff);
    const set = this.set;
    this.debug(this.pattern, "set", set);
    let filename = ff[ff.length - 1];
    if (!filename) {
      for (let i4 = ff.length - 2; !filename && i4 >= 0; i4--) {
        filename = ff[i4];
      }
    }
    for (let i4 = 0; i4 < set.length; i4++) {
      const pattern = set[i4];
      let file = ff;
      if (options.matchBase && pattern.length === 1) {
        file = [filename];
      }
      const hit = this.matchOne(file, pattern, partial);
      if (hit) {
        if (options.flipNegate) {
          return true;
        }
        return !this.negate;
      }
    }
    if (options.flipNegate) {
      return false;
    }
    return this.negate;
  }
  static defaults(def) {
    return minimatch.defaults(def).Minimatch;
  }
};
minimatch.Minimatch = Minimatch;
minimatch.escape = escape;
minimatch.unescape = unescape;

// node_modules/@redocly/realm/dist/server/utils/globs.js
var import_is_glob = __toESM(require_is_glob(), 1);
var p5 = (e2, n3) => {
  const r2 = e2.tokens ?? [], o3 = n3.tokens ?? [];
  if (e2.isGlob !== n3.isGlob)
    return e2.isGlob ? n3 : e2;
  if (r2.length !== o3.length)
    return r2.length > o3.length ? e2 : n3;
  for (let t4 = 0; t4 < r2.length; t4++) {
    if (r2[t4].isGlob !== o3[t4].isGlob)
      return r2[t4].isGlob ? n3 : e2;
    if (r2[t4].value !== o3[t4].value)
      return r2[t4].value.length > o3[t4].value.length ? e2 : n3;
  }
  return e2;
};

// node_modules/@redocly/realm/dist/server/utils/rbac.js
var P2 = ["NONE", "READ", "TRIAGE", "WRITE", "MAINTAIN", "ADMIN"];
function rt(t4, e2) {
  const n3 = P2.indexOf(t4.toUpperCase()), r2 = P2.indexOf(e2.toUpperCase());
  return n3 > r2 ? t4 : e2;
}
function p7(t4, e2) {
  if (!t4 || !e2)
    return p;
  const n3 = t4.content;
  if (!n3)
    return p;
  const { slug: r2, fsPath: o3 } = e2[REDOCLY_ROUTE_RBAC] ?? {}, a3 = Object.keys(n3).filter((f3) => r2 && import_picomatch2.default.isMatch(r2, f3) || o3 && import_picomatch2.default.isMatch(o3, f3));
  if (a3.length == 0)
    return p;
  const i4 = a3.map((f3) => import_picomatch2.default.scan(f3, { tokens: true }));
  let c6 = i4[0];
  for (let f3 = 1; f3 < i4.length; f3++)
    c6 = p5(c6, i4[f3]);
  return n3[c6.input];
}
function R3(t4, e2 = {}, n3 = {}, r2 = false) {
  if (t4.slug && typeof t4.slug == "string" && Object.values(t).some((c6) => t4.slug?.startsWith(c6)))
    return true;
  if (r2 && Object.keys(n3).length === 0)
    return !!e2.isAuthenticated;
  const o3 = R(n3, e2.teams || []), s4 = t4[REDOCLY_TEAMS_RBAC] || p7(o3, t4);
  if (Object.keys(s4 || {}).length === 0)
    return false;
  if (s4 === p)
    return true;
  const a3 = (e2?.email ? [...e2?.teams || [], e2?.email] : e2?.teams) || [], i4 = [];
  for (const c6 of a3 ?? [])
    s4[c6] ? i4.push(s4[c6]) : s4["*"] && c6 !== e2?.email && i4.push(s4["*"]);
  return i4.length ? i4.some((c6) => c6.toLowerCase() !== "none") : false;
}
function nt(t4, e2, n3, r2) {
  if (!t4.startsWith(C))
    return true;
  const o3 = t4.replace(new RegExp(`^${C}/`), ""), a3 = o3 === "." ? "" : o3, i4 = { [REDOCLY_ROUTE_RBAC]: { slug: t4, fsPath: a3 }, slug: t4 };
  return R3(i4, r2, e2, n3);
}
function D3(t4, e2, n3 = {}, r2 = false) {
  if (!t4)
    return t4;
  if (Array.isArray(t4))
    return t4.map((o3) => D3(o3, e2, n3, r2)).filter((o3) => o3 !== void 0);
  if (typeof t4 == "object") {
    if (!R3(t4, e2, n3, r2))
      return;
    let o3 = false;
    const s4 = Object.keys(t4).reduce((a3, i4) => {
      if (i4 === REDOCLY_TEAMS_RBAC || i4 === REDOCLY_ROUTE_RBAC)
        return a3;
      const c6 = D3(t4[i4], e2, n3, r2);
      return i4 === "items" && Array.isArray(c6) && c6.length === 0 && t4[i4].length !== 0 ? (o3 = true, a3) : (c6 !== void 0 && (a3[i4] = c6), a3);
    }, {});
    return o3 ? void 0 : s4;
  }
  return t4;
}

export {
  nt,
  D3 as D
};
/*! Bundled license information:

is-extglob/index.js:
  (*!
   * is-extglob <https://github.com/jonschlinkert/is-extglob>
   *
   * Copyright (c) 2014-2016, Jon Schlinkert.
   * Licensed under the MIT License.
   *)

is-glob/index.js:
  (*!
   * is-glob <https://github.com/jonschlinkert/is-glob>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   *)
*/
