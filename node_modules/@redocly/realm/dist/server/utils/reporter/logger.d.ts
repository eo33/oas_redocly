export type LoggerContext = {
    email?: string;
    subject?: string;
    ipAddress?: string;
    userAgent?: string;
    method?: string;
    pathname?: string;
    statusCode?: number;
    teams?: string[];
};
export declare class Logger {
    private context;
    private isProdMode;
    private timers;
    private timeouts;
    disableSticky: boolean;
    constructor(context?: LoggerContext);
    panic(message: string | Error, ...args: any[]): never;
    panicOnContentError(message: string | Error, ...args: any[]): never;
    info(message: string, ...args: any[]): void;
    infoTime(timingId: symbol | string, message: string, ...args: any[]): {
        message: string;
        time_ms: number;
    } | undefined;
    success(message: string, ...args: any[]): void;
    logSticky(id: string, message: string, ...args: any[]): void;
    successTime(timingId: symbol | string, message: string, ...args: any[]): {
        message: string;
        time_ms: number;
    } | undefined;
    warn(message: string, ...args: any[]): void;
    warnProd(message: string, ...args: any[]): void;
    error(message: string, ...args: any[]): void;
    contentError(message: string, ...args: any[]): void;
    verbose(message: string, ...args: any[]): void;
    verboseTime(timingId: symbol | string, message: string, ...args: any[]): {
        message: string;
        time_ms: number;
    } | undefined;
    httpTime(timingId: symbol | string): {
        message: string;
        time_ms: number;
    } | undefined;
    startTiming(label?: string): symbol | string;
    updateContext(context: Partial<LoggerContext>): void;
    clearAllTimeouts(): void;
    private logTiming;
    printSticky(): void;
    clearSticky(): void;
    private log;
    isInteractive({ stream }?: {
        stream?: (NodeJS.WriteStream & {
            fd: 1;
        }) | undefined;
    }): boolean;
    patchConsole(): void;
}
declare const logger: Logger;
export default logger;
//# sourceMappingURL=logger.d.ts.map