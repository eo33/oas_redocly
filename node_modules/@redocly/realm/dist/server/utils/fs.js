import{existsSync as c,readdirSync as m,lstatSync as u,mkdirSync as f,copyFileSync as p,lstat as F}from"fs";import{join as s,extname as S,basename as x,dirname as y,resolve as E}from"path";import{PUBLIC_ASSETS_FOLDER as a}from"../../shared/constants.js";import{withPathPrefix as w}from"../../shared/urls.js";import{shaDirPathShort as D,shaFileForUrl as P}from"./crypto.js";import{reporter as b}from"./reporter/reporter.js";import{slug as v}from"./slugger.js";import N from"./reporter/logger.js";function _(r){if(!c(r))return[];const o=[];return t(r),o;function t(e){try{m(e).forEach(n=>{let i=s(e,n);u(i).isDirectory()?t(i):o.push(i)})}catch(n){N.error(`Error reading all file names in ${e}: `+n.message)}}}function I(r,o,t){const e=E(r,o);if(!c(e))throw new g(`File not found at ${e}`);c(s(t,a))||f(s(t,a),{recursive:!0});const n=S(e),i=[v(x(e,n)),P(e),D(y(o))].join(".").concat(n),l=s(t,a,i),h=s(a,i);try{if(p(e,l),!c(l))throw new Error(`Cannot copy file ${o}`);return w(h)}catch(d){b.panicOnBuild(d.message)}}function $(r,o){let t=[];if(c(r)){if(c(o)||f(o,{recursive:!0}),!u(r).isDirectory())throw new Error(`Source path must be a directory, but ${r} provided`);t=m(r),t.forEach(e=>{const n=s(r,e);if(u(n).isDirectory())$(n,s(o,e));else{const i=s(o,e);p(n,i)}})}}function T(r){return f(y(r),{recursive:!0}),r}async function q(r){return new Promise(o=>{F(r,(t,e)=>{o(t==null&&e.isFile())})})}class g extends Error{constructor(o){super(o),this.name="FileNotFoundError"}}export{g as FileNotFoundError,$ as copyFolderRecursiveSync,I as copyStaticFile,T as ensureDir,q as fileExistsAsync,_ as readFileNames};
