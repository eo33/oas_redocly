import{useMemo as p,useState as H,useCallback as J}from"react";import{useCatalog as U}from"../../../../client/app/hooks";import{usePageSharedData as L}from"../../../../client/providers/page-data/hooks";import{isDefined as G}from"../../../../shared/jsUtils";import{NON_CONFORMANT as v,OTHER_TEAMS_LABEL as K}from"./utils";function j(h,d){return Object.entries(h).find(([g])=>d.startsWith(g))?.[1]}function ee(h){const{catalogConfig:d,scorecardConfig:g,scorecardInfo:c}=h.pageProps,C=L("catalog"),S=C.some(e=>e.metadata?.publishedAt||e.metadata?.createdAt),A=g.teamMetadataProperty?.label||"Team",f=g.teamMetadataProperty?.property||"team",y=g.teamMetadataProperty?.default,T=C.some(e=>e.metadata?.[f]||e.metadata?.owner),k=p(()=>({...d,filters:[{title:"Scorecard level",property:"scorecardLevel",options:[v,...c.levelNames],type:"checkboxes"},S?{title:"Published date",property:"publishedAt",type:"date-range"}:void 0,T&&!d.filters?.find(e=>e.property===f)?{title:A,property:f,type:"select",...y&&{missingCategoryName:y}}:void 0,...d.filters||[]].filter(G)}),[d,T,S,A,y,f,c.levelNames]),N=L("scorecard"),q=C.filter(e=>!!j(N,e.link||"")),{filterTerm:M,setFilterTerm:D,groups:P,filters:E}=U(k,q),u=p(()=>P.flatMap(e=>e.items).map(e=>({api:{...e,publishedAt:e.publishedAt||e.createdAt,team:e[f]||e.owner},scorecard:j(N,e.link)})).filter(e=>e.scorecard),[JSON.stringify(P),N,f]),w=c.levelNames,z=p(()=>{const e={total:u.length,levels:{}};return[v,...w].forEach(r=>{e.levels[r]=u.filter(s=>s.scorecard?.scorecardLevel===r).length}),e},[u,w]),O=p(()=>w.map(e=>{const r={error:new Set,warn:new Set},s={errors:0,warnings:0};for(const t of u){if(!t.scorecard)continue;const o=t.scorecard.levels[e];if(o){s.errors+=o.errors||0,s.warnings+=o.warnings||0;for(const n of o.problems)r[n.severity]?.add(n.ruleId)}}return{name:e,count:s,uniqueCount:{errors:r.error.size,warnings:r.warn.size}}}),[u,w]),R=p(()=>O.reduce((e,r)=>e+r.count.errors+r.count.warnings,0),[O]),V=p(()=>{const e={};for(const r of c.rules)e[r]={count:0,apis:[],ruleId:r,status:0,apisCount:0,warningApisCount:0,errorApisCount:0,teams:{},levels:c.levelNames.reduce((s,t)=>(s[t]={warnings:0,errors:0},s),{})};for(const r of u){if(!r.scorecard)continue;const{scorecard:s,api:t}=r,o=new Set;for(const n of Object.keys(s?.levels||{})){const l=s.levels[n];for(const m of l?.problems||[]){const a=m.ruleId;if(!o.has(a))if(e[a]=e[a]||{count:0,apis:[],ruleId:a,status:0,apisCount:0,levels:{}},e[a].count++,typeof t.team=="string"&&(e[a].teams[t.team]=(e[a].teams[t.team]||0)+1),e[a].levels[n]=e[a].levels[n]||{warnings:0,errors:0},m.severity==="error"?(e[a].levels[n].errors++,e[a].errorApisCount++):(e[a].levels[n].warnings++,e[a].warningApisCount++),!e[a].apis.find(b=>b.link===t.link))e[a].apis.push({...t,count:1,severity:m.severity,problems:[m]});else{const b=e[a].apis.find(_=>_.link===t.link);b&&(b.count++,b.problems.push(m))}}for(const m of l?.problems||[])o.add(m.ruleId)}}for(const r of Object.values(e))r.apisCount=r.apis.length,r.status=r.apisCount>0?1:0,r.warningApisCount=r.apis.filter(s=>s.severity==="warning").length,r.errorApisCount=r.apis.filter(s=>s.severity==="error").length;return Object.values(e).sort((r,s)=>{let t=r.ruleId,o=s.ruleId;return t<o?-1:t>o?1:0})},[u,c.levelNames,c.rules]),[i,B]=H({property:"below",direction:"desc"}),W=J(e=>{i.property===e?B(r=>({...r,direction:r.direction==="asc"?"desc":"asc"})):B({property:e,direction:"asc"})},[i]),{sortedStatsByTeam:x,statsByTeam:I}=p(()=>{const e={},r={};for(const s of u){if(!s.scorecard)continue;const{api:t}=s,o=t.team?String(t.team):y||K;if(!o)continue;e[o]=e[o]||{team:o,below:0,minimum:0,highest:0,levels:{}};const n=r[o]=r[o]||{};for(const l of[v,...c.levelNames]){e[o].levels[l]=e[o].levels[l]||{errors:0,warnings:0,uniqueErrors:0,uniqueWarnings:0,apis:0},n[l]=n[l]||{error:new Set,warn:new Set},e[o].levels[l].errors+=s.scorecard?.levels[l]?.errors||0,e[o].levels[l].warnings+=s.scorecard?.levels[l]?.warnings||0,e[o].levels[l].apis+=s.scorecard.scorecardLevel===l?1:0;for(const m of s.scorecard?.levels[l]?.problems||[])n[l][m.severity]?.add(m.ruleId)}}for(const s of Object.keys(e))for(const t of Object.keys(e[s].levels))e[s].levels[t].uniqueErrors=r[s][t].error.size,e[s].levels[t].uniqueWarnings=r[s][t].warn.size;return{sortedStatsByTeam:Object.values(e).sort((s,t)=>{let o=s[i.property],n=t[i.property];return["team","below","minimum","highest"].includes(i.property)||(o=s.levels[i.property].errors*1e3+s.levels[i.property].warnings,n=t.levels[i.property].errors*1e3+t.levels[i.property].warnings),o<n?i.direction==="asc"?-1:1:o>n?i.direction==="asc"?1:-1:0}),statsByTeam:e}},[u,c.levelNames,i.direction,i.property,y]),F=p(()=>Object.values(I).sort((e,r)=>r.levels[v].apis-e.levels[v].apis).filter(e=>e.levels[v].apis>0),[I]);return{apis:u,summary:z,problemsByStatus:O,totalProblems:R,problemsByRule:V,sortedStatsByTeam:x,handleSortRulesTeams:W,nonConformantByTeam:F,filterTerm:M,setFilterTerm:D,groups:P,filters:E,scorecardInfo:c,catalogConfig:k,hasTeam:T,hasPublishedAt:S,teamLabel:A,teamProperty:f}}export{ee as useData};
