import{writeFileSync as E}from"node:fs";import R from"path";import{SCORECARD_OUTPUT_FILE_NAME as y}from"../../constants.js";import{ensureDir as D,logger as O,readEnvVariable as I}from"../../utils/index.js";import{combineUrls as v}from"../../../shared/urls.js";import{getTemplatePath as L}from"./get-template-path.js";import{getAllRuleNames as T}from"./lint.js";import{getScorecardConfig as P}from"./get-scorecard-config.js";import{mapObject as h}from"../../../shared/jsUtils.js";import{CUSTOM_FIELDS_SERVER_PROPS_GETTER_ID as _}from"../catalog/index.js";import{Feature as b}from"../../entitlements/entitlements.types.js";import{getScorecardSlug as A}from"./shared-utils.js";import{scorecardConfigLoader as F}from"./loaders/scorecard-config.js";import{scorecardLoader as j}from"./loaders/scorecard.js";import{computeScorecard as w}from"./compute-scorecard.js";const U="scorecard";async function X(){let u=null,p=null,S=!1;return{id:"scorecard",requiredEntitlements:[b.Scorecard],loaders:{"scorecard-config":F,scorecard:j},async processContent(r,l){const g=r.createTemplate(U,L("./template/index.js")),c=await l.getConfig(),n=P(c),f=c?.reunite??{},m=c.catalog??{},a=n.levels||[];if(a.length<1)throw Error("Invalid configuration of levels config");u===null&&(u=await w({actions:r,context:l,scorecardConfig:n,reuniteConfig:f}));const{data:{configs:s}}=await l.cache.load("","scorecard-config"),{perLevel:e,all:d}=T(s);p={levelNames:a.map(i=>i.name),rules:d,rulesPerLevel:e};for(const[i,t]of Object.entries(m)){const o=v(t.slug,"scorecard/");r.addRoute({duplicateInAllLocales:!0,slug:o,fsPath:v(t.slug,"scorecard/"),templateId:g,hasClientRoutes:!0,excludeFromSidebar:!0,serverPropsGetterIds:[_],sharedData:[{id:"scorecard",key:"scorecard"},{key:"catalog",id:"catalog-"+i}],getNavText:()=>Promise.resolve(t.title||"API design scorecard"),getStaticData:async()=>({props:{catalogId:i,catalogConfig:{...t,items:void 0},scorecardConfig:n,scorecardInfo:p}})})}},afterRoutesCreated:async(r,{getConfig:l})=>{const g=await l(),c=g.catalog??{},n=P(g);if(Object.keys(c).length){const a={};for(const[s,e]of Object.entries(u||{})){const d=r.getRouteByFsPath(s),i=v(Object.values(c)[0].slug,"scorecard/"),t=r.getRouteByFsPath(s)?.slug;if(t&&(d&&!n.ignoreMetadata&&(d.metadata={...d.metadata,scorecardStatus:e.status,scorecardLevel:e.scorecardLevel,scorecardLevelIdx:e.scorecardLevelIdx,scorecardLevels:h(e.levels,o=>({uniqueErrors:o.uniqueErrors,uniqueWarnings:o.uniqueWarnings})),scoreCardSlug:i+"?api="+encodeURIComponent(t)}),a[t]={...e,levels:h(e.levels,o=>({...o,problems:o.problems.map(C=>({ruleId:C.ruleId,severity:C.severity}))}))},!S)){const o=R.resolve(r.outdir,"_scorecard",A(t));E(D(o),JSON.stringify(e))}}await r.createSharedData("scorecard",a)}const f={};for(const[a,s]of Object.entries(u||{})){const e=r.getRouteByFsPath(a)?.slug;e&&(f[e]=s)}const m=I("REDOCLY_METADATA_OUTPUT_FOLDER");!S&&m&&(O.info("Writing scorecard data..."),E(R.join(m,y),JSON.stringify({scorecardData:f,...p}))),S=!0}}}export{X as scorecardPlugin};
