import{writeFile as v,readFile as y,rm as _,readdir as w}from"node:fs/promises";import D from"fs";import h from"node:path";import{ensureDir as g}from"../../../../utils/index.js";import{SEARCH_INDEX_FIELDS as E,SEARCH_DATA_EXPORT_FOLDER as m,SEARCH_PRODUCT_FIELD as R,SEARCH_VERSION_FIELD as A}from"../../constants.js";import{FlexSearchIndex as C}from"./search-index.js";class V{indexes=new Map;indexSchema;async initIndexSchema(e){this.indexSchema={document:{id:"id",tag:"tags",index:E},worker:!1,tokenize:"forward",context:{depth:2,resolution:9}}}getIndex(e,t){const s=this.indexes.get(t);if(s)return s.find(n=>n.id===e)}createIndex(e,t){let s=this.getIndex(e,t);return s||(s=new C(e,this.indexSchema),this.indexes.set(t,[...this.indexes.get(t)??[],s])),s}getTopFacetField(e){return e?Array.from(e.values()).find(t=>t.isTop)?.field:""}addDocuments(e,t,s){s.length&&this.createIndex(e,t).add(s)}async search(e,t){const{query:s,locale:n,filter:a,loadMore:o,auth:f}=e,r=this.indexes.get(n)??[],l=this.getTopFacetField(t);let c=[],I="",p=["v:default"];if(a)for(const i of a)i.isTop?c=[...c,...i.values]:i.field===R?I=`p:${i.values[0]}`:i.field===A&&i.values.length&&i.values.length===2&&(p=[...p,`v:${i.values[0]}:${i.values[1]}`]);const F={auth:f,query:s,offset:0,topFacetField:l,product:I,versions:p},u=[];let d={facets:{},documents:{}};if(o){const i=this.getIndex(o.groupKey,n);i&&u.push(i.search({...F,offset:o.offset}))}else for(const i of r)c&&c.length?c.includes(i.id)&&u.push(i.search(F)):u.push(i.search(F));return await Promise.all(u).then(i=>{for(const S of i){d.documents={...d.documents,...S.documents};for(const[x,$]of Object.entries(S.facets))d.facets[x]?d.facets[x]=[...d.facets[x],...$]:d.facets[x]=$}}),d}async export(e){D.existsSync(`${e}/${m}`)&&await _(`${e}/${m}`,{recursive:!0});const t=g(h.join(e,m));for(const[s,n]of this.indexes){const a=g(h.join(t,s));for(const o of n){const f=g(h.join(a,`${o.id}.json`)),r={documents:[],index:{}};r.documents=Array.from(o.documents),await o.export((l,c)=>{r.index[l]=c}),await v(f,JSON.stringify(r),"utf-8")}}}async import(e){const t=`${e}/${m}`,s=await w(t);for(const n of s){const a=await w(`${t}/${n}`);for(const o of a){const f=`${t}/${n}/${o}`,r=JSON.parse(await y(f,"utf-8")),l=h.parse(o).name;await this.createIndex(l,n).import(r)}}}countFacets(e,t){const s={};for(const[n,a]of t)s[n]=a.values.map(o=>({value:o,count:0,isCounterVisible:!1}));return s}cleanupFacetValues(e){}}export{V as FlexSearch};
