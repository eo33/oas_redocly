import type { Config, Node, ValidationType } from '@markdoc/markdoc';
import type { MarkdocResolveContext } from './types.js';
import type { Store } from '../../store.js';
import type { LifecycleContext, MarkdownParseInput } from '../types.js';
import type { MarkdocError } from '../../../shared/types';
export type ResolvableType = ValidationType & {
    resolver?: string;
};
export interface MarkdocConfigProps extends Config {
    partials: Record<string, Node>;
    relativePath: string;
    nodes: any;
    tags: any;
}
type ParsedAstChunk = {
    ast: Node;
    rawContent: string;
    resolveErrors: MarkdocError[];
    markdocErrors: MarkdocError[];
    validatedAtRevision: number;
    sharedDataDeps?: Set<string>;
    dynamicMarkdocComponents?: Set<string>;
    relativePath: string;
};
export declare function resolveAndValidateMarkdoc(parsedAstChunk: ParsedAstChunk, markdocOpts: Config | undefined, context: MarkdocResolveContext): Promise<{
    sharedDataDeps: Set<string>;
    dynamicMarkdocComponents: string[];
}>;
export type MarkdocRawContent = {
    relativePath: string;
    content: string;
    contentHash?: string;
    cacheId?: string;
};
export declare function getAst(relativePath: string, rawContent: string): ParsedAstChunk;
export declare function extractMdFirstHeading(relativePath: string, context: LifecycleContext): Promise<string | undefined>;
export declare function validateAllMarkdowns(store: Store, context?: LifecycleContext): Promise<void>;
export type MarkdocDeps = {
    routeSlugs?: string[];
    sharedDataIds?: string[];
};
export declare function parseAndResolveMarkdoc(input: MarkdownParseInput, markdocOpts: Config | undefined, rootContext: MarkdocResolveContext): Promise<import("../../fs/types.js").LoadResult<{
    ast: Node;
    info: {
        sharedDataDeps?: Set<string>;
        dynamicMarkdocComponents?: string[];
    };
}>>;
export {};
//# sourceMappingURL=compiler.d.ts.map