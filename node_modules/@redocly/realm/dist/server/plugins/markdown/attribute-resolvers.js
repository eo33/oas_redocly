import l from"path";import{bundle as W}from"@redocly/openapi-core/lib/bundle.js";import{Config as M}from"@redocly/openapi-core/lib/config/index.js";import{formatBundleFromMarkdocError as T}from"./errors.js";import{OPENAPI_SHARED_DATA_PREFIX as U}from"../openapi-docs/constants.js";import{getInnerText as V,getNodeAttribute as u,setNodeAttributeValue as w}from"../../../shared/markdoc.js";import{isLocalLink as L,normalizeRouteSlug as E,slash as k}from"../../../shared/utils.js";import{withPathPrefix as C}from"../../../shared/urls.js";import{copyStaticFile as A,reporter as B,slug as z}from"../../utils/index.js";import{parseSrcSet as J}from"../../utils/attribute-parser.js";import{OPENAPI_DOCS_TEMPLATE_ID as G}from"../../../shared/constants.js";import{isOpenapiDoc as H}from"../openapi-docs/is-openapi-doc.js";import{optimize as K}from"../../../compiled/svgo/svgo-node.js";import{isMarkdownPage as Y}from"./is-markdown-page.js";import{ExternalResolver as q}from"../../fs/utils/external-ref-resolver.js";import{isL10nPath as D}from"../../fs/utils/is-l10n-path.js";import{getLocaleFromRelativePath as X}from"../../fs/utils/get-locale-from-relative-path.js";import{resolveLinksFromConfig as Q}from"../nav-utils.js";import{parseBaseName as Z}from"../utils.js";class d extends Error{meta;constructor(e,r){super(e),this.meta=r,Object.setPrototypeOf(this,new.target.prototype)}}const $="redocly:::linkOriginal";async function N(t,e,r,{actions:{contentDir:o},context:a}){const s=u(t,e);if(!s)return;const n=s.startsWith("/")?s.slice(1):k(l.relative(o,l.resolve(o,l.dirname(r),s)));if(!await a.fs.exists(n)){B.panicOnBuildContentError(`Code snippet file ${n} does not exist`);return}let i=await a.fs.read(n);const p=u(t,"after"),m=u(t,"before"),f=u(t,"from"),g=u(t,"to"),c=u(t,"prefix")||"",v=f??p,y=g??m,S=p!==null,P=m!==null,b=(typeof v=="number"?Math.max(v||0,1):1)+(S?1:0);let x=(typeof y=="number"?y:1/0)-(P?1:0);if(typeof v=="string"){let h=i.indexOf(v);if(h===-1)throw new d(`Cannot find start text "${v}" in snippet file`,{rawLink:n});for(;i[h]!==`
`&&h>0;)h--;typeof x=="number"&&(x-=i.slice(0,h-1).split(`
`).length),i=i.slice(h+1)}if(typeof y=="string"){let h=i.indexOf(y);if(h===-1)throw new d(`Cannot find end text "${m}" in snippet file`,{rawLink:n});i[h-1]===`
`&&h--,i=i.slice(0,h)}const I=i.split(`
`);if(P)for(;I[I.length-1]==="";)I.pop();t.children=[],t.attributes.rawContent=c+I.slice(b-1,x).join(`
`)}async function _(t,e,r,{actions:o,context:a}){const{contentDir:s,outdir:n,getRouteByFsPath:i,getRouteBySlug:p}=o,m=`${$}:${e}`,f=t[m]||u(t,e);if(t[m]=f,!L(f))return;const[g,c="",v,y]=/^([^\?#]+)?([^#]+)?(.+)?/.exec(f)||[],S=t.type==="image"?"IMAGE":"LINK",P=String(t.attributes.title||t.attributes.alt||V([t])||"");if(l.extname(c)===""){if(c.startsWith("/")){if(!p(E(c)))throw new d(`Route ${c} does not exist`,{rawLink:f,link:c,title:P,brokenLinkType:S});w(t,e,C(c+(v||"")+(y||"")))}if(!f.startsWith("#")&&!c.startsWith("/")&&Y(r)){const R=o.getRouteByFsPath(r)?.slug;if(!R)return;const{isIndexFile:F}=Z(r),O=F?E(l.posix.join(R,c)):E(l.posix.join(R,"../",c));if(!p(O))throw new d(`Route ${c} does not exist`,{rawLink:f,link:O,title:P,brokenLinkType:S});w(t,e,C(O+(v||"")+(y||"")))}return}const x=c.startsWith("/")?c.substring(1):l.posix.join(l.posix.dirname(r),decodeURI(c)),I=c.startsWith("/")?l.posix.join("static",c.substring(1)):"";if(!await a.fs.exists(x)&&!o.getRouteByFsPath(x)&&!await a.fs.exists(I))throw w(t,e,"#"),new d(`File ${x} does not exist`,{rawLink:f,link:x,title:P,brokenLinkType:S});const h=i(x);if(h)w(t,e,C((h.templateId===G?h.baseSlug:h.slug)+(y||"")));else if(await a.fs.exists(x)){const R=await a.fs.getFileInfo(x);if(!R||R.isVirtual)return;const F=A(s,R.realRelativePath,n);w(t,e,F)}}async function tt(t,e,r,{actions:{contentDir:o,outdir:a}}){const s=u(t,"attrs")?.[e];if(!s)return;const n=`${$}:attrs:${e}`,i=t[n]||s;t[n]=i;const p=m=>{const f=l.resolve(o,m);return A(o,f,a)};if(e==="src"){if(!L(i))return;const m=p(i);t.attributes.attrs[e]=m}if(e==="srcSet"){const f=s.split(",").map(g=>g.trim()).map(g=>{const[c,v]=g.split(" ").map(S=>S.trim());return L(c)?`${p(c)} ${v||""}`:g});t.attributes.attrs[e]=f.join(", ")}}async function et(t,e,r,{actions:{contentDir:o,outdir:a}}){if(u(t,e)){const n=`${$}:${e}`,i=t[n]||u(t,e);if(t[n]=i,!L(i))return;const p=A(o,l.resolve(o,r,i),a);w(t,e,p);return}}async function it(t,e,r,{actions:{contentDir:o,outdir:a}}){if(u(t,e)){const n=`${$}:${e}`,i=t[n]||u(t,e);if(t[n]=i,!i)return;const p=J(i),m=[];p.forEach((f,g)=>{const c=L(f)?A(o,l.resolve(o,r,f),a):f;m.push(`${c} ${g}`)}),m.length&&w(t,e,m.join(", "))}}async function st(t,e,r,{context:o}){const a=`${$}:${e}`;let s=t[a]||u(t,e);if(s||await H(r,o)&&(s=l.basename(r)),t[a]=s,!s)return;const n=l.posix.join(l.posix.dirname(r),s),i=U+n;if(w(t,e,i),!await o.fs.exists(n))throw new d(`Definition file ${n} does not exist`,{rawLink:n});if(await o.isPathIgnored(n))throw new d(`Definition file ${n} is ignored in config`,{rawLink:n});return{sharedDataId:i}}async function nt(t,e,r,{context:o}){const a=u(t,e);if(a){const s=l.posix.join(l.posix.dirname(r),a);if(!await o.fs.exists(s))throw new d(`Schema file ${s} does not exist`,{rawLink:s});const n=(await o.cache.load(s,"yaml")).data;w(t,e+"Resolved",n)}}async function ot(t,e,r,o){const a=u(t,e);if(!a)return;const s=o.actions.contentDir,n=`${$}:${e}`,i=t[n]||a;t[n]=i;const p=D(r)?X(r):void 0,m=o.context.fs,f=p&&!D(i.slice(1))?`${m.localizationFolder}/${p}/`:"",g=i.startsWith("/")?f+i.slice(1):k(l.relative(s,l.resolve(s,l.dirname(r),i)));w(t,e,g)}async function rt(t,e,r,{context:o,actions:a}){const s=u(t,e),n=a.contentDir;if(s){const i=s.startsWith("/")?s.slice(1):k(l.relative(n,l.resolve(n,l.dirname(r),s)));if(!await o.fs.exists(i))throw new d(`File ${i} does not exist`,i);let p=await o.fs.read(i);w(t,e+"RawContent",p)}}async function j(t,e,r,{context:o,actions:a}){const s=u(t,e),n=a.contentDir;if(s){const i=s.startsWith("/")?s.slice(1):k(l.relative(n,l.resolve(n,l.dirname(r),s)));if(!await o.fs.exists(i))throw new d(`File ${i} does not exist`,{rawLink:s});let p=K(await o.fs.read(i),{plugins:[{name:"prefixIds",params:{prefix:z(i).replaceAll(/[\/\.]/g,"-")}}]}).data;w(t,e+"RawContent",p)}}async function at(t,e,r,{context:o,actions:a}){const s=u(t,e),n=a.contentDir;if(typeof s!="object"||!s)return;const i=l.resolve(n,r),m={config:new M({styleguide:{},apis:{}}),base:l.dirname(i),doc:{source:{absoluteRef:i},parsed:JSON.parse(JSON.stringify({openapi:"3.1.0",components:{schemas:{__root:s}}}))},externalRefResolver:new q(o.fs)},{bundle:{parsed:f},problems:g}=await W(m);w(t,e+"Resolved",f);const c=g[0];if(!c)return{};const v=T(c,r,n);throw w(t,e+"ResolvedErrors",[v]),new d(v,{rawLink:""})}async function lt(t,e,r,{context:o,actions:a}){const s=`${$}:${e}`,n=t[s]||u(t,e);t[s]=n;const i=await Q(n,l.dirname(l.resolve(a.contentDir,r)),a,o,{navFile:r});w(t,e,i)}async function ct(t,e,r,{context:o,actions:a}){const s=u(t,e);s&&(s.endsWith(".svg")?await j(t,e,r,{context:o,actions:a}):await _(t,e,r,{context:o,actions:a}))}const Ft={openapiRef:st,jsonSchemaRef:at,parsedYaml:nt,rawContent:rt,svgContent:j,relativePath:ot,link:_,codeSnippetFile:N,htmlSourceAttribute:tt,imageSrc:et,imageSrcSet:it,navLinks:lt,inlineSvgOrImageLink:ct};export{d as MdResolveError,Ft as attributeResolvers,N as resolveCodeSnippetFromFile,tt as resolveHTMLSourceAttribute,et as resolveImageSrc,it as resolveImageSrcSet,ct as resolveInlineSvgOrImageLink,at as resolveJsonSchemaRef,_ as resolveLink,lt as resolveNavLinks,nt as resolveParsedYaml,rt as resolveRawContent,j as resolveSvgContent};
