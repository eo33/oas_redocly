import u from"@markdoc/markdoc";import{formatMarkdocError as D}from"./errors.js";import{logger as p,reporter as R,sha1 as E}from"../../utils/index.js";import{extractFirstHeading as I,visit as S}from"./markdoc/plugins/utils.js";import{MdResolveError as T,attributeResolvers as y}from"./attribute-resolvers.js";import{processHtmlTokens as z}from"./html/process-html-tokens.js";import{resolveRawPartials as F}from"./markdoc/resolve-raw-partials.js";async function H(a,o,t){const{actions:s}=t,c=new Set,d=new Set,{relativePath:m,resolveErrors:l}=a,f=[];return a.resolveErrors.length=0,S(a.ast,e=>{try{const r=h();f.push(r.then(i=>{i?.sharedDataIds&&i.sharedDataIds.forEach(k=>c.add(k))}).catch(n))}catch(r){n(r)}async function h(){const r=[];switch(e.type){case"link":case"image":await y.link(e,e.type==="link"?"href":"src",m,t);break;case"tag":if(!e.tag)break;const i=o?.tags?.[e.tag];if(!i||(i.dynamicComponentLib&&d.add(i.dynamicComponentLib),!i.attributes))break;for(const[v,w]of Object.entries(i.attributes)){const g=w.type;if(g&&(g.resolver||w.resolver)){const P=y[g.resolver||w.resolver],b=await P?.(e,v,m,t);b?.sharedDataId&&r.push(b.sharedDataId)}}const k=e.attributes?.attrs;if(k&&e.tag==="html")for(const v of Object.keys(k))(v==="src"||v==="srcSet")&&await y.htmlSourceAttribute(e,v,m,t);break}return{sharedDataIds:r}}function n(r){if(!(r instanceof T)){R.panicOnBuild(r.message);return}l.push(D({type:"resolve_link",meta:{...r.meta,link:r.meta.link??r.meta.rawLink},lines:e.lines,location:e.location,error:{id:"",level:"error",message:r.message,location:e.location}},a.relativePath,a.rawContent))}}),await Promise.all(f),a.sharedDataDeps=c,a.dynamicMarkdocComponents=d,a.validatedAtRevision<s.buildRevision&&(a.markdocErrors=u.validate(a.ast,o).map(e=>D(e,m,a.rawContent)),a.validatedAtRevision=s.buildRevision),{sharedDataDeps:a.sharedDataDeps,dynamicMarkdocComponents:Array.from(a.dynamicMarkdocComponents?.values()??[])}}const M=new u.Tokenizer({html:!0,allowIndentation:!0,allowComments:!0});M.parser.block.ruler.getRules("reference").length=0;function L(a,o){const t=M.tokenize(o),s=z(t);return{ast:u.parse(s,a),rawContent:o,resolveErrors:[],markdocErrors:[],relativePath:a,sharedDataDeps:void 0,validatedAtRevision:-1}}async function q(a,o){const{data:t}=await o.cache.load(a,"markdown-ast");return I(t.ast)}async function G(a,o){R.clearMarkdocProblems();const t=a.getAllRoutes();let s=0;for(const c of t)await a.resolveRouteStaticData(c,o,!0),s++,p.isInteractive()&&s%100===0&&p.logSticky("validate",`  \u{1F50D} Status: validating markdoc (${s}/${t.length})`)}async function J(a,o,t){const s=a.content?E(a.content):"";return await t.context.cache.load(a.cacheId||a.relativePath,{loader:d,name:"markdown-inline-parser"},[s,String(t.actions.buildRevision)]);async function d(m,l,f){let e;if(a.content){const n=a.content?a.content:await l.fs.read(a.relativePath),r=await l.getConfig(),i=await F(n,a.relativePath,r.markdown?.partialsFolders,l);e=L(a.relativePath,i)}else e=(await l.cache.load(a.relativePath,"markdown-ast")).data;let h={};if(t.actions.buildRevision!==0&&(h=await H(e,o,t)),!a.isVirtual){for(const n of e.markdocErrors)f(n);for(const n of e.resolveErrors)f(n)}return{ast:e.ast,info:h}}}export{q as extractMdFirstHeading,L as getAst,J as parseAndResolveMarkdoc,H as resolveAndValidateMarkdoc,G as validateAllMarkdowns};
