import{unique as S,isDefined as h}from"../../../../shared/jsUtils.js";import{addOrgToId as E,joinOrgsInIds as $,parseCombinedId as w}from"../utils.js";import{logger as C}from"../../../utils/index.js";class B{adapters;adapterId="apigee-combined";constructor(e){this.adapters=e}async getApps(e){const a=(await Promise.all(this.adapters.map(t=>t.getApps(e)))).flatMap(t=>t.data),r={};for(const t of a)r[t.id]=s(t,r[t.id]);const i=Object.values(r);return{data:i.slice(0,e?.limit||i.length),total:i.length};function s(t,d){return{...t,...d,attributes:{...t.attributes,...d?.attributes},scopes:[...t.scopes||[],...d?.scopes||[]]}}}async getApp(e){const a=(await Promise.all(this.adapters.map(async s=>{try{const t=await s.getApp(e);return{...t,credentials:t.credentials?.map(d=>({...d,stage:s.stage,apiProductsStatus:d.apiProductsStatus.map(u=>({...u,id:E(u.id,s.adapterId)}))}))||[],_adapterIds:[s.adapterId]}}catch(t){if(t.status===404||t.message.includes("does not exist"))return;throw t}}))).filter(h);let r=a[0];for(const s of a.slice(1))r=i(s,r);return r;function i(s,t){return{...s,...t,attributes:{...s.attributes,...t?.attributes},_adapterIds:S([...s._adapterIds||[],...t?._adapterIds||[]]),scopes:[...s.scopes||[],...t?.scopes||[]],credentials:N(s.credentials,t?.credentials)}}}async getApiProducts(e){const a=(await Promise.all(this.adapters.map(async t=>{const d=await t.getApiProducts(e);return{...d,data:d.data.map(u=>({...u,id:E(u.id,t.adapterId)}))}}))).flatMap(t=>t.data),r={};for(const t of a){const{id:d}=w(t.id);r[d]=s(t,r[d])}const i=Object.values(r);return{data:i.slice(0,e?.limit||i.length),total:i.length};function s(t,d){return{...t,...d,id:$(t.id,d?.id),attributes:{...t.attributes,...d?.attributes},scopes:S([...t.scopes||[],...d?.scopes||[]])}}}async createApp(e){const a=e.apiProductIds?.map(c=>w(c))||[],r=new Set(a.map(({adapterIds:c})=>c).flat()),i=this.adapters.filter(c=>r.has(c.adapterId)),s=i.filter(c=>c.stage==="production"),t=i.filter(c=>c.stage!=="production");return(await Promise.all([u(s,"production"),u(t,"non-production")])).flat().filter(h)[0];async function u(c,A){if(c.length===0)return;const[I,...o]=c,n=await I.createApp(P(e,I)),p={...e,credentials:e.credentials||n.credentials};return C.info(`Created first app for ${A}`),await Promise.all(o.map(l=>l.createApp(P(p,l)))),C.info(`Created apps for ${A}`),n}function P(c,A){const I=c.apiProductIds?.map(o=>{const{id:n,adapterIds:p}=w(o);if(p.includes(A.adapterId))return n}).filter(h)||[];return{...c,apiProductIds:I}}}async getApiAccessStatus(e,a){const r=await Promise.all(this.adapters.map(async t=>{try{return await t.getApiAccessStatus(e,a)}catch(d){const u=d.message.toLowerCase();if(u.includes("does not exist")||u.includes("not found"))return{status:"NONE"};throw d}})),i=r.find(t=>t.status==="ACCEPTED");if(i)return i;const s=r.find(t=>t.status==="PENDING");return s||{status:"NONE"}}async getAppLogDetails(e,a){const r=(await Promise.all(this.adapters.map(async i=>{try{return await i.getAppLogDetails(e,a)}catch(s){if(s.message.includes("does not exist"))return;throw s}}))).filter(h);if(r.length>0)return r[0];throw new Error("Not found")}async getAppLogs(e,a){const r=(await Promise.all(this.adapters.map(async i=>{try{return await i.getAppLogs(e,a)}catch(s){if(s.message.includes("does not exist"))return;throw s}}))).filter(h);return r.length>0?r[0]:{data:[],total:0}}async createCredential(e,a){const r=a.apiProductIds?.map(n=>w(n))||[],i=new Set(r.map(({adapterIds:n})=>n).flat()),s=this.adapters.filter(n=>i.has(n.adapterId)),t=s.filter(n=>n.stage==="production"),d=s.filter(n=>n.stage!=="production"),u=await this.getApp(e),P=u._adapterIds||[];return(await Promise.all([A(t,"production"),A(d,"non-production")])).flat()[0];async function A(n,p){if(n.length===0)return;const l=n.find(b=>P.includes(b.adapterId))||n[0],f=n.filter(b=>b!==l);let m=await I(l,a);if(!m)throw new Error("Failed to create credential");const y={...a,clientId:m.clientId,clientSecret:m.clientSecret};return C.info(`Created first credential for ${p}`),await Promise.all(f.map(async b=>await I(b,y))),C.info(`Created rest of the credentials for ${p}`),m}async function I(n,p){if(!P.includes(n.adapterId)){const l=o(p,n);return(await n.createApp({...u,apiProductIds:l.apiProductIds,credentials:p.clientId?[l]:void 0}))?.credentials?.[0]}return n.createCredential(e,o(p,n))}function o(n,p){const l=n.apiProductIds?.map(f=>{const{id:m,adapterIds:y}=w(f);if(y.includes(p.adapterId))return m}).filter(h)||[];return{...n,apiProductIds:l}}}async updateCredential(e,a,r){const i=this.adapters,s=i.filter(o=>o.stage==="production"),t=i.filter(o=>o.stage!=="production"),d=await this.getApp(e),u=d._adapterIds||[],P=d.credentials.find(o=>o.id===a);if(!P)throw new Error("Credential not found");return await(P.stage==="production"?A(s,"production"):A(t,"non-production"));async function A(o,n){if(o.length===0)return;const p=(await Promise.all(o.map(async f=>{const m=I(r,f);if(!u.includes(f.adapterId))return m.apiProductIds.length?(C.info(`Creating app for ${f.adapterId} for ${n}`),(await f.createApp({...d,apiProductIds:m.apiProductIds,credentials:[m]}))?.credentials?.[0]):void 0;try{return C.info(`Updating existing credential for ${f.adapterId} for ${n}`),f.updateCredential(e,a,m)}catch(y){if(y.status!==404)throw y}}))).filter(h);let l=p[0];for(const f of p.slice(1))l=v(l,f);return l}function I(o,n){const p=S(o.apiProductIds?.map(l=>{const{id:f,adapterIds:m}=w(l);if(m.includes(n.adapterId))return f}).filter(h)||[]);return{...o,apiProductIds:p}}}async deleteCredential(e,a){const r=this.adapters,i=(await Promise.all(r.map(async t=>{try{return await t.deleteCredential(e,a)}catch(d){if(d.status===404||d.message.match(/invalid consumer key/i))return;throw d}}))).filter(h);let s=i[0];for(const t of i.slice(1))s=v(s,t);return s}async deleteApp(e){const a=this.adapters;await Promise.all(a.map(r=>r.deleteApp(e)))}async updateApp(e,a){const r=this.adapters;return(await Promise.all(r.map(s=>s.updateApp(e,a)))).filter(Boolean)[0]}}function x(g){const e={};for(const a of g){const{id:r}=w(a.id);e[r]={...a,...e[a.id],status:O(a.status,e[a.id]?.status),id:r}}return Object.values(e)}function O(g,e){return g==="revoked"||e==="revoked"?"revoked":g==="pending"||e==="pending"?"pending":"approved"}function N(g,e){const a={};for(const r of[...g,...e||[]]){const{id:i}=w(r.id);a[i]=v(r,a[i])}return Object.values(a)}function v(g,e){return{...g,...e,status:O(g.status,e?.status),apiProductsStatus:x([...g.apiProductsStatus||[],...e?.apiProductsStatus||[]])}}export{B as CombineAdapter};
