import*as s from"path";import{convertSwagger2OpenAPI as q}from"@redocly/openapi-docs/lib/utils/loadAndBundleSpec.js";import{bundle as K}from"@redocly/openapi-core/lib/bundle.js";import{getTotals as Q}from"@redocly/openapi-core/lib/format/format.js";import{createConfig as W}from"@redocly/openapi-core/lib/config/load.js";import C from"@redocly/openapi-docs";import{logger as v,reporter as I}from"../../utils/index.js";import{CONFIG_FILE_NAME as A}from"../../constants.js";import{pluralize as D}from"../../../shared/utils.js";import{injectDecoratorIntoConfig as X}from"./decorators.js";import{getAllApiConfigsByPath as Y}from"../get-api-config.js";import{deepMerge as F}from"../../../shared/jsUtils.js";import{normalizeFeedbackOptions as Z}from"./utils.js";import{combineUrls as j}from"../../../shared/urls.js";import{replaceFileExtension as B}from"./store-definition-bundles.js";import{PUBLIC_API_DEFINITIONS_FOLDER as N}from"../../../shared/constants.js";import{ExternalResolver as oo}from"../../fs/utils/external-ref-resolver.js";async function yo(o,{fs:t,cache:u,getConfig:p,isPathIgnored:g}){if(s.posix.basename(o)===A)return[];let c;try{c=(await u.load(o,"yaml")).data}catch{return[]}if(!c?.openapi&&!c?.swagger)return v.verbose(`${o} file is not definition. Skipping`),[];const f=await p("."),d=await t.getFileInfo(o),n=await p(s.posix.dirname(o)),l=Y(n?.apis,o,n.configPath),$=[],_=await g(o);for(const a of l){if(!a.output&&_)continue;const i=F(n,{rbac:void 0},a);if(i.decorators&&typeof i.decorators!="object"){I.panicOnBuildContentError(`'decorators' must be an object at redocly.yaml, got '${typeof i.decorators}'`);continue}if(i.plugins&&!Array.isArray(i.plugins)){I.panicOnBuildContentError(`'plugins' must be an array at redocly.yaml, got '${typeof i.plugins}'`);continue}const L=n.configPath?s.posix.dirname(n.configPath):".",r=a.output?s.posix.join(L,a.output):o;d&&a.output&&!await t.exists(r)&&t.addVirtualFile(r,d);const x=[],z=s.resolve(t.cwd,n.realConfigPath||A),k=new oo(t),U=await W(X(i,r,x),{configPath:z,externalRefResolver:k}),P=s.resolve(t.cwd,o),V={config:U,base:s.dirname(P),doc:{source:{absoluteRef:P},parsed:JSON.parse(JSON.stringify(c))},externalRefResolver:k},{bundle:{parsed:w},problems:R}=await K(V),e=Q(R);let E=[e.errors&&`${e.errors} ${D(e.errors,"error","errors")}`,e.warnings&&`${e.warnings} ${D(e.warnings,"warning","warnings")}`,e.ignored&&`${e.ignored} ignored`].filter(Boolean).join(", ");if(e.errors){const m=R.find(H=>H.severity==="error");throw new Error(`${E} while bundling %rp definition.

${m?.message} at ${m?.location?.[0].pointer}

`)}e.warnings&&v.warn(`${E} while bundling %rp definition`,r);const b=no(w.swagger!==void 0?await q(w):w,n.metadata),h=F(f.openapi||{},n.openapi||{},a.openapi||a?.theme?.openapi||{}),M=b["x-feedback"]||h.feedback||n.feedback,S={...h,feedback:Z(M),hideSidebar:!0,disableRouter:!0,mockServer:i?.mockServer||f?.mockServer,downloadUrls:h.downloadUrls||[{url:j(N,`${B(r,".json")}?download`)},{url:j(N,`${B(r,".yaml")}?download`)}]},y=C.normalizeOptions(S);let O;try{O=new C.OpenAPIParser(b,void 0,y)}catch(m){I.panicOnBuild(m);continue}const{contentItems:T,flatItems:J}=C.buildContentItems(O,y),G={definition:b,config:i,relativePath:r,realRelativePath:d?.realRelativePath||r,customOutputRelativeFile:a.output&&r,markdocChunks:x,contentItems:T,flatItems:J,options:y,rawOptions:S,parser:O};$.push(G)}return $}async function Oo(o,t){const{fs:u,cache:p,getConfig:g}=t,c=[];for(const f of await u.scan(/(\.ya?ml|\.json)$/)){if(!await g(s.posix.dirname(f.relativePath)))continue;const n=await p.load(f.relativePath,"load-oas");n.data&&n.data.length&&c.push(...n.data.map(l=>({...l,isVirtual:f.isVirtual||l.isVirtual,hash:n.compoundHash})))}return c}function no(o,t){return t?{...o,info:{...o.info,"x-metadata":{...o.info["x-metadata"],...t}}}:o}export{yo as definitionLoader,Oo as definitionsLoader};
