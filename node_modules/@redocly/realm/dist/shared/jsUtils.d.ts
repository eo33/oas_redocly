export declare function mapObject<T, P>(obj: Record<string, T>, fn: (v: T, k: string) => P): Record<string, P>;
export declare function mapObjectAsync<T, P>(obj: Record<string, T>, fn: (v: T, k: string) => Promise<P>): Promise<Record<string, P>>;
type ItemWithNestedProps = {
    items?: ItemWithNestedProps[];
    [key: string]: any;
};
/**
 * Only works when items are nested in 'items' prop. Make generic if needed
 * @param list input list to collect the prop from
 * @param propName name of the prop to collect
 * @param res Resulting array
 * @returns Array of collected prop values
 */
export declare function collectPropValueDeep<T>(list: ItemWithNestedProps[], propName: string, res?: T[]): T[];
/**
 * Inspired by https://davidwalsh.name/javascript-debounce-function
 */
export declare function debounce<Args extends any[], F extends (...args: Args) => any>(func: F, wait?: number, immediate?: boolean): (this: ThisParameterType<F>, ...args: Args & Parameters<F>) => void;
export declare function memoize<F extends (...args: any[]) => any>(func: F, resolver?: (...args: Parameters<F>) => unknown): F;
export declare function isFunction<T>(value: any): value is (...args: any[]) => T;
export declare function mapToObject<T>(map: Pick<Map<string, T>, 'entries'>): Record<string, T>;
export declare function isBrowser(): boolean;
export declare function compareURIs(entityIdA: string, entityIdB: string): boolean;
export declare function isDefined<T>(value: T | undefined | null): value is T;
type TUnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never;
export declare function isObject(obj: unknown): obj is object;
export declare function deepMerge<T extends object[]>(...objects: T): TUnionToIntersection<T[number]>;
type ObjectOrArray = Record<string, unknown> | unknown[];
export declare function removeDeepProperty(obj: ObjectOrArray | unknown, [field, ...path]: string[]): void;
export declare function findInIterable<T>(iter: Iterable<T>, predicate: (item: T) => boolean | undefined): T | undefined;
export declare function unique<T>(array: T[], predicate?: (item: T) => unknown): T[];
export declare function findDeepFirst<T extends {
    items?: T[];
}>(list: T[], cb: (item: T) => boolean): T | undefined;
export declare function partition<T>(list: T[], predicate: (item: T) => string | undefined): T[][];
export declare function ensureArray<T>(maybeArray: T | T[]): T[];
/**
 * Splits an array using a provided predicate.
 * Returns two arrays as a tuple. First array contains all values for which predicate returned true.
 * Second array contains all values for which predicate returned false.
 * @param inputArray
 */
export declare function splitArrayAsync<T>(inputArray: T[], predicate: (arrayItem: T) => boolean | Promise<boolean>): Promise<[T[], T[]]>;
/**
 * Sorts object keys in alphabetical order.
 * Can be used for serialization.
 * @param input
 * @returns
 */
export declare function sortObjectKeys(input: Record<string, unknown>): {
    [k: string]: unknown;
};
/**
 * Based on https://stackoverflow.com/questions/18749591/encode-html-entities-in-javascript/23834738#23834738
 */
export declare function encodeHtmlEntities(input: string): string;
export declare function toStringIfDefined(value: unknown): string | undefined;
export {};
//# sourceMappingURL=jsUtils.d.ts.map