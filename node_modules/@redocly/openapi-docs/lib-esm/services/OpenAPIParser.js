var __rest=this&&this.__rest||function(e,t){var i={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(i[r]=e[r]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var n=0;for(r=Object.getOwnPropertySymbols(e);n<r.length;n++)t.indexOf(r[n])<0&&Object.prototype.propertyIsEnumerable.call(e,r[n])&&(i[r[n]]=e[r[n]])}return i};import{IS_BROWSER,isObject,isString,isUndefined}from"@redocly/theme";import{tryDecodeURIComponent,getDefinitionName}from"../utils";import{JsonPointer}from"../utils/JsonPointer";import{normalizeOptions}from"./config-options/normalizeOptions";export function pushRef(e,t){return t&&e[e.length-1]!==t?[...e,t]:e}export function concatRefStacks(e,t){return t?e.concat(t):e}export class OpenAPIParser{constructor(e,t,i=normalizeOptions({})){Object.defineProperty(this,"options",{enumerable:!0,configurable:!0,writable:!0,value:i}),Object.defineProperty(this,"definitionUrl",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"definition",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"allowMergeRefs",{enumerable:!0,configurable:!0,writable:!0,value:!1}),Object.defineProperty(this,"byRef",{enumerable:!0,configurable:!0,writable:!0,value:e=>{let t;if(this.definition){"#"!==e.charAt(0)&&(e="#"+e),e=tryDecodeURIComponent(e);try{t=JsonPointer.get(this.definition,e)}catch(e){}return t||{}}}}),this.definition=Object.assign({},e),this.validate(e),this.definition=e,this.allowMergeRefs=e.openapi.startsWith("3.1");const r=IS_BROWSER?window.location.href:"";isString(t)&&(this.definitionUrl=new URL(t,r).href)}validate(e){if(isUndefined(e.openapi))throw new Error("Document must be valid OpenAPI 3.0.0 definition")}isRef(e){return!!e&&(void 0!==e.$ref&&null!==e.$ref)}deref(e,t=[],i=!1){const r=null==e?void 0:e["x-refsStack"];if((t=concatRefStacks(t,r)).length>100)return{resolved:Object.assign({},e,{"x-complex":!0}),refsStack:t};if(this.isRef(e)){const r=getDefinitionName(e.$ref);if(r&&this.options.ignoreNamedSchemas.has(r))return{resolved:{type:"object",title:r},refsStack:t};let n=this.byRef(e.$ref);if(!n)throw new Error(`Failed to resolve $ref "${e.$ref}"`);if(t.includes(e.$ref))n=Object.assign({},n,{"x-circular-ref":!0});else if(this.isRef(n)){n=this.deref(n,t,i).resolved}return this.allowMergeRefs&&(n=this.mergeRefs(e,n,i)),{resolved:n,refsStack:pushRef(t,e.$ref)}}return{resolved:e,refsStack:concatRefStacks(t,r)}}mergeRefs(e,t,i){const{$ref:r}=e,n=__rest(e,["$ref"]),s=Object.keys(n);if(0===s.length)return t;if(i&&s.some((e=>!["description","title","externalDocs","x-refsStack","x-parentRefs","readOnly","writeOnly","x-complex"].includes(e)))){const e=n,{description:i,title:r,readOnly:s,writeOnly:o}=e;return{allOf:[{description:i,title:r,readOnly:s,writeOnly:o},t,__rest(e,["description","title","readOnly","writeOnly"])]}}return Object.assign(Object.assign({},t),n)}mergeAllOf(e,t,i,r=""){var n;if(e["x-circular-ref"])return e;if(void 0===(e=this.hoistOneOfs(e)).allOf)return Object.assign({absolutePointer:r},e);let s=Object.assign(Object.assign({},e),{"x-parentRefs":[],absolutePointer:JsonPointer.join(r,["allOf"]),allOf:void 0,title:e.title||getDefinitionName(t)});!isUndefined(s.properties)&&isObject(s.properties)&&(s.properties=Object.assign({},s.properties)),!isUndefined(s.items)&&isObject(s.items)&&(s.items=Object.assign({},s.items));const o=e.allOf.map(((e,t)=>{var n;const{resolved:o,refsStack:f}=this.deref(e,i,!0),l=e.$ref,a=l||JsonPointer.join(r,[String(t)]);if(o["x-complex"])return{$ref:l,refsStack:pushRef(f,l),schema:{"x-complex":!0},absolutePointer:a};const c=this.mergeAllOf(o,l,f,a);return c["x-circular-ref"]&&c.allOf?void 0:(l&&(null===(n=s["x-parentRefs"])||void 0===n||n.push(...c["x-parentRefs"]||[],l)),{$ref:l,refsStack:pushRef(f,l),schema:c,absolutePointer:a})})).filter(Boolean);for(const[e,{schema:i,refsStack:r,absolutePointer:f}]of o.entries()){const o=i||{},{type:l,enum:a,properties:c,items:d,required:p,title:O,description:u,readOnly:m,writeOnly:y,oneOf:b,anyOf:h,"x-circular-ref":g,"x-complex":x}=o,j=__rest(o,["type","enum","properties","items","required","title","description","readOnly","writeOnly","oneOf","anyOf","x-circular-ref","x-complex"]);if(s.type===l||isUndefined(s.type)||isUndefined(l)){if(isUndefined(l)||(Array.isArray(l)&&Array.isArray(s.type)?s.type=[...l,...s.type]:s.type=l),isUndefined(a)||(Array.isArray(a)&&Array.isArray(s.enum)?s.enum=Array.from(new Set([...a,...s.enum])):s.enum=a),!isUndefined(c)&&isObject(c)){s.properties=s.properties||{};for(const i in c){const o=concatRefStacks(r,null===(n=c[i])||void 0===n?void 0:n["x-refsStack"]);if(s.properties[i]){if(!g){const r=this.mergeAllOf({allOf:[s.properties[i],c[i]],"x-refsStack":o},t+"/properties/"+i,o,JsonPointer.join(f,["allOf",String(e),"properties",i]));s.properties[i]=r}}else s.properties[i]=Object.assign(Object.assign({},c[i]),{absolutePointer:JsonPointer.join(f,["properties",i]),"x-refsStack":o})}}if(!isUndefined(d)&&!g&&!x){const e="boolean"==typeof s.items?{}:Object.assign({},s.items),n="boolean"==typeof i.items?{}:Object.assign({},i.items);s.items=this.mergeAllOf({allOf:[e,n]},t+"/items",r)}isUndefined(b)||(s.oneOf=b),isUndefined(h)||(s.anyOf=h),Array.isArray(p)&&(s.required=[...s.required||[],...p]),s=Object.assign(Object.assign(Object.assign({},s),{title:s.title||O,description:s.description||u,readOnly:isUndefined(s.readOnly)?m:s.readOnly,writeOnly:isUndefined(s.writeOnly)?y:s.writeOnly,"x-circular-ref":s["x-circular-ref"]||g,"x-complex":s["x-complex"]||x}),j)}}return s}findDerived(e){const t={},i=this.definition.components&&this.definition.components.schemas||{};for(const r in i){const{resolved:n}=this.deref(i[r]);!isUndefined(n.allOf)&&n.allOf.find((t=>!isUndefined(t.$ref)&&e.indexOf(t.$ref)>-1))&&(t["#/components/schemas/"+r]=[n["x-discriminator-value"]||r])}return t}hoistOneOfs(e){if(isUndefined(e.allOf))return e;const{allOf:t}=e,i=__rest(e,["allOf"]);for(let e=0;e<t.length;e++){const r=t[e],{oneOf:n}=r,s=__rest(r,["oneOf"]);if(n&&Array.isArray(n)){const r=t.slice(0,e),o=t.slice(e+1),f=Object.keys(s).length>0?[s]:[];return Object.assign(Object.assign({},i),{oneOf:n.map((e=>({allOf:[...r,...f,e,...o]})))})}}return e}}
//# sourceMappingURL=OpenAPIParser.js.map