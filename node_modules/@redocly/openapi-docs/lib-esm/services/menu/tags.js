import{getTagOrGroup}from"../../models/group";import{DEFAULT_WEBHOOKS_TAG_NAME,GROUP_DEPTH}from"../../constants";import{getValueFromMdParsedExtension,isOperationName,JsonPointer}from"../../utils";import{getOperationsItems}from"./operation";import{addMarkdownItems}from"./markdown";export function getTagsItems(e,t,o,n,s){let a;if(a=void 0===n?Object.keys(t):n.tags,!Array.isArray(a))return console.warn("Unexpected values of tags. Check tags or x-tagGroups in your definition."),[];const i=a.map((e=>t[e]?(t[e].used=!0,t[e]):(console.warn(`Non-existing tag "${e}" is added to the group "${null==n?void 0:n.name}"`),null))),r=[];for(const t of i){if(!t)continue;const n=getTagOrGroup("tag",t,o);if(n.depth=GROUP_DEPTH+1,""===t.name){const e=[...addMarkdownItems(getValueFromMdParsedExtension(t,"description")||"",n,n.depth+1),...getOperationsItems(void 0,t,n.depth+1)];r.push(...e);continue}const a=getTagRelatedSchema({definition:e.definition,tag:t,parent:n,schemaDefinitionsTagName:s.schemaDefinitionsTagName});n.items=[...a,...addMarkdownItems(getValueFromMdParsedExtension(t,"description")||"",n,n.depth+1),...getOperationsItems(n,t,n.depth+1)],r.push(n)}return r.filter((({name:e,items:t})=>e!==DEFAULT_WEBHOOKS_TAG_NAME||t.length>0))}export function getTagGroupsItems(e,t,o,n,s){const a=[];for(const i of o){const o=getTagOrGroup("group",i,t);o.depth=GROUP_DEPTH,o.items=getTagsItems(e,n,o,i,s),a.push(o)}return a}function getTagRelatedSchema({definition:e,tag:t,parent:o,schemaDefinitionsTagName:n}){var s;const a=n?[n]:[];return Object.entries((null===(s=e.components)||void 0===s?void 0:s.schemas)||{}).map((([e,n])=>{if(!(n["x-tags"]||a).includes(t.name))return null;const s=getTagOrGroup("schema",{name:e,"x-displayName":`${n.title||e}`,description:`{% schemaDefinition showWriteOnly="true" schemaRef="#/components/schemas/${e}" /%}`,isSchema:!0,level:2},o);return s.depth=o.depth+1,s})).filter(Boolean)}export function getTagsWithOperations(e,t){const{definition:o}=e,n={},s=o["x-webhooks"]||o.webhooks;for(const e of t||[])n[e.name]=Object.assign(Object.assign({},e),{operations:[]});return o.paths&&getTags(e,o.paths,n),s&&getTags(e,s,n,!0),n}function getTags(e,t,o,n){for(const s of Object.keys(t||{})){const a=t[s],i=Object.keys(a).filter(isOperationName);for(const t of i){const i=a[t];if(a.$ref){const{resolved:t}=e.deref(a);getTags(e,{[s]:t},o,n);continue}let r=null==i?void 0:i.tags;r&&r.length||(r=n?[DEFAULT_WEBHOOKS_TAG_NAME]:[""]);for(const e of r){let r=o[e];void 0===r&&(r={name:e,operations:[]},o[e]=r),r["x-traitTag"]||r.operations.push(Object.assign(Object.assign({},i),{pathName:s,pointer:JsonPointer.compile(["paths",s,t]),httpVerb:t,pathParameters:a.parameters||[],pathServers:a.servers,isWebhook:!!n}))}}}}
//# sourceMappingURL=tags.js.map