"use strict";var __rest=this&&this.__rest||function(e,t){var r={};for(var i in e)Object.prototype.hasOwnProperty.call(e,i)&&t.indexOf(i)<0&&(r[i]=e[i]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var n=0;for(i=Object.getOwnPropertySymbols(e);n<i.length;n++)t.indexOf(i[n])<0&&Object.prototype.propertyIsEnumerable.call(e,i[n])&&(r[i[n]]=e[i[n]])}return r};Object.defineProperty(exports,"__esModule",{value:!0}),exports.OpenAPIParser=void 0,exports.pushRef=pushRef,exports.concatRefStacks=concatRefStacks;const theme_1=require("@redocly/theme"),utils_1=require("../utils"),JsonPointer_1=require("../utils/JsonPointer"),normalizeOptions_1=require("./config-options/normalizeOptions");function pushRef(e,t){return t&&e[e.length-1]!==t?[...e,t]:e}function concatRefStacks(e,t){return t?e.concat(t):e}class OpenAPIParser{constructor(e,t,r=(0,normalizeOptions_1.normalizeOptions)({})){Object.defineProperty(this,"options",{enumerable:!0,configurable:!0,writable:!0,value:r}),Object.defineProperty(this,"definitionUrl",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"definition",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"allowMergeRefs",{enumerable:!0,configurable:!0,writable:!0,value:!1}),Object.defineProperty(this,"byRef",{enumerable:!0,configurable:!0,writable:!0,value:e=>{let t;if(this.definition){"#"!==e.charAt(0)&&(e="#"+e),e=(0,utils_1.tryDecodeURIComponent)(e);try{t=JsonPointer_1.JsonPointer.get(this.definition,e)}catch(e){}return t||{}}}}),this.definition=Object.assign({},e),this.validate(e),this.definition=e,this.allowMergeRefs=e.openapi.startsWith("3.1");const i=theme_1.IS_BROWSER?window.location.href:"";(0,theme_1.isString)(t)&&(this.definitionUrl=new URL(t,i).href)}validate(e){if((0,theme_1.isUndefined)(e.openapi))throw new Error("Document must be valid OpenAPI 3.0.0 definition")}isRef(e){return!!e&&(void 0!==e.$ref&&null!==e.$ref)}deref(e,t=[],r=!1){const i=null==e?void 0:e["x-refsStack"];if((t=concatRefStacks(t,i)).length>100)return{resolved:Object.assign({},e,{"x-complex":!0}),refsStack:t};if(this.isRef(e)){const i=(0,utils_1.getDefinitionName)(e.$ref);if(i&&this.options.ignoreNamedSchemas.has(i))return{resolved:{type:"object",title:i},refsStack:t};let n=this.byRef(e.$ref);if(!n)throw new Error(`Failed to resolve $ref "${e.$ref}"`);if(t.includes(e.$ref))n=Object.assign({},n,{"x-circular-ref":!0});else if(this.isRef(n)){n=this.deref(n,t,r).resolved}return this.allowMergeRefs&&(n=this.mergeRefs(e,n,r)),{resolved:n,refsStack:pushRef(t,e.$ref)}}return{resolved:e,refsStack:concatRefStacks(t,i)}}mergeRefs(e,t,r){const{$ref:i}=e,n=__rest(e,["$ref"]),s=Object.keys(n);if(0===s.length)return t;if(r&&s.some((e=>!["description","title","externalDocs","x-refsStack","x-parentRefs","readOnly","writeOnly","x-complex"].includes(e)))){const e=n,{description:r,title:i,readOnly:s,writeOnly:o}=e;return{allOf:[{description:r,title:i,readOnly:s,writeOnly:o},t,__rest(e,["description","title","readOnly","writeOnly"])]}}return Object.assign(Object.assign({},t),n)}mergeAllOf(e,t,r,i=""){var n;if(e["x-circular-ref"])return e;if(void 0===(e=this.hoistOneOfs(e)).allOf)return Object.assign({absolutePointer:i},e);let s=Object.assign(Object.assign({},e),{"x-parentRefs":[],absolutePointer:JsonPointer_1.JsonPointer.join(i,["allOf"]),allOf:void 0,title:e.title||(0,utils_1.getDefinitionName)(t)});!(0,theme_1.isUndefined)(s.properties)&&(0,theme_1.isObject)(s.properties)&&(s.properties=Object.assign({},s.properties)),!(0,theme_1.isUndefined)(s.items)&&(0,theme_1.isObject)(s.items)&&(s.items=Object.assign({},s.items));const o=e.allOf.map(((e,t)=>{var n;const{resolved:o,refsStack:l}=this.deref(e,r,!0),f=e.$ref,a=f||JsonPointer_1.JsonPointer.join(i,[String(t)]);if(o["x-complex"])return{$ref:f,refsStack:pushRef(l,f),schema:{"x-complex":!0},absolutePointer:a};const c=this.mergeAllOf(o,f,l,a);return c["x-circular-ref"]&&c.allOf?void 0:(f&&(null===(n=s["x-parentRefs"])||void 0===n||n.push(...c["x-parentRefs"]||[],f)),{$ref:f,refsStack:pushRef(l,f),schema:c,absolutePointer:a})})).filter(Boolean);for(const[e,{schema:r,refsStack:i,absolutePointer:l}]of o.entries()){const o=r||{},{type:f,enum:a,properties:c,items:p,required:d,title:O,description:u,readOnly:m,writeOnly:h,oneOf:y,anyOf:b,"x-circular-ref":_,"x-complex":g}=o,x=__rest(o,["type","enum","properties","items","required","title","description","readOnly","writeOnly","oneOf","anyOf","x-circular-ref","x-complex"]);if(s.type===f||(0,theme_1.isUndefined)(s.type)||(0,theme_1.isUndefined)(f)){if((0,theme_1.isUndefined)(f)||(Array.isArray(f)&&Array.isArray(s.type)?s.type=[...f,...s.type]:s.type=f),(0,theme_1.isUndefined)(a)||(Array.isArray(a)&&Array.isArray(s.enum)?s.enum=Array.from(new Set([...a,...s.enum])):s.enum=a),!(0,theme_1.isUndefined)(c)&&(0,theme_1.isObject)(c)){s.properties=s.properties||{};for(const r in c){const o=concatRefStacks(i,null===(n=c[r])||void 0===n?void 0:n["x-refsStack"]);if(s.properties[r]){if(!_){const i=this.mergeAllOf({allOf:[s.properties[r],c[r]],"x-refsStack":o},t+"/properties/"+r,o,JsonPointer_1.JsonPointer.join(l,["allOf",String(e),"properties",r]));s.properties[r]=i}}else s.properties[r]=Object.assign(Object.assign({},c[r]),{absolutePointer:JsonPointer_1.JsonPointer.join(l,["properties",r]),"x-refsStack":o})}}if(!(0,theme_1.isUndefined)(p)&&!_&&!g){const e="boolean"==typeof s.items?{}:Object.assign({},s.items),n="boolean"==typeof r.items?{}:Object.assign({},r.items);s.items=this.mergeAllOf({allOf:[e,n]},t+"/items",i)}(0,theme_1.isUndefined)(y)||(s.oneOf=y),(0,theme_1.isUndefined)(b)||(s.anyOf=b),Array.isArray(d)&&(s.required=[...s.required||[],...d]),s=Object.assign(Object.assign(Object.assign({},s),{title:s.title||O,description:s.description||u,readOnly:(0,theme_1.isUndefined)(s.readOnly)?m:s.readOnly,writeOnly:(0,theme_1.isUndefined)(s.writeOnly)?h:s.writeOnly,"x-circular-ref":s["x-circular-ref"]||_,"x-complex":s["x-complex"]||g}),x)}}return s}findDerived(e){const t={},r=this.definition.components&&this.definition.components.schemas||{};for(const i in r){const{resolved:n}=this.deref(r[i]);!(0,theme_1.isUndefined)(n.allOf)&&n.allOf.find((t=>!(0,theme_1.isUndefined)(t.$ref)&&e.indexOf(t.$ref)>-1))&&(t["#/components/schemas/"+i]=[n["x-discriminator-value"]||i])}return t}hoistOneOfs(e){if((0,theme_1.isUndefined)(e.allOf))return e;const{allOf:t}=e,r=__rest(e,["allOf"]);for(let e=0;e<t.length;e++){const i=t[e],{oneOf:n}=i,s=__rest(i,["oneOf"]);if(n&&Array.isArray(n)){const i=t.slice(0,e),o=t.slice(e+1),l=Object.keys(s).length>0?[s]:[];return Object.assign(Object.assign({},r),{oneOf:n.map((e=>({allOf:[...i,...l,e,...o]})))})}}return e}}exports.OpenAPIParser=OpenAPIParser;
//# sourceMappingURL=OpenAPIParser.js.map