import { useNavigate, useLocation } from 'react-router-dom';
import { useCallback, useEffect, useState } from 'react';

import type { MenuItemProps } from '@redocly/theme/core/types';

import { useMenuItemExpanded, useCollapse } from '@redocly/theme/core/hooks';
import { loadAndNavigate } from '@redocly/theme/core/utils';

type NestedMenuProps = MenuItemProps & {
  labelRef?: React.RefObject<HTMLElement>;
  nestedMenuRef?: React.RefObject<HTMLDivElement>;
};

export function useNestedMenu({ item, labelRef, nestedMenuRef }: NestedMenuProps) {
  const [isExpanded, setIsExpanded] = useMenuItemExpanded(item);
  // we need to know when the item is collapsed after transition to remove children from DOM
  const [canUnmount, setCanUnmount] = useState(!isExpanded);

  const navigate = useNavigate();
  const location = useLocation();

  const { style } = useCollapse({
    isExpanded,
    collapseElRef: nestedMenuRef || { current: null },
    onTransitionStateChange: (state) => {
      if (state === 'collapseEnd') {
        setCanUnmount(true);
      }
      if (state === 'expandStart') {
        setCanUnmount(false);
      }
    },
  });

  function scrollIfNeeded(el: Element, centerIfNeeded: boolean = false) {
    // @ts-ignore
    if (typeof el.scrollIntoViewIfNeeded === 'function') {
      // @ts-ignore
      el.scrollIntoViewIfNeeded(centerIfNeeded);
    }
  }

  // scroll to active element if needed
  useEffect(() => {
    if (item.active && labelRef && labelRef.current) {
      scrollIfNeeded(labelRef.current, true); // center item on the first scroll
    }
  }, [labelRef, item.active]);

  // scroll to expanded element if needed (position could change after collapse)
  useEffect(() => {
    if (item.active && isExpanded && labelRef && labelRef.current) {
      scrollIfNeeded(labelRef.current);
    }
  }, [labelRef, isExpanded, item.active]);

  const handleExpand = useCallback(async () => {
    if (
      item.expanded === 'always' ||
      (item.link && item.hasActiveSubItem && item.link !== location.pathname)
    ) {
      return;
    }

    const [firstChild] = item.items;
    if (!isExpanded && item.selectFirstItemOnExpand && firstChild.link) {
      await loadAndNavigate(navigate, firstChild.link);
    }
    setIsExpanded(!isExpanded);
  }, [item, isExpanded, navigate, location.pathname, setIsExpanded]);

  return {
    isExpanded,
    canUnmount,
    style,
    handleExpand,
  };
}
