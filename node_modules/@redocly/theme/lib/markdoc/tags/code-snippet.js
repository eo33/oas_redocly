"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.codeSnippet = void 0;
const markdoc_1 = __importDefault(require("@markdoc/markdoc"));
const code_snippet_file_1 = require("../../markdoc/attributes/code-snippet-file");
exports.codeSnippet = {
    schema: {
        attributes: {
            file: { type: code_snippet_file_1.CodeSnippetFile, render: false, required: true },
            language: { type: String, render: true },
            title: { type: String, render: true },
            to: { type: [String, Number], render: false },
            from: { type: [String, Number], render: false },
            after: { type: [String, Number], render: false },
            before: { type: [String, Number], render: false },
            prefix: { type: String, render: false },
            wrap: { type: Boolean, render: false },
            rawContent: { type: String, render: false }, // internal
        },
        render: 'CodeBlock',
        selfClosing: true,
        transform: (node, config) => {
            const attributes = node.transformAttributes(config);
            const rawContent = node.attributes.rawContent;
            const header = {
                title: node.attributes.title,
                controls: { copy: {} },
            };
            if (typeof rawContent === 'string') {
                return new markdoc_1.default.Tag('CodeBlock', Object.assign(Object.assign({}, attributes), { header, lang: attributes.language, source: rawContent, wrapContents: node.attributes.wrap }), []);
            }
            else {
                return new markdoc_1.default.Tag(node.tag, attributes, []);
            }
        },
        validate(node) {
            const errors = [];
            if (node.attributes.from && node.attributes.after) {
                errors.push({
                    id: 'from-and-after-attributes-are-mutually-exclusive',
                    level: 'error',
                    message: 'attributes "from" and "after" are mutually exclusive',
                });
            }
            if (node.attributes.to && node.attributes.before) {
                errors.push({
                    id: 'to-and-before-attributes-are-mutually-exclusive',
                    level: 'error',
                    message: 'attributes "to" and "before" are mutually exclusive',
                });
            }
            return errors;
        },
    },
    tagName: 'code-snippet',
};
//# sourceMappingURL=code-snippet.js.map