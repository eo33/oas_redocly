"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MockIntersectionObserver = void 0;
class MockIntersectionObserver {
    constructor(callback, options) {
        Object.defineProperty(this, "root", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "rootMargin", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "thresholds", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "viewPort", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "entries", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "callback", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "intersect", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: () => {
                this.entries.map((entry) => {
                    entry.isIntersecting = this.isInViewPort(entry.target);
                });
                this.callback(this.entries, this);
            }
        });
        this.viewPort = (options === null || options === void 0 ? void 0 : options.root) ? options.root : window;
        this.entries = [];
        this.root = null;
        this.rootMargin = '0px';
        this.thresholds = [1];
        this.callback = callback;
        this.viewPort.addEventListener('scroll', this.intersect);
    }
    isInViewPort(target) {
        return target.id !== 'toc-0';
    }
    observe(target) {
        this.entries.push({ isIntersecting: false, target });
    }
    unobserve(target) {
        this.entries = this.entries.filter((ob) => ob.target !== target);
    }
    disconnect() {
        this.viewPort.removeEventListener('scroll', this.intersect);
        this.entries = [];
    }
    takeRecords() {
        return this.entries;
    }
}
exports.MockIntersectionObserver = MockIntersectionObserver;
//# sourceMappingURL=mock-intersection-observer.js.map